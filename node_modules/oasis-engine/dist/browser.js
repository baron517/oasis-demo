(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.oasisEngine = {}));
})(this, (function (exports) { 'use strict';

  /**
   * Defines how the bounding volumes intersects or contain one another.
   */
  exports.ContainmentType = void 0;
  (function (ContainmentType) {
    ContainmentType[ContainmentType["Disjoint"] = 0] = "Disjoint";
    ContainmentType[ContainmentType["Contains"] = 1] = "Contains";
    ContainmentType[ContainmentType["Intersects"] = 2] = "Intersects";
  })(exports.ContainmentType || (exports.ContainmentType = {}));

  /**
   * Defines the intersection between a plane and a bounding volume.
   */
  exports.PlaneIntersectionType = void 0;
  (function (PlaneIntersectionType) {
    PlaneIntersectionType[PlaneIntersectionType["Back"] = 0] = "Back";
    PlaneIntersectionType[PlaneIntersectionType["Front"] = 1] = "Front";
    PlaneIntersectionType[PlaneIntersectionType["Intersecting"] = 2] = "Intersecting";
  })(exports.PlaneIntersectionType || (exports.PlaneIntersectionType = {}));
  function _defineProperties$4(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$4(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  /**
   * Common utility methods for math operations.
   */
  var MathUtil = /*#__PURE__*/function () {
    function MathUtil() {}
    /** The value for which all absolute numbers smaller than are considered equal to zero. */
    /** The conversion factor that radian to degree. */
    /** The conversion factor that degree to radian. */
    /**
     * Clamps the specified value.
     * @param v - The specified value
     * @param min - The min value
     * @param max - The max value
     * @returns The result of clamping a value between min and max
     */
    MathUtil.clamp = function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    /**
     * Checks if a and b are almost equals.
     * The absolute value of the difference between a and b is close to zero.
     * @param a - The left value to compare
     * @param b - The right value to compare
     * @returns True if a almost equal to b, false otherwise
     */;
    MathUtil.equals = function equals(a, b) {
      return Math.abs(a - b) <= MathUtil.zeroTolerance;
    }

    /**
     * Determines whether the specified v is pow2.
     * @param v - The specified v
     * @returns True if the specified v is pow2, false otherwise
     */;
    MathUtil.isPowerOf2 = function isPowerOf2(v) {
      return (v & v - 1) === 0;
    }

    /**
     * Modify the specified r from radian to degree.
     * @param r - The specified r
     * @returns The degree value
     */;
    MathUtil.radianToDegree = function radianToDegree(r) {
      return r * MathUtil.radToDegreeFactor;
    }

    /**
     * Modify the specified d from degree to radian.
     * @param d - The specified d
     * @returns The radian value
     */;
    MathUtil.degreeToRadian = function degreeToRadian(d) {
      return d * MathUtil.degreeToRadFactor;
    };
    return MathUtil;
  }();
  MathUtil.zeroTolerance = 1e-6;
  MathUtil.radToDegreeFactor = 180 / Math.PI;
  MathUtil.degreeToRadFactor = Math.PI / 180;

  /**
   * Describes a 3D-vector.
   */
  var Vector3 = /*#__PURE__*/function () {
    /** @internal */
    /** @internal */
    /**
     * Determines the sum of two vectors.
     * @param left - The first vector to add
     * @param right - The second vector to add
     * @param out - The sum of two vectors
     */
    Vector3.add = function add(left, right, out) {
      out._x = left._x + right._x;
      out._y = left._y + right._y;
      out._z = left._z + right._z;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the difference between two vectors.
     * @param left - The first vector to subtract
     * @param right - The second vector to subtract
     * @param out - The difference between two vectors
     */;
    Vector3.subtract = function subtract(left, right, out) {
      out._x = left._x - right._x;
      out._y = left._y - right._y;
      out._z = left._z - right._z;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the product of two vectors.
     * @param left - The first vector to multiply
     * @param right - The second vector to multiply
     * @param out - The product of two vectors
     */;
    Vector3.multiply = function multiply(left, right, out) {
      out._x = left._x * right._x;
      out._y = left._y * right._y;
      out._z = left._z * right._z;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the divisor of two vectors.
     * @param left - The first vector to divide
     * @param right - The second vector to divide
     * @param out - The divisor of two vectors
     */;
    Vector3.divide = function divide(left, right, out) {
      out._x = left._x / right._x;
      out._y = left._y / right._y;
      out._z = left._z / right._z;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the dot product of two vectors.
     * @param left - The first vector to dot
     * @param right - The second vector to dot
     * @returns The dot product of two vectors
     */;
    Vector3.dot = function dot(left, right) {
      return left._x * right._x + left._y * right._y + left._z * right._z;
    }

    /**
     * Determines the cross product of two vectors.
     * @param left - The first vector to cross
     * @param right - The second vector to cross
     * @param out - The cross product of two vectors
     */;
    Vector3.cross = function cross(left, right, out) {
      var ax = left._x;
      var ay = left._y;
      var az = left._z;
      var bx = right._x;
      var by = right._y;
      var bz = right._z;
      out.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
    }

    /**
     * Determines the distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The distance of two vectors
     */;
    Vector3.distance = function distance(a, b) {
      var x = b._x - a._x;
      var y = b._y - a._y;
      var z = b._z - a._z;
      return Math.sqrt(x * x + y * y + z * z);
    }

    /**
     * Determines the squared distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The squared distance of two vectors
     */;
    Vector3.distanceSquared = function distanceSquared(a, b) {
      var x = b._x - a._x;
      var y = b._y - a._y;
      var z = b._z - a._z;
      return x * x + y * y + z * z;
    }

    /**
     * Determines whether the specified vectors are equals.
     * @param left - The first vector to compare
     * @param right - The second vector to compare
     * @returns True if the specified vectors are equals, false otherwise
     */;
    Vector3.equals = function equals(left, right) {
      return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z);
    }

    /**
     * Performs a linear interpolation between two vectors.
     * @param start - The first vector
     * @param end - The second vector
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two vectors
     */;
    Vector3.lerp = function lerp(start, end, t, out) {
      var _x = start._x,
        _y = start._y,
        _z = start._z;
      out._x = _x + (end._x - _x) * t;
      out._y = _y + (end._y - _y) * t;
      out._z = _z + (end._z - _z) * t;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a vector containing the largest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the largest components of the specified vectors
     */;
    Vector3.max = function max(left, right, out) {
      out._x = Math.max(left._x, right._x);
      out._y = Math.max(left._y, right._y);
      out._z = Math.max(left._z, right._z);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a vector containing the smallest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the smallest components of the specified vectors
     */;
    Vector3.min = function min(left, right, out) {
      out._x = Math.min(left._x, right._x);
      out._y = Math.min(left._y, right._y);
      out._z = Math.min(left._z, right._z);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Reverses the direction of a given vector.
     * @param a - The vector to negate
     * @param out - The vector facing in the opposite direction
     */;
    Vector3.negate = function negate(a, out) {
      out._x = -a._x;
      out._y = -a._y;
      out._z = -a._z;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Converts the vector into a unit vector.
     * @param a - The vector to normalize
     * @param out - The normalized vector
     */;
    Vector3.normalize = function normalize(a, out) {
      var _x = a._x,
        _y = a._y,
        _z = a._z;
      var len = Math.sqrt(_x * _x + _y * _y + _z * _z);
      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.set(_x * len, _y * len, _z * len);
      }
    }

    /**
     * Scale a vector by the given value.
     * @param a - The vector to scale
     * @param s - The amount by which to scale the vector
     * @param out - The scaled vector
     */;
    Vector3.scale = function scale(a, s, out) {
      out._x = a._x * s;
      out._y = a._y * s;
      out._z = a._z * s;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a normal transformation using the given 4x4 matrix.
     * @remarks
     * A normal transform performs the transformation with the assumption that the w component
     * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
     * end result is a vector that is not translated, but all other transformation properties
     * apply. This is often preferred for normal vectors as normals purely represent direction
     * rather than location because normal vectors should not be translated.
     * @param v - The normal vector to transform
     * @param m - The transform matrix
     * @param out - The transformed normal
     */;
    Vector3.transformNormal = function transformNormal(v, m, out) {
      var _x = v._x,
        _y = v._y,
        _z = v._z;
      var e = m.elements;
      out._x = _x * e[0] + _y * e[4] + _z * e[8];
      out._y = _x * e[1] + _y * e[5] + _z * e[9];
      out._z = _x * e[2] + _y * e[6] + _z * e[10];
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a transformation using the given 4x4 matrix.
     * @param v - The vector to transform
     * @param m - The transform matrix
     * @param out - The transformed vector3
     */;
    Vector3.transformToVec3 = function transformToVec3(v, m, out) {
      var _x = v._x,
        _y = v._y,
        _z = v._z;
      var e = m.elements;
      out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
      out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
      out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a transformation from vector3 to vector4 using the given 4x4 matrix.
     * @param v - The vector to transform
     * @param m - The transform matrix
     * @param out - The transformed vector4
     */;
    Vector3.transformToVec4 = function transformToVec4(v, m, out) {
      var _x = v._x,
        _y = v._y,
        _z = v._z;
      var e = m.elements;
      out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
      out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
      out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
      out._w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a coordinate transformation using the given 4x4 matrix.
     *
     * @remarks
     * A coordinate transform performs the transformation with the assumption that the w component
     * is one. The four dimensional vector obtained from the transformation operation has each
     * component in the vector divided by the w component. This forces the w-component to be one and
     * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
     * with coordinates as the w component can safely be ignored.
     * @param v - The coordinate vector to transform
     * @param m - The transform matrix
     * @param out - The transformed coordinates
     */;
    Vector3.transformCoordinate = function transformCoordinate(v, m, out) {
      var _x = v._x,
        _y = v._y,
        _z = v._z;
      var e = m.elements;
      var w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
      w = 1.0 / w;
      out._x = (_x * e[0] + _y * e[4] + _z * e[8] + e[12]) * w;
      out._y = (_x * e[1] + _y * e[5] + _z * e[9] + e[13]) * w;
      out._z = (_x * e[2] + _y * e[6] + _z * e[10] + e[14]) * w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a transformation using the given quaternion.
     * @param v - The vector to transform
     * @param quaternion - The transform quaternion
     * @param out - The transformed vector
     */;
    Vector3.transformByQuat = function transformByQuat(v, quaternion, out) {
      var _x = v._x,
        _y = v._y,
        _z = v._z;
      var qx = quaternion._x,
        qy = quaternion._y,
        qz = quaternion._z,
        qw = quaternion._w;

      // calculate quat * vec
      var ix = qw * _x + qy * _z - qz * _y;
      var iy = qw * _y + qz * _x - qx * _z;
      var iz = qw * _z + qx * _y - qy * _x;
      var iw = -qx * _x - qy * _y - qz * _z;

      // calculate result * inverse quat
      out._x = ix * qw - iw * qx - iy * qz + iz * qy;
      out._y = iy * qw - iw * qy - iz * qx + ix * qz;
      out._z = iz * qw - iw * qz - ix * qy + iy * qx;
      out._onValueChanged && out._onValueChanged();
    }

    /** @internal */;

    /**
     * Constructor of Vector3.
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     * @param z - The z component of the vector, default 0
     */
    function Vector3(x, y, z) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      this._x = void 0;
      this._y = void 0;
      this._z = void 0;
      this._onValueChanged = null;
      this._x = x;
      this._y = y;
      this._z = z;
    }

    /**
     * Set the value of this vector.
     * @param x - The x component of the vector
     * @param y - The y component of the vector
     * @param z - The z component of the vector
     * @returns This vector
     */
    var _proto = Vector3.prototype;
    _proto.set = function set(x, y, z) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the sum of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.add = function add(right) {
      this._x += right._x;
      this._y += right._y;
      this._z += right._z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the difference of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.subtract = function subtract(right) {
      this._x -= right._x;
      this._y -= right._y;
      this._z -= right._z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the product of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.multiply = function multiply(right) {
      this._x *= right._x;
      this._y *= right._y;
      this._z *= right._z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the divisor of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.divide = function divide(right) {
      this._x /= right._x;
      this._y /= right._y;
      this._z /= right._z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Calculate the length of this vector.
     * @returns The length of this vector
     */;
    _proto.length = function length() {
      var _x = this._x,
        _y = this._y,
        _z = this._z;
      return Math.sqrt(_x * _x + _y * _y + _z * _z);
    }

    /**
     * Calculate the squared length of this vector.
     * @returns The squared length of this vector
     */;
    _proto.lengthSquared = function lengthSquared() {
      var _x = this._x,
        _y = this._y,
        _z = this._z;
      return _x * _x + _y * _y + _z * _z;
    }

    /**
     * Reverses the direction of this vector.
     * @returns This vector
     */;
    _proto.negate = function negate() {
      this._x = -this._x;
      this._y = -this._y;
      this._z = -this._z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Converts this vector into a unit vector.
     * @returns This vector
     */;
    _proto.normalize = function normalize() {
      Vector3.normalize(this, this);
      return this;
    }

    /**
     * Scale this vector by the given value.
     * @param s - The amount by which to scale the vector
     * @returns This vector
     */;
    _proto.scale = function scale(s) {
      this._x *= s;
      this._y *= s;
      this._z *= s;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * This vector performs a normal transformation using the given 4x4 matrix.
     * @remarks
     * A normal transform performs the transformation with the assumption that the w component
     * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
     * end result is a vector that is not translated, but all other transformation properties
     * apply. This is often preferred for normal vectors as normals purely represent direction
     * rather than location because normal vectors should not be translated.
     * @param m - The transform matrix
     * @returns This vector
     */;
    _proto.transformNormal = function transformNormal(m) {
      Vector3.transformNormal(this, m, this);
      return this;
    }

    /**
     * This vector performs a transformation using the given 4x4 matrix.
     * @param m - The transform matrix
     * @returns This vector
     */;
    _proto.transformToVec3 = function transformToVec3(m) {
      Vector3.transformToVec3(this, m, this);
      return this;
    }

    /**
     * This vector performs a coordinate transformation using the given 4x4 matrix.
     * @remarks
     * A coordinate transform performs the transformation with the assumption that the w component
     * is one. The four dimensional vector obtained from the transformation operation has each
     * component in the vector divided by the w component. This forces the w-component to be one and
     * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
     * with coordinates as the w component can safely be ignored.
     * @param m - The transform matrix
     * @returns This vector
     */;
    _proto.transformCoordinate = function transformCoordinate(m) {
      Vector3.transformCoordinate(this, m, this);
      return this;
    }

    /**
     * This vector performs a transformation using the given quaternion.
     * @param quaternion - The transform quaternion
     * @returns This vector
     */;
    _proto.transformByQuat = function transformByQuat(quaternion) {
      Vector3.transformByQuat(this, quaternion, this);
      return this;
    }

    /**
     * Creates a clone of this vector.
     * @returns A clone of this vector
     */;
    _proto.clone = function clone() {
      return new Vector3(this._x, this._y, this._z);
    }

    /**
     * Copy from vector3 like object.
     * @param source - Vector3 like object.
     * @returns This vector
     */;
    _proto.copyFrom = function copyFrom(source) {
      this._x = source.x;
      this._y = source.y;
      this._z = source.z;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this vector from an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This vector
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this vector to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      out[outOffset] = this._x;
      out[outOffset + 1] = this._y;
      out[outOffset + 2] = this._z;
    };
    _createClass$4(Vector3, [{
      key: "x",
      get:
      /**
       * The x component of the vector.
       */
      function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The y component of the vector.
       */
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The z component of the vector.
       */
    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onValueChanged && this._onValueChanged();
      }
    }]);
    return Vector3;
  }();
  Vector3._zero = new Vector3(0.0, 0.0, 0.0);
  Vector3._one = new Vector3(1.0, 1.0, 1.0);

  /**
   * A bounding sphere.
   * */
  var BoundingSphere = /*#__PURE__*/function () {
    /**
     * Calculate a bounding sphere that fully contains the given points.
     * @param points - The given points
     * @param out - The calculated bounding sphere
     */
    BoundingSphere.fromPoints = function fromPoints(points, out) {
      if (!points || points.length === 0) {
        throw new Error("points must be array and length must > 0");
      }
      var len = points.length;
      var center = BoundingSphere._tempVec30;
      center.x = center.y = center.z = 0;

      // Calculate the center of the sphere.
      for (var i = 0; i < len; ++i) {
        Vector3.add(points[i], center, center);
      }

      // The center of the sphere.
      Vector3.scale(center, 1 / len, out.center);

      // Calculate the radius of the sphere.
      var radius = 0.0;
      for (var _i = 0; _i < len; ++_i) {
        var distance = Vector3.distanceSquared(center, points[_i]);
        distance > radius && (radius = distance);
      }
      // The radius of the sphere.
      out.radius = Math.sqrt(radius);
    }

    /**
     * Calculate a bounding sphere from a given box.
     * @param box - The given box
     * @param out - The calculated bounding sphere
     */;
    BoundingSphere.fromBox = function fromBox(box, out) {
      var center = out.center;
      var min = box.min,
        max = box.max;
      center.x = (min.x + max.x) * 0.5;
      center.y = (min.y + max.y) * 0.5;
      center.z = (min.z + max.z) * 0.5;
      out.radius = Vector3.distance(center, max);
    }

    /** The center point of the sphere. */;

    /**
     * Constructor of BoundingSphere.
     * @param center - The center point of the sphere
     * @param radius - The radius of the sphere
     */
    function BoundingSphere(center, radius) {
      if (center === void 0) {
        center = null;
      }
      if (radius === void 0) {
        radius = 0;
      }
      this.center = new Vector3();
      this.radius = 0;
      center && this.center.copyFrom(center);
      this.radius = radius;
    }

    /**
     * Creates a clone of this sphere.
     * @returns A clone of this sphere
     */
    var _proto = BoundingSphere.prototype;
    _proto.clone = function clone() {
      return new BoundingSphere(this.center, this.radius);
    }

    /**
     * Copy this sphere from the specified sphere.
     * @param source - The specified sphere
     * @returns This sphere
     */;
    _proto.copyFrom = function copyFrom(source) {
      this.center.copyFrom(source.center);
      this.radius = source.radius;
      return this;
    };
    return BoundingSphere;
  }();
  BoundingSphere._tempVec30 = new Vector3();

  /**
   * Axis Aligned Bound Box (AABB).
   */
  var BoundingBox = /*#__PURE__*/function () {
    /**
     * Calculate a bounding box from the center point and the extent of the bounding box.
     * @param center - The center point
     * @param extent - The extent of the bounding box
     * @param out - The calculated bounding box
     */
    BoundingBox.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
      Vector3.subtract(center, extent, out.min);
      Vector3.add(center, extent, out.max);
    }

    /**
     * Calculate a bounding box that fully contains the given points.
     * @param points - The given points
     * @param out - The calculated bounding box
     */;
    BoundingBox.fromPoints = function fromPoints(points, out) {
      if (!points || points.length === 0) {
        throw new Error("points must be array and length must > 0");
      }
      var min = out.min,
        max = out.max;
      min.x = min.y = min.z = Number.MAX_VALUE;
      max.x = max.y = max.z = -Number.MAX_VALUE;
      for (var i = 0, l = points.length; i < l; ++i) {
        var point = points[i];
        Vector3.min(min, point, min);
        Vector3.max(max, point, max);
      }
    }

    /**
     * Calculate a bounding box from a given sphere.
     * @param sphere - The given sphere
     * @param out - The calculated bounding box
     */;
    BoundingBox.fromSphere = function fromSphere(sphere, out) {
      var center = sphere.center,
        radius = sphere.radius;
      var min = out.min,
        max = out.max;
      min.x = center.x - radius;
      min.y = center.y - radius;
      min.z = center.z - radius;
      max.x = center.x + radius;
      max.y = center.y + radius;
      max.z = center.z + radius;
    }

    /**
     * Transform a bounding box.
     * @param source - The original bounding box
     * @param matrix - The transform to apply to the bounding box
     * @param out - The transformed bounding box
     */;
    BoundingBox.transform = function transform(source, matrix, out) {
      // https://zeux.io/2010/10/17/aabb-from-obb-with-component-wise-abs/
      var center = BoundingBox._tempVec30;
      var extent = BoundingBox._tempVec31;
      source.getCenter(center);
      source.getExtent(extent);
      Vector3.transformCoordinate(center, matrix, center);
      var x = extent.x,
        y = extent.y,
        z = extent.z;
      var e = matrix.elements;
      extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
      extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
      extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);

      // set minã€max
      Vector3.subtract(center, extent, out.min);
      Vector3.add(center, extent, out.max);
    }

    /**
     * Calculate a bounding box that is as large as the total combined area of the two specified boxes.
     * @param box1 - The first box to merge
     * @param box2 - The second box to merge
     * @param out - The merged bounding box
     * @returns The merged bounding box
     */;
    BoundingBox.merge = function merge(box1, box2, out) {
      Vector3.min(box1.min, box2.min, out.min);
      Vector3.max(box1.max, box2.max, out.max);
      return out;
    }

    /** The minimum point of the box. */;

    /**
     * Constructor of BoundingBox.
     * @param min - The minimum point of the box
     * @param max - The maximum point of the box
     */
    function BoundingBox(min, max) {
      if (min === void 0) {
        min = null;
      }
      if (max === void 0) {
        max = null;
      }
      this.min = new Vector3();
      this.max = new Vector3();
      min && this.min.copyFrom(min);
      max && this.max.copyFrom(max);
    }

    /**
     * Get the center point of this bounding box.
     * @param out - The center point of this bounding box
     * @returns The center point of this bounding box
     */
    var _proto = BoundingBox.prototype;
    _proto.getCenter = function getCenter(out) {
      Vector3.add(this.min, this.max, out);
      Vector3.scale(out, 0.5, out);
      return out;
    }

    /**
     * Get the extent of this bounding box.
     * @param out - The extent of this bounding box
     * @returns The extent of this bounding box
     */;
    _proto.getExtent = function getExtent(out) {
      Vector3.subtract(this.max, this.min, out);
      Vector3.scale(out, 0.5, out);
      return out;
    }

    /**
     * Get the eight corners of this bounding box.
     * @param out - An array of points representing the eight corners of this bounding box
     * @returns An array of points representing the eight corners of this bounding box
     */;
    _proto.getCorners = function getCorners(out) {
      if (out === void 0) {
        out = [];
      }
      var min = this.min,
        max = this.max;
      var minX = min.x;
      var minY = min.y;
      var minZ = min.z;
      var maxX = max.x;
      var maxY = max.y;
      var maxZ = max.z;
      var len = out.length;

      // The array length is less than 8 to make up
      if (len < 8) {
        for (var i = 0, l = 8 - len; i < l; ++i) {
          out[len + i] = new Vector3();
        }
      }
      out[0].set(minX, maxY, maxZ);
      out[1].set(maxX, maxY, maxZ);
      out[2].set(maxX, minY, maxZ);
      out[3].set(minX, minY, maxZ);
      out[4].set(minX, maxY, minZ);
      out[5].set(maxX, maxY, minZ);
      out[6].set(maxX, minY, minZ);
      out[7].set(minX, minY, minZ);
      return out;
    }

    /**
     * Transform a bounding box.
     * @param matrix - The transform to apply to the bounding box
     * @returns The transformed bounding box
     */;
    _proto.transform = function transform(matrix) {
      BoundingBox.transform(this, matrix, this);
      return this;
    }

    /**
     * Creates a clone of this box.
     * @returns A clone of this box
     */;
    _proto.clone = function clone() {
      return new BoundingBox(this.min, this.max);
    }

    /**
     * Copy this bounding box from the specified box.
     * @param source - The specified box
     * @returns This bounding box
     */;
    _proto.copyFrom = function copyFrom(source) {
      this.min.copyFrom(source.min);
      this.max.copyFrom(source.max);
      return this;
    };
    return BoundingBox;
  }();
  BoundingBox._tempVec30 = new Vector3();
  BoundingBox._tempVec31 = new Vector3();

  /**
   * Contains static methods to help in determining intersections, containment, etc.
   */
  var CollisionUtil = /*#__PURE__*/function () {
    function CollisionUtil() {}
    /**
     * Calculate the distance from a point to a plane.
     * @param plane - The plane
     * @param point - The point
     * @returns The distance from a point to a plane
     */
    CollisionUtil.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
      return Vector3.dot(plane.normal, point) + plane.distance;
    }

    /**
     * Get the intersection type between a plane and a point.
     * @param plane - The plane
     * @param point - The point
     * @returns The intersection type
     */;
    CollisionUtil.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
      var distance = CollisionUtil.distancePlaneAndPoint(plane, point);
      if (distance > 0) {
        return exports.PlaneIntersectionType.Front;
      }
      if (distance < 0) {
        return exports.PlaneIntersectionType.Back;
      }
      return exports.PlaneIntersectionType.Intersecting;
    }

    /**
     * Get the intersection type between a plane and a box (AABB).
     * @param plane - The plane
     * @param box - The box
     * @returns The intersection type
     */;
    CollisionUtil.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
      var min = box.min,
        max = box.max;
      var normal = plane.normal;
      var front = CollisionUtil._tempVec30;
      var back = CollisionUtil._tempVec31;
      if (normal.x >= 0) {
        front.x = max.x;
        back.x = min.x;
      } else {
        front.x = min.x;
        back.x = max.x;
      }
      if (normal.y >= 0) {
        front.y = max.y;
        back.y = min.y;
      } else {
        front.y = min.y;
        back.y = max.y;
      }
      if (normal.z >= 0) {
        front.z = max.z;
        back.z = min.z;
      } else {
        front.z = min.z;
        back.z = max.z;
      }
      if (CollisionUtil.distancePlaneAndPoint(plane, front) < 0) {
        return exports.PlaneIntersectionType.Back;
      }
      if (CollisionUtil.distancePlaneAndPoint(plane, back) > 0) {
        return exports.PlaneIntersectionType.Front;
      }
      return exports.PlaneIntersectionType.Intersecting;
    }

    /**
     * Get the intersection type between a plane and a sphere.
     * @param plane - The plane
     * @param sphere - The sphere
     * @returns The intersection type
     */;
    CollisionUtil.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
      var center = sphere.center,
        radius = sphere.radius;
      var distance = CollisionUtil.distancePlaneAndPoint(plane, center);
      if (distance > radius) {
        return exports.PlaneIntersectionType.Front;
      }
      if (distance < -radius) {
        return exports.PlaneIntersectionType.Back;
      }
      return exports.PlaneIntersectionType.Intersecting;
    }

    /**
     * Get the intersection type between a ray and a plane.
     * @param ray - The ray
     * @param plane - The plane
     * @returns The distance from ray to plane if intersecting, -1 otherwise
     */;
    CollisionUtil.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
      var normal = plane.normal;
      var zeroTolerance = MathUtil.zeroTolerance;
      var dir = Vector3.dot(normal, ray.direction);
      // Parallel
      if (Math.abs(dir) < zeroTolerance) {
        return -1;
      }
      var position = Vector3.dot(normal, ray.origin);
      var distance = (-plane.distance - position) / dir;
      if (distance < 0) {
        if (distance < -zeroTolerance) {
          return -1;
        }
        distance = 0;
      }
      return distance;
    }

    /**
     * Get the intersection type between a ray and a box (AABB).
     * @param ray - The ray
     * @param box - The box
     * @returns The distance from ray to box if intersecting, -1 otherwise
     */;
    CollisionUtil.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
      var zeroTolerance = MathUtil.zeroTolerance;
      var origin = ray.origin,
        direction = ray.direction;
      var min = box.min,
        max = box.max;
      var dirX = direction.x;
      var dirY = direction.y;
      var dirZ = direction.z;
      var oriX = origin.x;
      var oriY = origin.y;
      var oriZ = origin.z;
      var distance = 0;
      var tmax = Number.MAX_VALUE;
      if (Math.abs(dirX) < zeroTolerance) {
        if (oriX < min.x || oriX > max.x) {
          return -1;
        }
      } else {
        var inverse = 1.0 / dirX;
        var t1 = (min.x - oriX) * inverse;
        var t2 = (max.x - oriX) * inverse;
        if (t1 > t2) {
          var temp = t1;
          t1 = t2;
          t2 = temp;
        }
        distance = Math.max(t1, distance);
        tmax = Math.min(t2, tmax);
        if (distance > tmax) {
          return -1;
        }
      }
      if (Math.abs(dirY) < zeroTolerance) {
        if (oriY < min.y || oriY > max.y) {
          return -1;
        }
      } else {
        var _inverse = 1.0 / dirY;
        var _t = (min.y - oriY) * _inverse;
        var _t2 = (max.y - oriY) * _inverse;
        if (_t > _t2) {
          var _temp = _t;
          _t = _t2;
          _t2 = _temp;
        }
        distance = Math.max(_t, distance);
        tmax = Math.min(_t2, tmax);
        if (distance > tmax) {
          return -1;
        }
      }
      if (Math.abs(dirZ) < zeroTolerance) {
        if (oriZ < min.z || oriZ > max.z) {
          return -1;
        }
      } else {
        var _inverse2 = 1.0 / dirZ;
        var _t3 = (min.z - oriZ) * _inverse2;
        var _t4 = (max.z - oriZ) * _inverse2;
        if (_t3 > _t4) {
          var _temp2 = _t3;
          _t3 = _t4;
          _t4 = _temp2;
        }
        distance = Math.max(_t3, distance);
        tmax = Math.min(_t4, tmax);
        if (distance > tmax) {
          return -1;
        }
      }
      return distance;
    }

    /**
     * Get the intersection type between a ray and a sphere.
     * @param ray - The ray
     * @param sphere - The sphere
     * @returns The distance from ray to sphere if intersecting, -1 otherwise
     */;
    CollisionUtil.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
      var origin = ray.origin,
        direction = ray.direction;
      var center = sphere.center,
        radius = sphere.radius;
      var m = CollisionUtil._tempVec30;
      Vector3.subtract(origin, center, m);
      var b = Vector3.dot(m, direction);
      var c = Vector3.dot(m, m) - radius * radius;
      if (b > 0 && c > 0) {
        return -1;
      }
      var discriminant = b * b - c;
      if (discriminant < 0) {
        return -1;
      }
      var distance = -b - Math.sqrt(discriminant);
      if (distance < 0) {
        distance = 0;
      }
      return distance;
    }

    /**
     * Check whether the boxes intersect.
     * @param boxA - The first box to check
     * @param boxB - The second box to check
     * @returns True if the boxes intersect, false otherwise
     */;
    CollisionUtil.intersectsBoxAndBox = function intersectsBoxAndBox(boxA, boxB) {
      if (boxA.min.x > boxB.max.x || boxB.min.x > boxA.max.x) {
        return false;
      }
      if (boxA.min.y > boxB.max.y || boxB.min.y > boxA.max.y) {
        return false;
      }
      return !(boxA.min.z > boxB.max.z || boxB.min.z > boxA.max.z);
    }

    /**
     * Check whether the spheres intersect.
     * @param sphereA - The first sphere to check
     * @param sphereB - The second sphere to check
     * @returns True if the spheres intersect, false otherwise
     */;
    CollisionUtil.intersectsSphereAndSphere = function intersectsSphereAndSphere(sphereA, sphereB) {
      var radiisum = sphereA.radius + sphereB.radius;
      return Vector3.distanceSquared(sphereA.center, sphereB.center) < radiisum * radiisum;
    }

    /**
     * Check whether the sphere and the box intersect.
     * @param sphere - The sphere to check
     * @param box - The box to check
     * @returns True if the sphere and the box intersect, false otherwise
     */;
    CollisionUtil.intersectsSphereAndBox = function intersectsSphereAndBox(sphere, box) {
      var center = sphere.center;
      var max = box.max;
      var min = box.min;
      var closestPoint = CollisionUtil._tempVec30;
      closestPoint.set(Math.max(min.x, Math.min(center.x, max.x)), Math.max(min.y, Math.min(center.y, max.y)), Math.max(min.z, Math.min(center.z, max.z)));
      var distance = Vector3.distanceSquared(center, closestPoint);
      return distance <= sphere.radius * sphere.radius;
    }

    /**
     * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
     * @param frustum - The frustum
     * @param box - The box
     * @returns True if bounding box intersects with this frustum, false otherwise
     */;
    CollisionUtil.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
      var min = box.min,
        max = box.max;
      var back = CollisionUtil._tempVec30;
      for (var i = 0; i < 6; ++i) {
        var plane = frustum.getPlane(i);
        var normal = plane.normal;
        back.set(normal.x >= 0 ? min.x : max.x, normal.y >= 0 ? min.y : max.y, normal.z >= 0 ? min.z : max.z);
        if (Vector3.dot(normal, back) > -plane.distance) {
          return false;
        }
      }
      return true;
    }

    /**
     * Get the containment type between a frustum and a box (AABB).
     * @param frustum - The frustum
     * @param box - The box
     * @returns The containment type
     */;
    CollisionUtil.frustumContainsBox = function frustumContainsBox(frustum, box) {
      var min = box.min,
        max = box.max;
      var front = CollisionUtil._tempVec30;
      var back = CollisionUtil._tempVec31;
      var result = exports.ContainmentType.Contains;
      for (var i = 0; i < 6; ++i) {
        var plane = frustum.getPlane(i);
        var normal = plane.normal;
        if (normal.x >= 0) {
          front.x = max.x;
          back.x = min.x;
        } else {
          front.x = min.x;
          back.x = max.x;
        }
        if (normal.y >= 0) {
          front.y = max.y;
          back.y = min.y;
        } else {
          front.y = min.y;
          back.y = max.y;
        }
        if (normal.z >= 0) {
          front.z = max.z;
          back.z = min.z;
        } else {
          front.z = min.z;
          back.z = max.z;
        }
        if (CollisionUtil.intersectsPlaneAndPoint(plane, back) === exports.PlaneIntersectionType.Front) {
          return exports.ContainmentType.Disjoint;
        }
        if (CollisionUtil.intersectsPlaneAndPoint(plane, front) === exports.PlaneIntersectionType.Front) {
          result = exports.ContainmentType.Intersects;
        }
      }
      return result;
    }

    /**
     * Get the containment type between a frustum and a sphere.
     * @param frustum - The frustum
     * @param sphere - The sphere
     * @returns The containment type
     */;
    CollisionUtil.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
      var result = exports.ContainmentType.Contains;
      for (var i = 0; i < 6; ++i) {
        var plane = frustum.getPlane(i);
        var intersectionType = CollisionUtil.intersectsPlaneAndSphere(plane, sphere);
        if (intersectionType === exports.PlaneIntersectionType.Front) {
          return exports.ContainmentType.Disjoint;
        } else if (intersectionType === exports.PlaneIntersectionType.Intersecting) {
          result = exports.ContainmentType.Intersects;
          break;
        }
      }
      return result;
    };
    return CollisionUtil;
  }();
  CollisionUtil._tempVec30 = new Vector3();
  CollisionUtil._tempVec31 = new Vector3();

  /**
   * Represents a plane in three dimensional space.
   */
  var Plane = /*#__PURE__*/function () {
    /**
     * Normalize the normal vector of the specified plane.
     * @param p - The specified plane
     * @param out - A normalized version of the specified plane
     */
    Plane.normalize = function normalize(p, out) {
      var normal = p.normal;
      var factor = 1.0 / normal.length();
      Vector3.scale(normal, factor, out.normal);
      out.distance = p.distance * factor;
    }

    /**
     * Calculate the plane that contains the three specified points.
     * @param point0 - The first point
     * @param point1 - The second point
     * @param point2 - The third point
     * @param out - The calculated plane
     */;
    Plane.fromPoints = function fromPoints(point0, point1, point2, out) {
      var x0 = point0.x;
      var y0 = point0.y;
      var z0 = point0.z;
      var x1 = point1.x - x0;
      var y1 = point1.y - y0;
      var z1 = point1.z - z0;
      var x2 = point2.x - x0;
      var y2 = point2.y - y0;
      var z2 = point2.z - z0;
      var yz = y1 * z2 - z1 * y2;
      var xz = z1 * x2 - x1 * z2;
      var xy = x1 * y2 - y1 * x2;
      var invPyth = 1.0 / Math.sqrt(yz * yz + xz * xz + xy * xy);
      var x = yz * invPyth;
      var y = xz * invPyth;
      var z = xy * invPyth;
      var normal = out.normal;
      normal.x = x;
      normal.y = y;
      normal.z = z;
      out.distance = -(x * x0 + y * y0 + z * z0);
    }

    /** The normal of the plane. */;

    /**
     * Constructor of Plane.
     * @param normal - The normal vector
     * @param distance - The distance of the plane along its normal to the origin
     */
    function Plane(normal, distance) {
      if (normal === void 0) {
        normal = null;
      }
      if (distance === void 0) {
        distance = 0;
      }
      this.normal = new Vector3();
      this.distance = 0;
      normal && this.normal.copyFrom(normal);
      this.distance = distance;
    }

    /**
     * Normalize the normal vector of this plane.
     * @returns The plane after normalize
     */
    var _proto = Plane.prototype;
    _proto.normalize = function normalize() {
      Plane.normalize(this, this);
      return this;
    }

    /**
     * Creates a clone of this plane.
     * @returns A clone of this plane
     */;
    _proto.clone = function clone() {
      var out = new Plane();
      out.copyFrom(this);
      return out;
    }

    /**
     * Copy this plane from the specified plane.
     * @param source - The specified plane
     * @returns This plane
     */;
    _proto.copyFrom = function copyFrom(source) {
      this.normal.copyFrom(source.normal);
      this.distance = source.distance;
      return this;
    };
    return Plane;
  }();

  /**
   * A bounding frustum.
   */
  var BoundingFrustum = /*#__PURE__*/function () {
    /** The near plane of this frustum. */

    /** The far plane of this frustum. */

    /** The left plane of this frustum. */

    /** The right plane of this frustum. */

    /** The top plane of this frustum. */

    /** The bottom plane of this frustum. */

    /**
     * Constructor of BoundingFrustum.
     * @param matrix - The view-projection matrix
     */
    function BoundingFrustum(matrix) {
      if (matrix === void 0) {
        matrix = null;
      }
      this.near = void 0;
      this.far = void 0;
      this.left = void 0;
      this.right = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.near = new Plane();
      this.far = new Plane();
      this.left = new Plane();
      this.right = new Plane();
      this.top = new Plane();
      this.bottom = new Plane();
      matrix && this.calculateFromMatrix(matrix);
    }

    /**
     * Get the plane by the given index.
     * 0: near
     * 1: far
     * 2: left
     * 3: right
     * 4: top
     * 5: bottom
     * @param index - The index
     * @returns The plane get
     */
    var _proto = BoundingFrustum.prototype;
    _proto.getPlane = function getPlane(index) {
      switch (index) {
        case 0:
          return this.near;
        case 1:
          return this.far;
        case 2:
          return this.left;
        case 3:
          return this.right;
        case 4:
          return this.top;
        case 5:
          return this.bottom;
        default:
          return null;
      }
    }

    /**
     * Update all planes from the given matrix.
     * @param matrix - The given view-projection matrix
     */;
    _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
      var me = matrix.elements;
      var m11 = me[0];
      var m12 = me[1];
      var m13 = me[2];
      var m14 = me[3];
      var m21 = me[4];
      var m22 = me[5];
      var m23 = me[6];
      var m24 = me[7];
      var m31 = me[8];
      var m32 = me[9];
      var m33 = me[10];
      var m34 = me[11];
      var m41 = me[12];
      var m42 = me[13];
      var m43 = me[14];
      var m44 = me[15];

      // near
      var nearNormal = this.near.normal;
      nearNormal.set(-m14 - m13, -m24 - m23, -m34 - m33);
      this.near.distance = -m44 - m43;
      this.near.normalize();

      // far
      var farNormal = this.far.normal;
      farNormal.set(m13 - m14, m23 - m24, m33 - m34);
      this.far.distance = m43 - m44;
      this.far.normalize();

      // left
      var leftNormal = this.left.normal;
      leftNormal.set(-m14 - m11, -m24 - m21, -m34 - m31);
      this.left.distance = -m44 - m41;
      this.left.normalize();

      // right
      var rightNormal = this.right.normal;
      rightNormal.set(m11 - m14, m21 - m24, m31 - m34);
      this.right.distance = m41 - m44;
      this.right.normalize();

      // top
      var topNormal = this.top.normal;
      topNormal.set(m12 - m14, m22 - m24, m32 - m34);
      this.top.distance = m42 - m44;
      this.top.normalize();

      // bottom
      var bottomNormal = this.bottom.normal;
      bottomNormal.set(-m14 - m12, -m24 - m22, -m34 - m32);
      this.bottom.distance = -m44 - m42;
      this.bottom.normalize();
    }

    /**
     * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
     * @param box - The box for testing
     * @returns True if bounding box intersects with this frustum, false otherwise
     */;
    _proto.intersectsBox = function intersectsBox(box) {
      return CollisionUtil.intersectsFrustumAndBox(this, box);
    }

    /**
     * Get whether or not a specified bounding sphere intersects with this frustum (Contains or Intersects).
     * @param sphere - The sphere for testing
     * @returns True if bounding sphere intersects with this frustum, false otherwise
     */;
    _proto.intersectsSphere = function intersectsSphere(sphere) {
      return CollisionUtil.frustumContainsSphere(this, sphere) !== exports.ContainmentType.Disjoint;
    }

    /**
     * Creates a clone of this frustum.
     * @returns A clone of this frustum
     */;
    _proto.clone = function clone() {
      var out = new BoundingFrustum();
      out.copyFrom(this);
      return out;
    }

    /**
     * Copy this frustum from the specified frustum.
     * @param source - The specified frustum
     * @returns This frustum
     */;
    _proto.copyFrom = function copyFrom(source) {
      this.near.copyFrom(source.near);
      this.far.copyFrom(source.far);
      this.left.copyFrom(source.left);
      this.right.copyFrom(source.right);
      this.top.copyFrom(source.top);
      this.bottom.copyFrom(source.bottom);
      return this;
    };
    return BoundingFrustum;
  }();

  /**
   * Represents a 3x3 mathematical matrix.
   */
  var Matrix3x3 = /*#__PURE__*/function () {
    /**
     * Determines the sum of two matrices.
     * @param left - The first matrix to add
     * @param right - The second matrix to add
     * @param out - The sum of two matrices
     */
    Matrix3x3.add = function add(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      oe[0] = le[0] + re[0];
      oe[1] = le[1] + re[1];
      oe[2] = le[2] + re[2];
      oe[3] = le[3] + re[3];
      oe[4] = le[4] + re[4];
      oe[5] = le[5] + re[5];
      oe[6] = le[6] + re[6];
      oe[7] = le[7] + re[7];
      oe[8] = le[8] + re[8];
    }

    /**
     * Determines the difference between two matrices.
     * @param left - The first matrix to subtract
     * @param right - The second matrix to subtract
     * @param out - The difference between two matrices
     */;
    Matrix3x3.subtract = function subtract(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      oe[0] = le[0] - re[0];
      oe[1] = le[1] - re[1];
      oe[2] = le[2] - re[2];
      oe[3] = le[3] - re[3];
      oe[4] = le[4] - re[4];
      oe[5] = le[5] - re[5];
      oe[6] = le[6] - re[6];
      oe[7] = le[7] - re[7];
      oe[8] = le[8] - re[8];
    }

    /**
     * Determines the product of two matrices.
     * @param left - The first matrix to multiply
     * @param right - The second matrix to multiply
     * @param out - The product of two matrices
     */;
    Matrix3x3.multiply = function multiply(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      var l11 = le[0],
        l12 = le[1],
        l13 = le[2];
      var l21 = le[3],
        l22 = le[4],
        l23 = le[5];
      var l31 = le[6],
        l32 = le[7],
        l33 = le[8];
      var r11 = re[0],
        r12 = re[1],
        r13 = re[2];
      var r21 = re[3],
        r22 = re[4],
        r23 = re[5];
      var r31 = re[6],
        r32 = re[7],
        r33 = re[8];
      oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
      oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
      oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
      oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
      oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
      oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
      oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
      oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
      oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
    }

    /**
     * Determines whether the specified matrices are equals.
     * @param left - The first matrix to compare
     * @param right - The second matrix to compare
     * @returns True if the specified matrices are equals, false otherwise
     */;
    Matrix3x3.equals = function equals(left, right) {
      var le = left.elements;
      var re = right.elements;
      return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
    }

    /**
     * Performs a linear interpolation between two matrices.
     * @param start - The first matrix
     * @param end - The second matrix
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two matrices
     */;
    Matrix3x3.lerp = function lerp(start, end, t, out) {
      var se = start.elements;
      var ee = end.elements;
      var oe = out.elements;
      var inv = 1.0 - t;
      oe[0] = se[0] * inv + ee[0] * t;
      oe[1] = se[1] * inv + ee[1] * t;
      oe[2] = se[2] * inv + ee[2] * t;
      oe[3] = se[3] * inv + ee[3] * t;
      oe[4] = se[4] * inv + ee[4] * t;
      oe[5] = se[5] * inv + ee[5] * t;
      oe[6] = se[6] * inv + ee[6] * t;
      oe[7] = se[7] * inv + ee[7] * t;
      oe[8] = se[8] * inv + ee[8] * t;
    }

    /**
     * Calculate a rotation matrix from a quaternion.
     * @param quaternion - The quaternion used to calculate the matrix
     * @param out - The calculated rotation matrix
     */;
    Matrix3x3.rotationQuaternion = function rotationQuaternion(quaternion, out) {
      var oe = out.elements;
      var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      oe[0] = 1 - yy - zz;
      oe[3] = yx - wz;
      oe[6] = zx + wy;
      oe[1] = yx + wz;
      oe[4] = 1 - xx - zz;
      oe[7] = zy - wx;
      oe[2] = zx - wy;
      oe[5] = zy + wx;
      oe[8] = 1 - xx - yy;
    }

    /**
     * Calculate a matrix from scale vector.
     * @param s - The scale vector
     * @param out - The calculated matrix
     */;
    Matrix3x3.scaling = function scaling(s, out) {
      var oe = out.elements;
      oe[0] = s._x;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = s._y;
      oe[5] = 0;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 1;
    }

    /**
     * Calculate a matrix from translation vector.
     * @param translation - The translation vector
     * @param out - The calculated matrix
     */;
    Matrix3x3.translation = function translation(_translation, out) {
      var oe = out.elements;
      oe[0] = 1;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 1;
      oe[5] = 0;
      oe[6] = _translation._x;
      oe[7] = _translation._y;
      oe[8] = 1;
    }

    /**
     * Calculate the inverse of the specified matrix.
     * @param a - The matrix whose inverse is to be calculated
     * @param out - The inverse of the specified matrix
     */;
    Matrix3x3.invert = function invert(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      var a11 = ae[0],
        a12 = ae[1],
        a13 = ae[2];
      var a21 = ae[3],
        a22 = ae[4],
        a23 = ae[5];
      var a31 = ae[6],
        a32 = ae[7],
        a33 = ae[8];
      var b12 = a33 * a22 - a23 * a32;
      var b22 = -a33 * a21 + a23 * a31;
      var b32 = a32 * a21 - a22 * a31;
      var det = a11 * b12 + a12 * b22 + a13 * b32;
      if (!det) {
        return;
      }
      det = 1.0 / det;
      oe[0] = b12 * det;
      oe[1] = (-a33 * a12 + a13 * a32) * det;
      oe[2] = (a23 * a12 - a13 * a22) * det;
      oe[3] = b22 * det;
      oe[4] = (a33 * a11 - a13 * a31) * det;
      oe[5] = (-a23 * a11 + a13 * a21) * det;
      oe[6] = b32 * det;
      oe[7] = (-a32 * a11 + a12 * a31) * det;
      oe[8] = (a22 * a11 - a12 * a21) * det;
    }

    /**
     * Calculate a 3x3 normal matrix from a 4x4 matrix.
     * @remarks The calculation process is the transpose matrix of the inverse matrix.
     * @param mat4 - The 4x4 matrix
     * @param out - THe 3x3 normal matrix
     */;
    Matrix3x3.normalMatrix = function normalMatrix(mat4, out) {
      var ae = mat4.elements;
      var oe = out.elements;
      var a11 = ae[0],
        a12 = ae[1],
        a13 = ae[2],
        a14 = ae[3];
      var a21 = ae[4],
        a22 = ae[5],
        a23 = ae[6],
        a24 = ae[7];
      var a31 = ae[8],
        a32 = ae[9],
        a33 = ae[10],
        a34 = ae[11];
      var a41 = ae[12],
        a42 = ae[13],
        a43 = ae[14],
        a44 = ae[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return null;
      }
      det = 1.0 / det;
      oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
      oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
      oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
      oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
      oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
      oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
      oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
      oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
      oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    }

    /**
     * The specified matrix rotates around an angle.
     * @param a - The specified matrix
     * @param r - The rotation angle in radians
     * @param out - The rotated matrix
     */;
    Matrix3x3.rotate = function rotate(a, r, out) {
      var ae = a.elements;
      var oe = out.elements;
      var s = Math.sin(r);
      var c = Math.cos(r);
      var a11 = ae[0],
        a12 = ae[1],
        a13 = ae[2];
      var a21 = ae[3],
        a22 = ae[4],
        a23 = ae[5];
      var a31 = ae[6],
        a32 = ae[7],
        a33 = ae[8];
      oe[0] = c * a11 + s * a21;
      oe[1] = c * a12 + s * a22;
      oe[2] = c * a13 + s * a23;
      oe[3] = c * a21 - s * a11;
      oe[4] = c * a22 - s * a12;
      oe[5] = c * a23 - s * a13;
      oe[6] = a31;
      oe[7] = a32;
      oe[8] = a33;
    }

    /**
     * Scale a matrix by a given vector.
     * @param m - The matrix
     * @param s - The given vector
     * @param out - The scaled matrix
     */;
    Matrix3x3.scale = function scale(m, s, out) {
      var x = s._x,
        y = s._y;
      var ae = m.elements;
      var oe = out.elements;
      oe[0] = x * ae[0];
      oe[1] = x * ae[1];
      oe[2] = x * ae[2];
      oe[3] = y * ae[3];
      oe[4] = y * ae[4];
      oe[5] = y * ae[5];
      oe[6] = ae[6];
      oe[7] = ae[7];
      oe[8] = ae[8];
    }

    /**
     * Translate a matrix by a given vector.
     * @param m - The matrix
     * @param translation - The given vector
     * @param out - The translated matrix
     */;
    Matrix3x3.translate = function translate(m, translation, out) {
      var x = translation._x,
        y = translation._y;
      var ae = m.elements;
      var oe = out.elements;
      var a11 = ae[0],
        a12 = ae[1],
        a13 = ae[2];
      var a21 = ae[3],
        a22 = ae[4],
        a23 = ae[5];
      var a31 = ae[6],
        a32 = ae[7],
        a33 = ae[8];
      oe[0] = a11;
      oe[1] = a12;
      oe[2] = a13;
      oe[3] = a21;
      oe[4] = a22;
      oe[5] = a23;
      oe[6] = x * a11 + y * a21 + a31;
      oe[7] = x * a12 + y * a22 + a32;
      oe[8] = x * a13 + y * a23 + a33;
    }

    /**
     * Calculate the transpose of the specified matrix.
     * @param a - The specified matrix
     * @param out - The transpose of the specified matrix
     */;
    Matrix3x3.transpose = function transpose(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      if (out === a) {
        var a12 = ae[1];
        var a13 = ae[2];
        var a23 = ae[5];
        oe[1] = ae[3];
        oe[2] = ae[6];
        oe[3] = a12;
        oe[5] = ae[7];
        oe[6] = a13;
        oe[7] = a23;
      } else {
        oe[0] = ae[0];
        oe[1] = ae[3];
        oe[2] = ae[6];
        oe[3] = ae[1];
        oe[4] = ae[4];
        oe[5] = ae[7];
        oe[6] = ae[2];
        oe[7] = ae[5];
        oe[8] = ae[8];
      }
    }

    /**
     * An array containing the elements of the matrix (column matrix).
     * @remarks
     * elements[0] first column and first row value m11
     * elements[1] first column and second row value m12
     * elements[2] first column and third row value m13
     * elements[3] second column and first row value m21
     * and so on
     */;

    /**
     * Constructor of 3*3 matrix.
     * @param m11 - Default 1 column 1, row 1
     * @param m12 - Default 0 column 1, row 2
     * @param m13 - Default 0 column 1, row 3
     * @param m21 - Default 0 column 2, row 1
     * @param m22 - Default 1 column 2, row 2
     * @param m23 - Default 0 column 2, row 3
     * @param m31 - Default 0 column 3, row 1
     * @param m32 - Default 0 column 3, row 2
     * @param m33 - Default 1 column 3, row 3
     */
    function Matrix3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
      if (m11 === void 0) {
        m11 = 1;
      }
      if (m12 === void 0) {
        m12 = 0;
      }
      if (m13 === void 0) {
        m13 = 0;
      }
      if (m21 === void 0) {
        m21 = 0;
      }
      if (m22 === void 0) {
        m22 = 1;
      }
      if (m23 === void 0) {
        m23 = 0;
      }
      if (m31 === void 0) {
        m31 = 0;
      }
      if (m32 === void 0) {
        m32 = 0;
      }
      if (m33 === void 0) {
        m33 = 1;
      }
      this.elements = new Float32Array(9);
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m21;
      e[4] = m22;
      e[5] = m23;
      e[6] = m31;
      e[7] = m32;
      e[8] = m33;
    }

    /**
     * Set the value of this matrix, and return this matrix.
     * @param m11
     * @param m12
     * @param m13
     * @param m21
     * @param m22
     * @param m23
     * @param m31
     * @param m32
     * @param m33
     * @returns This matrix
     */
    var _proto = Matrix3x3.prototype;
    _proto.set = function set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m21;
      e[4] = m22;
      e[5] = m23;
      e[6] = m31;
      e[7] = m32;
      e[8] = m33;
      return this;
    }

    /**
     * Determines the sum of this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the sum of the two matrices
     */;
    _proto.add = function add(right) {
      Matrix3x3.add(this, right, this);
      return this;
    }

    /**
     * Determines the difference between this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the difference between the two matrices
     */;
    _proto.subtract = function subtract(right) {
      Matrix3x3.subtract(this, right, this);
      return this;
    }

    /**
     * Determines the product of this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the product of the two matrices
     */;
    _proto.multiply = function multiply(right) {
      Matrix3x3.multiply(this, right, this);
      return this;
    }

    /**
     * Calculate a determinant of this matrix.
     * @returns The determinant of this matrix
     */;
    _proto.determinant = function determinant() {
      var e = this.elements;
      var a11 = e[0],
        a12 = e[1],
        a13 = e[2];
      var a21 = e[3],
        a22 = e[4],
        a23 = e[5];
      var a31 = e[6],
        a32 = e[7],
        a33 = e[8];
      var b12 = a33 * a22 - a23 * a32;
      var b22 = -a33 * a21 + a23 * a31;
      var b32 = a32 * a21 - a22 * a31;
      return a11 * b12 + a12 * b22 + a13 * b32;
    }

    /**
     * Identity this matrix.
     * @returns This matrix after identity
     */;
    _proto.identity = function identity() {
      var e = this.elements;
      e[0] = 1;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 1;
      e[5] = 0;
      e[6] = 0;
      e[7] = 0;
      e[8] = 1;
      return this;
    }

    /**
     * Invert the matrix.
     * @returns The matrix after invert
     */;
    _proto.invert = function invert() {
      Matrix3x3.invert(this, this);
      return this;
    }

    /**
     * This matrix rotates around an angle.
     * @param r - The rotation angle in radians
     * @returns This matrix after rotate
     */;
    _proto.rotate = function rotate(r) {
      Matrix3x3.rotate(this, r, this);
      return this;
    }

    /**
     * Scale this matrix by a given vector.
     * @param s - The given vector
     * @returns This matrix after scale
     */;
    _proto.scale = function scale(s) {
      Matrix3x3.scale(this, s, this);
      return this;
    }

    /**
     * Translate this matrix by a given vector.
     * @param translation - The given vector
     * @returns This matrix after translate
     */;
    _proto.translate = function translate(translation) {
      Matrix3x3.translate(this, translation, this);
      return this;
    }

    /**
     * Calculate the transpose of this matrix.
     * @returns This matrix after transpose
     */;
    _proto.transpose = function transpose() {
      Matrix3x3.transpose(this, this);
      return this;
    }

    /**
     * Creates a clone of this matrix.
     * @returns A clone of this matrix
     */;
    _proto.clone = function clone() {
      var e = this.elements;
      var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
      return ret;
    }

    /**
     * Copy this matrix from the specified matrix.
     * @param source - The specified matrix
     * @returns This matrix
     */;
    _proto.copyFrom = function copyFrom(source) {
      var e = this.elements;
      var se = source.elements;
      e[0] = se[0];
      e[1] = se[1];
      e[2] = se[2];
      e[3] = se[3];
      e[4] = se[4];
      e[5] = se[5];
      e[6] = se[6];
      e[7] = se[7];
      e[8] = se[8];
      return this;
    }

    /**
     * Copy the value of this matrix from an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This matrix
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var srce = this.elements;
      for (var i = 0; i < 12; i++) {
        srce[i] = array[i + offset];
      }
      return this;
    }

    /**
     * Copy the value of this matrix to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      var e = this.elements;
      out[outOffset] = e[0];
      out[outOffset + 1] = e[1];
      out[outOffset + 2] = e[2];
      out[outOffset + 3] = e[3];
      out[outOffset + 4] = e[4];
      out[outOffset + 5] = e[5];
      out[outOffset + 6] = e[6];
      out[outOffset + 7] = e[7];
      out[outOffset + 8] = e[8];
    }

    /**
     * Copy the value of this 3x3 matrix from the specified 4x4 matrix.
     * upper-left principle
     * @param source - The specified 4x4 matrix
     * @returns This 3x3 matrix
     */;
    _proto.copyFromMatrix = function copyFromMatrix(source) {
      var ae = source.elements;
      var e = this.elements;
      e[0] = ae[0];
      e[1] = ae[1];
      e[2] = ae[2];
      e[3] = ae[4];
      e[4] = ae[5];
      e[5] = ae[6];
      e[6] = ae[8];
      e[7] = ae[9];
      e[8] = ae[10];
      return this;
    };
    return Matrix3x3;
  }();

  /**
   * Represents a four dimensional mathematical quaternion.
   */
  var Quaternion = /*#__PURE__*/function () {
    /** @internal */
    /** @internal */
    /**
     * Determines the sum of two quaternions.
     * @param left - The first quaternion to add
     * @param right - The second quaternion to add
     * @param out - The sum of two quaternions
     */
    Quaternion.add = function add(left, right, out) {
      out._x = left._x + right._x;
      out._y = left._y + right._y;
      out._z = left._z + right._z;
      out._w = left._w + right._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the product of two quaternions.
     * @param left - The first quaternion to multiply
     * @param right - The second quaternion to multiply
     * @param out - The product of two quaternions
     */;
    Quaternion.multiply = function multiply(left, right, out) {
      var ax = left._x,
        ay = left._y,
        az = left._z,
        aw = left._w;
      var bx = right._x,
        by = right._y,
        bz = right._z,
        bw = right._w;
      out._x = ax * bw + aw * bx + ay * bz - az * by;
      out._y = ay * bw + aw * by + az * bx - ax * bz;
      out._z = az * bw + aw * bz + ax * by - ay * bx;
      out._w = aw * bw - ax * bx - ay * by - az * bz;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate quaternion that contains conjugated version of the specified quaternion.
     * @param a - The specified quaternion
     * @param out - The conjugate version of the specified quaternion
     */;
    Quaternion.conjugate = function conjugate(a, out) {
      out._x = -a._x;
      out._y = -a._y;
      out._z = -a._z;
      out._w = a._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the dot product of two quaternions.
     * @param left - The first quaternion to dot
     * @param right - The second quaternion to dot
     * @returns The dot product of two quaternions
     */;
    Quaternion.dot = function dot(left, right) {
      return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    }

    /**
     * Determines whether the specified quaternions are equals.
     * @param left - The first quaternion to compare
     * @param right - The second quaternion to compare
     * @returns True if the specified quaternions are equals, false otherwise
     */;
    Quaternion.equals = function equals(left, right) {
      return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
    }

    /**
     * Calculate a quaternion rotates around an arbitrary axis.
     * @param axis - The axis
     * @param rad - The rotation angle in radians
     * @param out - The quaternion after rotate
     */;
    Quaternion.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
      var normalAxis = Quaternion._tempVector3;
      Vector3.normalize(axis, normalAxis);
      rad *= 0.5;
      var s = Math.sin(rad);
      out._x = normalAxis._x * s;
      out._y = normalAxis._y * s;
      out._z = normalAxis._z * s;
      out._w = Math.cos(rad);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion rotates around x, y, z axis (pitch/yaw/roll).
     * @param x - The radian of rotation around X (pitch)
     * @param y - The radian of rotation around Y (yaw)
     * @param z - The radian of rotation around Z (roll)
     * @param out - The calculated quaternion
     */;
    Quaternion.rotationEuler = function rotationEuler(x, y, z, out) {
      Quaternion.rotationYawPitchRoll(y, x, z, out);
    }

    /**
     * Calculate a quaternion from the specified yaw, pitch and roll angles.
     * @param yaw - Yaw around the y axis in radians
     * @param pitch - Pitch around the x axis in radians
     * @param roll - Roll around the z axis in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
      var halfRoll = roll * 0.5;
      var halfPitch = pitch * 0.5;
      var halfYaw = yaw * 0.5;
      var sinRoll = Math.sin(halfRoll);
      var cosRoll = Math.cos(halfRoll);
      var sinPitch = Math.sin(halfPitch);
      var cosPitch = Math.cos(halfPitch);
      var sinYaw = Math.sin(halfYaw);
      var cosYaw = Math.cos(halfYaw);
      var cosYawPitch = cosYaw * cosPitch;
      var sinYawPitch = sinYaw * sinPitch;
      out._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
      out._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      out._z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
      out._w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion from the specified 3x3 matrix.
     * @param m - The specified 3x3 matrix
     * @param out - The calculated quaternion
     */;
    Quaternion.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
      var me = m.elements;
      var m11 = me[0],
        m12 = me[1],
        m13 = me[2];
      var m21 = me[3],
        m22 = me[4],
        m23 = me[5];
      var m31 = me[6],
        m32 = me[7],
        m33 = me[8];
      var scale = m11 + m22 + m33;
      var sqrt, half;
      if (scale > 0) {
        sqrt = Math.sqrt(scale + 1.0);
        out._w = sqrt * 0.5;
        sqrt = 0.5 / sqrt;
        out._x = (m23 - m32) * sqrt;
        out._y = (m31 - m13) * sqrt;
        out._z = (m12 - m21) * sqrt;
      } else if (m11 >= m22 && m11 >= m33) {
        sqrt = Math.sqrt(1.0 + m11 - m22 - m33);
        half = 0.5 / sqrt;
        out._x = 0.5 * sqrt;
        out._y = (m12 + m21) * half;
        out._z = (m13 + m31) * half;
        out._w = (m23 - m32) * half;
      } else if (m22 > m33) {
        sqrt = Math.sqrt(1.0 + m22 - m11 - m33);
        half = 0.5 / sqrt;
        out._x = (m21 + m12) * half;
        out._y = 0.5 * sqrt;
        out._z = (m32 + m23) * half;
        out._w = (m31 - m13) * half;
      } else {
        sqrt = Math.sqrt(1.0 + m33 - m11 - m22);
        half = 0.5 / sqrt;
        out._x = (m13 + m31) * half;
        out._y = (m23 + m32) * half;
        out._z = 0.5 * sqrt;
        out._w = (m12 - m21) * half;
      }
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate the inverse of the specified quaternion.
     * @param a - The quaternion whose inverse is to be calculated
     * @param out - The inverse of the specified quaternion
     */;
    Quaternion.invert = function invert(a, out) {
      var x = a._x,
        y = a._y,
        z = a._z,
        w = a._w;
      var dot = x * x + y * y + z * z + w * w;
      if (dot > MathUtil.zeroTolerance) {
        var invDot = 1.0 / dot;
        out._x = -x * invDot;
        out._y = -y * invDot;
        out._z = -z * invDot;
        out._w = w * invDot;
        out._onValueChanged && out._onValueChanged();
      }
    }

    /**
     * Performs a linear blend between two quaternions.
     * @param start - The first quaternion
     * @param end - The second quaternion
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two quaternions
     */;
    Quaternion.lerp = function lerp(start, end, t, out) {
      var inv = 1.0 - t;
      if (Quaternion.dot(start, end) >= 0) {
        out._x = start._x * inv + end._x * t;
        out._y = start._y * inv + end._y * t;
        out._z = start._z * inv + end._z * t;
        out._w = start._w * inv + end._w * t;
      } else {
        out._x = start._x * inv - end._x * t;
        out._y = start._y * inv - end._y * t;
        out._z = start._z * inv - end._z * t;
        out._w = start._w * inv - end._w * t;
      }
      out.normalize();
    }

    /**
     * Performs a spherical linear blend between two quaternions.
     * @param start - The first quaternion
     * @param end - The second quaternion
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of spherical linear blending between two quaternions
     */;
    Quaternion.slerp = function slerp(start, end, t, out) {
      var ax = start._x;
      var ay = start._y;
      var az = start._z;
      var aw = start._w;
      var bx = end._x;
      var by = end._y;
      var bz = end._z;
      var bw = end._w;
      var scale0, scale1;
      // calc cosine
      var cosom = ax * bx + ay * by + az * bz + aw * bw;
      // adjust signs (if necessary)
      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      // calculate coefficients
      if (1.0 - cosom > MathUtil.zeroTolerance) {
        // standard case (slerp)
        var omega = Math.acos(cosom);
        var sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
      }
      // calculate final values
      out._x = scale0 * ax + scale1 * bx;
      out._y = scale0 * ay + scale1 * by;
      out._z = scale0 * az + scale1 * bz;
      out._w = scale0 * aw + scale1 * bw;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Scales the specified quaternion magnitude to unit length.
     * @param a - The specified quaternion
     * @param out - The normalized quaternion
     */;
    Quaternion.normalize = function normalize(a, out) {
      var _x = a._x,
        _y = a._y,
        _z = a._z,
        _w = a._w;
      var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out._x = _x * len;
        out._y = _y * len;
        out._z = _z * len;
        out._w = _w * len;
        out._onValueChanged && out._onValueChanged();
      }
    }

    /**
     * Calculate a quaternion rotate around X axis.
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotationX = function rotationX(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out._x = s;
      out._y = 0;
      out._z = 0;
      out._w = c;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion rotate around Y axis.
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotationY = function rotationY(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out._x = 0;
      out._y = s;
      out._z = 0;
      out._w = c;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion rotate around Z axis.
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotationZ = function rotationZ(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out._x = 0;
      out._y = 0;
      out._z = s;
      out._w = c;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion that the specified quaternion rotate around X axis.
     * @param quaternion - The specified quaternion
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotateX = function rotateX(quaternion, rad, out) {
      var _x = quaternion._x,
        _y = quaternion._y,
        _z = quaternion._z,
        _w = quaternion._w;
      rad *= 0.5;
      var bx = Math.sin(rad);
      var bw = Math.cos(rad);
      out._x = _x * bw + _w * bx;
      out._y = _y * bw + _z * bx;
      out._z = _z * bw - _y * bx;
      out._w = _w * bw - _x * bx;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion that the specified quaternion rotate around Y axis.
     * @param quaternion - The specified quaternion
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotateY = function rotateY(quaternion, rad, out) {
      var _x = quaternion._x,
        _y = quaternion._y,
        _z = quaternion._z,
        _w = quaternion._w;
      rad *= 0.5;
      var by = Math.sin(rad);
      var bw = Math.cos(rad);
      out._x = _x * bw - _z * by;
      out._y = _y * bw + _w * by;
      out._z = _z * bw + _x * by;
      out._w = _w * bw - _y * by;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a quaternion that the specified quaternion rotate around Z axis.
     * @param quaternion - The specified quaternion
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */;
    Quaternion.rotateZ = function rotateZ(quaternion, rad, out) {
      var _x = quaternion._x,
        _y = quaternion._y,
        _z = quaternion._z,
        _w = quaternion._w;
      rad *= 0.5;
      var bz = Math.sin(rad);
      var bw = Math.cos(rad);
      out._x = _x * bw + _y * bz;
      out._y = _y * bw - _x * bz;
      out._z = _z * bw + _w * bz;
      out._w = _w * bw - _z * bz;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Scale a quaternion by a given number.
     * @param a - The quaternion
     * @param s - The given number
     * @param out - The scaled quaternion
     */;
    Quaternion.scale = function scale(a, s, out) {
      out._x = a._x * s;
      out._y = a._y * s;
      out._z = a._z * s;
      out._w = a._w * s;
      out._onValueChanged && out._onValueChanged();
    }

    /** @internal */;

    /**
     * Constructor of Quaternion.
     * @param x - The x component of the quaternion, default 0
     * @param y - The y component of the quaternion, default 0
     * @param z - The z component of the quaternion, default 0
     * @param w - The w component of the quaternion, default 1
     */
    function Quaternion(x, y, z, w) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (w === void 0) {
        w = 1;
      }
      this._x = void 0;
      this._y = void 0;
      this._z = void 0;
      this._w = void 0;
      this._onValueChanged = null;
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }

    /**
     * Set the value of this quaternion, and return this quaternion.
     * @param x - The x component of the quaternion
     * @param y - The y component of the quaternion
     * @param z - The z component of the quaternion
     * @param w - The w component of the quaternion
     * @returns This quaternion
     */
    var _proto = Quaternion.prototype;
    _proto.set = function set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Transforms this quaternion into its conjugated version.
     * @returns This quaternion
     */;
    _proto.conjugate = function conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Get the rotation axis and rotation angle of the quaternion (unit: radians).
     * @param out - The axis as an output parameter
     * @returns The rotation angle (unit: radians)
     */;
    _proto.getAxisAngle = function getAxisAngle(out) {
      var _x = this._x,
        _y = this._y,
        _z = this._z;
      var length = _x * _x + _y * _y + _z * _z;
      if (length < MathUtil.zeroTolerance) {
        out._x = 1;
        out._y = 0;
        out._z = 0;
        return 0;
      } else {
        var inv = 1.0 / length;
        out._x = this._x * inv;
        out._y = this._y * inv;
        out._z = this._z * inv;
        return Math.acos(this._w) * 2.0;
      }
    }

    /**
     * Identity this quaternion.
     * @returns This quaternion after identity
     */;
    _proto.identity = function identity() {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Calculate the length of this quaternion.
     * @returns The length of this quaternion
     */;
    _proto.length = function length() {
      var _x = this._x,
        _y = this._y,
        _z = this._z,
        _w = this._w;
      return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    }

    /**
     * Calculates the squared length of this quaternion.
     * @returns The squared length of this quaternion
     */;
    _proto.lengthSquared = function lengthSquared() {
      var _x = this._x,
        _y = this._y,
        _z = this._z,
        _w = this._w;
      return _x * _x + _y * _y + _z * _z + _w * _w;
    }

    /**
     * Converts this quaternion into a unit quaternion.
     * @returns This quaternion
     */;
    _proto.normalize = function normalize() {
      Quaternion.normalize(this, this);
      return this;
    }

    /**
     * Get the euler of this quaternion.
     * @param out - The euler (in radians) as an output parameter
     * @returns Euler x->pitch y->yaw z->roll
     */;
    _proto.toEuler = function toEuler(out) {
      this._toYawPitchRoll(out);
      var t = out._x;
      out._x = out._y;
      out._y = t;
      out._onValueChanged && out._onValueChanged();
      return out;
    }

    /**
     * Get the euler of this quaternion.
     * @param out - The euler (in radians) as an output parameter
     * @returns Euler x->yaw y->pitch z->roll
     */;
    _proto.toYawPitchRoll = function toYawPitchRoll(out) {
      this._toYawPitchRoll(out);
      out._onValueChanged && out._onValueChanged();
      return out;
    }

    /**
     * Calculate this quaternion rotate around X axis.
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */;
    _proto.rotateX = function rotateX(rad) {
      Quaternion.rotateX(this, rad, this);
      return this;
    }

    /**
     * Calculate this quaternion rotate around Y axis.
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */;
    _proto.rotateY = function rotateY(rad) {
      Quaternion.rotateY(this, rad, this);
      return this;
    }

    /**
     * Calculate this quaternion rotate around Z axis.
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */;
    _proto.rotateZ = function rotateZ(rad) {
      Quaternion.rotateZ(this, rad, this);
      return this;
    }

    /**
     * Calculate this quaternion rotates around an arbitrary axis.
     * @param axis - The axis
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */;
    _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
      Quaternion.rotationAxisAngle(axis, rad, this);
      return this;
    }

    /**
     * Determines the product of this quaternion and the specified quaternion.
     * @param quat - The specified quaternion
     * @returns The product of the two quaternions
     */;
    _proto.multiply = function multiply(quat) {
      Quaternion.multiply(this, quat, this);
      return this;
    }

    /**
     * Invert this quaternion.
     * @returns This quaternion after invert
     */;
    _proto.invert = function invert() {
      Quaternion.invert(this, this);
      return this;
    }

    /**
     * Determines the dot product of this quaternion and the specified quaternion.
     * @param quat - The specified quaternion
     * @returns The dot product of two quaternions
     */;
    _proto.dot = function dot(quat) {
      return Quaternion.dot(this, quat);
    }

    /**
     * Performs a linear blend between this quaternion and the specified quaternion.
     * @param quat - The specified quaternion
     * @param t - The blend amount where 0 returns this and 1 quat
     * @returns - The result of linear blending between two quaternions
     */;
    _proto.lerp = function lerp(quat, t) {
      Quaternion.lerp(this, quat, t, this);
      return this;
    }

    /**
     * Calculate this quaternion rotation around an arbitrary axis.
     * @param axis - The axis
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */;
    _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
      Quaternion._tempQuat1.rotationAxisAngle(axis, rad);
      this.multiply(Quaternion._tempQuat1);
      return this;
    }

    /**
     * Creates a clone of this quaternion.
     * @returns A clone of this quaternion
     */;
    _proto.clone = function clone() {
      return new Quaternion(this._x, this._y, this._z, this._w);
    }

    /**
     * Copy this quaternion from the specified quaternion.
     * @param source - The specified quaternion
     * @returns This quaternion
     */;
    _proto.copyFrom = function copyFrom(source) {
      this._x = source.x;
      this._y = source.y;
      this._z = source.z;
      this._w = source.w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this quaternion from an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This quaternion
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this quaternion to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      out[outOffset] = this._x;
      out[outOffset + 1] = this._y;
      out[outOffset + 2] = this._z;
      out[outOffset + 3] = this._w;
    };
    _proto._toYawPitchRoll = function _toYawPitchRoll(out) {
      var _x = this._x,
        _y = this._y,
        _z = this._z,
        _w = this._w;
      var xx = _x * _x;
      var yy = _y * _y;
      var zz = _z * _z;
      var xy = _x * _y;
      var zw = _z * _w;
      var zx = _z * _x;
      var yw = _y * _w;
      var yz = _y * _z;
      var xw = _x * _w;
      out._y = Math.asin(2.0 * (xw - yz));
      if (Math.cos(out.y) > MathUtil.zeroTolerance) {
        out._z = Math.atan2(2.0 * (xy + zw), 1.0 - 2.0 * (zz + xx));
        out._x = Math.atan2(2.0 * (zx + yw), 1.0 - 2.0 * (yy + xx));
      } else {
        out._z = Math.atan2(-2.0 * (xy - zw), 1.0 - 2.0 * (yy + zz));
        out._x = 0.0;
      }
      return out;
    };
    _createClass$4(Quaternion, [{
      key: "x",
      get:
      /**
       * The x component of the quaternion.
       */
      function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The y component of the quaternion.
       */
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The z component of the quaternion.
       */
    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * Indicting whether this instance is normalized.
       */
    }, {
      key: "normalized",
      get: function get() {
        return Math.abs(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w - 1) < MathUtil.zeroTolerance;
      }

      /**
       * The w component of the quaternion.
       */
    }, {
      key: "w",
      get: function get() {
        return this._w;
      },
      set: function set(value) {
        this._w = value;
        this._onValueChanged && this._onValueChanged();
      }
    }]);
    return Quaternion;
  }();
  Quaternion._tempVector3 = new Vector3();
  Quaternion._tempQuat1 = new Quaternion();

  /**
   * Represents a 4x4 mathematical matrix.
   */
  var Matrix = /*#__PURE__*/function () {
    /** @internal Identity matrix. */
    /**
     * Determines the product of two matrices.
     * @param left - The first matrix to multiply
     * @param right - The second matrix to multiply
     * @param out - The product of the two matrices
     */
    Matrix.multiply = function multiply(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      var l11 = le[0],
        l12 = le[1],
        l13 = le[2],
        l14 = le[3];
      var l21 = le[4],
        l22 = le[5],
        l23 = le[6],
        l24 = le[7];
      var l31 = le[8],
        l32 = le[9],
        l33 = le[10],
        l34 = le[11];
      var l41 = le[12],
        l42 = le[13],
        l43 = le[14],
        l44 = le[15];
      var r11 = re[0],
        r12 = re[1],
        r13 = re[2],
        r14 = re[3];
      var r21 = re[4],
        r22 = re[5],
        r23 = re[6],
        r24 = re[7];
      var r31 = re[8],
        r32 = re[9],
        r33 = re[10],
        r34 = re[11];
      var r41 = re[12],
        r42 = re[13],
        r43 = re[14],
        r44 = re[15];
      oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
      oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
      oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
      oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
      oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
      oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
      oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
      oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
      oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
      oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
      oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
      oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
      oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
      oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
      oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
      oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    }

    /**
     * Determines whether the specified matrices are equals.
     * @param left - The first matrix to compare
     * @param right - The second matrix to compare
     * @returns True if the specified matrices are equals, false otherwise
     */;
    Matrix.equals = function equals(left, right) {
      var le = left.elements;
      var re = right.elements;
      return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
    }

    /**
     * Performs a linear interpolation between two matrices.
     * @param start - The first matrix
     * @param end - The second matrix
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two matrices
     */;
    Matrix.lerp = function lerp(start, end, t, out) {
      var se = start.elements;
      var ee = end.elements;
      var oe = out.elements;
      var inv = 1.0 - t;
      oe[0] = se[0] * inv + ee[0] * t;
      oe[1] = se[1] * inv + ee[1] * t;
      oe[2] = se[2] * inv + ee[2] * t;
      oe[3] = se[3] * inv + ee[3] * t;
      oe[4] = se[4] * inv + ee[4] * t;
      oe[5] = se[5] * inv + ee[5] * t;
      oe[6] = se[6] * inv + ee[6] * t;
      oe[7] = se[7] * inv + ee[7] * t;
      oe[8] = se[8] * inv + ee[8] * t;
      oe[9] = se[9] * inv + ee[9] * t;
      oe[10] = se[10] * inv + ee[10] * t;
      oe[11] = se[11] * inv + ee[11] * t;
      oe[12] = se[12] * inv + ee[12] * t;
      oe[13] = se[13] * inv + ee[13] * t;
      oe[14] = se[14] * inv + ee[14] * t;
      oe[15] = se[15] * inv + ee[15] * t;
    }

    /**
     * Calculate a rotation matrix from a quaternion.
     * @param quaternion - The quaternion used to calculate the matrix
     * @param out - The calculated rotation matrix
     */;
    Matrix.rotationQuaternion = function rotationQuaternion(quaternion, out) {
      var oe = out.elements;
      var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      oe[0] = 1 - yy - zz;
      oe[1] = yx + wz;
      oe[2] = zx - wy;
      oe[3] = 0;
      oe[4] = yx - wz;
      oe[5] = 1 - xx - zz;
      oe[6] = zy + wx;
      oe[7] = 0;
      oe[8] = zx + wy;
      oe[9] = zy - wx;
      oe[10] = 1 - xx - yy;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }

    /**
     * Calculate a matrix rotates around an arbitrary axis.
     * @param axis - The axis
     * @param r - The rotation angle in radians
     * @param out - The matrix after rotate
     */;
    Matrix.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
      var oe = out.elements;
      var x = axis._x,
        y = axis._y,
        z = axis._z;
      var len = Math.sqrt(x * x + y * y + z * z);
      var s, c, t;
      if (Math.abs(len) < MathUtil.zeroTolerance) {
        return;
      }
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(r);
      c = Math.cos(r);
      t = 1 - c;

      // Perform rotation-specific matrix multiplication
      oe[0] = x * x * t + c;
      oe[1] = y * x * t + z * s;
      oe[2] = z * x * t - y * s;
      oe[3] = 0;
      oe[4] = x * y * t - z * s;
      oe[5] = y * y * t + c;
      oe[6] = z * y * t + x * s;
      oe[7] = 0;
      oe[8] = x * z * t + y * s;
      oe[9] = y * z * t - x * s;
      oe[10] = z * z * t + c;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }

    /**
     * Calculate a matrix from a quaternion and a translation.
     * @param quaternion - The quaternion used to calculate the matrix
     * @param translation - The translation used to calculate the matrix
     * @param out - The calculated matrix
     */;
    Matrix.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
      Matrix.rotationQuaternion(quaternion, out);
      var oe = out.elements;
      oe[12] = translation._x;
      oe[13] = translation._y;
      oe[14] = translation._z;
    }

    /**
     * Calculate an affine matrix.
     * @param scale - The scale used to calculate matrix
     * @param rotation - The rotation used to calculate matrix
     * @param translation - The translation used to calculate matrix
     * @param out - The calculated matrix
     */;
    Matrix.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
      var oe = out.elements;
      var x = rotation._x,
        y = rotation._y,
        z = rotation._z,
        w = rotation._w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var sx = scale._x;
      var sy = scale._y;
      var sz = scale._z;
      oe[0] = (1 - (yy + zz)) * sx;
      oe[1] = (xy + wz) * sx;
      oe[2] = (xz - wy) * sx;
      oe[3] = 0;
      oe[4] = (xy - wz) * sy;
      oe[5] = (1 - (xx + zz)) * sy;
      oe[6] = (yz + wx) * sy;
      oe[7] = 0;
      oe[8] = (xz + wy) * sz;
      oe[9] = (yz - wx) * sz;
      oe[10] = (1 - (xx + yy)) * sz;
      oe[11] = 0;
      oe[12] = translation._x;
      oe[13] = translation._y;
      oe[14] = translation._z;
      oe[15] = 1;
    }

    /**
     * Calculate a matrix from scale vector.
     * @param s - The scale vector
     * @param out - The calculated matrix
     */;
    Matrix.scaling = function scaling(s, out) {
      var oe = out.elements;
      oe[0] = s._x;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = s._y;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = s._z;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }

    /**
     * Calculate a matrix from translation vector.
     * @param translation - The translation vector
     * @param out - The calculated matrix
     */;
    Matrix.translation = function translation(_translation, out) {
      var oe = out.elements;
      oe[0] = 1;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = 1;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = 1;
      oe[11] = 0;
      oe[12] = _translation._x;
      oe[13] = _translation._y;
      oe[14] = _translation._z;
      oe[15] = 1;
    }

    /**
     * Calculate the inverse of the specified matrix.
     * @param a - The matrix whose inverse is to be calculated
     * @param out - The inverse of the specified matrix
     */;
    Matrix.invert = function invert(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      var a11 = ae[0],
        a12 = ae[1],
        a13 = ae[2],
        a14 = ae[3];
      var a21 = ae[4],
        a22 = ae[5],
        a23 = ae[6],
        a24 = ae[7];
      var a31 = ae[8],
        a32 = ae[9],
        a33 = ae[10],
        a34 = ae[11];
      var a41 = ae[12],
        a42 = ae[13],
        a43 = ae[14],
        a44 = ae[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return null;
      }
      det = 1.0 / det;
      oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
      oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
      oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
      oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
      oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
      oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
      oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
      oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
      oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
      oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
      oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
      oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
      oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
      oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
      oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
      oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
    }

    /**
     * Calculate a right-handed look-at matrix.
     * @param eye - The position of the viewer's eye
     * @param target - The camera look-at target
     * @param up - The camera's up vector
     * @param out - The calculated look-at matrix
     */;
    Matrix.lookAt = function lookAt(eye, target, up, out) {
      var oe = out.elements;
      var xAxis = Matrix._tempVec30;
      var yAxis = Matrix._tempVec31;
      var zAxis = Matrix._tempVec32;
      Vector3.subtract(eye, target, zAxis);
      zAxis.normalize();
      Vector3.cross(up, zAxis, xAxis);
      xAxis.normalize();
      Vector3.cross(zAxis, xAxis, yAxis);
      oe[0] = xAxis._x;
      oe[1] = yAxis._x;
      oe[2] = zAxis._x;
      oe[3] = 0;
      oe[4] = xAxis._y;
      oe[5] = yAxis._y;
      oe[6] = zAxis._y;
      oe[7] = 0;
      oe[8] = xAxis._z;
      oe[9] = yAxis._z;
      oe[10] = zAxis._z;
      oe[11] = 0;
      oe[12] = -Vector3.dot(xAxis, eye);
      oe[13] = -Vector3.dot(yAxis, eye);
      oe[14] = -Vector3.dot(zAxis, eye);
      oe[15] = 1;
    }

    /**
     * Calculate an orthographic projection matrix.
     * @param left - The left edge of the viewing
     * @param right - The right edge of the viewing
     * @param bottom - The bottom edge of the viewing
     * @param top - The top edge of the viewing
     * @param near - The depth of the near plane
     * @param far - The depth of the far plane
     * @param out - The calculated orthographic projection matrix
     */;
    Matrix.ortho = function ortho(left, right, bottom, top, near, far, out) {
      var oe = out.elements;
      var lr = 1 / (left - right);
      var bt = 1 / (bottom - top);
      var nf = 1 / (near - far);
      oe[0] = -2 * lr;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = -2 * bt;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = 2 * nf;
      oe[11] = 0;
      oe[12] = (left + right) * lr;
      oe[13] = (top + bottom) * bt;
      oe[14] = (far + near) * nf;
      oe[15] = 1;
    }

    /**
     * Calculate a perspective projection matrix.
     * @param fovY - Field of view in the y direction, in radians
     * @param aspect - Aspect ratio, defined as view space width divided by height
     * @param near - The depth of the near plane
     * @param far - The depth of the far plane
     * @param out - The calculated perspective projection matrix
     */;
    Matrix.perspective = function perspective(fovY, aspect, near, far, out) {
      var oe = out.elements;
      var f = 1.0 / Math.tan(fovY / 2);
      var nf = 1 / (near - far);
      oe[0] = f / aspect;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = f;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = (far + near) * nf;
      oe[11] = -1;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 2 * far * near * nf;
      oe[15] = 0;
    }

    /**
     * The specified matrix rotates around an arbitrary axis.
     * @param m - The specified matrix
     * @param axis - The axis
     * @param r - The rotation angle in radians
     * @param out - The rotated matrix
     */;
    Matrix.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
      var x = axis._x,
        y = axis._y,
        z = axis._z;
      var len = Math.sqrt(x * x + y * y + z * z);
      if (Math.abs(len) < MathUtil.zeroTolerance) {
        return;
      }
      var me = m.elements;
      var oe = out.elements;
      var s, c, t;
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(r);
      c = Math.cos(r);
      t = 1 - c;
      var a11 = me[0],
        a12 = me[1],
        a13 = me[2],
        a14 = me[3];
      var a21 = me[4],
        a22 = me[5],
        a23 = me[6],
        a24 = me[7];
      var a31 = me[8],
        a32 = me[9],
        a33 = me[10],
        a34 = me[11];

      // Construct the elements of the rotation matrix
      var b11 = x * x * t + c;
      var b12 = y * x * t + z * s;
      var b13 = z * x * t - y * s;
      var b21 = x * y * t - z * s;
      var b22 = y * y * t + c;
      var b23 = z * y * t + x * s;
      var b31 = x * z * t + y * s;
      var b32 = y * z * t - x * s;
      var b33 = z * z * t + c;

      // Perform rotation-specific matrix multiplication
      oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
      oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
      oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
      oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
      oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
      oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
      oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
      oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
      oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
      oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
      oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
      oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
      if (m !== out) {
        // If the source and destination differ, copy the unchanged last row
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
      }
    }

    /**
     * Scale a matrix by a given vector.
     * @param m - The matrix
     * @param s - The given vector
     * @param out - The scaled matrix
     */;
    Matrix.scale = function scale(m, s, out) {
      var me = m.elements;
      var oe = out.elements;
      var x = s._x,
        y = s._y,
        z = s._z;
      oe[0] = me[0] * x;
      oe[1] = me[1] * x;
      oe[2] = me[2] * x;
      oe[3] = me[3] * x;
      oe[4] = me[4] * y;
      oe[5] = me[5] * y;
      oe[6] = me[6] * y;
      oe[7] = me[7] * y;
      oe[8] = me[8] * z;
      oe[9] = me[9] * z;
      oe[10] = me[10] * z;
      oe[11] = me[11] * z;
      oe[12] = me[12];
      oe[13] = me[13];
      oe[14] = me[14];
      oe[15] = me[15];
    }

    /**
     * Translate a matrix by a given vector.
     * @param m - The matrix
     * @param v - The given vector
     * @param out - The translated matrix
     */;
    Matrix.translate = function translate(m, v, out) {
      var me = m.elements;
      var oe = out.elements;
      var x = v._x,
        y = v._y,
        z = v._z;
      if (m === out) {
        oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
        oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
        oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
        oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
      } else {
        var a11 = me[0],
          a12 = me[1],
          a13 = me[2],
          a14 = me[3];
        var a21 = me[4],
          a22 = me[5],
          a23 = me[6],
          a24 = me[7];
        var a31 = me[8],
          a32 = me[9],
          a33 = me[10],
          a34 = me[11];
        oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
        oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
        oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
        oe[12] = a11 * x + a21 * y + a31 * z + me[12];
        oe[13] = a12 * x + a22 * y + a32 * z + me[13];
        oe[14] = a13 * x + a23 * y + a33 * z + me[14];
        oe[15] = a14 * x + a24 * y + a34 * z + me[15];
      }
    }

    /**
     * Calculate the transpose of the specified matrix.
     * @param a - The specified matrix
     * @param out - The transpose of the specified matrix
     */;
    Matrix.transpose = function transpose(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      if (out === a) {
        var a12 = ae[1];
        var a13 = ae[2];
        var a14 = ae[3];
        var a23 = ae[6];
        var a24 = ae[7];
        var a34 = ae[11];
        oe[1] = ae[4];
        oe[2] = ae[8];
        oe[3] = ae[12];
        oe[4] = a12;
        oe[6] = ae[9];
        oe[7] = ae[13];
        oe[8] = a13;
        oe[9] = a23;
        oe[11] = ae[14];
        oe[12] = a14;
        oe[13] = a24;
        oe[14] = a34;
      } else {
        oe[0] = ae[0];
        oe[1] = ae[4];
        oe[2] = ae[8];
        oe[3] = ae[12];
        oe[4] = ae[1];
        oe[5] = ae[5];
        oe[6] = ae[9];
        oe[7] = ae[13];
        oe[8] = ae[2];
        oe[9] = ae[6];
        oe[10] = ae[10];
        oe[11] = ae[14];
        oe[12] = ae[3];
        oe[13] = ae[7];
        oe[14] = ae[11];
        oe[15] = ae[15];
      }
    }

    /**
     * An array containing the elements of the matrix (column matrix).
     * @remarks
     * elements[0] first column and first row value m11
     * elements[1] first column and second row value m12
     * elements[2] first column and third row value m13
     * elements[3] first column and fourth row value m14
     * elements[4] second column and first row value m21
     * and so on
     */;

    /**
     * Constructor of 4x4 Matrix.
     * @param m11 - default 1, column 1, row 1
     * @param m12 - default 0, column 1, row 2
     * @param m13 - default 0, column 1, row 3
     * @param m14 - default 0, column 1, row 4
     * @param m21 - default 0, column 2, row 1
     * @param m22 - default 1, column 2, row 2
     * @param m23 - default 0, column 2, row 3
     * @param m24 - default 0, column 2, row 4
     * @param m31 - default 0, column 3, row 1
     * @param m32 - default 0, column 3, row 2
     * @param m33 - default 1, column 3, row 3
     * @param m34 - default 0, column 3, row 4
     * @param m41 - default 0, column 4, row 1
     * @param m42 - default 0, column 4, row 2
     * @param m43 - default 0, column 4, row 3
     * @param m44 - default 1, column 4, row 4
     */
    function Matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
      if (m11 === void 0) {
        m11 = 1;
      }
      if (m12 === void 0) {
        m12 = 0;
      }
      if (m13 === void 0) {
        m13 = 0;
      }
      if (m14 === void 0) {
        m14 = 0;
      }
      if (m21 === void 0) {
        m21 = 0;
      }
      if (m22 === void 0) {
        m22 = 1;
      }
      if (m23 === void 0) {
        m23 = 0;
      }
      if (m24 === void 0) {
        m24 = 0;
      }
      if (m31 === void 0) {
        m31 = 0;
      }
      if (m32 === void 0) {
        m32 = 0;
      }
      if (m33 === void 0) {
        m33 = 1;
      }
      if (m34 === void 0) {
        m34 = 0;
      }
      if (m41 === void 0) {
        m41 = 0;
      }
      if (m42 === void 0) {
        m42 = 0;
      }
      if (m43 === void 0) {
        m43 = 0;
      }
      if (m44 === void 0) {
        m44 = 1;
      }
      this.elements = new Float32Array(16);
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m14;
      e[4] = m21;
      e[5] = m22;
      e[6] = m23;
      e[7] = m24;
      e[8] = m31;
      e[9] = m32;
      e[10] = m33;
      e[11] = m34;
      e[12] = m41;
      e[13] = m42;
      e[14] = m43;
      e[15] = m44;
    }

    /**
     * Set the value of this matrix, and return this matrix.
     * @param m11 - column 1, row 1
     * @param m12 - column 1, row 2
     * @param m13 - column 1, row 3
     * @param m14 - column 1, row 4
     * @param m21 - column 2, row 1
     * @param m22 - column 2, row 2
     * @param m23 - column 2, row 3
     * @param m24 - column 2, row 4
     * @param m31 - column 3, row 1
     * @param m32 - column 3, row 2
     * @param m33 - column 3, row 3
     * @param m34 - column 3, row 4
     * @param m41 - column 4, row 1
     * @param m42 - column 4, row 2
     * @param m43 - column 4, row 3
     * @param m44 - column 4, row 4
     * @returns This matrix
     */
    var _proto = Matrix.prototype;
    _proto.set = function set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m14;
      e[4] = m21;
      e[5] = m22;
      e[6] = m23;
      e[7] = m24;
      e[8] = m31;
      e[9] = m32;
      e[10] = m33;
      e[11] = m34;
      e[12] = m41;
      e[13] = m42;
      e[14] = m43;
      e[15] = m44;
      return this;
    }

    /**
     * Determines the product of this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the product of the two matrices
     */;
    _proto.multiply = function multiply(right) {
      Matrix.multiply(this, right, this);
      return this;
    }

    /**
     * Calculate a determinant of this matrix.
     * @returns The determinant of this matrix
     */;
    _proto.determinant = function determinant() {
      var e = this.elements;
      var a11 = e[0],
        a12 = e[1],
        a13 = e[2],
        a14 = e[3];
      var a21 = e[4],
        a22 = e[5],
        a23 = e[6],
        a24 = e[7];
      var a31 = e[8],
        a32 = e[9],
        a33 = e[10],
        a34 = e[11];
      var a41 = e[12],
        a42 = e[13],
        a43 = e[14],
        a44 = e[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;

      // Calculate the determinant
      return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    }

    /**
     * Decompose this matrix to translation, rotation and scale elements.
     * @param translation - Translation vector as an output parameter
     * @param rotation - Rotation quaternion as an output parameter
     * @param scale - Scale vector as an output parameter
     * @returns True if this matrix can be decomposed, false otherwise
     */;
    _proto.decompose = function decompose(translation, rotation, scale) {
      var rm = Matrix._tempMat30;
      var e = this.elements;
      var rme = rm.elements;
      var m11 = e[0];
      var m12 = e[1];
      var m13 = e[2];
      var m14 = e[3];
      var m21 = e[4];
      var m22 = e[5];
      var m23 = e[6];
      var m24 = e[7];
      var m31 = e[8];
      var m32 = e[9];
      var m33 = e[10];
      var m34 = e[11];
      translation.set(e[12], e[13], e[14]);
      var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
      var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
      var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
      var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
      var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
      var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
      scale.set(sx, sy, sz);
      if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
        rotation.identity();
        return false;
      } else {
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        rme[0] = m11 * invSX;
        rme[1] = m12 * invSX;
        rme[2] = m13 * invSX;
        rme[3] = m21 * invSY;
        rme[4] = m22 * invSY;
        rme[5] = m23 * invSY;
        rme[6] = m31 * invSZ;
        rme[7] = m32 * invSZ;
        rme[8] = m33 * invSZ;
        Quaternion.rotationMatrix3x3(rm, rotation);
        return true;
      }
    }

    /**
     * Get rotation from this matrix.
     * @param out - Rotation quaternion as an output parameter
     * @returns The out
     */;
    _proto.getRotation = function getRotation(out) {
      var e = this.elements;
      var trace = e[0] + e[5] + e[10];
      if (trace > MathUtil.zeroTolerance) {
        var s = Math.sqrt(trace + 1.0) * 2;
        out._w = 0.25 * s;
        out._x = (e[6] - e[9]) / s;
        out._y = (e[8] - e[2]) / s;
        out._z = (e[1] - e[4]) / s;
      } else if (e[0] > e[5] && e[0] > e[10]) {
        var _s = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;
        out._w = (e[6] - e[9]) / _s;
        out._x = 0.25 * _s;
        out._y = (e[1] + e[4]) / _s;
        out._z = (e[8] + e[2]) / _s;
      } else if (e[5] > e[10]) {
        var _s2 = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;
        out._w = (e[8] - e[2]) / _s2;
        out._x = (e[1] + e[4]) / _s2;
        out._y = 0.25 * _s2;
        out._z = (e[6] + e[9]) / _s2;
      } else {
        var _s3 = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;
        out._w = (e[1] - e[4]) / _s3;
        out._x = (e[8] + e[2]) / _s3;
        out._y = (e[6] + e[9]) / _s3;
        out._z = 0.25 * _s3;
      }
      out._onValueChanged && out._onValueChanged();
      return out;
    }

    /**
     * Get scale from this matrix.
     * @param out - Scale vector as an output parameter
     * @returns The out
     */;
    _proto.getScaling = function getScaling(out) {
      //getScale()
      var e = this.elements;
      var m11 = e[0],
        m12 = e[1],
        m13 = e[2];
      var m21 = e[4],
        m22 = e[5],
        m23 = e[6];
      var m31 = e[8],
        m32 = e[9],
        m33 = e[10];
      out.set(Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13), Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33));
      return out;
    }

    /**
     * Get translation from this matrix.
     * @param out - Translation vector as an output parameter
     * @returns The out
     */;
    _proto.getTranslation = function getTranslation(out) {
      var e = this.elements;
      out.set(e[12], e[13], e[14]);
      return out;
    }

    /**
     * Identity this matrix.
     * @returns This matrix after identity
     */;
    _proto.identity = function identity() {
      var e = this.elements;
      e[0] = 1;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 0;
      e[5] = 1;
      e[6] = 0;
      e[7] = 0;
      e[8] = 0;
      e[9] = 0;
      e[10] = 1;
      e[11] = 0;
      e[12] = 0;
      e[13] = 0;
      e[14] = 0;
      e[15] = 1;
      return this;
    }

    /**
     * Invert the matrix.
     * @returns The matrix after invert
     */;
    _proto.invert = function invert() {
      Matrix.invert(this, this);
      return this;
    }

    /**
     * This matrix rotates around an arbitrary axis.
     * @param axis - The axis
     * @param r - The rotation angle in radians
     * @returns This matrix after rotate
     */;
    _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
      Matrix.rotateAxisAngle(this, axis, r, this);
      return this;
    }

    /**
     * Scale this matrix by a given vector.
     * @param s - The given vector
     * @returns This matrix after scale
     */;
    _proto.scale = function scale(s) {
      Matrix.scale(this, s, this);
      return this;
    }

    /**
     * Translate this matrix by a given vector.
     * @param v - The given vector
     * @returns This matrix after translate
     */;
    _proto.translate = function translate(v) {
      Matrix.translate(this, v, this);
      return this;
    }

    /**
     * Calculate the transpose of this matrix.
     * @returns This matrix after transpose
     */;
    _proto.transpose = function transpose() {
      Matrix.transpose(this, this);
      return this;
    }

    /**
     * Creates a clone of this matrix.
     * @returns A clone of this matrix
     */;
    _proto.clone = function clone() {
      var e = this.elements;
      var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
      return ret;
    }

    /**
     * Copy this matrix from the specified matrix.
     * @param source - The specified matrix
     * @returns This matrix
     */;
    _proto.copyFrom = function copyFrom(source) {
      var e = this.elements;
      var se = source.elements;
      e[0] = se[0];
      e[1] = se[1];
      e[2] = se[2];
      e[3] = se[3];
      e[4] = se[4];
      e[5] = se[5];
      e[6] = se[6];
      e[7] = se[7];
      e[8] = se[8];
      e[9] = se[9];
      e[10] = se[10];
      e[11] = se[11];
      e[12] = se[12];
      e[13] = se[13];
      e[14] = se[14];
      e[15] = se[15];
      return this;
    }

    /**
     * Copy the value of this matrix from an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This matrix
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var srce = this.elements;
      for (var i = 0; i < 16; i++) {
        srce[i] = array[i + offset];
      }
      return this;
    }

    /**
     * Copy the value of this matrix to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      var e = this.elements;
      out[outOffset] = e[0];
      out[outOffset + 1] = e[1];
      out[outOffset + 2] = e[2];
      out[outOffset + 3] = e[3];
      out[outOffset + 4] = e[4];
      out[outOffset + 5] = e[5];
      out[outOffset + 6] = e[6];
      out[outOffset + 7] = e[7];
      out[outOffset + 8] = e[8];
      out[outOffset + 9] = e[9];
      out[outOffset + 10] = e[10];
      out[outOffset + 11] = e[11];
      out[outOffset + 12] = e[12];
      out[outOffset + 13] = e[13];
      out[outOffset + 14] = e[14];
      out[outOffset + 15] = e[15];
    };
    return Matrix;
  }();
  Matrix._tempVec30 = new Vector3();
  Matrix._tempVec31 = new Vector3();
  Matrix._tempVec32 = new Vector3();
  Matrix._tempMat30 = new Matrix3x3();
  Matrix._identity = new Matrix(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);

  /**
   * Represents a ray with an origin and a direction in 3D space.
   */
  var Ray = /*#__PURE__*/function () {
    /** The origin of the ray. */

    /** The normalized direction of the ray. */

    /**
     * Constructor of Ray.
     * @param origin - The origin vector
     * @param direction - The direction vector
     */
    function Ray(origin, direction) {
      if (origin === void 0) {
        origin = null;
      }
      if (direction === void 0) {
        direction = null;
      }
      this.origin = new Vector3();
      this.direction = new Vector3();
      origin && this.origin.copyFrom(origin);
      direction && this.direction.copyFrom(direction);
    }

    /**
     * Check if this ray intersects the specified plane.
     * @param plane - The specified plane
     * @returns The distance from this ray to the specified plane if intersecting, -1 otherwise
     */
    var _proto = Ray.prototype;
    _proto.intersectPlane = function intersectPlane(plane) {
      return CollisionUtil.intersectsRayAndPlane(this, plane);
    }

    /**
     * Check if this ray intersects the specified sphere.
     * @param sphere - The specified sphere
     * @returns The distance from this ray to the specified sphere if intersecting, -1 otherwise
     */;
    _proto.intersectSphere = function intersectSphere(sphere) {
      return CollisionUtil.intersectsRayAndSphere(this, sphere);
    }

    /**
     * Check if this ray intersects the specified box (AABB).
     * @param box - The specified box
     * @returns The distance from this ray to the specified box if intersecting, -1 otherwise
     */;
    _proto.intersectBox = function intersectBox(box) {
      return CollisionUtil.intersectsRayAndBox(this, box);
    }

    /**
     * The coordinates of the specified distance from the origin in the ray direction.
     * @param distance - The specified distance
     * @param out - The coordinates as an output parameter
     * @returns The out
     */;
    _proto.getPoint = function getPoint(distance, out) {
      Vector3.scale(this.direction, distance, out);
      return out.add(this.origin);
    };
    return Ray;
  }();

  /**
   * Describes a 2D-vector.
   */
  var Vector2 = /*#__PURE__*/function () {
    /** @internal */
    /** @internal */
    /**
     * Determines the sum of two vectors.
     * @param left - The first vector to add
     * @param right - The second vector to add
     * @param out - The sum of two vectors
     */
    Vector2.add = function add(left, right, out) {
      out._x = left._x + right._x;
      out._y = left._y + right._y;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the difference between two vectors.
     * @param left - The first vector to subtract
     * @param right - The second vector to subtract
     * @param out - The difference between two vectors
     */;
    Vector2.subtract = function subtract(left, right, out) {
      out._x = left._x - right._x;
      out._y = left._y - right._y;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the product of two vectors.
     * @param left - The first vector to multiply
     * @param right - The second vector to multiply
     * @param out - The product of two vectors
     */;
    Vector2.multiply = function multiply(left, right, out) {
      out._x = left._x * right._x;
      out._y = left._y * right._y;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the divisor of two vectors.
     * @param left - The first vector to divide
     * @param right - The second vector to divide
     * @param out - The divisor of two vectors
     */;
    Vector2.divide = function divide(left, right, out) {
      out._x = left._x / right._x;
      out._y = left._y / right._y;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the dot product of two vectors.
     * @param left - The first vector to dot
     * @param right - The second vector to dot
     * @returns The dot product of two vectors
     */;
    Vector2.dot = function dot(left, right) {
      return left._x * right._x + left._y * right._y;
    }

    /**
     * Determines the distance of two vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @returns The distance of two vectors
     */;
    Vector2.distance = function distance(left, right) {
      var x = right._x - left._x;
      var y = right._y - left._y;
      return Math.sqrt(x * x + y * y);
    }

    /**
     * Determines the squared distance of two vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @returns The squared distance of two vectors
     */;
    Vector2.distanceSquared = function distanceSquared(left, right) {
      var x = right._x - left._x;
      var y = right._y - left._y;
      return x * x + y * y;
    }

    /**
     * Determines whether the specified vectors are equals.
     * @param left - The first vector to compare
     * @param right - The second vector to compare
     * @returns True if the specified vectors are equals, false otherwise
     */;
    Vector2.equals = function equals(left, right) {
      return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y);
    }

    /**
     * Performs a linear interpolation between two vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param t - The blend amount where 0 returns left and 1 right
     * @param out - The result of linear blending between two vectors
     */;
    Vector2.lerp = function lerp(left, right, t, out) {
      var _x = left._x,
        _y = left._y;
      out._x = _x + (right._x - _x) * t;
      out._y = _y + (right._y - _y) * t;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a vector containing the largest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the largest components of the specified vectors
     */;
    Vector2.max = function max(left, right, out) {
      out._x = Math.max(left._x, right._x);
      out._y = Math.max(left._y, right._y);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a vector containing the smallest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the smallest components of the specified vectors
     */;
    Vector2.min = function min(left, right, out) {
      out._x = Math.min(left._x, right._x);
      out._y = Math.min(left._y, right._y);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Reverses the direction of a given vector.
     * @param left - The vector to negate
     * @param out - The vector facing in the opposite direction
     */;
    Vector2.negate = function negate(left, out) {
      out._x = -left._x;
      out._y = -left._y;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Converts the vector into a unit vector.
     * @param left - The vector to normalize
     * @param out - The normalized vector
     */;
    Vector2.normalize = function normalize(left, out) {
      var _x = left._x,
        _y = left._y;
      var len = Math.sqrt(_x * _x + _y * _y);
      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out._x = _x * len;
        out._y = _y * len;
        out._onValueChanged && out._onValueChanged();
      }
    }

    /**
     * Scale a vector by the given value.
     * @param left - The vector to scale
     * @param s - The amount by which to scale the vector
     * @param out - The scaled vector
     */;
    Vector2.scale = function scale(left, s, out) {
      out._x = left._x * s;
      out._y = left._y * s;
      out._onValueChanged && out._onValueChanged();
    }

    /** @internal */;

    /**
     * Constructor of Vector2.
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     */
    function Vector2(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this._x = void 0;
      this._y = void 0;
      this._onValueChanged = null;
      this._x = x;
      this._y = y;
    }

    /**
     * Set the value of this vector.
     * @param x - The x component of the vector
     * @param y - The y component of the vector
     * @returns This vector
     */
    var _proto = Vector2.prototype;
    _proto.set = function set(x, y) {
      this._x = x;
      this._y = y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the sum of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.add = function add(right) {
      this._x += right._x;
      this._y += right._y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the difference of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.subtract = function subtract(right) {
      this._x -= right._x;
      this._y -= right._y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the product of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.multiply = function multiply(right) {
      this._x *= right._x;
      this._y *= right._y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the divisor of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.divide = function divide(right) {
      this._x /= right._x;
      this._y /= right._y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Calculate the length of this vector.
     * @returns The length of this vector
     */;
    _proto.length = function length() {
      var _x = this._x,
        _y = this._y;
      return Math.sqrt(_x * _x + _y * _y);
    }

    /**
     * Calculate the squared length of this vector.
     * @returns The squared length of this vector
     */;
    _proto.lengthSquared = function lengthSquared() {
      var _x = this._x,
        _y = this._y;
      return _x * _x + _y * _y;
    }

    /**
     * Reverses the direction of this vector.
     * @returns This vector
     */;
    _proto.negate = function negate() {
      this._x = -this._x;
      this._y = -this._y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Converts this vector into a unit vector.
     * @returns This vector
     */;
    _proto.normalize = function normalize() {
      Vector2.normalize(this, this);
      return this;
    }

    /**
     * Scale this vector by the given value.
     * @param s - The amount by which to scale the vector
     * @returns This vector
     */;
    _proto.scale = function scale(s) {
      this._x *= s;
      this._y *= s;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Creates a clone of this vector.
     * @returns A clone of this vector
     */;
    _proto.clone = function clone() {
      return new Vector2(this._x, this._y);
    }

    /**
     * Copy from vector2 like object.
     * @param source - Vector2 like object
     * @returns This vector
     */;
    _proto.copyFrom = function copyFrom(source) {
      this._x = source.x;
      this._y = source.y;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this vector from an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This vector
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this._x = array[offset];
      this._y = array[offset + 1];
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this vector to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      out[outOffset] = this._x;
      out[outOffset + 1] = this._y;
    };
    _createClass$4(Vector2, [{
      key: "x",
      get:
      /**
       * The x component of the vector.
       */
      function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The y component of the vector.
       */
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }
    }]);
    return Vector2;
  }();
  Vector2._zero = new Vector2(0.0, 0.0);
  Vector2._one = new Vector2(1.0, 1.0);

  /**
   * Describes a 4D-vector.
   */
  var Vector4 = /*#__PURE__*/function () {
    /** @internal */
    /** @internal */
    /**
     * Determines the sum of two vectors.
     * @param left - The first vector to add
     * @param right - The second vector to add
     * @param out - The sum of two vectors
     */
    Vector4.add = function add(left, right, out) {
      out._x = left._x + right._x;
      out._y = left._y + right._y;
      out._z = left._z + right._z;
      out._w = left._w + right._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the difference between two vectors.
     * @param left - The first vector to subtract
     * @param right - The second vector to subtract
     * @param out - The difference between two vectors
     */;
    Vector4.subtract = function subtract(left, right, out) {
      out._x = left._x - right._x;
      out._y = left._y - right._y;
      out._z = left._z - right._z;
      out._w = left._w - right._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the product of two vectors.
     * @param left - The first vector to multiply
     * @param right - The second vector to multiply
     * @param out - The product of two vectors
     */;
    Vector4.multiply = function multiply(left, right, out) {
      out._x = left._x * right._x;
      out._y = left._y * right._y;
      out._z = left._z * right._z;
      out._w = left._w * right._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the divisor of two vectors.
     * @param left - The first vector to divide
     * @param right - The second vector to divide
     * @param out - The divisor of two vectors
     */;
    Vector4.divide = function divide(left, right, out) {
      out._x = left._x / right._x;
      out._y = left._y / right._y;
      out._z = left._z / right._z;
      out._w = left._w / right._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Determines the dot product of two vectors.
     * @param left - The first vector to dot
     * @param right - The second vector to dot
     * @returns The dot product of two vectors
     */;
    Vector4.dot = function dot(left, right) {
      return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    }

    /**
     * Determines the distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The distance of two vectors
     */;
    Vector4.distance = function distance(a, b) {
      var x = b._x - a._x;
      var y = b._y - a._y;
      var z = b._z - a._z;
      var w = b._w - a._w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }

    /**
     * Determines the squared distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The squared distance of two vectors
     */;
    Vector4.distanceSquared = function distanceSquared(a, b) {
      var x = b._x - a._x;
      var y = b._y - a._y;
      var z = b._z - a._z;
      var w = b._w - a._w;
      return x * x + y * y + z * z + w * w;
    }

    /**
     * Determines whether the specified vectors are equals.
     * @param left - The first vector to compare
     * @param right - The second vector to compare
     * @returns True if the specified vectors are equals, false otherwise
     */;
    Vector4.equals = function equals(left, right) {
      return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
    }

    /**
     * Performs a linear interpolation between two vectors.
     * @param start - The first vector
     * @param end - The second vector
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two vectors
     */;
    Vector4.lerp = function lerp(start, end, t, out) {
      var _x = start._x,
        _y = start._y,
        _z = start._z,
        _w = start._w;
      out._x = _x + (end._x - _x) * t;
      out._y = _y + (end._y - _y) * t;
      out._z = _z + (end._z - _z) * t;
      out._w = _w + (end._w - _w) * t;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a vector containing the largest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the largest components of the specified vectors
     */;
    Vector4.max = function max(left, right, out) {
      out._x = Math.max(left._x, right._x);
      out._y = Math.max(left._y, right._y);
      out._z = Math.max(left._z, right._z);
      out._w = Math.max(left._w, right._w);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Calculate a vector containing the smallest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the smallest components of the specified vectors
     */;
    Vector4.min = function min(left, right, out) {
      out._x = Math.min(left._x, right._x);
      out._y = Math.min(left._y, right._y);
      out._z = Math.min(left._z, right._z);
      out._w = Math.min(left._w, right._w);
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Reverses the direction of a given vector.
     * @param a - The vector to negate
     * @param out - The vector facing in the opposite direction
     */;
    Vector4.negate = function negate(a, out) {
      out._x = -a._x;
      out._y = -a._y;
      out._z = -a._z;
      out._w = -a._w;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Converts the vector into a unit vector.
     * @param a - The vector to normalize
     * @param out - The normalized vector
     */;
    Vector4.normalize = function normalize(a, out) {
      var _x = a._x,
        _y = a._y,
        _z = a._z,
        _w = a._w;
      var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out._x = _x * len;
        out._y = _y * len;
        out._z = _z * len;
        out._w = _w * len;
        out._onValueChanged && out._onValueChanged();
      }
    }

    /**
     * Scale a vector by the given value.
     * @param a - The vector to scale
     * @param s - The amount by which to scale the vector
     * @param out - The scaled vector
     */;
    Vector4.scale = function scale(a, s, out) {
      out._x = a._x * s;
      out._y = a._y * s;
      out._z = a._z * s;
      out._w = a._w * s;
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a transformation using the given 4x4 matrix.
     * @param v - The vector to transform
     * @param m - The transform matrix
     * @param out - The transformed vector3
     */;
    Vector4.transform = function transform(v, m, out) {
      var _x = v._x,
        _y = v._y,
        _z = v._z,
        _w = v._w;
      var e = m.elements;
      out._x = _x * e[0] + _y * e[4] + _z * e[8] + _w * e[12];
      out._y = _x * e[1] + _y * e[5] + _z * e[9] + _w * e[13];
      out._z = _x * e[2] + _y * e[6] + _z * e[10] + _w * e[14];
      out._w = _x * e[3] + _y * e[7] + _z * e[11] + _w * e[15];
      out._onValueChanged && out._onValueChanged();
    }

    /**
     * Performs a transformation using the given quaternion.
     * @param v - The vector to transform
     * @param q - The transform quaternion
     * @param out - The transformed vector
     */;
    Vector4.transformByQuat = function transformByQuat(v, q, out) {
      var x = v._x,
        y = v._y,
        z = v._z,
        w = v._w;
      var qx = q._x;
      var qy = q._y;
      var qz = q._z;
      var qw = q._w;

      // calculate quat * vec
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;

      // calculate result * inverse quat
      out._x = ix * qw - iw * qx - iy * qz + iz * qy;
      out._y = iy * qw - iw * qy - iz * qx + ix * qz;
      out._z = iz * qw - iw * qz - ix * qy + iy * qx;
      out._w = w;
      out._onValueChanged && out._onValueChanged();
    }

    /** @internal */;

    /**
     * Constructor of Vector4.
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     * @param z - The z component of the vector, default 0
     * @param w - The w component of the vector, default 0
     */
    function Vector4(x, y, z, w) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (w === void 0) {
        w = 0;
      }
      this._x = void 0;
      this._y = void 0;
      this._z = void 0;
      this._w = void 0;
      this._onValueChanged = null;
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }

    /**
     * Set the value of this vector.
     * @param x - The x component of the vector
     * @param y - The y component of the vector
     * @param z - The z component of the vector
     * @param w - The w component of the vector
     * @returns This vector
     */
    var _proto = Vector4.prototype;
    _proto.set = function set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the sum of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */;
    _proto.add = function add(right) {
      this._x += right._x;
      this._y += right._y;
      this._z += right._z;
      this._w += right._w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the difference of this vector and the specified vector.
     * @param right - the specified vector
     * @returns This vector
     */;
    _proto.subtract = function subtract(right) {
      this._x -= right._x;
      this._y -= right._y;
      this._z -= right._z;
      this._w -= right._w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the product of this vector and the specified vector.
     * @param right - the specified vector
     * @returns This vector
     */;
    _proto.multiply = function multiply(right) {
      this._x *= right._x;
      this._y *= right._y;
      this._z *= right._z;
      this._w *= right._w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Determines the divisor of this vector and the specified vector.
     * @param right - the specified vector
     * @returns This vector
     */;
    _proto.divide = function divide(right) {
      this._x /= right._x;
      this._y /= right._y;
      this._z /= right._z;
      this._w /= right._w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Calculate the length of this vector.
     * @returns The length of this vector
     */;
    _proto.length = function length() {
      var _x = this._x,
        _y = this._y,
        _z = this._z,
        _w = this._w;
      return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    }

    /**
     * Calculate the squared length of this vector.
     * @returns The squared length of this vector
     */;
    _proto.lengthSquared = function lengthSquared() {
      var _x = this._x,
        _y = this._y,
        _z = this._z,
        _w = this._w;
      return _x * _x + _y * _y + _z * _z + _w * _w;
    }

    /**
     * Reverses the direction of this vector.
     * @returns This vector
     */;
    _proto.negate = function negate() {
      this._x = -this._x;
      this._y = -this._y;
      this._z = -this._z;
      this._w = -this._w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Converts this vector into a unit vector.
     * @returns This vector
     */;
    _proto.normalize = function normalize() {
      Vector4.normalize(this, this);
      return this;
    }

    /**
     * Scale this vector by the given value.
     * @param s - The amount by which to scale the vector
     * @returns This vector
     */;
    _proto.scale = function scale(s) {
      this._x *= s;
      this._y *= s;
      this._z *= s;
      this._w *= s;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Creates a clone of this vector.
     * @returns A clone of this vector
     */;
    _proto.clone = function clone() {
      var ret = new Vector4(this._x, this._y, this._z, this._w);
      return ret;
    }

    /**
     * Copy from vector3 like object.
     * @param source - Vector3 like object.
     * @returns This vector
     */;
    _proto.copyFrom = function copyFrom(source) {
      this._x = source.x;
      this._y = source.y;
      this._z = source.z;
      this._w = source.w;
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this vector by an array.
     * @param array - The arrayÆ’
     * @param offset - The start offset of the array
     * @returns This vector
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onValueChanged && this._onValueChanged();
      return this;
    }

    /**
     * Copy the value of this vector to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      out[outOffset] = this._x;
      out[outOffset + 1] = this._y;
      out[outOffset + 2] = this._z;
      out[outOffset + 3] = this._w;
    };
    _createClass$4(Vector4, [{
      key: "x",
      get:
      /**
       * The x component of the vector.
       */
      function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The y component of the vector.
       */
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The z component of the vector.
       */
    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onValueChanged && this._onValueChanged();
      }

      /**
       * The w component of the vector.
       */
    }, {
      key: "w",
      get: function get() {
        return this._w;
      },
      set: function set(value) {
        this._w = value;
        this._onValueChanged && this._onValueChanged();
      }
    }]);
    return Vector4;
  }();
  Vector4._zero = new Vector4(0.0, 0.0, 0.0, 0.0);
  Vector4._one = new Vector4(1.0, 1.0, 1.0, 1.0);

  /**
   * Describes a color in the from of RGBA (in order: R, G, B, A).
   */
  var Color = /*#__PURE__*/function () {
    /**
     * Modify a value from the gamma space to the linear space.
     * @param value - The value in gamma space
     * @returns The value in linear space
     */
    Color.gammaToLinearSpace = function gammaToLinearSpace(value) {
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt

      if (value <= 0.0) return 0.0;else if (value <= 0.04045) return value / 12.92;else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);else return Math.pow(value, 2.4);
    }

    /**
     * Modify a value from the linear space to the gamma space.
     * @param value - The value in linear space
     * @returns The value in gamma space
     */;
    Color.linearToGammaSpace = function linearToGammaSpace(value) {
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt

      if (value <= 0.0) return 0.0;else if (value < 0.0031308) return 12.92 * value;else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;else return Math.pow(value, 0.41666);
    }

    /**
     * Determines whether the specified colors are equals.
     * @param left - The first color to compare
     * @param right - The second color to compare
     * @returns True if the specified colors are equals, false otherwise
     */;
    Color.equals = function equals(left, right) {
      return MathUtil.equals(left.r, right.r) && MathUtil.equals(left.g, right.g) && MathUtil.equals(left.b, right.b) && MathUtil.equals(left.a, right.a);
    }

    /**
     * Determines the sum of two colors.
     * @param left - The first color to add
     * @param right - The second color to add
     * @param out - The sum of two colors
     * @returns The added color
     */;
    Color.add = function add(left, right, out) {
      out.r = left.r + right.r;
      out.g = left.g + right.g;
      out.b = left.b + right.b;
      out.a = left.a + right.a;
      return out;
    }

    /**
     * Scale a color by the given value.
     * @param left - The color to scale
     * @param s - The amount by which to scale the color
     * @param out - The scaled color
     * @returns The scaled color
     */;
    Color.scale = function scale(left, s, out) {
      out.r = left.r * s;
      out.g = left.g * s;
      out.b = left.b * s;
      out.a = left.a * s;
      return out;
    }

    /** The red component of the color, 0~1. */;

    /**
     * Constructor of Color.
     * @param r - The red component of the color
     * @param g - The green component of the color
     * @param b - The blue component of the color
     * @param a - The alpha component of the color
     */
    function Color(r, g, b, a) {
      if (r === void 0) {
        r = 1;
      }
      if (g === void 0) {
        g = 1;
      }
      if (b === void 0) {
        b = 1;
      }
      if (a === void 0) {
        a = 1;
      }
      this.r = void 0;
      this.g = void 0;
      this.b = void 0;
      this.a = void 0;
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

    /**
     * Set the value of this color.
     * @param r - The red component of the color
     * @param g - The green component of the color
     * @param b - The blue component of the color
     * @param a - The alpha component of the color
     * @returns This color.
     */
    var _proto = Color.prototype;
    _proto.set = function set(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      return this;
    }

    /**
     * Determines the sum of this color and the specified color.
     * @param color - The specified color
     * @returns The added color
     */;
    _proto.add = function add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      this.a += color.a;
      return this;
    }

    /**
     * Scale this color by the given value.
     * @param s - The amount by which to scale the color
     * @returns The scaled color
     */;
    _proto.scale = function scale(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      this.a *= s;
      return this;
    }

    /**
     * Creates a clone of this color.
     * @returns A clone of this color
     */;
    _proto.clone = function clone() {
      var ret = new Color(this.r, this.g, this.b, this.a);
      return ret;
    }

    /**
     * Copy from color like object.
     * @param source - Color like object.
     * @returns This vector
     */;
    _proto.copyFrom = function copyFrom(source) {
      this.r = source.r;
      this.g = source.g;
      this.b = source.b;
      this.a = source.a;
      return this;
    }

    /**
     * Modify components (r, g, b) of this color from gamma space to linear space.
     * @param out - The color in linear space
     * @returns The color in linear space
     */;
    _proto.toLinear = function toLinear(out) {
      out.r = Color.gammaToLinearSpace(this.r);
      out.g = Color.gammaToLinearSpace(this.g);
      out.b = Color.gammaToLinearSpace(this.b);
      return out;
    }

    /**
     * Modify components (r, g, b) of this color from linear space to gamma space.
     * @param out - The color in gamma space
     * @returns The color in gamma space
     */;
    _proto.toGamma = function toGamma(out) {
      out.r = Color.linearToGammaSpace(this.r);
      out.g = Color.linearToGammaSpace(this.g);
      out.b = Color.linearToGammaSpace(this.b);
      return out;
    };
    return Color;
  }();

  // A 2d rectangle defined by x and y position, width and height.
  var Rect = /*#__PURE__*/function () {
    /** The x coordinate of the rectangle. */

    /** The y coordinate of the rectangle. */

    /** The width of the rectangle, measured from the x position. */

    /** The height of the rectangle, measured from the y position. */

    /**
     * Constructor of Rect.
     * @param x - The x coordinate of the rectangle, default 0
     * @param y - The y coordinate of the rectangle, default 0
     * @param width - The width of the rectangle, measured from the x position, default 0
     * @param height - The height of the rectangle, measured from the y position, default 0
     */
    function Rect(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = void 0;
      this.y = void 0;
      this.width = void 0;
      this.height = void 0;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }

    /**
     * Set the value of this rectangle.
     * @param x - The x coordinate of the rectangle
     * @param y - The y coordinate of the rectangle
     * @param width - The width of the rectangle, measured from the x position
     * @param height - The height of the rectangle, measured from the y position
     * @returns This rectangle
     */
    var _proto = Rect.prototype;
    _proto.set = function set(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    }

    /**
     * Creates a clone of this rect.
     * @returns A clone of this rect
     */;
    _proto.clone = function clone() {
      return new Rect(this.x, this.y, this.width, this.height);
    }

    /**
     * Copy this rect from the specified rect.
     * @param source - The specified rect
     * @returns This rect
     */;
    _proto.copyFrom = function copyFrom(source) {
      this.x = source.x;
      this.y = source.y;
      this.width = source.width;
      this.height = source.height;
      return this;
    };
    return Rect;
  }();

  /**
   * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
   * @remarks
   * https://graphics.stanford.edu/papers/envmap/envmap.pdf
   * http://www.ppsloan.org/publications/StupidSH36.pdf
   * https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics
   */
  var SphericalHarmonics3 = /*#__PURE__*/function () {
    function SphericalHarmonics3() {
      this.coefficients = new Float32Array(27);
    }
    var _proto = SphericalHarmonics3.prototype;
    /**
     * Add light to SphericalHarmonics3.
     * @param direction - Light direction
     * @param color - Light color
     * @param deltaSolidAngle - The delta solid angle of the light
     */
    _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
      /**
       * Implements `EvalSHBasis` from [Projection from Cube maps] in http://www.ppsloan.org/publications/StupidSH36.pdf.
       *
       * Basis constants
       * 0: Math.sqrt(1/(4 * Math.PI))
       *
       * 1: -Math.sqrt(3 / (4 * Math.PI))
       * 2: Math.sqrt(3 / (4 * Math.PI))
       * 3: -Math.sqrt(3 / (4 * Math.PI))
       *
       * 4: Math.sqrt(15 / (4 * Math.PI))
       * 5: -Math.sqrt(15 / (4 * Math.PI))
       * 6: Math.sqrt(5 / (16 * Math.PI))
       * 7: -Math.sqrt(15 / (4 * Math.PI)ï¼‰
       * 8: Math.sqrt(15 / (16 * Math.PI))
       */

      color.scale(deltaSolidAngle);
      var coe = this.coefficients;
      var x = direction._x,
        y = direction._y,
        z = direction._z;
      var r = color.r,
        g = color.g,
        b = color.b;
      var bv0 = 0.282095; // basis0 = 0.886227
      var bv1 = -0.488603 * y; // basis1 = -0.488603
      var bv2 = 0.488603 * z; // basis2 = 0.488603
      var bv3 = -0.488603 * x; // basis3 = -0.488603
      var bv4 = 1.092548 * (x * y); // basis4 = 1.092548
      var bv5 = -1.092548 * (y * z); // basis5 = -1.092548
      var bv6 = 0.315392 * (3 * z * z - 1); // basis6 = 0.315392
      var bv7 = -1.092548 * (x * z); // basis7 = -1.092548
      var bv8 = 0.546274 * (x * x - y * y); // basis8 = 0.546274

      coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
      coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
      coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
      coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
      coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
      coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
      coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
      coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
      coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
    }

    /**
     * Evaluates the color for the specified direction.
     * @param direction - Specified direction
     * @param out - Out color
     */;
    _proto.evaluate = function evaluate(direction, out) {
      /**
       * Equations based on data from: http://ppsloan.org/publications/StupidSH36.pdf
       *
       *
       * Basis constants
       * 0: Math.sqrt(1/(4 * Math.PI))
       *
       * 1: -Math.sqrt(3 / (4 * Math.PI))
       * 2: Math.sqrt(3 / (4 * Math.PI))
       * 3: -Math.sqrt(3 / (4 * Math.PI))
       *
       * 4: Math.sqrt(15 / (4 * Math.PI)ï¼‰
       * 5: -Math.sqrt(15 / (4 * Math.PI))
       * 6: Math.sqrt(5 / (16 * Math.PI)ï¼‰
       * 7: -Math.sqrt(15 / (4 * Math.PI)ï¼‰
       * 8: Math.sqrt(15 / (16 * Math.PI)ï¼‰
       *
       *
       * Convolution kernel
       * 0: Math.PI
       * 1: (2 * Math.PI) / 3
       * 2: Math.PI / 4
       */

      var coe = this.coefficients;
      var x = direction._x,
        y = direction._y,
        z = direction._z;
      var bv0 = 0.886227; // kernel0 * basis0 = 0.886227
      var bv1 = -1.023327 * y; // kernel1 * basis1 = -1.023327
      var bv2 = 1.023327 * z; // kernel1 * basis2 = 1.023327
      var bv3 = -1.023327 * x; // kernel1 * basis3 = -1.023327
      var bv4 = 0.858086 * y * x; // kernel2 * basis4 = 0.858086
      var bv5 = -0.858086 * y * z; // kernel2 * basis5 = -0.858086
      var bv6 = 0.247708 * (3 * z * z - 1); // kernel2 * basis6 = 0.247708
      var bv7 = -0.858086 * z * x; // kernel2 * basis7 = -0.858086
      var bv8 = 0.429042 * (x * x - y * y); // kernel2 * basis8 = 0.429042

      // l0
      var r = coe[0] * bv0;
      var g = coe[1] * bv0;
      var b = coe[2] * bv0;

      // l1
      r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
      g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
      b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;

      // l2
      r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
      g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
      b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
      out.set(r, g, b, 1.0);
      return out;
    }

    /**
     * Scale the coefficients.
     * @param s - The amount by which to scale the SphericalHarmonics3
     */;
    _proto.scale = function scale(s) {
      var src = this.coefficients;
      src[0] *= s, src[1] *= s, src[2] *= s;
      src[3] *= s, src[4] *= s, src[5] *= s;
      src[6] *= s, src[7] *= s, src[8] *= s;
      src[9] *= s, src[10] *= s, src[11] *= s;
      src[12] *= s, src[13] *= s, src[14] *= s;
      src[15] *= s, src[16] *= s, src[17] *= s;
      src[18] *= s, src[19] *= s, src[20] *= s;
      src[21] *= s, src[22] *= s, src[23] *= s;
      src[24] *= s, src[25] *= s, src[26] *= s;
    }

    /**
     * Creates a clone of this SphericalHarmonics3.
     * @returns A clone of this SphericalHarmonics3
     */;
    _proto.clone = function clone() {
      var sh = new SphericalHarmonics3();
      sh.copyFrom(this);
      return sh;
    }

    /**
     * Copy this SphericalHarmonics3 from the specified SphericalHarmonics3.
     * @param source - The specified SphericalHarmonics3
     * @returns This SphericalHarmonics3
     */;
    _proto.copyFrom = function copyFrom(source) {
      source.copyToArray(this.coefficients);
      return this;
    }

    /**
     * Copy the value of this spherical harmonics from an array.
     * @param array - The array
     * @param offset - The start offset of the array
     */;
    _proto.copyFromArray = function copyFromArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var s = this.coefficients;
      s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
      s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
      s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
      s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
      s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
      s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
      s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
      s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
      s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
    }

    /**
     * Copy the value of this spherical harmonics to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */;
    _proto.copyToArray = function copyToArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }
      var s = this.coefficients;
      out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
      out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
      out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
      out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
      out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
      out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
      out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
      out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
      out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
    };
    return SphericalHarmonics3;
  }();

  function ownKeys$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread2$2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$2(Object(source),!0).forEach(function(key){_defineProperty$2(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$2(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}function _defineProperties$3(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass$3(Constructor,protoProps,staticProps){if(protoProps)_defineProperties$3(Constructor.prototype,protoProps);if(staticProps)_defineProperties$3(Constructor,staticProps);Object.defineProperty(Constructor,"prototype",{writable:false});return Constructor;}function _defineProperty$2(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _inheritsLoose$2(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;_setPrototypeOf$2(subClass,superClass);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _setPrototypeOf$2(o,p){_setPrototypeOf$2=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf$2(o,p);}function _isNativeReflectConstruct$1(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _construct$1(Parent,args,Class){if(_isNativeReflectConstruct$1()){_construct$1=Reflect.construct.bind();}else {_construct$1=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf$2(instance,Class.prototype);return instance;};}return _construct$1.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1;}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct$1(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf$2(Wrapper,Class);};return _wrapNativeSuper(Class);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _unsupportedIterableToArray$1(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray$1(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$1(o,minLen);}function _arrayLikeToArray$1(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _createForOfIteratorHelperLoose$1(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(it)return (it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray$1(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;return function(){if(i>=o.length)return {done:true};return {done:false,value:o[i++]};};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _initializerDefineProperty(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0});}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object.keys(descriptor).forEach(function(key){desc[key]=descriptor[key];});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value'in desc||desc.initializer){desc.writable=true;}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc;},desc);if(context&&desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined;}if(desc.initializer===void 0){Object.defineProperty(target,property,desc);desc=null;}return desc;}var Util={isArray:"isArray"in Array?Array.isArray:function(value){return toString.call(value)==="[object Array]";},isArrayLike:function isArrayLike(x){return !!x&&typeof x.length==="number"&&typeof x!=="function";},clone:function clone(obj){if(typeof obj!=="object"||obj===null){return obj;}var rst;if(Util.isArrayLike(obj)){rst=obj.slice();for(var i=0,l=obj.length;i<l;i++){rst[i]=Util.clone(obj[i]);}}else {rst={};for(var k in obj){if(obj.hasOwnProperty(k)){rst[k]=Util.clone(obj[k]);}}}return rst;},downloadBlob:function downloadBlob(blob,fileName){if(fileName===void 0){fileName="";}var url=window.URL.createObjectURL(blob);var a=document.createElement("a");document.body.appendChild(a);a.style.display="none";a.href=url;a.download=fileName;a.addEventListener("click",function(){if(a.parentElement){a.parentElement.removeChild(a);}});a.click();window.URL.revokeObjectURL(url);}};/**
   * Fastly remove an element from array.
   * @param array - Array
   * @param item - Element
   */function removeFromArray(array,item){var index=array.indexOf(item);if(index<0){return false;}var last=array.length-1;if(index!==last){var end=array[last];array[index]=end;}array.length--;return true;}function ObjectValues(obj){return Object.keys(obj).map(function(key){return obj[key];});}var Utils=/*#__PURE__*/function(){function Utils(){}/**
     * @internal
     * Simplify lodash get: https://github.com/lodash/lodash/blob/master/get.js.
     * @param target - The object to query.
     * @param path - The path of the property to get.
     * @returns Returns the resolved value.
     */Utils._reflectGet=function _reflectGet(target,path){var pathArr=this._stringToPath(path);var object=target;var index=0;var length=pathArr.length;while(object!=null&&index<length){object=object[pathArr[index++]];}return index&&index==length?object:undefined;};Utils._stringToPath=function _stringToPath(string){var result=[];if(string.charCodeAt(0)===charCodeOfDot){result.push("");}string.replace(rePropName,function(match,expression,quote,subString){var key=match;if(quote){key=subString.replace(reEscapeChar,"$1");}else if(expression){key=expression.trim();}result.push(key);});return result;};return Utils;}();var charCodeOfDot=".".charCodeAt(0);var reEscapeChar=/\\(\\)?/g;var rePropName=RegExp(// Match anything that isn't a dot or bracket.
  "[^.[\\]]+"+"|"+// Or match property names within brackets.
  "\\[(?:"+// Match a non-string expression.
  "([^\"'][^[]*)"+"|"+// Or match strings (supports escaping characters).
  "([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"+")\\]"+"|"+// Or match "" as the space between consecutive dots or empty brackets.
  "(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))","g");/**
   * Asset Promise Status
   */exports.AssetPromiseStatus = void 0;/**
   * Asset Loading Promise.
   */(function(AssetPromiseStatus){AssetPromiseStatus[AssetPromiseStatus["Success"]=0]="Success";AssetPromiseStatus[AssetPromiseStatus["Pending"]=1]="Pending";AssetPromiseStatus[AssetPromiseStatus["Failed"]=2]="Failed";})(exports.AssetPromiseStatus||(exports.AssetPromiseStatus={}));var AssetPromise=/*#__PURE__*/function(_Promise){_inheritsLoose$2(AssetPromise,_Promise);/**
     * Return a new resource Promise through the provided asset promise collection.
     * The resolved of the new AssetPromise will be triggered when all the Promises in the provided set are completed.
     * @param - AssetPromise Collection
     * @returns AssetPromise
     */AssetPromise.all=function all(promises){return new AssetPromise(function(resolve,reject,setProgress){if(!Array.isArray(promises)){return resolve([promises]);}var completed=0;var total=promises.length;var results=new Array(total);promises.forEach(function(value,index){Promise.resolve(value).then(function(result){results[index]=result;completed+=1;setProgress(completed/total);if(completed==total){resolve(results);}}).catch(function(err){return reject(err);});});});};var _proto=AssetPromise.prototype;/**
     * Progress callback.
     * @param callback - Progress callback
     * @returns Asset Promise
     */_proto.onProgress=function onProgress(callback){this._listeners.add(callback);return this;}/**
     * Cancel promise request.
     * @returns Asset promise
     */;_proto.cancel=function cancel(){if(this._status!==exports.AssetPromiseStatus.Pending){return this;}this._reject("Promise Canceled");return this;}/**
     * Create an asset loading Promise.
     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:
     * a resolve callback used to resolve the promise with a value or the result of another promise,
     * and a reject callback used to reject the promise with a provided reason or error.
     * and a setProgress callback used to set promise progress with a percent.
     */;function AssetPromise(executor){var _this;var newReject;var setProgress=function setProgress(progress){if(progress<=_this._progress){return;}_this._progress=progress;for(var _iterator=_createForOfIteratorHelperLoose$1(_this._listeners),_step;!(_step=_iterator()).done;){var listener=_step.value;listener(progress);}};_this=_Promise.call(this,function(resolve,reject){newReject=function newReject(reason){// Add it to the micro task to avoid reporting an error when calling this directly.
  Promise.resolve().then(function(){_this._status=exports.AssetPromiseStatus.Failed;reject(reason);});};executor(function(value){// Add it to the micro task to avoid reporting an error when calling this directly.
  Promise.resolve().then(function(){setProgress(1);_this._status=exports.AssetPromiseStatus.Success;resolve(value);});},newReject,function(progress){// Add it to the micro task to avoid reporting an error when calling this directly
  Promise.resolve().then(function(){setProgress(progress);});});})||this;_this._status=void 0;_this._progress=void 0;_this._reject=void 0;_this._listeners=void 0;_this._reject=newReject;_this._listeners=new Set();_this._progress=0;_this._status=exports.AssetPromiseStatus.Pending;return _this;}_createClass$3(AssetPromise,[{key:"status",get:/**
       * Current promise state.
       */function get(){return this._status;}/**
       * Loading progress.
       */},{key:"progress",get:function get(){return this._progress;}}]);return AssetPromise;}(/*#__PURE__*/_wrapNativeSuper(Promise));/**
   * ResourceManager
   */var ResourceManager=/*#__PURE__*/function(){/** Loader collection. */ /**
     * @internal
     */ResourceManager._addLoader=function _addLoader(type,loader,extNames){this._loaders[type]=loader;for(var i=0,len=extNames.length;i<len;i++){this._extTypeMapping[extNames[i]]=type;}};ResourceManager._getTypeByUrl=function _getTypeByUrl(url){var path=url.split("?")[0];return this._extTypeMapping[path.substring(path.lastIndexOf(".")+1)];}/** The number of retries after failing to load assets. */;/**
     * Create a ResourceManager.
     * @param engine - Engine to which the current ResourceManager belongs
     */function ResourceManager(engine){this.engine=engine;this.retryCount=1;this.retryInterval=0;this.timeout=Infinity;this._objectPool=Object.create(null);this._editorResourceConfig=Object.create(null);this._virtualPathMap=Object.create(null);this._assetPool=Object.create(null);this._assetUrlPool=Object.create(null);this._refObjectPool=Object.create(null);this._loadingPromises={};}/**
     * Load asset asynchronously through the path.
     * @param path - Path
     * @returns Asset promise
     */var _proto=ResourceManager.prototype;_proto.load=function load(assetInfo){var _this=this;// single item
  if(!Array.isArray(assetInfo)){return this._loadSingleItem(assetInfo);}// multi items
  var promises=assetInfo.map(function(item){return _this._loadSingleItem(item);});return AssetPromise.all(promises);}/**
     * Cancel all assets that have not finished loading.
     */;_proto.cancelNotLoaded=function cancelNotLoaded(url){var _this2=this;if(!url){ObjectValues(this._loadingPromises).forEach(function(promise){promise.cancel();});}else if(typeof url==="string"){var _this$_loadingPromise;(_this$_loadingPromise=this._loadingPromises[url])===null||_this$_loadingPromise===void 0?void 0:_this$_loadingPromise.cancel();}else {url.forEach(function(p){var _this2$_loadingPromis;(_this2$_loadingPromis=_this2._loadingPromises[p])===null||_this2$_loadingPromis===void 0?void 0:_this2$_loadingPromis.cancel();});}}/**
     * Garbage collection will release resource objects managed by reference counting.
     * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
     */;_proto.gc=function gc(){this._gc(false);}/**
     * Get asset url from instanceId.
     * @param instanceId - Engine instance id
     * @returns Asset url
     */;_proto.getAssetPath=function getAssetPath(instanceId){return this._assetPool[instanceId];}/**
     * @beta Just for internal editor, not recommended for developers.
     */;_proto.getResourceByRef=function getResourceByRef(ref){var refId=ref.refId,key=ref.key,isClone=ref.isClone;var obj=this._objectPool[refId];var promise=obj?Promise.resolve(obj):this.load({type:this._editorResourceConfig[refId].type,url:this._editorResourceConfig[refId].path});return promise.then(function(res){return key?Utils._reflectGet(res,key):res;}).then(function(item){return isClone?item.clone():item;});}/**
     * @internal
     * @beta Just for internal editor, not recommended for developers.
     */;_proto.initVirtualResources=function initVirtualResources(config){var _this3=this;config.forEach(function(element){_this3._virtualPathMap[element.virtualPath]=element.path;_this3._editorResourceConfig[element.id]=element;});}/**
     * @internal
     */;_proto._addAsset=function _addAsset(path,asset){this._assetPool[asset.instanceId]=path;this._assetUrlPool[path]=asset;}/**
     * @internal
     */;_proto._deleteAsset=function _deleteAsset(asset){var id=asset.instanceId;var path=this._assetPool[id];if(path){delete this._assetPool[id];delete this._assetUrlPool[path];}}/**
     * @internal
     */;_proto._addRefObject=function _addRefObject(id,asset){this._refObjectPool[id]=asset;}/**
     * @internal
     */;_proto._deleteRefObject=function _deleteRefObject(id){delete this._refObjectPool[id];}/**
     * @internal
     */;_proto._destroy=function _destroy(){this.cancelNotLoaded();this._gc(true);this._assetPool=null;this._assetUrlPool=null;this._refObjectPool=null;this._loadingPromises=null;};_proto._assignDefaultOptions=function _assignDefaultOptions(assetInfo){var _assetInfo$type,_assetInfo$retryCount,_assetInfo$timeout,_assetInfo$retryInter,_assetInfo$url;assetInfo.type=(_assetInfo$type=assetInfo.type)!=null?_assetInfo$type:ResourceManager._getTypeByUrl(assetInfo.url);if(assetInfo.type===undefined){throw "asset type should be specified: "+assetInfo.url;}assetInfo.retryCount=(_assetInfo$retryCount=assetInfo.retryCount)!=null?_assetInfo$retryCount:this.retryCount;assetInfo.timeout=(_assetInfo$timeout=assetInfo.timeout)!=null?_assetInfo$timeout:this.timeout;assetInfo.retryInterval=(_assetInfo$retryInter=assetInfo.retryInterval)!=null?_assetInfo$retryInter:this.retryInterval;assetInfo.url=(_assetInfo$url=assetInfo.url)!=null?_assetInfo$url:assetInfo.urls.join(",");return assetInfo;};_proto._loadSingleItem=function _loadSingleItem(item){var _this4=this;var info=this._assignDefaultOptions(typeof item==="string"?{url:item}:item);var infoUrl=info.url;// check url mapping
  var url=this._virtualPathMap[infoUrl]?this._virtualPathMap[infoUrl]:infoUrl;// has cache
  if(this._assetUrlPool[url]){return new AssetPromise(function(resolve){resolve(_this4._assetUrlPool[url]);});}// loading
  if(this._loadingPromises[url]){return this._loadingPromises[info.url];}var loader=ResourceManager._loaders[info.type];if(!loader){throw "loader not found: "+info.type;}info.url=url;var promise=loader.load(info,this);this._loadingPromises[url]=promise;promise.then(function(res){if(loader.useCache)_this4._addAsset(url,res);if(_this4._loadingPromises){delete _this4._loadingPromises[url];}}).catch(function(err){Promise.reject(err);if(_this4._loadingPromises){delete _this4._loadingPromises[url];}});return promise;};_proto._gc=function _gc(forceDestroy){var objects=ObjectValues(this._refObjectPool);for(var i=0,len=objects.length;i<len;i++){if(!objects[i].isGCIgnored||forceDestroy){objects[i].destroy();}}};return ResourceManager;}();/**
   * Declare ResourceLoader's decorator.
   * @param assetType - Type of asset
   * @param extnames - Name of file extension
   */ResourceManager._loaders={};ResourceManager._extTypeMapping={};function resourceLoader(assetType,extnames,useCache){if(useCache===void 0){useCache=true;}return function(Target){var loader=new Target(useCache);ResourceManager._addLoader(assetType,loader,extnames);};}/** Event Object. * @class */var Event=/*#__PURE__*/function(){function Event(type,target,data,bubbles){if(target===void 0){target=null;}if(data===void 0){data={};}if(bubbles===void 0){bubbles=true;}this.data=void 0;this._timeStamp=void 0;this._target=void 0;this._currentTarget=void 0;this._bubbles=void 0;this._propagationStopped=void 0;this._type=void 0;this._timeStamp=new Date().getTime();this._target=target;this.data=data;this._currentTarget=null;this._bubbles=bubbles;this._propagationStopped=false;this._type=type;}var _proto=Event.prototype;_proto.stopPropagation=function stopPropagation(){this._propagationStopped=true;};_createClass$3(Event,[{key:"propagationStopped",get:function get(){return this._propagationStopped;}},{key:"target",get:function get(){return this._target;},set:function set(t){this._target=t;}},{key:"timeStamp",get:function get(){return this._timeStamp;}},{key:"currentTarget",get:function get(){return this._currentTarget;},set:function set(t){this._currentTarget=t;}},{key:"bubbles",get:function get(){return this._bubbles;}},{key:"type",get:function get(){return this._type;}}]);return Event;}();/**
   * Clone mode.
   */var CloneMode;(function(CloneMode){CloneMode[CloneMode["Ignore"]=0]="Ignore";CloneMode[CloneMode["Assignment"]=1]="Assignment";CloneMode[CloneMode["Shallow"]=2]="Shallow";CloneMode[CloneMode["Deep"]=3]="Deep";})(CloneMode||(CloneMode={}));/**
   * Property decorator, ignore the property when cloning.
   */function ignoreClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Ignore);}/**
   * Property decorator, assign value to the property when cloning.
   *
   * @remarks
   * If it's a primitive type, the value will be copied.
   * If it's a class type, the reference will be copied.
   */function assignmentClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Assignment);}/**
   * Property decorator, shallow clone the property when cloning.
   * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.
   * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.ã€‚
   *
   * @remarks
   * Applicable to Object, Array, TypedArray and Class types.
   */function shallowClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Shallow);}/**
   * Property decorator, deep clone the property when cloning.
   * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.
   *
   * @remarks
   * Applicable to Object, Array, TypedArray and Class types.
   * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.
   * Custom cloning requires the object to implement the IClone interface.
   */function deepClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Deep);}/**
   * @internal
   * Clone manager.
   */var CloneManager=/*#__PURE__*/function(){function CloneManager(){}/** @internal */ /** @internal */ /**
     * Register clone mode.
     * @param target - Clone target
     * @param propertyKey - Clone property name
     * @param mode - Clone mode
     */CloneManager.registerCloneMode=function registerCloneMode(target,propertyKey,mode){var targetMap=CloneManager._subCloneModeMap.get(target.constructor);if(!targetMap){targetMap=Object.create(null);CloneManager._subCloneModeMap.set(target.constructor,targetMap);}targetMap[propertyKey]=mode;}/**
     * Get the clone mode according to the prototype chain.
     */;CloneManager.getCloneMode=function getCloneMode(type){var cloneModes=CloneManager._cloneModeMap.get(type);if(!cloneModes){cloneModes=Object.create(null);CloneManager._cloneModeMap.set(type,cloneModes);var objectType=CloneManager._objectType;var cloneModeMap=CloneManager._subCloneModeMap;while(type!==objectType){var subCloneModes=cloneModeMap.get(type);if(subCloneModes){_extends(cloneModes,subCloneModes);}type=Object.getPrototypeOf(type);}}return cloneModes;}/**
     * Deep clone the object.
     * @param source - Clone source
     * @param target - Clone target
     */;CloneManager.deepCloneObject=function deepCloneObject(source,target){var type=source.constructor;switch(type){case Uint8Array:case Uint16Array:case Uint32Array:case Int8Array:case Int16Array:case Int32Array:case Float32Array:case Float64Array:// Type array clone.
  target.set(source);break;case Array:// Array clone.
  for(var i=0,n=source.length;i<n;i++){CloneManager._deepCloneObjectItem(source,target,i);}break;default:var customSource=source;if(customSource.clone&&customSource.cloneTo){// Custom clone.
  customSource.cloneTo(target);}else {// Object or other class not implements custom clone.
  var keys=Object.keys(source);for(var _i=0,_n=keys.length;_i<_n;_i++){CloneManager._deepCloneObjectItem(source,target,keys[_i]);}}}};CloneManager._deepCloneObjectItem=function _deepCloneObjectItem(source,target,k){var sourceItem=source[k];if(sourceItem instanceof Object){var itemType=sourceItem.constructor;switch(itemType){case Uint8Array:case Uint16Array:case Uint32Array:case Int8Array:case Int16Array:case Int32Array:case Float32Array:case Float64Array:// Type array clone.
  var sourceTypeArrayItem=sourceItem;var targetTypeArrayItem=target[k];if(targetTypeArrayItem==null){target[k]=sourceTypeArrayItem.slice();}else {targetTypeArrayItem.set(sourceTypeArrayItem);}break;case Array:// Array clone.
  var sourceArrayItem=sourceItem;var targetArrayItem=target[k];if(targetArrayItem==null){target[k]=new Array(sourceArrayItem.length);}else {targetArrayItem.length=sourceArrayItem.length;}CloneManager.deepCloneObject(sourceArrayItem,targetArrayItem);break;default:if(sourceItem.clone&&sourceItem.cloneTo){// Custom clone.
  var sourceCustomItem=sourceItem;var targetCustomItem=target[k];if(targetCustomItem){sourceCustomItem.cloneTo(targetCustomItem);}else {target[k]=sourceCustomItem.clone();}}else {// Object or other class not implements custom clone.
  var targetItem=target[k];targetItem==null&&(target[k]=targetItem=new sourceItem.constructor());CloneManager.deepCloneObject(sourceItem,targetItem);break;}}}else {// Null or undefined and primitive type.
  target[k]=sourceItem;}};return CloneManager;}();CloneManager._subCloneModeMap=new Map();CloneManager._cloneModeMap=new Map();CloneManager._objectType=Object.getPrototypeOf(Object);var _class$g$1,_descriptor$d;/**
   * EventDispatcher, which can be inherited as a base class.
   */var EventDispatcher=(_class$g$1=/*#__PURE__*/function(){function EventDispatcher(){_initializerDefineProperty(this,"_evts",_descriptor$d,this);this._evtCount=0;}var _proto=EventDispatcher.prototype;/**
     * Determine whether there is event listening.
     * @param event - Event name
     * @returns Returns whether there is a corresponding event
     */_proto.hasEvent=function hasEvent(event){return this._evts[event]!=null;}/**
     * Returns the names of all registered events.
     * @returns All event names
     */;_proto.eventNames=function eventNames(){if(this._evtCount===0)return [];return Object.keys(this._evts);}/**
     * Returns the number of listeners with the specified event name.
     * @param event - Event name
     * @returns The count of listeners
     */;_proto.listenerCount=function listenerCount(event){var listeners=this._evts[event];if(!listeners)return 0;if(listeners.fn)return 1;return listeners.length;}/**
     * Dispatch the event with the specified event name.
     * @param event - Event name
     * @param data - Data
     * @returns - Whether the dispatching is successful
     */;_proto.dispatch=function dispatch(event,data){if(!this._evts[event]){return false;}var listeners=this._evts[event];if(listeners.fn){if(listeners.once)this.removeEventListener(event,listeners.fn);listeners.fn(data);}else {var l=listeners.length;for(var i=0;i<l;i++){if(listeners[i].once)this.removeEventListener(event,listeners[i].fn);listeners[i].fn(data);}}return true;}/**
     * Add a listener/
     * @param event - Event name
     * @param fn - Function
     * @returns This
     */;_proto.on=function on(event,fn){return this.addEventListener(event,fn);}/**
     * Add a one-time listener.
     * @param event - Event name
     * @param fn - Function
     * @returns This
     */;_proto.once=function once(event,fn){return this.addEventListener(event,fn,true);}/**
     * @deprecated Use `on/once` instead.
     * Add a listener function with the specified event name.
     * @param event - Event name
     * @param fn - Function
     * @param once - Is it a one-time listener
     * @returns this
     */;_proto.addEventListener=function addEventListener(event,fn,once){var listener={fn:fn,once:once};var events=this._evts;if(!events[event]){events[event]=listener;this._evtCount++;}else if(!events[event].fn){events[event].push(listener);}else {events[event]=[events[event],listener];}return this;}/**
     * Remove the event listener(s) of the specified event name.
     * @param event - Event name
     * @param fn - Function, If is undefined, delete all corresponding event listeners.
     */;_proto.off=function off(event,fn){if(!this._evts[event])return this;if(!fn){this._clearEvent(event);return this;}var listeners=this._evts[event];if(listeners.fn&&listeners.fn===fn){this._clearEvent(event);}else {var index=listeners.indexOf(fn);if(index>-1){var temp=listeners[listeners.length-1];listeners[index]=temp;listeners.length--;if(listeners.length===1){this._evts[event]=listeners[0];}}}return this;}/**
     * @deprecated Use `off` instead.
     * Remove the event listener(s) of the specified event name.
     * @param event - Event name
     * @param fn - Function, If is undefined, delete all corresponding event listeners.
     */;_proto.removeEventListener=function removeEventListener(event,fn){return this.off(event,fn);}/**
     * Remove all event listeners.
     * @param event - Event name, delete all events if not passed
     */;_proto.removeAllEventListeners=function removeAllEventListeners(event){if(event){if(this._evts[event])this._clearEvent(event);}else {this._evts=Object.create(null);this._evtCount=0;}}/**
     * @deprecated Use `dispatch` instead.
     */;_proto.trigger=function trigger(e){this.dispatch(e.type,e.data);};_proto._clearEvent=function _clearEvent(event){if(--this._evtCount===0){this._evts=Object.create(null);}else {delete this._evts[event];}};return EventDispatcher;}(),_descriptor$d=_applyDecoratedDescriptor(_class$g$1.prototype,"_evts",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return Object.create(null);}}),_class$g$1);/**
   * @class
   * @private
   */ /* tslint:disable */var noop=function noop(message){};var debug=console.log.bind(console);var info=console.info.bind(console);var warn=console.warn.bind(console);var error=console.error.bind(console);var Logger={debug:noop,info:noop,warn:noop,error:noop,isEnabled:false,/** Turn on log */enable:function enable(){this.debug=debug;this.info=info;this.warn=warn;this.error=error;this.isEnabled=true;},/** Turn off log */disable:function disable(){this.debug=noop;this.info=noop;this.warn=noop;this.error=noop;this.isEnabled=false;}};/**
   * Tools for calculating the time per frame.
   */var Time=/*#__PURE__*/function(){/**
     * Constructor of the Time.
     */function Time(){this._clock=void 0;this._timeScale=void 0;this._deltaTime=void 0;this._startTime=void 0;this._lastTickTime=void 0;this._clock=performance?performance:Date;this._timeScale=1.0;this._deltaTime=0.0001;var now=this._clock.now();this._startTime=now;this._lastTickTime=now;}var _proto=Time.prototype;_proto.reset=function reset(){this._lastTickTime=this._clock.now();}/**
     * Current Time
     */;/**
     * Call every frame, update delta time and other data.
     */_proto.tick=function tick(){var now=this.nowTime;this._deltaTime=(now-this._lastTickTime)*this._timeScale;this._lastTickTime=now;};_createClass$3(Time,[{key:"nowTime",get:function get(){return this._clock.now();}/**
       * Time between two ticks
       */},{key:"deltaTime",get:function get(){return this._deltaTime;}/**
       * Scaled delta time.
       */},{key:"timeScale",get:function get(){return this._timeScale;},set:function set(s){this._timeScale=s;}/**
       * Unscaled delta time.
       */},{key:"unscaledDeltaTime",get:function get(){return this._deltaTime/this._timeScale;}/**
       * The elapsed time, after the clock is initialized.
       */},{key:"timeSinceStartup",get:function get(){return this.nowTime-this._startTime;}}]);return Time;}();var _class$f$1,_descriptor$c,_descriptor2$b,_class2$c;/**
   * EngineObject.
   */var EngineObject=(_class$f$1=(_class2$c=/*#__PURE__*/function(){function EngineObject(engine){_initializerDefineProperty(this,"instanceId",_descriptor$c,this);_initializerDefineProperty(this,"_engine",_descriptor2$b,this);this._destroyed=false;this._engine=engine;}/**
     * Destroy self.
     */var _proto=EngineObject.prototype;_proto.destroy=function destroy(){var _this$_engine$resourc;if(this._destroyed)return;(_this$_engine$resourc=this._engine.resourceManager)===null||_this$_engine$resourc===void 0?void 0:_this$_engine$resourc._deleteAsset(this);this._destroyed=true;};_createClass$3(EngineObject,[{key:"engine",get:/** Engine unique id. */ /**
       * Get the engine which the object belongs.
       */function get(){return this._engine;}/**
       * Whether it has been destroyed.
       */},{key:"destroyed",get:function get(){return this._destroyed;}}]);return EngineObject;}(),_class2$c._instanceIdCounter=0,_class2$c),(_descriptor$c=_applyDecoratedDescriptor(_class$f$1.prototype,"instanceId",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return ++EngineObject._instanceIdCounter;}}),_descriptor2$b=_applyDecoratedDescriptor(_class$f$1.prototype,"_engine",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null})),_class$f$1);/**
   * Data type enumeration
   */exports.DataType = void 0;/**
   * GL Capabilities
   * Some capabilities can be smoothed out by extension, and some capabilities must use WebGL 2.0.
   * */(function(DataType){DataType[DataType["FLOAT"]=5126]="FLOAT";DataType[DataType["FLOAT_VEC2"]=35664]="FLOAT_VEC2";DataType[DataType["FLOAT_VEC3"]=35665]="FLOAT_VEC3";DataType[DataType["FLOAT_VEC4"]=35666]="FLOAT_VEC4";DataType[DataType["INT"]=5124]="INT";DataType[DataType["INT_VEC2"]=35667]="INT_VEC2";DataType[DataType["INT_VEC3"]=35668]="INT_VEC3";DataType[DataType["INT_VEC4"]=35669]="INT_VEC4";DataType[DataType["BOOL"]=35670]="BOOL";DataType[DataType["BOOL_VEC2"]=35671]="BOOL_VEC2";DataType[DataType["BOOL_VEC3"]=35672]="BOOL_VEC3";DataType[DataType["BOOL_VEC4"]=35673]="BOOL_VEC4";DataType[DataType["FLOAT_MAT2"]=35674]="FLOAT_MAT2";DataType[DataType["FLOAT_MAT3"]=35675]="FLOAT_MAT3";DataType[DataType["FLOAT_MAT4"]=35676]="FLOAT_MAT4";DataType[DataType["FLOAT_ARRAY"]=35677]="FLOAT_ARRAY";DataType[DataType["FLOAT_VEC2_ARRAY"]=100000]="FLOAT_VEC2_ARRAY";DataType[DataType["FLOAT_VEC3_ARRAY"]=100001]="FLOAT_VEC3_ARRAY";DataType[DataType["FLOAT_VEC4_ARRAY"]=100002]="FLOAT_VEC4_ARRAY";DataType[DataType["INT_ARRAY"]=100003]="INT_ARRAY";DataType[DataType["INT_VEC2_ARRAY"]=100004]="INT_VEC2_ARRAY";DataType[DataType["INT_VEC3_ARRAY"]=100005]="INT_VEC3_ARRAY";DataType[DataType["INT_VEC4_ARRAY"]=100006]="INT_VEC4_ARRAY";DataType[DataType["FLOAT_MAT2_ARRAY"]=100007]="FLOAT_MAT2_ARRAY";DataType[DataType["FLOAT_MAT3_ARRAY"]=100008]="FLOAT_MAT3_ARRAY";DataType[DataType["FLOAT_MAT4_ARRAY"]=100009]="FLOAT_MAT4_ARRAY";DataType[DataType["SAMPLER_2D_ARRAY"]=100010]="SAMPLER_2D_ARRAY";DataType[DataType["SAMPLER_CUBE_ARRAY"]=100011]="SAMPLER_CUBE_ARRAY";DataType[DataType["SAMPLER_2D"]=35678]="SAMPLER_2D";DataType[DataType["SAMPLER_CUBE"]=35680]="SAMPLER_CUBE";DataType[DataType["BYTE"]=5120]="BYTE";DataType[DataType["UNSIGNED_BYTE"]=5121]="UNSIGNED_BYTE";DataType[DataType["SHORT"]=5122]="SHORT";DataType[DataType["UNSIGNED_SHORT"]=5123]="UNSIGNED_SHORT";DataType[DataType["UNSIGNED_INT"]=5125]="UNSIGNED_INT";})(exports.DataType||(exports.DataType={}));exports.GLCapabilityType = void 0;(function(GLCapabilityType){GLCapabilityType["shaderVertexID"]="shaderVertexID";GLCapabilityType["standardDerivatives"]="OES_standard_derivatives";GLCapabilityType["shaderTextureLod"]="EXT_shader_texture_lod";GLCapabilityType["elementIndexUint"]="OES_element_index_uint";GLCapabilityType["depthTexture"]="WEBGL_depth_texture";GLCapabilityType["drawBuffers"]="WEBGL_draw_buffers";GLCapabilityType["vertexArrayObject"]="OES_vertex_array_object";GLCapabilityType["instancedArrays"]="ANGLE_instanced_arrays";GLCapabilityType["multipleSample"]="multipleSampleOnlySupportedInWebGL2";GLCapabilityType["textureFloat"]="OES_texture_float";GLCapabilityType["textureFloatLinear"]="OES_texture_float_linear";GLCapabilityType["textureHalfFloat"]="OES_texture_half_float";GLCapabilityType["textureHalfFloatLinear"]="OES_texture_half_float_linear";GLCapabilityType["WEBGL_colorBufferFloat"]="WEBGL_color_buffer_float";GLCapabilityType["colorBufferFloat"]="EXT_color_buffer_float";GLCapabilityType["colorBufferHalfFloat"]="EXT_color_buffer_half_float";GLCapabilityType["textureFilterAnisotropic"]="EXT_texture_filter_anisotropic";GLCapabilityType["blendMinMax"]="EXT_blend_minmax";GLCapabilityType["astc"]="WEBGL_compressed_texture_astc";GLCapabilityType["astc_webkit"]="WEBKIT_WEBGL_compressed_texture_astc";GLCapabilityType["etc"]="WEBGL_compressed_texture_etc";GLCapabilityType["etc_webkit"]="WEBKIT_WEBGL_compressed_texture_etc";GLCapabilityType["etc1"]="WEBGL_compressed_texture_etc1";GLCapabilityType["etc1_webkit"]="WEBKIT_WEBGL_compressed_texture_etc1";GLCapabilityType["pvrtc"]="WEBGL_compressed_texture_pvrtc";GLCapabilityType["pvrtc_webkit"]="WEBKIT_WEBGL_compressed_texture_pvrtc";GLCapabilityType["s3tc"]="WEBGL_compressed_texture_s3tc";GLCapabilityType["s3tc_webkit"]="WEBKIT_WEBGL_compressed_texture_s3tc";})(exports.GLCapabilityType||(exports.GLCapabilityType={}));/**
   * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.
   */var DisorderedArray=/*#__PURE__*/function(){function DisorderedArray(count){if(count===void 0){count=0;}this._elements=void 0;this.length=0;this._elements=new Array(count);}var _proto=DisorderedArray.prototype;_proto.add=function add(element){if(this.length===this._elements.length)this._elements.push(element);else this._elements[this.length]=element;this.length++;};_proto.delete=function _delete(element){//TODO: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.
  var index=this._elements.indexOf(element);this.deleteByIndex(index);};_proto.get=function get(index){if(index>=this.length){throw "Index is out of range.";}return this._elements[index];}/**
     *
     * @param index
     * @returns The replaced item is used to reset its index.
     */;_proto.deleteByIndex=function deleteByIndex(index){var elements=this._elements;var end=null;var lastIndex=this.length-1;if(index!==lastIndex){end=elements[lastIndex];elements[index]=end;}this.length--;return end;};_proto.garbageCollection=function garbageCollection(){this._elements.length=this.length;};return DisorderedArray;}();/**
   * Shader macro collection.
   * @internal
   */var ShaderMacroCollection=/*#__PURE__*/function(){function ShaderMacroCollection(){this._mask=[];this._length=0;}/**
     * Union of two macro collection.
     * @param left - input macro collection
     * @param right - input macro collection
     * @param out - union output macro collection
     */ShaderMacroCollection.unionCollection=function unionCollection(left,right,out){var outMask=out._mask;var minSize,maxSize;var minMask,maxMask;if(left._length<right._length){minSize=left._length;maxSize=right._length;minMask=left._mask;maxMask=right._mask;}else {minSize=right._length;maxSize=left._length;minMask=right._mask;maxMask=left._mask;}var i=0;outMask.length<maxSize&&(outMask.length=maxSize);for(;i<minSize;i++){outMask[i]=minMask[i]|maxMask[i];}for(;i<maxSize;i++){outMask[i]=maxMask[i];}out._length=maxSize;}/** @internal */;var _proto=ShaderMacroCollection.prototype;/**
     * Enable one macro in this macro collection.
     * @param macro - ShaderMacro
     */_proto.enable=function enable(macro){var index=macro._maskIndex;var size=index+1;var mask=this._mask;var maskStart=this._length;// must from this._length because this._length maybe less than mask.length and have dirty data should clear.
  if(maskStart<size){mask.length<size&&(mask.length=size);// mask.length maybe small than size,maybe not.
  for(;maskStart<index;maskStart++){mask[maskStart]=0;}mask[index]=macro._maskValue;this._length=size;}else {mask[index]|=macro._maskValue;}}/**
     * Disable one macro in this macro collection.
     * @param macro - ShaderMacro
     */;_proto.disable=function disable(macro){var index=macro._maskIndex;var mask=this._mask;var endIndex=this._length-1;if(index>endIndex){return;}var newValue=mask[index]&~macro._maskValue;if(index==endIndex&&newValue===0){this._length--;}else {mask[index]=newValue;}}/**
     * Union of this and other macro collection.
     * @param macroCollection - macro collection
     */;_proto.unionCollection=function unionCollection(macroCollection){var addMask=macroCollection._mask;var addSize=macroCollection._length;var mask=this._mask;var maskSize=this._length;if(maskSize<addSize){mask.length<addSize&&(mask.length=addSize);var i=0;for(;i<maskSize;i++){mask[i]|=addMask[i];}for(;i<addSize;i++){mask[i]=addMask[i];}this._length=addSize;}else {for(var _i=0;_i<addSize;_i++){mask[_i]|=addMask[_i];}}}/**
     * Complementarity of this and other macro collection.
     * @param macroCollection - macro collection
     */;_proto.complementaryCollection=function complementaryCollection(macroCollection){var removeMask=macroCollection._mask;var mask=this._mask;var endIndex=this._length-1;var i=Math.min(macroCollection._length-1,endIndex);for(;i>=0;i--){var newValue=mask[i]&~removeMask[i];if(i==endIndex&&newValue===0){endIndex--;this._length--;}else {mask[i]=newValue;}}}/**
     * Intersection of this and other macro collection.
     * @param macroCollection - macro collection
     */;_proto.intersectionCollection=function intersectionCollection(macroCollection){var unionMask=macroCollection._mask;var mask=this._mask;for(var i=this._length-1;i>=0;i--){var value=mask[i]&unionMask[i];if(value==0&&i==this._length-1){this._length--;}else {mask[i]=value;}}}/**
     * Whether macro is enabled in this macro collection.
     * @param macro - ShaderMacro
     */;_proto.isEnable=function isEnable(macro){var index=macro._maskIndex;if(index>=this._length){return false;}return (this._mask[index]&macro._maskValue)!==0;}/**
     * Clear this macro collection.
     */;_proto.clear=function clear(){this._length=0;};return ShaderMacroCollection;}();/**
   * The manager of the components.
   */var ComponentsManager=/*#__PURE__*/function(){function ComponentsManager(){this._onStartScripts=new DisorderedArray();this._onUpdateScripts=new DisorderedArray();this._onLateUpdateScripts=new DisorderedArray();this._onPhysicsUpdateScripts=new DisorderedArray();this._disableScripts=[];this._destroyScripts=[];this._onUpdateAnimations=new DisorderedArray();this._renderers=new DisorderedArray();this._onUpdateRenderers=new DisorderedArray();this._componentsContainerPool=[];}var _proto=ComponentsManager.prototype;_proto.addRenderer=function addRenderer(renderer){renderer._rendererIndex=this._renderers.length;this._renderers.add(renderer);};_proto.removeRenderer=function removeRenderer(renderer){var replaced=this._renderers.deleteByIndex(renderer._rendererIndex);replaced&&(replaced._rendererIndex=renderer._rendererIndex);renderer._rendererIndex=-1;};_proto.addOnStartScript=function addOnStartScript(script){script._onStartIndex=this._onStartScripts.length;this._onStartScripts.add(script);};_proto.removeOnStartScript=function removeOnStartScript(script){var replaced=this._onStartScripts.deleteByIndex(script._onStartIndex);replaced&&(replaced._onStartIndex=script._onStartIndex);script._onStartIndex=-1;};_proto.addOnUpdateScript=function addOnUpdateScript(script){script._onUpdateIndex=this._onUpdateScripts.length;this._onUpdateScripts.add(script);};_proto.removeOnUpdateScript=function removeOnUpdateScript(script){var replaced=this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);replaced&&(replaced._onUpdateIndex=script._onUpdateIndex);script._onUpdateIndex=-1;};_proto.addOnLateUpdateScript=function addOnLateUpdateScript(script){script._onLateUpdateIndex=this._onLateUpdateScripts.length;this._onLateUpdateScripts.add(script);};_proto.removeOnLateUpdateScript=function removeOnLateUpdateScript(script){var replaced=this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);replaced&&(replaced._onLateUpdateIndex=script._onLateUpdateIndex);script._onLateUpdateIndex=-1;};_proto.addOnPhysicsUpdateScript=function addOnPhysicsUpdateScript(script){script._onPhysicsUpdateIndex=this._onPhysicsUpdateScripts.length;this._onPhysicsUpdateScripts.add(script);};_proto.removeOnPhysicsUpdateScript=function removeOnPhysicsUpdateScript(script){var replaced=this._onPhysicsUpdateScripts.deleteByIndex(script._onPhysicsUpdateIndex);replaced&&(replaced._onPhysicsUpdateIndex=script._onPhysicsUpdateIndex);script._onPhysicsUpdateIndex=-1;};_proto.addOnUpdateAnimations=function addOnUpdateAnimations(animation){//@ts-ignore
  animation._onUpdateIndex=this._onUpdateAnimations.length;this._onUpdateAnimations.add(animation);};_proto.removeOnUpdateAnimations=function removeOnUpdateAnimations(animation){//@ts-ignore
  var replaced=this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);//@ts-ignore
  replaced&&(replaced._onUpdateIndex=animation._onUpdateIndex);//@ts-ignore
  animation._onUpdateIndex=-1;};_proto.addOnUpdateRenderers=function addOnUpdateRenderers(renderer){renderer._onUpdateIndex=this._onUpdateRenderers.length;this._onUpdateRenderers.add(renderer);};_proto.removeOnUpdateRenderers=function removeOnUpdateRenderers(renderer){var replaced=this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);replaced&&(replaced._onUpdateIndex=renderer._onUpdateIndex);renderer._onUpdateIndex=-1;};_proto.addDisableScript=function addDisableScript(component){this._disableScripts.push(component);};_proto.addDestroyScript=function addDestroyScript(component){this._destroyScripts.push(component);};_proto.callScriptOnStart=function callScriptOnStart(){var onStartScripts=this._onStartScripts;if(onStartScripts.length>0){var elements=onStartScripts._elements;// The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()
  for(var i=0;i<onStartScripts.length;i++){var script=elements[i];if(!script._waitHandlingInValid){script._started=true;script._onStartIndex=-1;script.onStart();}}onStartScripts.length=0;}};_proto.callScriptOnUpdate=function callScriptOnUpdate(deltaTime){var elements=this._onUpdateScripts._elements;for(var i=this._onUpdateScripts.length-1;i>=0;--i){var element=elements[i];if(!element._waitHandlingInValid&&element._started){element.onUpdate(deltaTime);}}};_proto.callScriptOnLateUpdate=function callScriptOnLateUpdate(deltaTime){var elements=this._onLateUpdateScripts._elements;for(var i=this._onLateUpdateScripts.length-1;i>=0;--i){var element=elements[i];if(!element._waitHandlingInValid&&element._started){element.onLateUpdate(deltaTime);}}};_proto.callScriptOnPhysicsUpdate=function callScriptOnPhysicsUpdate(){var elements=this._onPhysicsUpdateScripts._elements;for(var i=this._onPhysicsUpdateScripts.length-1;i>=0;--i){var element=elements[i];if(!element._waitHandlingInValid&&element._started){element.onPhysicsUpdate();}}};_proto.callAnimationUpdate=function callAnimationUpdate(deltaTime){var elements=this._onUpdateAnimations._elements;for(var i=this._onUpdateAnimations.length-1;i>=0;--i){//@ts-ignore
  elements[i].update(deltaTime);}};_proto.callRendererOnUpdate=function callRendererOnUpdate(deltaTime){var elements=this._onUpdateRenderers._elements;for(var i=this._onUpdateRenderers.length-1;i>=0;--i){elements[i].update(deltaTime);}};_proto.callRender=function callRender(context){var camera=context._camera;var elements=this._renderers._elements;for(var i=this._renderers.length-1;i>=0;--i){var element=elements[i];// filter by camera culling mask.
  if(!(camera.cullingMask&element._entity.layer)){continue;}// filter by camera frustum.
  if(camera.enableFrustumCulling){element.isCulled=!camera._frustum.intersectsBox(element.bounds);if(element.isCulled){continue;}}var transform=camera.entity.transform;var position=transform.worldPosition;var center=element.bounds.getCenter(ComponentsManager._tempVector0);if(camera.isOrthographic){var forward=transform.getWorldForward(ComponentsManager._tempVector1);Vector3.subtract(center,position,center);element._distanceForSort=Vector3.dot(center,forward);}else {element._distanceForSort=Vector3.distanceSquared(center,position);}element._updateShaderData(context);element._render(camera);// union camera global macro and renderer macro.
  ShaderMacroCollection.unionCollection(camera._globalShaderMacro,element.shaderData._macroCollection,element._globalShaderMacro);}};_proto.handlingInvalidScripts=function handlingInvalidScripts(){var disableScripts=this._disableScripts,destroyScripts=this._destroyScripts;var length=disableScripts.length;if(length>0){for(var i=length-1;i>=0;i--){var disableScript=disableScripts[i];disableScript._waitHandlingInValid&&disableScript._handlingInValid();}disableScripts.length=0;}length=destroyScripts.length;if(length>0){for(var _i=length-1;_i>=0;_i--){destroyScripts[_i].onDestroy();}destroyScripts.length=0;}};_proto.callCameraOnBeginRender=function callCameraOnBeginRender(camera){var scripts=camera.entity._scripts;for(var i=scripts.length-1;i>=0;--i){var script=scripts.get(i);script._waitHandlingInValid||script.onBeginRender(camera);}};_proto.callCameraOnEndRender=function callCameraOnEndRender(camera){var scripts=camera.entity._scripts;for(var i=scripts.length-1;i>=0;--i){var script=scripts.get(i);script._waitHandlingInValid||script.onEndRender(camera);}};_proto.getActiveChangedTempList=function getActiveChangedTempList(){return this._componentsContainerPool.length?this._componentsContainerPool.pop():[];};_proto.putActiveChangedTempList=function putActiveChangedTempList(componentContainer){componentContainer.length=0;this._componentsContainerPool.push(componentContainer);};return ComponentsManager;}();ComponentsManager._tempVector0=new Vector3();ComponentsManager._tempVector1=new Vector3();/**
   * Custom clone interface.
   */var ComponentCloner=/*#__PURE__*/function(){function ComponentCloner(){}/**
     * Clone component.
     * @param source - Clone source
     * @param target - Clone target
     */ComponentCloner.cloneComponent=function cloneComponent(source,target){var cloneModes=CloneManager.getCloneMode(source.constructor);var keys=Object.keys(source);for(var i=0,n=keys.length;i<n;i++){var k=keys[i];var cloneMode=cloneModes[k];switch(cloneMode){case undefined:case CloneMode.Assignment:target[k]=source[k];break;case CloneMode.Shallow:var sourcePropS=source[k];if(sourcePropS instanceof Object){var tarProp=target[k];tarProp==null&&(tarProp=target[k]=sourcePropS.constructor());_extends(tarProp,sourcePropS);}else {// Null or undefined and primitive type.
  target[k]=sourcePropS;}break;case CloneMode.Deep:var sourcePropD=source[k];if(sourcePropD instanceof Object){var _tarProp=target[k];_tarProp==null&&(_tarProp=target[k]=sourcePropD.constructor());CloneManager.deepCloneObject(sourcePropD,_tarProp);}else {// Null or undefined and primitive type.
  target[k]=sourcePropD;}break;}}if(source._cloneTo){source._cloneTo(target);}};return ComponentCloner;}();/**
   * Used for component dependency registration.
   */var ComponentsDependencies=/*#__PURE__*/function(){/**
     * @internal
     */ /**
     * @internal
     */ComponentsDependencies._register=function _register(currentComponent,dependentComponent){this._addDependency(currentComponent,dependentComponent,this._dependenciesMap);this._addDependency(dependentComponent,currentComponent,this._invDependenciesMap);}/**
     * @internal
     */;ComponentsDependencies._addCheck=function _addCheck(entity,type){// Check if there are dependent components.
  var dependentComponents=ComponentsDependencies._dependenciesMap.get(type);if(dependentComponents){for(var i=0,n=dependentComponents.length;i<n;i++){var dependentComponent=dependentComponents[i];if(!entity.getComponent(dependentComponent)){entity.addComponent(dependentComponent);}}}}/**
     * @internal
     */;ComponentsDependencies._removeCheck=function _removeCheck(entity,type){var invDependencies=ComponentsDependencies._invDependenciesMap.get(type);if(invDependencies){for(var i=0,len=invDependencies.length;i<len;i++){if(entity.getComponent(invDependencies[i])){throw "you should remove "+invDependencies[i]+" before adding "+type;}}}};ComponentsDependencies._addDependency=function _addDependency(currentComponent,dependentComponent,map){var components=map.get(currentComponent);if(!components){components=[];map.set(currentComponent,components);}if(components.indexOf(dependentComponent)===-1){components.push(dependentComponent);}};function ComponentsDependencies(){}return ComponentsDependencies;}();/**
   * Dependent components, automatically added if they do not exist.
   * @param components -  Dependent components
   */ComponentsDependencies._dependenciesMap=new Map();ComponentsDependencies._invDependenciesMap=new Map();function dependentComponents(){for(var _len=arguments.length,components=new Array(_len),_key=0;_key<_len;_key++){components[_key]=arguments[_key];}return function(target){components.forEach(function(component){return ComponentsDependencies._register(target,component);});};}/**
   * Layer, used for bit operations.
   */exports.Layer = void 0;(function(Layer){Layer[Layer["Layer0"]=1]="Layer0";Layer[Layer["Layer1"]=2]="Layer1";Layer[Layer["Layer2"]=4]="Layer2";Layer[Layer["Layer3"]=8]="Layer3";Layer[Layer["Layer4"]=16]="Layer4";Layer[Layer["Layer5"]=32]="Layer5";Layer[Layer["Layer6"]=64]="Layer6";Layer[Layer["Layer7"]=128]="Layer7";Layer[Layer["Layer8"]=256]="Layer8";Layer[Layer["Layer9"]=512]="Layer9";Layer[Layer["Layer10"]=1024]="Layer10";Layer[Layer["Layer11"]=2048]="Layer11";Layer[Layer["Layer12"]=4096]="Layer12";Layer[Layer["Layer13"]=8192]="Layer13";Layer[Layer["Layer14"]=16384]="Layer14";Layer[Layer["Layer15"]=32768]="Layer15";Layer[Layer["Layer16"]=65536]="Layer16";Layer[Layer["Layer17"]=131072]="Layer17";Layer[Layer["Layer18"]=262144]="Layer18";Layer[Layer["Layer19"]=524288]="Layer19";Layer[Layer["Layer20"]=1048576]="Layer20";Layer[Layer["Layer21"]=2097152]="Layer21";Layer[Layer["Layer22"]=4194304]="Layer22";Layer[Layer["Layer23"]=8388608]="Layer23";Layer[Layer["Layer24"]=16777216]="Layer24";Layer[Layer["Layer25"]=33554432]="Layer25";Layer[Layer["Layer26"]=67108864]="Layer26";Layer[Layer["Layer27"]=134217728]="Layer27";Layer[Layer["Layer28"]=268435456]="Layer28";Layer[Layer["Layer29"]=536870912]="Layer29";Layer[Layer["Layer30"]=1073741824]="Layer30";Layer[Layer["Layer31"]=2147483648]="Layer31";Layer[Layer["Everything"]=4294967295]="Everything";Layer[Layer["Nothing"]=0]="Nothing";})(exports.Layer||(exports.Layer={}));/**
   * Used to update tags.
   */var UpdateFlag=/*#__PURE__*/function(){function UpdateFlag(){this._flagManagers=[];}var _proto=UpdateFlag.prototype;/**
     * Clear.
     */_proto.clearFromManagers=function clearFromManagers(){this._removeFromManagers();this._flagManagers.length=0;}/**
     * Destroy.
     */;_proto.destroy=function destroy(){this._removeFromManagers();this._flagManagers=null;};_proto._removeFromManagers=function _removeFromManagers(){var flagManagers=this._flagManagers;for(var i=0,n=flagManagers.length;i<n;i++){removeFromArray(flagManagers[i]._updateFlags,this);}};return UpdateFlag;}();/**
   * Used to update tags.
   */var BoolUpdateFlag=/*#__PURE__*/function(_UpdateFlag){_inheritsLoose$2(BoolUpdateFlag,_UpdateFlag);function BoolUpdateFlag(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_UpdateFlag.call.apply(_UpdateFlag,[this].concat(args))||this;_this.flag=true;return _this;}var _proto=BoolUpdateFlag.prototype;/**
     * @inheritdoc
     */_proto.dispatch=function dispatch(){this.flag=true;};return BoolUpdateFlag;}(UpdateFlag);var _class$e$1,_descriptor$b,_descriptor2$a,_descriptor3$9,_descriptor4$9,_descriptor5$9;/**
   * The base class of the components.
   */var Component=(_class$e$1=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Component,_EngineObject);function Component(entity){var _this;_this=_EngineObject.call(this,entity.engine)||this;_initializerDefineProperty(_this,"_entity",_descriptor$b,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_awoken",_descriptor2$a,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_destroyed",_descriptor3$9,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_phasedActive",_descriptor4$9,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_enabled",_descriptor5$9,_assertThisInitialized(_this));_this._entity=entity;return _this;}/**
     * Destroy this instance.
     */var _proto=Component.prototype;_proto.destroy=function destroy(){if(this._destroyed){return;}this._entity._removeComponent(this);if(this._entity.isActiveInHierarchy){this._enabled&&this._onDisable();}this._destroyed=true;this._onDestroy();}/**
     * @internal
     */;_proto._onAwake=function _onAwake(){}/**
     * @internal
     */;_proto._onEnable=function _onEnable(){}/**
     * @internal
     */;_proto._onDisable=function _onDisable(){}/**
     * @internal
     */;_proto._onDestroy=function _onDestroy(){}/**
     * @internal
     */;_proto._setActive=function _setActive(value){var entity=this._entity;if(value){// Awake condition is un awake && current entity is active in hierarchy
  if(!this._awoken&&entity._isActiveInHierarchy){this._awoken=true;this._onAwake();}// Developer maybe do `isActive = false` in `onAwake` method
  // Enable condition is phased active state is false && current compoment is active in hierarchy
  if(!this._phasedActive&&entity._isActiveInHierarchy&&this._enabled){this._phasedActive=true;this._onEnable();}}else {// Disable condition is phased active state is true && current compoment is inActive in hierarchy
  if(this._phasedActive&&!(entity._isActiveInHierarchy&&this._enabled)){this._phasedActive=false;this._onDisable();}}};_createClass$3(Component,[{key:"enabled",get:/** @internal */ /** @internal */ /** @internal */ /**
       * Indicates whether the component is enabled.
       */function get(){return this._enabled;},set:function set(value){if(value!==this._enabled){this._enabled=value;if(this._entity.isActiveInHierarchy){if(value){this._phasedActive=true;this._onEnable();}else {this._phasedActive=false;this._onDisable();}}}}/**
       * Indicates whether the component is destroyed.
       */},{key:"destroyed",get:function get(){return this._destroyed;}/**
       * The entity which the component belongs to.
       */},{key:"entity",get:function get(){return this._entity;}/**
       * The scene which the component's entity belongs to.
       */},{key:"scene",get:function get(){return this._entity.scene;}}]);return Component;}(EngineObject),(_descriptor$b=_applyDecoratedDescriptor(_class$e$1.prototype,"_entity",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$a=_applyDecoratedDescriptor(_class$e$1.prototype,"_awoken",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor3$9=_applyDecoratedDescriptor(_class$e$1.prototype,"_destroyed",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor4$9=_applyDecoratedDescriptor(_class$e$1.prototype,"_phasedActive",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor5$9=_applyDecoratedDescriptor(_class$e$1.prototype,"_enabled",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return true;}})),_class$e$1);/**
   * Used to update tags.
   */var ListenerUpdateFlag=/*#__PURE__*/function(_UpdateFlag){_inheritsLoose$2(ListenerUpdateFlag,_UpdateFlag);function ListenerUpdateFlag(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_UpdateFlag.call.apply(_UpdateFlag,[this].concat(args))||this;_this.listener=void 0;return _this;}var _proto=ListenerUpdateFlag.prototype;/**
     * @inheritdoc
     */_proto.dispatch=function dispatch(param){this.listener&&this.listener(param);};return ListenerUpdateFlag;}(UpdateFlag);/**
   * @internal
   */var UpdateFlagManager=/*#__PURE__*/function(){function UpdateFlagManager(){this._updateFlags=[];}var _proto=UpdateFlagManager.prototype;/**
     * Create a UpdateFlag.
     * @returns - The UpdateFlag.
     */_proto.createFlag=function createFlag(type){var flag=new type();this.addFlag(flag);return flag;}/**
     * Add a UpdateFlag.
     * @param flag - The UpdateFlag.
     */;_proto.addFlag=function addFlag(flag){this._updateFlags.push(flag);flag._flagManagers.push(this);}/**
     * Dispatch.
     */;_proto.dispatch=function dispatch(param){var updateFlags=this._updateFlags;for(var i=updateFlags.length-1;i>=0;i--){updateFlags[i].dispatch(param);}};return UpdateFlagManager;}();var _class$d$1,_descriptor$a,_descriptor2$9,_descriptor3$8,_descriptor4$8,_descriptor5$8,_descriptor6$8,_descriptor7$8,_descriptor8$8,_descriptor9$7,_descriptor10$4,_descriptor11$4,_descriptor12$4,_descriptor13$3,_class2$b;/**
   * Used to implement transformation related functions.
   */var Transform=(_class$d$1=(_class2$b=/*#__PURE__*/function(_Component){_inheritsLoose$2(Transform,_Component);/**
     * @internal
     */function Transform(entity){var _this;_this=_Component.call(this,entity)||this;_initializerDefineProperty(_this,"_position",_descriptor$a,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_rotation",_descriptor2$9,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_rotationQuaternion",_descriptor3$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_scale",_descriptor4$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_worldPosition",_descriptor5$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_worldRotation",_descriptor6$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_worldRotationQuaternion",_descriptor7$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_lossyWorldScale",_descriptor8$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_localMatrix",_descriptor9$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_worldMatrix",_descriptor10$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_updateFlagManager",_descriptor11$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_isParentDirty",_descriptor12$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_parentTransformCache",_descriptor13$3,_assertThisInitialized(_this));_this._dirtyFlag=TransformFlag.WmWpWeWqWs;_this._onPositionChanged=_this._onPositionChanged.bind(_assertThisInitialized(_this));_this._onWorldPositionChanged=_this._onWorldPositionChanged.bind(_assertThisInitialized(_this));_this._onRotationChanged=_this._onRotationChanged.bind(_assertThisInitialized(_this));_this._onWorldRotationChanged=_this._onWorldRotationChanged.bind(_assertThisInitialized(_this));_this._onRotationQuaternionChanged=_this._onRotationQuaternionChanged.bind(_assertThisInitialized(_this));_this._onWorldRotationQuaternionChanged=_this._onWorldRotationQuaternionChanged.bind(_assertThisInitialized(_this));_this._onScaleChanged=_this._onScaleChanged.bind(_assertThisInitialized(_this));//@ts-ignore
  _this._position._onValueChanged=_this._onPositionChanged;//@ts-ignore
  _this._worldPosition._onValueChanged=_this._onWorldPositionChanged;//@ts-ignore
  _this._rotation._onValueChanged=_this._onRotationChanged;//@ts-ignore
  _this._worldRotation._onValueChanged=_this._onWorldRotationChanged;//@ts-ignore
  _this._rotationQuaternion._onValueChanged=_this._onRotationQuaternionChanged;//@ts-ignore
  _this._worldRotationQuaternion._onValueChanged=_this._onWorldRotationQuaternionChanged;//@ts-ignore
  _this._scale._onValueChanged=_this._onScaleChanged;return _this;}/**
     * Set local position by X, Y, Z value.
     * @param x - X coordinate
     * @param y - Y coordinate
     * @param z - Z coordinate
     */var _proto=Transform.prototype;_proto.setPosition=function setPosition(x,y,z){this._position.set(x,y,z);}/**
     * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.
     * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
     * @param x - The angle of rotation around the X axis
     * @param y - The angle of rotation around the Y axis
     * @param z - The angle of rotation around the Z axis
     */;_proto.setRotation=function setRotation(x,y,z){this._rotation.set(x,y,z);}/**
     * Set local rotation by the X, Y, Z, and W components of the quaternion.
     * @param x - X component of quaternion
     * @param y - Y component of quaternion
     * @param z - Z component of quaternion
     * @param w - W component of quaternion
     */;_proto.setRotationQuaternion=function setRotationQuaternion(x,y,z,w){this._rotationQuaternion.set(x,y,z,w);}/**
     * Set local scaling by scaling values along X, Y, Z axis.
     * @param x - Scaling along X axis
     * @param y - Scaling along Y axis
     * @param z - Scaling along Z axis
     */;_proto.setScale=function setScale(x,y,z){this._scale.set(x,y,z);}/**
     * Set world position by X, Y, Z value.
     * @param x - X coordinate
     * @param y - Y coordinate
     * @param z - Z coordinate
     */;_proto.setWorldPosition=function setWorldPosition(x,y,z){this._worldPosition.set(x,y,z);}/**
     * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.
     * @param x - The angle of rotation around the X axis
     * @param y - The angle of rotation around the Y axis
     * @param z - The angle of rotation around the Z axis
     */;_proto.setWorldRotation=function setWorldRotation(x,y,z){this._worldRotation.set(x,y,z);}/**
     * Set local rotation by the X, Y, Z, and W components of the quaternion.
     * @param x - X component of quaternion
     * @param y - Y component of quaternion
     * @param z - Z component of quaternion
     * @param w - W component of quaternion
     */;_proto.setWorldRotationQuaternion=function setWorldRotationQuaternion(x,y,z,w){this._worldRotationQuaternion.set(x,y,z,w);}/**
     * Get the forward direction in world space.
     * @param forward - Forward vector
     * @returns Forward vector
     */;_proto.getWorldForward=function getWorldForward(forward){var e=this.worldMatrix.elements;forward.set(-e[8],-e[9],-e[10]);return forward.normalize();}/**
     * Get the right direction in world space.
     * @param right - Right vector
     * @returns Right vector
     */;_proto.getWorldRight=function getWorldRight(right){var e=this.worldMatrix.elements;right.set(e[0],e[1],e[2]);return right.normalize();}/**
     * Get the up direction in world space.
     * @param up - Up vector
     * @returns Up vector
     */;_proto.getWorldUp=function getWorldUp(up){var e=this.worldMatrix.elements;up.set(e[4],e[5],e[6]);return up.normalize();}/**
     * Translate in the direction and distance of the translation.
     * @param translation - Direction and distance of translation
     * @param relativeToLocal = `true` - Is relative to the local coordinate system
     */;_proto.translate=function translate(translationOrX,relativeToLocalOrY,z,relativeToLocal){if(typeof translationOrX==="number"){var _translate2=Transform._tempVec30;_translate2.set(translationOrX,relativeToLocalOrY,z);this._translate(_translate2,relativeToLocal);}else {this._translate(translationOrX,relativeToLocalOrY);}}/**
     * Rotate around the passed Vector3.
     * @param rotation - Euler angle in degrees
     * @param relativeToLocal = `true` - Is relative to the local coordinate system
     */;_proto.rotate=function rotate(rotationOrX,relativeToLocalOrY,z,relativeToLocal){if(typeof rotationOrX==="number"){this._rotateXYZ(rotationOrX,relativeToLocalOrY,z,relativeToLocal);}else {this._rotateXYZ(rotationOrX.x,rotationOrX.y,rotationOrX.z,relativeToLocalOrY);}}/**
     * Rotate around the specified axis according to the specified angle.
     * @param axis - Rotate axis
     * @param angle - Rotate angle in degrees
     * @param relativeToLocal = `true` - Relative to local space
     */;_proto.rotateByAxis=function rotateByAxis(axis,angle,relativeToLocal){if(relativeToLocal===void 0){relativeToLocal=true;}var rad=angle*MathUtil.degreeToRadFactor;Quaternion.rotationAxisAngle(axis,rad,Transform._tempQuat0);this._rotateByQuat(Transform._tempQuat0,relativeToLocal);}/**
     * Rotate and ensure that the world front vector points to the target world position.
     * @param targetPosition - Target world position
     * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)
     */;_proto.lookAt=function lookAt(targetPosition,worldUp){var zAxis=Transform._tempVec30;Vector3.subtract(this.worldPosition,targetPosition,zAxis);var axisLen=zAxis.length();if(axisLen<=MathUtil.zeroTolerance){// The current position and the target position are almost the same.
  return;}zAxis.scale(1/axisLen);var xAxis=Transform._tempVec31;if(worldUp){Vector3.cross(worldUp,zAxis,xAxis);}else {xAxis.set(zAxis.z,0,-zAxis.x);}axisLen=xAxis.length();if(axisLen<=MathUtil.zeroTolerance){// @todo:
  // 1.worldUp isï¼ˆ0,0,0ï¼‰
  // 2.worldUp is parallel to zAxis
  return;}xAxis.scale(1/axisLen);var yAxis=Transform._tempVec32;Vector3.cross(zAxis,xAxis,yAxis);var rotMat=Transform._tempMat41;var e=rotMat.elements;e[0]=xAxis.x,e[1]=xAxis.y,e[2]=xAxis.z;e[4]=yAxis.x,e[5]=yAxis.y,e[6]=yAxis.z;e[8]=zAxis.x,e[9]=zAxis.y,e[10]=zAxis.z;rotMat.getRotation(this._worldRotationQuaternion);}/**
     * Register world transform change flag.
     * @returns Change flag
     */;_proto.registerWorldChangeFlag=function registerWorldChangeFlag(){return this._updateFlagManager.createFlag(BoolUpdateFlag);}/**
     * @internal
     */;_proto._registerWorldChangeListener=function _registerWorldChangeListener(){return this._updateFlagManager.createFlag(ListenerUpdateFlag);}/**
     * @internal
     */;_proto._parentChange=function _parentChange(){this._isParentDirty=true;this._updateAllWorldFlag();}/**
     * @internal
     */;_proto._isFrontFaceInvert=function _isFrontFaceInvert(){var scale=this.lossyWorldScale;var isInvert=scale.x<0;scale.y<0&&(isInvert=!isInvert);scale.z<0&&(isInvert=!isInvert);return isInvert;}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
     */;_proto._updateWorldPositionFlag=function _updateWorldPositionFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWp)){this._worldAssociatedChange(TransformFlag.WmWp);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans;(_nodeChildren$i$trans=nodeChildren[i].transform)===null||_nodeChildren$i$trans===void 0?void 0:_nodeChildren$i$trans._updateWorldPositionFlag();}}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
     * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
     */;_proto._updateWorldRotationFlag=function _updateWorldRotationFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWeWq)){this._worldAssociatedChange(TransformFlag.WmWeWq);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans2;(_nodeChildren$i$trans2=nodeChildren[i].transform)===null||_nodeChildren$i$trans2===void 0?void 0:_nodeChildren$i$trans2._updateWorldPositionAndRotationFlag();// Rotation update of parent entity will trigger world position and rotation update of all child entity.
  }}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
     * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
     */;_proto._updateWorldPositionAndRotationFlag=function _updateWorldPositionAndRotationFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWpWeWq)){this._worldAssociatedChange(TransformFlag.WmWpWeWq);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans3;(_nodeChildren$i$trans3=nodeChildren[i].transform)===null||_nodeChildren$i$trans3===void 0?void 0:_nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();}}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldScale: Will trigger the scaling update of itself and all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
     */;_proto._updateWorldScaleFlag=function _updateWorldScaleFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWs)){this._worldAssociatedChange(TransformFlag.WmWs);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans4;(_nodeChildren$i$trans4=nodeChildren[i].transform)===null||_nodeChildren$i$trans4===void 0?void 0:_nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();}}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldScale: Will trigger the scaling update of itself and all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
     */;_proto._updateWorldPositionAndScaleFlag=function _updateWorldPositionAndScaleFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWpWs)){this._worldAssociatedChange(TransformFlag.WmWpWs);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans5;(_nodeChildren$i$trans5=nodeChildren[i].transform)===null||_nodeChildren$i$trans5===void 0?void 0:_nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();}}}/**
     * Update all world transform property dirty flag, the principle is the same as above.
     */;_proto._updateAllWorldFlag=function _updateAllWorldFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)){this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans6;(_nodeChildren$i$trans6=nodeChildren[i].transform)===null||_nodeChildren$i$trans6===void 0?void 0:_nodeChildren$i$trans6._updateAllWorldFlag();}}};_proto._getParentTransform=function _getParentTransform(){if(!this._isParentDirty){return this._parentTransformCache;}var parentCache=null;var parent=this._entity.parent;while(parent){var transform=parent.transform;if(transform){parentCache=transform;break;}else {parent=parent.parent;}}this._parentTransformCache=parentCache;this._isParentDirty=false;return parentCache;};_proto._getScaleMatrix=function _getScaleMatrix(){var invRotation=Transform._tempQuat0;var invRotationMat=Transform._tempMat30;var worldRotScaMat=Transform._tempMat31;var scaMat=Transform._tempMat32;worldRotScaMat.copyFromMatrix(this.worldMatrix);Quaternion.invert(this.worldRotationQuaternion,invRotation);Matrix3x3.rotationQuaternion(invRotation,invRotationMat);Matrix3x3.multiply(invRotationMat,worldRotScaMat,scaMat);return scaMat;};_proto._isContainDirtyFlags=function _isContainDirtyFlags(targetDirtyFlags){return (this._dirtyFlag&targetDirtyFlags)===targetDirtyFlags;};_proto._isContainDirtyFlag=function _isContainDirtyFlag(type){return (this._dirtyFlag&type)!=0;};_proto._setDirtyFlagTrue=function _setDirtyFlagTrue(type){this._dirtyFlag|=type;};_proto._setDirtyFlagFalse=function _setDirtyFlagFalse(type){this._dirtyFlag&=~type;};_proto._worldAssociatedChange=function _worldAssociatedChange(type){this._dirtyFlag|=type;this._updateFlagManager.dispatch();};_proto._rotateByQuat=function _rotateByQuat(rotateQuat,relativeToLocal){if(relativeToLocal){Quaternion.multiply(this.rotationQuaternion,rotateQuat,this._rotationQuaternion);}else {Quaternion.multiply(rotateQuat,this.worldRotationQuaternion,this._worldRotationQuaternion);}};_proto._translate=function _translate(translation,relativeToLocal){if(relativeToLocal===void 0){relativeToLocal=true;}if(relativeToLocal){var _tempVec30=Transform._tempVec30;Vector3.transformByQuat(translation,this.worldRotationQuaternion,_tempVec30);this._worldPosition.add(_tempVec30);}else {this._worldPosition.add(translation);}};_proto._rotateXYZ=function _rotateXYZ(x,y,z,relativeToLocal){if(relativeToLocal===void 0){relativeToLocal=true;}var radFactor=MathUtil.degreeToRadFactor;var rotQuat=Transform._tempQuat0;Quaternion.rotationEuler(x*radFactor,y*radFactor,z*radFactor,rotQuat);this._rotateByQuat(rotQuat,relativeToLocal);};_proto._onPositionChanged=function _onPositionChanged(){this._setDirtyFlagTrue(TransformFlag.LocalMatrix);this._updateWorldPositionFlag();};_proto._onWorldPositionChanged=function _onWorldPositionChanged(){var worldPosition=this._worldPosition;var parent=this._getParentTransform();if(parent){Matrix.invert(parent.worldMatrix,Transform._tempMat41);Vector3.transformCoordinate(worldPosition,Transform._tempMat41,this._position);}else {this._position.copyFrom(worldPosition);}this._setDirtyFlagFalse(TransformFlag.WorldPosition);};_proto._onRotationChanged=function _onRotationChanged(){this._setDirtyFlagTrue(TransformFlag.LocalMatrix|TransformFlag.LocalQuat);this._setDirtyFlagFalse(TransformFlag.LocalEuler);this._updateWorldRotationFlag();};_proto._onWorldRotationChanged=function _onWorldRotationChanged(){var worldRotation=this._worldRotation;Quaternion.rotationEuler(MathUtil.degreeToRadian(worldRotation.x),MathUtil.degreeToRadian(worldRotation.y),MathUtil.degreeToRadian(worldRotation.z),this._worldRotationQuaternion);this._setDirtyFlagFalse(TransformFlag.WorldEuler);};_proto._onRotationQuaternionChanged=function _onRotationQuaternionChanged(){this._setDirtyFlagTrue(TransformFlag.LocalMatrix|TransformFlag.LocalEuler);this._setDirtyFlagFalse(TransformFlag.LocalQuat);this._updateWorldRotationFlag();};_proto._onWorldRotationQuaternionChanged=function _onWorldRotationQuaternionChanged(){var worldRotationQuaternion=this._worldRotationQuaternion;var parent=this._getParentTransform();if(parent){var invParentQuaternion=Transform._tempQuat0;Quaternion.invert(parent.worldRotationQuaternion,invParentQuaternion);Quaternion.multiply(invParentQuaternion,worldRotationQuaternion,this._rotationQuaternion);}else {this._rotationQuaternion.copyFrom(worldRotationQuaternion);}this._setDirtyFlagFalse(TransformFlag.WorldQuat);};_proto._onScaleChanged=function _onScaleChanged(){this._setDirtyFlagTrue(TransformFlag.LocalMatrix);this._updateWorldScaleFlag();};_createClass$3(Transform,[{key:"position",get:/**
       * Local position.
       */function get(){return this._position;},set:function set(value){if(this._position!==value){this._position.copyFrom(value);}}/**
       * World position.
       */},{key:"worldPosition",get:function get(){var worldPosition=this._worldPosition;if(this._isContainDirtyFlag(TransformFlag.WorldPosition)){//@ts-ignore
  worldPosition._onValueChanged=null;if(this._getParentTransform()){this.worldMatrix.getTranslation(worldPosition);}else {worldPosition.copyFrom(this._position);}//@ts-ignore
  worldPosition._onValueChanged=this._onWorldPositionChanged;this._setDirtyFlagFalse(TransformFlag.WorldPosition);}return worldPosition;},set:function set(value){if(this._worldPosition!==value){this._worldPosition.copyFrom(value);}}/**
       * Local rotation, defining the rotation value in degrees.
       * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
       */},{key:"rotation",get:function get(){var rotation=this._rotation;if(this._isContainDirtyFlag(TransformFlag.LocalEuler)){//@ts-ignore
  rotation._onValueChanged=null;this._rotationQuaternion.toEuler(rotation);//@ts-ignore
  rotation._onValueChanged=this._onRotationChanged;rotation.scale(MathUtil.radToDegreeFactor);// radians to degrees
  this._setDirtyFlagFalse(TransformFlag.LocalEuler);}return rotation;},set:function set(value){if(this._rotation!==value){this._rotation.copyFrom(value);}}/**
       * World rotation, defining the rotation value in degrees.
       * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
       */},{key:"worldRotation",get:function get(){var worldRotation=this._worldRotation;if(this._isContainDirtyFlag(TransformFlag.WorldEuler)){//@ts-ignore
  worldRotation._onValueChanged=null;this.worldRotationQuaternion.toEuler(worldRotation);worldRotation.scale(MathUtil.radToDegreeFactor);// Radian to angle
  //@ts-ignore
  worldRotation._onValueChanged=this._onWorldRotationChanged;this._setDirtyFlagFalse(TransformFlag.WorldEuler);}return worldRotation;},set:function set(value){if(this._worldRotation!==value){this._worldRotation.copyFrom(value);}}/**
       * Local rotation, defining the rotation by using a unit quaternion.
       */},{key:"rotationQuaternion",get:function get(){var rotationQuaternion=this._rotationQuaternion;if(this._isContainDirtyFlag(TransformFlag.LocalQuat)){//@ts-ignore
  rotationQuaternion._onValueChanged=null;Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x),MathUtil.degreeToRadian(this._rotation.y),MathUtil.degreeToRadian(this._rotation.z),rotationQuaternion);//@ts-ignore
  rotationQuaternion._onValueChanged=this._onRotationQuaternionChanged;this._setDirtyFlagFalse(TransformFlag.LocalQuat);}return rotationQuaternion;},set:function set(value){if(this._rotationQuaternion!==value){if(value.normalized){this._rotationQuaternion.copyFrom(value);}else {Quaternion.normalize(value,this._rotationQuaternion);}}else {value.normalized||value.normalize();}}/**
       * World rotation, defining the rotation by using a unit quaternion.
       */},{key:"worldRotationQuaternion",get:function get(){var worldRotationQuaternion=this._worldRotationQuaternion;if(this._isContainDirtyFlag(TransformFlag.WorldQuat)){//@ts-ignore
  worldRotationQuaternion._onValueChanged=null;var parent=this._getParentTransform();if(parent!=null){Quaternion.multiply(parent.worldRotationQuaternion,this.rotationQuaternion,worldRotationQuaternion);}else {worldRotationQuaternion.copyFrom(this.rotationQuaternion);}//@ts-ignore
  worldRotationQuaternion._onValueChanged=this._onWorldRotationQuaternionChanged;this._setDirtyFlagFalse(TransformFlag.WorldQuat);}return worldRotationQuaternion;},set:function set(value){if(this._worldRotationQuaternion!==value){if(value.normalized){this._worldRotationQuaternion.copyFrom(value);}else {Quaternion.normalize(value,this._worldRotationQuaternion);}}value.normalized||value.normalize();}/**
       * Local scaling.
       */},{key:"scale",get:function get(){return this._scale;},set:function set(value){if(this._scale!==value){this._scale.copyFrom(value);}}/**
       * Local lossy scaling.
       * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has scaling,
       * and the child node has a rotation), the scaling will be tilted. Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3.
       */},{key:"lossyWorldScale",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldScale)){if(this._getParentTransform()){var scaleMat=this._getScaleMatrix();var e=scaleMat.elements;this._lossyWorldScale.set(e[0],e[4],e[8]);}else {this._lossyWorldScale.copyFrom(this._scale);}this._setDirtyFlagFalse(TransformFlag.WorldScale);}return this._lossyWorldScale;}/**
       * Local matrix.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"localMatrix",get:function get(){if(this._isContainDirtyFlag(TransformFlag.LocalMatrix)){Matrix.affineTransformation(this._scale,this.rotationQuaternion,this._position,this._localMatrix);this._setDirtyFlagFalse(TransformFlag.LocalMatrix);}return this._localMatrix;},set:function set(value){if(this._localMatrix!==value){this._localMatrix.copyFrom(value);}this._localMatrix.decompose(this._position,this._rotationQuaternion,this._scale);this._setDirtyFlagTrue(TransformFlag.LocalEuler);this._setDirtyFlagFalse(TransformFlag.LocalMatrix);this._updateAllWorldFlag();}/**
       * World matrix.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"worldMatrix",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldMatrix)){var parent=this._getParentTransform();if(parent){Matrix.multiply(parent.worldMatrix,this.localMatrix,this._worldMatrix);}else {this._worldMatrix.copyFrom(this.localMatrix);}this._setDirtyFlagFalse(TransformFlag.WorldMatrix);}return this._worldMatrix;},set:function set(value){if(this._worldMatrix!==value){this._worldMatrix.copyFrom(value);}var parent=this._getParentTransform();if(parent){Matrix.invert(parent.worldMatrix,Transform._tempMat42);Matrix.multiply(Transform._tempMat42,value,this._localMatrix);}else {this._localMatrix.copyFrom(value);}this.localMatrix=this._localMatrix;this._setDirtyFlagFalse(TransformFlag.WorldMatrix);}}]);return Transform;}(Component),_class2$b._tempQuat0=new Quaternion(),_class2$b._tempVec30=new Vector3(),_class2$b._tempVec31=new Vector3(),_class2$b._tempVec32=new Vector3(),_class2$b._tempMat30=new Matrix3x3(),_class2$b._tempMat31=new Matrix3x3(),_class2$b._tempMat32=new Matrix3x3(),_class2$b._tempMat41=new Matrix(),_class2$b._tempMat42=new Matrix(),_class2$b),(_descriptor$a=_applyDecoratedDescriptor(_class$d$1.prototype,"_position",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor2$9=_applyDecoratedDescriptor(_class$d$1.prototype,"_rotation",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor3$8=_applyDecoratedDescriptor(_class$d$1.prototype,"_rotationQuaternion",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Quaternion();}}),_descriptor4$8=_applyDecoratedDescriptor(_class$d$1.prototype,"_scale",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3(1,1,1);}}),_descriptor5$8=_applyDecoratedDescriptor(_class$d$1.prototype,"_worldPosition",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor6$8=_applyDecoratedDescriptor(_class$d$1.prototype,"_worldRotation",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor7$8=_applyDecoratedDescriptor(_class$d$1.prototype,"_worldRotationQuaternion",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Quaternion();}}),_descriptor8$8=_applyDecoratedDescriptor(_class$d$1.prototype,"_lossyWorldScale",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3(1,1,1);}}),_descriptor9$7=_applyDecoratedDescriptor(_class$d$1.prototype,"_localMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor10$4=_applyDecoratedDescriptor(_class$d$1.prototype,"_worldMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor11$4=_applyDecoratedDescriptor(_class$d$1.prototype,"_updateFlagManager",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new UpdateFlagManager();}}),_descriptor12$4=_applyDecoratedDescriptor(_class$d$1.prototype,"_isParentDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return true;}}),_descriptor13$3=_applyDecoratedDescriptor(_class$d$1.prototype,"_parentTransformCache",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}})),_class$d$1);/**
   * Dirty flag of transform.
   */var TransformFlag;(function(TransformFlag){TransformFlag[TransformFlag["LocalEuler"]=1]="LocalEuler";TransformFlag[TransformFlag["LocalQuat"]=2]="LocalQuat";TransformFlag[TransformFlag["WorldPosition"]=4]="WorldPosition";TransformFlag[TransformFlag["WorldEuler"]=8]="WorldEuler";TransformFlag[TransformFlag["WorldQuat"]=16]="WorldQuat";TransformFlag[TransformFlag["WorldScale"]=32]="WorldScale";TransformFlag[TransformFlag["LocalMatrix"]=64]="LocalMatrix";TransformFlag[TransformFlag["WorldMatrix"]=128]="WorldMatrix";TransformFlag[TransformFlag["WmWp"]=132]="WmWp";TransformFlag[TransformFlag["WmWeWq"]=152]="WmWeWq";TransformFlag[TransformFlag["WmWpWeWq"]=156]="WmWpWeWq";TransformFlag[TransformFlag["WmWs"]=160]="WmWs";TransformFlag[TransformFlag["WmWpWs"]=164]="WmWpWs";TransformFlag[TransformFlag["WmWpWeWqWs"]=188]="WmWpWeWqWs";})(TransformFlag||(TransformFlag={}));/**
   * Entity, be used as components container.
   */var Entity=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Entity,_EngineObject);/**
     * @internal
     */Entity._findChildByName=function _findChildByName(root,name){var children=root._children;for(var i=children.length-1;i>=0;i--){var _child=children[i];if(_child.name===name){return _child;}}return null;}/**
     * @internal
     */;Entity._traverseSetOwnerScene=function _traverseSetOwnerScene(entity,scene){entity._scene=scene;var children=entity._children;for(var i=entity.childCount-1;i>=0;i--){this._traverseSetOwnerScene(children[i],scene);}}/** The name of entity. */;/**
     * Create a entity.
     * @param engine - The engine the entity belongs to
     */function Entity(engine,name){var _this;_this=_EngineObject.call(this,engine)||this;_this.name=void 0;_this.layer=exports.Layer.Layer0;_this.transform=void 0;_this._isActiveInHierarchy=false;_this._components=[];_this._scripts=new DisorderedArray();_this._children=[];_this._scene=void 0;_this._isRoot=false;_this._isActive=true;_this._siblingIndex=-1;_this._parent=null;_this._activeChangedComponents=void 0;_this._invModelMatrix=new Matrix();_this._inverseWorldMatFlag=void 0;_this.name=name;_this.transform=_this.addComponent(Transform);_this._inverseWorldMatFlag=_this.transform.registerWorldChangeFlag();return _this;}/**
     * Add component based on the component type.
     * @param type - The type of the component
     * @returns	The component which has been added
     */var _proto=Entity.prototype;_proto.addComponent=function addComponent(type){ComponentsDependencies._addCheck(this,type);var component=new type(this);this._components.push(component);component._setActive(true);return component;}/**
     * Get component which match the type.
     * @param type - The type of the component
     * @returns	The first component which match type
     */;_proto.getComponent=function getComponent(type){for(var i=this._components.length-1;i>=0;i--){var component=this._components[i];if(component instanceof type){return component;}}}/**
     * Get components which match the type.
     * @param type - The type of the component
     * @param results - The components which match type
     * @returns	The components which match type
     */;_proto.getComponents=function getComponents(type,results){results.length=0;for(var i=this._components.length-1;i>=0;i--){var component=this._components[i];if(component instanceof type){results.push(component);}}return results;}/**
     * Get the components which match the type of the entity and it's children.
     * @param type - The component type
     * @param results - The components collection
     * @returns	The components collection which match the type
     */;_proto.getComponentsIncludeChildren=function getComponentsIncludeChildren(type,results){results.length=0;this._getComponentsInChildren(type,results);return results;}/**
     * Add child entity.
     * @param child - The child entity which want to be added
     */;_proto.addChild=function addChild(indexOrChild,child){var index;if(typeof indexOrChild==="number"){index=indexOrChild;}else {index=undefined;child=indexOrChild;}if(child._isRoot){child._scene._removeFromEntityList(child);child._isRoot=false;this._addToChildrenList(index,child);child._parent=this;var newScene=this._scene;if(child._scene!==newScene){Entity._traverseSetOwnerScene(child,newScene);}if(this._isActiveInHierarchy){!child._isActiveInHierarchy&&child._isActive&&child._processActive();}else {child._isActiveInHierarchy&&child._processInActive();}child._setTransformDirty();}else {child._setParent(this,index);}}/**
     * Remove child entity.
     * @param child - The child entity which want to be removed
     */;_proto.removeChild=function removeChild(child){child._setParent(null);}/**
     * @deprecated Please use `children` property instead.
     * Find child entity by index.
     * @param index - The index of the child entity
     * @returns	The component which be found
     */;_proto.getChild=function getChild(index){return this._children[index];}/**
     * Find child entity by name.
     * @param name - The name of the entity which want to be found
     * @returns The component which be found
     */;_proto.findByName=function findByName(name){var children=this._children;var child=Entity._findChildByName(this,name);if(child)return child;for(var i=children.length-1;i>=0;i--){var _child2=children[i];var grandson=_child2.findByName(name);if(grandson){return grandson;}}return null;}/**
     * Find the entity by path.
     * @param path - The path fo the entity eg: /entity
     * @returns The component which be found
     */;_proto.findByPath=function findByPath(path){var splits=path.split("/");var entity=this;for(var i=0,length=splits.length;i<length;++i){var split=splits[i];if(split){entity=Entity._findChildByName(entity,split);if(!entity){return null;}}}return entity;}/**
     * Create child entity.
     * @param name - The child entity's name
     * @returns The child entity
     */;_proto.createChild=function createChild(name){var child=new Entity(this.engine,name);child.layer=this.layer;child.parent=this;return child;}/**
     * Clear children entities.
     */;_proto.clearChildren=function clearChildren(){var children=this._children;for(var i=children.length-1;i>=0;i--){var _child3=children[i];_child3._parent=null;_child3._isActiveInHierarchy&&_child3._processInActive();Entity._traverseSetOwnerScene(_child3,null);// Must after child._processInActive().
  }children.length=0;}/**
     * Clone.
     * @returns Cloned entity
     */;_proto.clone=function clone(){var cloneEntity=new Entity(this._engine,this.name);cloneEntity._isActive=this._isActive;cloneEntity.transform.localMatrix=this.transform.localMatrix;var children=this._children;for(var i=0,len=this._children.length;i<len;i++){var _child4=children[i];cloneEntity.addChild(_child4.clone());}var components=this._components;for(var _i=0,n=components.length;_i<n;_i++){var sourceComp=components[_i];if(!(sourceComp instanceof Transform)){var targetComp=cloneEntity.addComponent(sourceComp.constructor);ComponentCloner.cloneComponent(sourceComp,targetComp);}}return cloneEntity;}/**
     * Destroy self.
     */;_proto.destroy=function destroy(){if(this._destroyed){return;}_EngineObject.prototype.destroy.call(this);var components=this._components;for(var i=components.length-1;i>=0;i--){components[i].destroy();}this._components.length=0;var children=this._children;for(var _i2=children.length-1;_i2>=0;_i2--){children[_i2].destroy();}this._children.length=0;if(this._isRoot){this._scene._removeFromEntityList(this);this._isRoot=false;}else {this._removeFromParent();}}/**
     * @internal
     */;_proto._removeComponent=function _removeComponent(component){ComponentsDependencies._removeCheck(this,component.constructor);var components=this._components;components.splice(components.indexOf(component),1);}/**
     * @internal
     */;_proto._addScript=function _addScript(script){script._entityScriptsIndex=this._scripts.length;this._scripts.add(script);}/**
     * @internal
     */;_proto._removeScript=function _removeScript(script){var replaced=this._scripts.deleteByIndex(script._entityScriptsIndex);replaced&&(replaced._entityScriptsIndex=script._entityScriptsIndex);script._entityScriptsIndex=-1;}/**
     * @internal
     */;_proto._removeFromParent=function _removeFromParent(){var oldParent=this._parent;if(oldParent!=null){var oldSibling=oldParent._children;var _index=this._siblingIndex;oldSibling.splice(_index,1);for(var n=oldSibling.length;_index<n;_index++){oldSibling[_index]._siblingIndex--;}this._parent=null;this._siblingIndex=-1;}}/**
     * @internal
     */;_proto._processActive=function _processActive(){if(this._activeChangedComponents){throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";}this._activeChangedComponents=this._engine._componentsManager.getActiveChangedTempList();this._setActiveInHierarchy(this._activeChangedComponents);this._setActiveComponents(true);}/**
     * @internal
     */;_proto._processInActive=function _processInActive(){if(this._activeChangedComponents){throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";}this._activeChangedComponents=this._engine._componentsManager.getActiveChangedTempList();this._setInActiveInHierarchy(this._activeChangedComponents);this._setActiveComponents(false);};_proto._addToChildrenList=function _addToChildrenList(index,child){var children=this._children;var childCount=children.length;if(index===undefined){child._siblingIndex=childCount;children.push(child);}else {if(index<0||index>childCount){throw "The index "+index+" is out of child list bounds "+childCount;}child._siblingIndex=index;children.splice(index,0,child);for(var i=index+1,n=childCount+1;i<n;i++){children[i]._siblingIndex++;}}};_proto._setParent=function _setParent(parent,siblingIndex){var oldParent=this._parent;if(parent!==oldParent){this._removeFromParent();this._parent=parent;if(parent){parent._addToChildrenList(siblingIndex,this);var parentScene=parent._scene;if(this._scene!==parentScene){Entity._traverseSetOwnerScene(this,parentScene);}if(parent._isActiveInHierarchy){!this._isActiveInHierarchy&&this._isActive&&this._processActive();}else {this._isActiveInHierarchy&&this._processInActive();}}else {this._isActiveInHierarchy&&this._processInActive();if(oldParent){Entity._traverseSetOwnerScene(this,null);}}this._setTransformDirty();}};_proto._getComponentsInChildren=function _getComponentsInChildren(type,results){for(var i=this._components.length-1;i>=0;i--){var component=this._components[i];if(component instanceof type){results.push(component);}}for(var _i3=this._children.length-1;_i3>=0;_i3--){this._children[_i3]._getComponentsInChildren(type,results);}};_proto._setActiveComponents=function _setActiveComponents(isActive){var activeChangedComponents=this._activeChangedComponents;for(var i=0,length=activeChangedComponents.length;i<length;++i){activeChangedComponents[i]._setActive(isActive);}this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);this._activeChangedComponents=null;};_proto._setActiveInHierarchy=function _setActiveInHierarchy(activeChangedComponents){this._isActiveInHierarchy=true;var components=this._components;for(var i=components.length-1;i>=0;i--){var component=components[i];(component.enabled||!component._awoken)&&activeChangedComponents.push(component);}var children=this._children;for(var _i4=children.length-1;_i4>=0;_i4--){var _child5=children[_i4];_child5.isActive&&_child5._setActiveInHierarchy(activeChangedComponents);}};_proto._setInActiveInHierarchy=function _setInActiveInHierarchy(activeChangedComponents){this._isActiveInHierarchy=false;var components=this._components;for(var i=components.length-1;i>=0;i--){var component=components[i];component.enabled&&activeChangedComponents.push(component);}var children=this._children;for(var _i5=children.length-1;_i5>=0;_i5--){var _child6=children[_i5];_child6.isActive&&_child6._setInActiveInHierarchy(activeChangedComponents);}};_proto._setTransformDirty=function _setTransformDirty(){if(this.transform){this.transform._parentChange();}else {for(var i=0,len=this._children.length;i<len;i++){this._children[i]._setTransformDirty();}}};_proto._setSiblingIndex=function _setSiblingIndex(sibling,target){target=Math.min(target,sibling.length-1);if(target<0){throw "Sibling index "+target+" should large than 0";}if(this._siblingIndex!==target){var oldIndex=this._siblingIndex;if(target<oldIndex){for(var i=oldIndex;i>=target;i--){var _child7=i==target?this:sibling[i-1];sibling[i]=_child7;_child7._siblingIndex=i;}}else {for(var _i6=oldIndex;_i6<=target;_i6++){var _child8=_i6==target?this:sibling[_i6+1];sibling[_i6]=_child8;_child8._siblingIndex=_i6;}}}}//--------------------------------------------------------------deprecated----------------------------------------------------------------
  ;/**
     * @deprecated
     */_proto.getInvModelMatrix=function getInvModelMatrix(){if(this._inverseWorldMatFlag.flag){Matrix.invert(this.transform.worldMatrix,this._invModelMatrix);this._inverseWorldMatFlag.flag=false;}return this._invModelMatrix;};_createClass$3(Entity,[{key:"isActive",get:/**
       * Whether to activate locally.
       */function get(){return this._isActive;},set:function set(value){if(value!==this._isActive){this._isActive=value;if(value){var parent=this._parent;if(parent!==null&&parent!==void 0&&parent._isActiveInHierarchy||this._isRoot&&this._scene._isActiveInEngine){this._processActive();}}else {if(this._isActiveInHierarchy){this._processInActive();}}}}/**
       * Whether it is active in the hierarchy.
       */},{key:"isActiveInHierarchy",get:function get(){return this._isActiveInHierarchy;}/**
       * The parent entity.
       */},{key:"parent",get:function get(){return this._parent;},set:function set(value){this._setParent(value);}/**
       * The children entities
       */},{key:"children",get:function get(){return this._children;}/**
       * @deprecated Please use `children.length` property instead.
       * Number of the children entities
       */},{key:"childCount",get:function get(){return this._children.length;}/**
       * The scene the entity belongs to.
       */},{key:"scene",get:function get(){return this._scene;}/**
       * The sibling index.
       */},{key:"siblingIndex",get:function get(){return this._siblingIndex;},set:function set(value){if(this._siblingIndex===-1){throw "The entity "+this.name+" is not in the hierarchy";}this._setSiblingIndex(this._isRoot?this._scene._rootEntities:this._parent._children,value);}}]);return Entity;}(EngineObject);/**
   * Manage a set of feature objects.
   */var FeatureManager=/*#__PURE__*/function(){function FeatureManager(){this._features=[];this._objects=[];}var _proto=FeatureManager.prototype;/**
     * Register a feature.
     * @param {SceneFeature|EngineFeature} IFeature
     */_proto.registerFeature=function registerFeature(IFeature){var featureArray=this._features;// Search by type, avoid adding
  for(var i=0,len=featureArray.length;i<len;i++){if(featureArray[i]===IFeature){return;}}// Add to global array
  featureArray.push(IFeature);// Add to existing scene
  var objectArray=this._objects;for(var _i=0,_len=objectArray.length;_i<_len;_i++){objectArray[_i].features.push(new IFeature());}}/**
     * Add an feature with functional characteristics.
     * @param {Scene|Engine} obj - Scene or engine
     */;_proto.addObject=function addObject(obj){obj.features=[];for(var i=0,len=this._features.length;i<len;i++){var _engine;obj.features.push(new this._features[i]((_engine=obj.engine)!=null?_engine:obj));}this._objects.push(obj);}/**
     * Call the specified method of the feature.
     * @param obj - Scene or engine
     * @param method - Method name
     * @param args - Function args
     */;_proto.callFeatureMethod=function callFeatureMethod(obj,method,args){var features=obj.features;var count=features.length;for(var i=0;i<count;i++){var feature=features[i];if(feature[method]){feature[method].apply(feature,args);}}}/**
     * Find feature.
     * @param obj - Scene or engine
     * @param IFeature - plug-in
     */;_proto.findFeature=function findFeature(obj,IFeature){var features=obj.features;var count=features.length;for(var i=0;i<count;i++){var feature=features[i];if(feature.constructor===IFeature){return feature;}}return undefined;};return FeatureManager;}();/**
   * The keys of the keyboard.
   * Keep up with W3C standards.(https://www.w3.org/TR/2017/CR-uievents-code-20170601/)
   */exports.Keys = void 0;(function(Keys){Keys[Keys["Backquote"]=0]="Backquote";Keys[Keys["Backslash"]=1]="Backslash";Keys[Keys["Backspace"]=2]="Backspace";Keys[Keys["BracketLeft"]=3]="BracketLeft";Keys[Keys["BracketRight"]=4]="BracketRight";Keys[Keys["Comma"]=5]="Comma";Keys[Keys["Digit0"]=6]="Digit0";Keys[Keys["Digit1"]=7]="Digit1";Keys[Keys["Digit2"]=8]="Digit2";Keys[Keys["Digit3"]=9]="Digit3";Keys[Keys["Digit4"]=10]="Digit4";Keys[Keys["Digit5"]=11]="Digit5";Keys[Keys["Digit6"]=12]="Digit6";Keys[Keys["Digit7"]=13]="Digit7";Keys[Keys["Digit8"]=14]="Digit8";Keys[Keys["Digit9"]=15]="Digit9";Keys[Keys["Equal"]=16]="Equal";Keys[Keys["IntlBackslash"]=17]="IntlBackslash";Keys[Keys["IntlRo"]=18]="IntlRo";Keys[Keys["IntlYen"]=19]="IntlYen";Keys[Keys["KeyA"]=20]="KeyA";Keys[Keys["KeyB"]=21]="KeyB";Keys[Keys["KeyC"]=22]="KeyC";Keys[Keys["KeyD"]=23]="KeyD";Keys[Keys["KeyE"]=24]="KeyE";Keys[Keys["KeyF"]=25]="KeyF";Keys[Keys["KeyG"]=26]="KeyG";Keys[Keys["KeyH"]=27]="KeyH";Keys[Keys["KeyI"]=28]="KeyI";Keys[Keys["KeyJ"]=29]="KeyJ";Keys[Keys["KeyK"]=30]="KeyK";Keys[Keys["KeyL"]=31]="KeyL";Keys[Keys["KeyM"]=32]="KeyM";Keys[Keys["KeyN"]=33]="KeyN";Keys[Keys["KeyO"]=34]="KeyO";Keys[Keys["KeyP"]=35]="KeyP";Keys[Keys["KeyQ"]=36]="KeyQ";Keys[Keys["KeyR"]=37]="KeyR";Keys[Keys["KeyS"]=38]="KeyS";Keys[Keys["KeyT"]=39]="KeyT";Keys[Keys["KeyU"]=40]="KeyU";Keys[Keys["KeyV"]=41]="KeyV";Keys[Keys["KeyW"]=42]="KeyW";Keys[Keys["KeyX"]=43]="KeyX";Keys[Keys["KeyY"]=44]="KeyY";Keys[Keys["KeyZ"]=45]="KeyZ";Keys[Keys["Minus"]=46]="Minus";Keys[Keys["Period"]=47]="Period";Keys[Keys["Quote"]=48]="Quote";Keys[Keys["Semicolon"]=49]="Semicolon";Keys[Keys["Slash"]=50]="Slash";Keys[Keys["AltLeft"]=51]="AltLeft";Keys[Keys["AltRight"]=52]="AltRight";Keys[Keys["CapsLock"]=53]="CapsLock";Keys[Keys["ContextMenu"]=54]="ContextMenu";Keys[Keys["ControlLeft"]=55]="ControlLeft";Keys[Keys["ControlRight"]=56]="ControlRight";Keys[Keys["Enter"]=57]="Enter";Keys[Keys["MetaLeft"]=58]="MetaLeft";Keys[Keys["MetaRight"]=59]="MetaRight";Keys[Keys["ShiftLeft"]=60]="ShiftLeft";Keys[Keys["ShiftRight"]=61]="ShiftRight";Keys[Keys["Space"]=62]="Space";Keys[Keys["Tab"]=63]="Tab";Keys[Keys["Convert"]=64]="Convert";Keys[Keys["KanaMode"]=65]="KanaMode";Keys[Keys["Lang1"]=66]="Lang1";Keys[Keys["Lang2"]=67]="Lang2";Keys[Keys["Lang3"]=68]="Lang3";Keys[Keys["Lang4"]=69]="Lang4";Keys[Keys["Lang5"]=70]="Lang5";Keys[Keys["NonConvert"]=71]="NonConvert";Keys[Keys["Delete"]=72]="Delete";Keys[Keys["End"]=73]="End";Keys[Keys["Help"]=74]="Help";Keys[Keys["Home"]=75]="Home";Keys[Keys["Insert"]=76]="Insert";Keys[Keys["PageDown"]=77]="PageDown";Keys[Keys["PageUp"]=78]="PageUp";Keys[Keys["ArrowDown"]=79]="ArrowDown";Keys[Keys["ArrowLeft"]=80]="ArrowLeft";Keys[Keys["ArrowRight"]=81]="ArrowRight";Keys[Keys["ArrowUp"]=82]="ArrowUp";Keys[Keys["NumLock"]=83]="NumLock";Keys[Keys["Numpad0"]=84]="Numpad0";Keys[Keys["Numpad1"]=85]="Numpad1";Keys[Keys["Numpad2"]=86]="Numpad2";Keys[Keys["Numpad3"]=87]="Numpad3";Keys[Keys["Numpad4"]=88]="Numpad4";Keys[Keys["Numpad5"]=89]="Numpad5";Keys[Keys["Numpad6"]=90]="Numpad6";Keys[Keys["Numpad7"]=91]="Numpad7";Keys[Keys["Numpad8"]=92]="Numpad8";Keys[Keys["Numpad9"]=93]="Numpad9";Keys[Keys["NumpadAdd"]=94]="NumpadAdd";Keys[Keys["NumpadBackspace"]=95]="NumpadBackspace";Keys[Keys["NumpadClear"]=96]="NumpadClear";Keys[Keys["NumpadClearEntry"]=97]="NumpadClearEntry";Keys[Keys["NumpadComma"]=98]="NumpadComma";Keys[Keys["NumpadDecimal"]=99]="NumpadDecimal";Keys[Keys["NumpadDivide"]=100]="NumpadDivide";Keys[Keys["NumpadEnter"]=101]="NumpadEnter";Keys[Keys["NumpadEqual"]=102]="NumpadEqual";Keys[Keys["NumpadHash"]=103]="NumpadHash";Keys[Keys["NumpadMemoryAdd"]=104]="NumpadMemoryAdd";Keys[Keys["NumpadMemoryClear"]=105]="NumpadMemoryClear";Keys[Keys["NumpadMemoryRecall"]=106]="NumpadMemoryRecall";Keys[Keys["NumpadMemoryStore"]=107]="NumpadMemoryStore";Keys[Keys["NumpadMemorySubtract"]=108]="NumpadMemorySubtract";Keys[Keys["NumpadMultiply"]=109]="NumpadMultiply";Keys[Keys["NumpadParenLeft"]=110]="NumpadParenLeft";Keys[Keys["NumpadParenRight"]=111]="NumpadParenRight";Keys[Keys["NumpadStar"]=112]="NumpadStar";Keys[Keys["NumpadSubtract"]=113]="NumpadSubtract";Keys[Keys["Escape"]=114]="Escape";Keys[Keys["F1"]=115]="F1";Keys[Keys["F2"]=116]="F2";Keys[Keys["F3"]=117]="F3";Keys[Keys["F4"]=118]="F4";Keys[Keys["F5"]=119]="F5";Keys[Keys["F6"]=120]="F6";Keys[Keys["F7"]=121]="F7";Keys[Keys["F8"]=122]="F8";Keys[Keys["F9"]=123]="F9";Keys[Keys["F10"]=124]="F10";Keys[Keys["F11"]=125]="F11";Keys[Keys["F12"]=126]="F12";Keys[Keys["F13"]=127]="F13";Keys[Keys["F14"]=128]="F14";Keys[Keys["F15"]=129]="F15";Keys[Keys["Fn"]=130]="Fn";Keys[Keys["FnLock"]=131]="FnLock";Keys[Keys["PrintScreen"]=132]="PrintScreen";Keys[Keys["ScrollLock"]=133]="ScrollLock";Keys[Keys["Pause"]=134]="Pause";Keys[Keys["BrowserBack"]=135]="BrowserBack";Keys[Keys["BrowserFavorites"]=136]="BrowserFavorites";Keys[Keys["BrowserForward"]=137]="BrowserForward";Keys[Keys["BrowserHome"]=138]="BrowserHome";Keys[Keys["BrowserRefresh"]=139]="BrowserRefresh";Keys[Keys["BrowserSearch"]=140]="BrowserSearch";Keys[Keys["BrowserStop"]=141]="BrowserStop";Keys[Keys["Eject"]=142]="Eject";Keys[Keys["LaunchApp1"]=143]="LaunchApp1";Keys[Keys["LaunchApp2"]=144]="LaunchApp2";Keys[Keys["LaunchMail"]=145]="LaunchMail";Keys[Keys["MediaPlayPause"]=146]="MediaPlayPause";Keys[Keys["MediaSelect"]=147]="MediaSelect";Keys[Keys["MediaStop"]=148]="MediaStop";Keys[Keys["MediaTrackNext"]=149]="MediaTrackNext";Keys[Keys["MediaTrackPrevious"]=150]="MediaTrackPrevious";Keys[Keys["Power"]=151]="Power";Keys[Keys["Sleep"]=152]="Sleep";Keys[Keys["AudioVolumeDown"]=153]="AudioVolumeDown";Keys[Keys["AudioVolumeMute"]=154]="AudioVolumeMute";Keys[Keys["AudioVolumeUp"]=155]="AudioVolumeUp";Keys[Keys["WakeUp"]=156]="WakeUp";Keys[Keys["Hyper"]=157]="Hyper";Keys[Keys["Super"]=158]="Super";Keys[Keys["Turbo"]=159]="Turbo";Keys[Keys["Abort"]=160]="Abort";Keys[Keys["Resume"]=161]="Resume";Keys[Keys["Suspend"]=162]="Suspend";Keys[Keys["Again"]=163]="Again";Keys[Keys["Copy"]=164]="Copy";Keys[Keys["Cut"]=165]="Cut";Keys[Keys["Find"]=166]="Find";Keys[Keys["Open"]=167]="Open";Keys[Keys["Paste"]=168]="Paste";Keys[Keys["Props"]=169]="Props";Keys[Keys["Select"]=170]="Select";Keys[Keys["Undo"]=171]="Undo";Keys[Keys["Hiragana"]=172]="Hiragana";Keys[Keys["Katakana"]=173]="Katakana";Keys[Keys["Unidentified"]=174]="Unidentified";})(exports.Keys||(exports.Keys={}));/**
   * Keyboard Manager.
   * @internal
   */var KeyboardManager=/*#__PURE__*/function(){/** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
     * Create a KeyboardManager.
     */function KeyboardManager(htmlCanvas){this._curHeldDownKeyToIndexMap=[];this._upKeyToFrameCountMap=[];this._downKeyToFrameCountMap=[];this._curFrameHeldDownList=new DisorderedArray();this._curFrameDownList=new DisorderedArray();this._curFrameUpList=new DisorderedArray();this._htmlCanvas=void 0;this._nativeEvents=[];this._hadListener=false;this._htmlCanvas=htmlCanvas;// Need to set tabIndex to make the canvas focus.
  htmlCanvas.tabIndex=htmlCanvas.tabIndex;this._onKeyEvent=this._onKeyEvent.bind(this);htmlCanvas.addEventListener("keydown",this._onKeyEvent);htmlCanvas.addEventListener("keyup",this._onKeyEvent);this._hadListener=true;}/**
     * @internal
     */var _proto=KeyboardManager.prototype;_proto._update=function _update(frameCount){var nativeEvents=this._nativeEvents,curFrameDownList=this._curFrameDownList,curFrameUpList=this._curFrameUpList;curFrameDownList.length=0;curFrameUpList.length=0;if(nativeEvents.length>0){var curHeldDownKeyToIndexMap=this._curHeldDownKeyToIndexMap,curFrameHeldDownList=this._curFrameHeldDownList,downKeyToFrameCountMap=this._downKeyToFrameCountMap,upKeyToFrameCountMap=this._upKeyToFrameCountMap;for(var i=0,n=nativeEvents.length;i<n;i++){var evt=nativeEvents[i];var codeKey=exports.Keys[evt.code];switch(evt.type){case"keydown":// Filter the repeated triggers of the keyboard.
  if(curHeldDownKeyToIndexMap[codeKey]==null){curFrameDownList.add(codeKey);curFrameHeldDownList.add(codeKey);curHeldDownKeyToIndexMap[codeKey]=curFrameHeldDownList.length-1;downKeyToFrameCountMap[codeKey]=frameCount;}break;case"keyup":var delIndex=curHeldDownKeyToIndexMap[codeKey];if(delIndex!=null){curHeldDownKeyToIndexMap[codeKey]=null;var swapCode=curFrameHeldDownList.deleteByIndex(delIndex);swapCode&&(curHeldDownKeyToIndexMap[swapCode]=delIndex);}curFrameUpList.add(codeKey);upKeyToFrameCountMap[codeKey]=frameCount;break;}}nativeEvents.length=0;}}/**
     * @internal
     */;_proto._onFocus=function _onFocus(){if(!this._hadListener){this._htmlCanvas.addEventListener("keydown",this._onKeyEvent);this._htmlCanvas.addEventListener("keyup",this._onKeyEvent);this._hadListener=true;}}/**
     * @internal
     */;_proto._onBlur=function _onBlur(){if(this._hadListener){this._htmlCanvas.removeEventListener("keydown",this._onKeyEvent);this._htmlCanvas.removeEventListener("keyup",this._onKeyEvent);this._curHeldDownKeyToIndexMap.length=0;this._curFrameHeldDownList.length=0;this._curFrameDownList.length=0;this._curFrameUpList.length=0;this._nativeEvents.length=0;this._hadListener=false;}}/**
     * @internal
     */;_proto._destroy=function _destroy(){if(this._hadListener){this._htmlCanvas.removeEventListener("keydown",this._onKeyEvent);this._htmlCanvas.removeEventListener("keyup",this._onKeyEvent);this._hadListener=false;}this._curHeldDownKeyToIndexMap=null;this._upKeyToFrameCountMap=null;this._downKeyToFrameCountMap=null;this._nativeEvents=null;this._curFrameHeldDownList=null;this._curFrameDownList=null;this._curFrameUpList=null;};_proto._onKeyEvent=function _onKeyEvent(evt){evt.cancelable&&evt.preventDefault();this._nativeEvents.push(evt);};return KeyboardManager;}();/**
   * Camera clear flags enumeration.
   */exports.CameraClearFlags = void 0;(function(CameraClearFlags){CameraClearFlags[CameraClearFlags["None"]=0]="None";CameraClearFlags[CameraClearFlags["Color"]=1]="Color";CameraClearFlags[CameraClearFlags["Depth"]=2]="Depth";CameraClearFlags[CameraClearFlags["Stencil"]=4]="Stencil";CameraClearFlags[CameraClearFlags["ColorDepth"]=3]="ColorDepth";CameraClearFlags[CameraClearFlags["ColorStencil"]=5]="ColorStencil";CameraClearFlags[CameraClearFlags["DepthStencil"]=6]="DepthStencil";CameraClearFlags[CameraClearFlags["All"]=7]="All";})(exports.CameraClearFlags||(exports.CameraClearFlags={}));/**
   * Structure used to get information back from a raycast or a sweep.
   */var HitResult=function HitResult(){this.entity=null;this.distance=0;this.point=new Vector3();this.normal=new Vector3();};/**
   * A physics manager is a collection of colliders and constraints which can interact.
   */var PhysicsManager=/*#__PURE__*/function(){function PhysicsManager(engine){var _this=this;this._initialized=false;this._engine=void 0;this._restTime=0;this._colliders=new DisorderedArray();this._gravity=new Vector3(0,-9.81,0);this._nativePhysicsManager=void 0;this._physicalObjectsMap={};this._onContactEnter=function(obj1,obj2){var shape1=_this._physicalObjectsMap[obj1];var shape2=_this._physicalObjectsMap[obj2];var scripts=shape1.collider.entity._scripts;for(var i=0,len=scripts.length;i<len;i++){var script=scripts.get(i);script._waitHandlingInValid||script.onCollisionEnter(shape2);}scripts=shape2.collider.entity._scripts;for(var _i=0,_len=scripts.length;_i<_len;_i++){var _script=scripts.get(_i);_script._waitHandlingInValid||_script.onCollisionEnter(shape1);}};this._onContactExit=function(obj1,obj2){var shape1=_this._physicalObjectsMap[obj1];var shape2=_this._physicalObjectsMap[obj2];var scripts=shape1.collider.entity._scripts;for(var i=0,len=scripts.length;i<len;i++){var script=scripts.get(i);script._waitHandlingInValid||script.onCollisionExit(shape2);}scripts=shape2.collider.entity._scripts;for(var _i2=0,_len2=scripts.length;_i2<_len2;_i2++){var _script2=scripts.get(_i2);_script2._waitHandlingInValid||_script2.onCollisionExit(shape1);}};this._onContactStay=function(obj1,obj2){var shape1=_this._physicalObjectsMap[obj1];var shape2=_this._physicalObjectsMap[obj2];var scripts=shape1.collider.entity._scripts;for(var i=0,len=scripts.length;i<len;i++){var script=scripts.get(i);script._waitHandlingInValid||script.onCollisionStay(shape2);}scripts=shape2.collider.entity._scripts;for(var _i3=0,_len3=scripts.length;_i3<_len3;_i3++){var _script3=scripts.get(_i3);_script3._waitHandlingInValid||_script3.onCollisionStay(shape1);}};this._onTriggerEnter=function(obj1,obj2){var shape1=_this._physicalObjectsMap[obj1];var shape2=_this._physicalObjectsMap[obj2];var scripts=shape1.collider.entity._scripts;for(var i=0,len=scripts.length;i<len;i++){var script=scripts.get(i);script._waitHandlingInValid||script.onTriggerEnter(shape2);}scripts=shape2.collider.entity._scripts;for(var _i4=0,_len4=scripts.length;_i4<_len4;_i4++){var _script4=scripts.get(_i4);_script4._waitHandlingInValid||_script4.onTriggerEnter(shape1);}};this._onTriggerExit=function(obj1,obj2){var shape1=_this._physicalObjectsMap[obj1];var shape2=_this._physicalObjectsMap[obj2];var scripts=shape1.collider.entity._scripts;for(var i=0,n=scripts.length;i<n;i++){var script=scripts.get(i);script._waitHandlingInValid||script.onTriggerExit(shape2);}scripts=shape2.collider.entity._scripts;for(var _i5=0,_n=scripts.length;_i5<_n;_i5++){var _script5=scripts.get(_i5);_script5._waitHandlingInValid||_script5.onTriggerExit(shape1);}};this._onTriggerStay=function(obj1,obj2){var shape1=_this._physicalObjectsMap[obj1];var shape2=_this._physicalObjectsMap[obj2];var scripts=shape1.collider.entity._scripts;for(var i=0,len=scripts.length;i<len;i++){var script=scripts.get(i);script._waitHandlingInValid||script.onTriggerStay(shape2);}scripts=shape2.collider.entity._scripts;for(var _i6=0,_len5=scripts.length;_i6<_len5;_i6++){var _script6=scripts.get(_i6);_script6._waitHandlingInValid||_script6.onTriggerStay(shape1);}};this.fixedTimeStep=1/60;this.maxSumTimeStep=1/3;this._engine=engine;}/**
     * initialize PhysicsManager.
     * @param physics - Physics Engine
     */var _proto=PhysicsManager.prototype;_proto.initialize=function initialize(physics){if(this._initialized){return;}PhysicsManager._nativePhysics=physics;this._nativePhysicsManager=PhysicsManager._nativePhysics.createPhysicsManager(this._onContactEnter,this._onContactExit,this._onContactStay,this._onTriggerEnter,this._onTriggerExit,this._onTriggerStay);this._initialized=true;}/**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @returns Returns True if the ray intersects with a collider, otherwise false
     */;_proto.raycast=function raycast(ray,distanceOrResult,layerMaskOrResult,outHitResult){var _this2=this;var hitResult;var distance=Number.MAX_VALUE;if(typeof distanceOrResult==="number"){distance=distanceOrResult;}else if(distanceOrResult!=undefined){hitResult=distanceOrResult;}var layerMask=exports.Layer.Everything;if(typeof layerMaskOrResult==="number"){layerMask=layerMaskOrResult;}else if(layerMaskOrResult!=undefined){hitResult=layerMaskOrResult;}if(outHitResult){hitResult=outHitResult;}if(hitResult!=undefined){var result=this._nativePhysicsManager.raycast(ray,distance,function(idx,distance,position,normal){hitResult.entity=_this2._physicalObjectsMap[idx]._collider.entity;hitResult.distance=distance;hitResult.normal.copyFrom(normal);hitResult.point.copyFrom(position);});if(result){if(hitResult.entity.layer&layerMask){return true;}else {hitResult.entity=null;hitResult.distance=0;hitResult.point.set(0,0,0);hitResult.normal.set(0,0,0);return false;}}return false;}else {return this._nativePhysicsManager.raycast(ray,distance);}}/**
     * Call on every frame to update pose of objects.
     * @internal
     */;_proto._update=function _update(deltaTime){var fixedTimeStep=this.fixedTimeStep,nativePhysicsManager=this._nativePhysicsManager;var componentsManager=this._engine._componentsManager;var simulateTime=deltaTime+this._restTime;var step=Math.floor(Math.min(this.maxSumTimeStep,simulateTime)/fixedTimeStep);this._restTime=simulateTime-step*fixedTimeStep;for(var i=0;i<step;i++){componentsManager.callScriptOnPhysicsUpdate();this._callColliderOnUpdate();nativePhysicsManager.update(fixedTimeStep);this._callColliderOnLateUpdate();}}/**
     * Add ColliderShape into the manager.
     * @param colliderShape - The Collider Shape.
     * @internal
     */;_proto._addColliderShape=function _addColliderShape(colliderShape){this._physicalObjectsMap[colliderShape.id]=colliderShape;this._nativePhysicsManager.addColliderShape(colliderShape._nativeShape);}/**
     * Remove ColliderShape.
     * @param colliderShape - The Collider Shape.
     * @internal
     */;_proto._removeColliderShape=function _removeColliderShape(colliderShape){delete this._physicalObjectsMap[colliderShape.id];this._nativePhysicsManager.removeColliderShape(colliderShape._nativeShape);}/**
     * Add collider into the manager.
     * @param collider - StaticCollider or DynamicCollider.
     * @internal
     */;_proto._addCollider=function _addCollider(collider){if(collider._index===-1){collider._index=this._colliders.length;this._colliders.add(collider);}this._nativePhysicsManager.addCollider(collider._nativeCollider);}/**
     * Add character controller into the manager.
     * @param controller - Character Controller.
     * @internal
     */;_proto._addCharacterController=function _addCharacterController(controller){if(controller._index===-1){controller._index=this._colliders.length;this._colliders.add(controller);}this._nativePhysicsManager.addCharacterController(controller._nativeCollider);}/**
     * Remove collider.
     * @param collider - StaticCollider or DynamicCollider.
     * @internal
     */;_proto._removeCollider=function _removeCollider(collider){var replaced=this._colliders.deleteByIndex(collider._index);replaced&&(replaced._index=collider._index);collider._index=-1;this._nativePhysicsManager.removeCollider(collider._nativeCollider);}/**
     * Remove collider.
     * @param controller - Character Controller.
     * @internal
     */;_proto._removeCharacterController=function _removeCharacterController(controller){var replaced=this._colliders.deleteByIndex(controller._index);replaced&&(replaced._index=controller._index);controller._index=-1;this._nativePhysicsManager.removeCharacterController(controller._nativeCollider);}/**
     * @internal
     */;_proto._callColliderOnUpdate=function _callColliderOnUpdate(){var elements=this._colliders._elements;for(var i=this._colliders.length-1;i>=0;--i){elements[i]._onUpdate();}}/**
     * @internal
     */;_proto._callColliderOnLateUpdate=function _callColliderOnLateUpdate(){var elements=this._colliders._elements;for(var i=this._colliders.length-1;i>=0;--i){elements[i]._onLateUpdate();}};_createClass$3(PhysicsManager,[{key:"gravity",get:/** @internal */ /** @internal */ /** The fixed time step in seconds at which physics are performed. */ /** The max sum of time step in seconds one frame. */ /**
       * The gravity of physics scene.
       */function get(){return this._gravity;},set:function set(value){var gravity=this._gravity;if(gravity!==value){gravity.copyFrom(value);}this._nativePhysicsManager.setGravity(gravity);}}]);return PhysicsManager;}();PhysicsManager._nativePhysics=void 0;/**
   * Describes how physics materials of the colliding objects are combined.
   */exports.PhysicsMaterialCombineMode = void 0;(function(PhysicsMaterialCombineMode){PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Average"]=0]="Average";PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Minimum"]=1]="Minimum";PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Multiply"]=2]="Multiply";PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Maximum"]=3]="Maximum";})(exports.PhysicsMaterialCombineMode||(exports.PhysicsMaterialCombineMode={}));/**
   * Material class to represent a set of surface properties.
   */var PhysicsMaterial=/*#__PURE__*/function(){/** @internal */function PhysicsMaterial(){this._bounciness=0.1;this._dynamicFriction=0.1;this._staticFriction=0.1;this._bounceCombine=exports.PhysicsMaterialCombineMode.Average;this._frictionCombine=exports.PhysicsMaterialCombineMode.Average;this._nativeMaterial=void 0;this._nativeMaterial=PhysicsManager._nativePhysics.createPhysicsMaterial(this._staticFriction,this._dynamicFriction,this._bounciness,this._bounceCombine,this._frictionCombine);}/**
     * The coefficient of bounciness.
     */var _proto=PhysicsMaterial.prototype;/**
     * @internal
     */_proto._destroy=function _destroy(){this._nativeMaterial.destroy();};_createClass$3(PhysicsMaterial,[{key:"bounciness",get:function get(){return this._bounciness;},set:function set(value){this._bounciness=value;this._nativeMaterial.setBounciness(value);}/**
       * The DynamicFriction value.
       */},{key:"dynamicFriction",get:function get(){return this._dynamicFriction;},set:function set(value){this._dynamicFriction=value;this._nativeMaterial.setDynamicFriction(value);}/**
       * The coefficient of static friction.
       */},{key:"staticFriction",get:function get(){return this._staticFriction;},set:function set(value){this._staticFriction=value;this._nativeMaterial.setStaticFriction(value);}/**
       * The restitution combine mode.
       */},{key:"bounceCombine",get:function get(){return this._bounceCombine;},set:function set(value){this._bounceCombine=value;this._nativeMaterial.setBounceCombine(value);}/**
       * The friction combine mode.
       */},{key:"frictionCombine",get:function get(){return this._frictionCombine;},set:function set(value){this._frictionCombine=value;this._nativeMaterial.setFrictionCombine(value);}}]);return PhysicsMaterial;}();var _dec$5$1,_class$c$1,_class2$a,_descriptor$9;/**
   * Base class for all colliders.
   * @decorator `@dependentComponents(Transform)`
   */var Collider=(_dec$5$1=dependentComponents(Transform),_dec$5$1(_class$c$1=(_class2$a=/*#__PURE__*/function(_Component){_inheritsLoose$2(Collider,_Component);/**
     * @internal
     */function Collider(entity){var _this;_this=_Component.call(this,entity)||this;_initializerDefineProperty(_this,"_index",_descriptor$9,_assertThisInitialized(_this));_this._nativeCollider=void 0;_this._updateFlag=void 0;_this._shapes=[];_this._updateFlag=_this.entity.transform.registerWorldChangeFlag();return _this;}/**
     * Add collider shape on this collider.
     * @param shape - Collider shape
     */var _proto=Collider.prototype;_proto.addShape=function addShape(shape){var oldCollider=shape._collider;if(oldCollider!==this){if(oldCollider){oldCollider.removeShape(shape);}this._shapes.push(shape);this.engine.physicsManager._addColliderShape(shape);shape._collider=this;this._nativeCollider.addShape(shape._nativeShape);}}/**
     * Remove a collider shape.
     * @param shape - The collider shape.
     */;_proto.removeShape=function removeShape(shape){var index=this._shapes.indexOf(shape);if(index!==-1){this._shapes.splice(index,1);this.engine.physicsManager._removeColliderShape(shape);shape._collider=null;this._nativeCollider.removeShape(shape._nativeShape);}}/**
     * Remove all shape attached.
     */;_proto.clearShapes=function clearShapes(){var shapes=this._shapes;for(var i=0,n=shapes.length;i<n;i++){var shape=shapes[i];this.engine.physicsManager._removeColliderShape(shape);shape._destroy();this._nativeCollider.removeShape(shape._nativeShape);}shapes.length=0;}/**
     * @internal
     */;_proto._onUpdate=function _onUpdate(){if(this._updateFlag.flag){var transform=this.entity.transform;this._nativeCollider.setWorldTransform(transform.worldPosition,transform.worldRotationQuaternion);var worldScale=transform.lossyWorldScale;for(var i=0,n=this.shapes.length;i<n;i++){this.shapes[i]._nativeShape.setWorldScale(worldScale);}this._updateFlag.flag=false;}}/**
     * @internal
     */;_proto._onLateUpdate=function _onLateUpdate(){}/**
     * @override
     * @internal
     */;_proto._onEnable=function _onEnable(){this.engine.physicsManager._addCollider(this);}/**
     * @override
     * @internal
     */;_proto._onDisable=function _onDisable(){this.engine.physicsManager._removeCollider(this);}/**
     * @override
     * @internal
     */;_proto._onDestroy=function _onDestroy(){this.clearShapes();this._nativeCollider.destroy();};_createClass$3(Collider,[{key:"shapes",get:/** @internal */ /** @internal */ /**
       * The shapes of this collider.
       */function get(){return this._shapes;}}]);return Collider;}(Component),_descriptor$9=_applyDecoratedDescriptor(_class2$a.prototype,"_index",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_class2$a))||_class$c$1);/**
   * The up axis of the collider shape.
   */exports.ControllerNonWalkableMode = void 0;(function(ControllerNonWalkableMode){ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbing"]=0]="PreventClimbing";ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbingAndForceSliding"]=1]="PreventClimbingAndForceSliding";})(exports.ControllerNonWalkableMode||(exports.ControllerNonWalkableMode={}));/**
   * The character controllers.
   */var CharacterController=/*#__PURE__*/function(_Collider){_inheritsLoose$2(CharacterController,_Collider);/**
     * @internal
     */function CharacterController(entity){var _this;_this=_Collider.call(this,entity)||this;_this._index=-1;_this._stepOffset=0;_this._nonWalkableMode=exports.ControllerNonWalkableMode.PreventClimbing;_this._upDirection=new Vector3(0,1,0);_this._slopeLimit=0;_this._nativeCollider=PhysicsManager._nativePhysics.createCharacterController();return _this;}/**
     * Moves the character using a "collide-and-slide" algorithm.
     * @param disp - Displacement vector
     * @param minDist - The minimum travelled distance to consider.
     * @param elapsedTime - Time elapsed since last call
     * @return flags - The ControllerCollisionFlag
     */var _proto=CharacterController.prototype;_proto.move=function move(disp,minDist,elapsedTime){return this._nativeCollider.move(disp,minDist,elapsedTime);}/**
     * Add collider shape on this controller.
     * @param shape - Collider shape
     * @override
     */;_proto.addShape=function addShape(shape){if(this._shapes.length>0){throw "only allow single shape on controller!";}_Collider.prototype.addShape.call(this,shape);this._updateFlag.flag=true;}/**
     * Remove all shape attached.
     * @override
     */;_proto.clearShapes=function clearShapes(){if(this._shapes.length>0){_Collider.prototype.removeShape.call(this,this._shapes[0]);}}/**
     * @internal
     * @override
     */;_proto._onUpdate=function _onUpdate(){if(this._updateFlag.flag){var transform=this.entity.transform;var shapes=this.shapes;this._nativeCollider.setWorldPosition(transform.worldPosition);var worldScale=transform.lossyWorldScale;for(var i=0,n=shapes.length;i<n;i++){shapes[i]._nativeShape.setWorldScale(worldScale);}this._updateFlag.flag=false;}}/**
     * @internal
     * @override
     */;_proto._onLateUpdate=function _onLateUpdate(){var position=this.entity.transform.worldPosition;this._nativeCollider.getWorldPosition(position);this.entity.transform.worldPosition=position;this._updateFlag.flag=false;}/**
     * @override
     * @internal
     */;_proto._onEnable=function _onEnable(){this.engine.physicsManager._addCharacterController(this);}/**
     * @override
     * @internal
     */;_proto._onDisable=function _onDisable(){this.engine.physicsManager._removeCharacterController(this);};_createClass$3(CharacterController,[{key:"stepOffset",get:/** @internal */ /**
       * The step offset for the controller.
       */function get(){return this._stepOffset;},set:function set(value){this._stepOffset=value;this._nativeCollider.setStepOffset(value);}/**
       * The value of the non-walkable mode.
       */},{key:"nonWalkableMode",get:function get(){return this._nonWalkableMode;},set:function set(value){this._nonWalkableMode=value;this._nativeCollider.setNonWalkableMode(value);}/**
       * The up direction for the controller.
       */},{key:"upDirection",get:function get(){return this._upDirection;},set:function set(value){if(this._upDirection!==value){this._upDirection.copyFrom(value);}this._nativeCollider.setUpDirection(this._upDirection);}/**
       * The slope limit for the controller.
       */},{key:"slopeLimit",get:function get(){return this._slopeLimit;},set:function set(value){this._slopeLimit=value;this._nativeCollider.setSlopeLimit(value);}}]);return CharacterController;}(Collider);/**
   * Abstract class for collider shapes.
   */var ColliderShape=/*#__PURE__*/function(){function ColliderShape(){this._collider=void 0;this._nativeShape=void 0;this._id=void 0;this._position=new Vector3();this._material=void 0;this._isTrigger=false;this._isSceneQuery=true;this._contactOffset=0;this._material=new PhysicsMaterial();this._id=ColliderShape._idGenerator++;}/**
     * Set local position of collider shape
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     * @param z - The z component of the vector, default 0
     */var _proto=ColliderShape.prototype;_proto.setPosition=function setPosition(x,y,z){this._position.set(x,y,z);this._nativeShape.setPosition(this._position);}/**
     * @internal
     */;_proto._destroy=function _destroy(){this._material._destroy();this._nativeShape.destroy();};_createClass$3(ColliderShape,[{key:"collider",get:/** @internal */ /** @internal */ /**
       * Collider owner of this shape.
       */function get(){return this._collider;}/**
       * Unique id for this shape.
       */},{key:"id",get:function get(){return this._id;}/**
       * Contact offset for this shape.
       */},{key:"contactOffset",get:function get(){return this._contactOffset;},set:function set(value){this._contactOffset=value;this._nativeShape.setContactOffset(value);}/**
       * Physical material.
       */},{key:"material",get:function get(){return this._material;},set:function set(value){this._material=value;this._nativeShape.setMaterial(value._nativeMaterial);}/**
       * The local position of this ColliderShape.
       */},{key:"position",get:function get(){return this._position;},set:function set(value){if(this._position!==value){this._position.copyFrom(value);}this._nativeShape.setPosition(value);}/**
       * True for TriggerShape, false for SimulationShape.
       */},{key:"isTrigger",get:function get(){return this._isTrigger;},set:function set(value){this._isTrigger=value;this._nativeShape.setIsTrigger(value);}}]);return ColliderShape;}();ColliderShape._idGenerator=0;/**
   * Physical collider shape for box.
   */var BoxColliderShape=/*#__PURE__*/function(_ColliderShape){_inheritsLoose$2(BoxColliderShape,_ColliderShape);function BoxColliderShape(){var _this;_this=_ColliderShape.call(this)||this;_this._size=new Vector3(1,1,1);_this._nativeShape=PhysicsManager._nativePhysics.createBoxColliderShape(_this._id,_this._size,_this._material._nativeMaterial);return _this;}/**
     * Set size of box.
     * @param x - Size of x-axis
     * @param y - Size of y-axis
     * @param z - Size of z-axis
     */var _proto=BoxColliderShape.prototype;_proto.setSize=function setSize(x,y,z){this._size.x=x;this._size.y=y;this._size.z=z;this._nativeShape.setSize(this._size);};_createClass$3(BoxColliderShape,[{key:"size",get:/**
       * Size of box shape.
       */function get(){return this._size;},set:function set(value){if(this._size!=value){this._size.copyFrom(value);}this._nativeShape.setSize(value);}}]);return BoxColliderShape;}(ColliderShape);/**
   * Physical collider shape for sphere.
   */var SphereColliderShape=/*#__PURE__*/function(_ColliderShape){_inheritsLoose$2(SphereColliderShape,_ColliderShape);function SphereColliderShape(){var _this;_this=_ColliderShape.call(this)||this;_this._radius=1;_this._nativeShape=PhysicsManager._nativePhysics.createSphereColliderShape(_this._id,_this._radius,_this._material._nativeMaterial);return _this;}_createClass$3(SphereColliderShape,[{key:"radius",get:/**
       * Radius of sphere shape.
       */function get(){return this._radius;},set:function set(value){this._radius=value;this._nativeShape.setRadius(value);}}]);return SphereColliderShape;}(ColliderShape);/**
   * Physical collider shape plane.
   */var PlaneColliderShape=/*#__PURE__*/function(_ColliderShape){_inheritsLoose$2(PlaneColliderShape,_ColliderShape);function PlaneColliderShape(){var _this;_this=_ColliderShape.call(this)||this;_this._rotation=new Vector3();_this._nativeShape=PhysicsManager._nativePhysics.createPlaneColliderShape(_this._id,_this._material._nativeMaterial);return _this;}/**
     * Set the local rotation of this plane.
     * @param x - Radian of yaw
     * @param y - Radian of pitch
     * @param z - Radian of roll
     */var _proto=PlaneColliderShape.prototype;_proto.setRotation=function setRotation(x,y,z){this._rotation.set(x,y,z);this._nativeShape.setRotation(this._rotation);};_createClass$3(PlaneColliderShape,[{key:"rotation",get:/**
       * The local rotation of this plane.
       */function get(){return this._rotation;},set:function set(value){if(this._rotation!=value){this._rotation.copyFrom(value);}this._nativeShape.setRotation(value);}}]);return PlaneColliderShape;}(ColliderShape);/**
   * The up axis of the collider shape.
   */exports.ColliderShapeUpAxis = void 0;(function(ColliderShapeUpAxis){ColliderShapeUpAxis[ColliderShapeUpAxis["X"]=0]="X";ColliderShapeUpAxis[ColliderShapeUpAxis["Y"]=1]="Y";ColliderShapeUpAxis[ColliderShapeUpAxis["Z"]=2]="Z";})(exports.ColliderShapeUpAxis||(exports.ColliderShapeUpAxis={}));/**
   * Physical collider shape for capsule.
   */var CapsuleColliderShape=/*#__PURE__*/function(_ColliderShape){_inheritsLoose$2(CapsuleColliderShape,_ColliderShape);function CapsuleColliderShape(){var _this;_this=_ColliderShape.call(this)||this;_this._radius=1;_this._height=2;_this._upAxis=exports.ColliderShapeUpAxis.Y;_this._nativeShape=PhysicsManager._nativePhysics.createCapsuleColliderShape(_this._id,_this._radius,_this._height,_this._material._nativeMaterial);_this._nativeShape.setUpAxis(exports.ColliderShapeUpAxis.Y);return _this;}_createClass$3(CapsuleColliderShape,[{key:"radius",get:/**
       * Radius of capsule.
       */function get(){return this._radius;},set:function set(value){this._radius=value;this._nativeShape.setRadius(value);}/**
       * Height of capsule.
       */},{key:"height",get:function get(){return this._height;},set:function set(value){this._height=value;this._nativeShape.setHeight(value);}/**
       * Up axis of capsule.
       */},{key:"upAxis",get:function get(){return this._upAxis;},set:function set(value){this._upAxis=value;this._nativeShape.setUpAxis(value);}}]);return CapsuleColliderShape;}(ColliderShape);var _dec$4$1,_class$b$1;/**
   * A base class providing common functionality for joints.
   * @decorator `@dependentComponents(Collider)`
   */var Joint=(_dec$4$1=dependentComponents(Collider),_dec$4$1(_class$b$1=/*#__PURE__*/function(_Component){_inheritsLoose$2(Joint,_Component);function Joint(entity){var _this;_this=_Component.call(this,entity)||this;_this._connectedCollider=new JointCollider();_this._collider=new JointCollider();_this._nativeJoint=void 0;_this._force=0;_this._torque=0;_this._connectedCollider.localPosition=new Vector3();return _this;}_createClass$3(Joint,[{key:"connectedCollider",get:/**
       * The connected collider.
       */function get(){return this._connectedCollider.collider;},set:function set(value){if(this._connectedCollider.collider!==value){this._connectedCollider.collider=value;this._nativeJoint.setConnectedCollider(value._nativeCollider);}}/**
       * The connected anchor position.
       * @remarks If connectedCollider is set, this anchor is relative offset, or the anchor is world position.
       */},{key:"connectedAnchor",get:function get(){return this._connectedCollider.localPosition;},set:function set(value){var connectedAnchor=this._connectedCollider.localPosition;if(value!==connectedAnchor){connectedAnchor.copyFrom(value);}this._nativeJoint.setConnectedAnchor(value);}/**
       *  The scale to apply to the inverse mass of collider 0 for resolving this constraint.
       */},{key:"connectedMassScale",get:function get(){return this._connectedCollider.massScale;},set:function set(value){if(value!==this._connectedCollider.massScale){this._connectedCollider.massScale=value;this._nativeJoint.setConnectedMassScale(value);}}/**
       * The scale to apply to the inverse inertia of collider0 for resolving this constraint.
       */},{key:"connectedInertiaScale",get:function get(){return this._connectedCollider.inertiaScale;},set:function set(value){if(value!==this._connectedCollider.inertiaScale){this._connectedCollider.inertiaScale=value;this._nativeJoint.setConnectedInertiaScale(value);}}/**
       * The scale to apply to the inverse mass of collider 1 for resolving this constraint.
       */},{key:"massScale",get:function get(){return this._collider.massScale;},set:function set(value){if(value!==this._collider.massScale){this._collider.massScale=value;this._nativeJoint.setMassScale(value);}}/**
       * The scale to apply to the inverse inertia of collider1 for resolving this constraint.
       */},{key:"inertiaScale",get:function get(){return this._collider.inertiaScale;},set:function set(value){if(value!==this._collider.inertiaScale){this._collider.inertiaScale=value;this._nativeJoint.setInertiaScale(value);}}/**
       * The maximum force the joint can apply before breaking.
       */},{key:"breakForce",get:function get(){return this._force;},set:function set(value){if(value!==this._force){this._force=value;this._nativeJoint.setBreakForce(value);}}/**
       * The maximum torque the joint can apply before breaking.
       */},{key:"breakTorque",get:function get(){return this._torque;},set:function set(value){if(value!==this._torque){this._torque=value;this._nativeJoint.setBreakTorque(value);}}}]);return Joint;}(Component))||_class$b$1);/**
   * @internal
   */var JointCollider=function JointCollider(){this.collider=null;this.localPosition=void 0;this.localRotation=void 0;this.massScale=0;this.inertiaScale=0;};/*
   * A fixed joint permits no relative movement between two colliders. ie the colliders are glued together.
   */var FixedJoint=/*#__PURE__*/function(_Joint){_inheritsLoose$2(FixedJoint,_Joint);function FixedJoint(){return _Joint.apply(this,arguments)||this;}var _proto=FixedJoint.prototype;/**
     * @override
     * @internal
     */_proto._onAwake=function _onAwake(){var collider=this._collider;collider.collider=this.entity.getComponent(Collider);this._nativeJoint=PhysicsManager._nativePhysics.createFixedJoint(collider.collider._nativeCollider);};return FixedJoint;}(Joint);/**
   * Flags specific to the Hinge Joint.
   * @internal
   */var HingeJointFlag;(function(HingeJointFlag){HingeJointFlag[HingeJointFlag["LimitEnabled"]=1]="LimitEnabled";HingeJointFlag[HingeJointFlag["DriveEnabled"]=2]="DriveEnabled";HingeJointFlag[HingeJointFlag["DriveFreeSpin"]=4]="DriveFreeSpin";})(HingeJointFlag||(HingeJointFlag={}));/**
   * A joint which behaves in a similar way to a hinge or axle.
   */var HingeJoint=/*#__PURE__*/function(_Joint){_inheritsLoose$2(HingeJoint,_Joint);function HingeJoint(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Joint.call.apply(_Joint,[this].concat(args))||this;_this._axis=new Vector3(1,0,0);_this._hingeFlags=0;_this._useSpring=false;_this._jointMonitor=void 0;_this._limits=void 0;return _this;}var _proto=HingeJoint.prototype;/**
     * @override
     * @internal
     */_proto._onAwake=function _onAwake(){var collider=this._collider;collider.localPosition=new Vector3();collider.collider=this.entity.getComponent(Collider);this._nativeJoint=PhysicsManager._nativePhysics.createHingeJoint(collider.collider._nativeCollider);};_createClass$3(HingeJoint,[{key:"axis",get:/**
       * The anchor rotation.
       */function get(){return this._axis;},set:function set(value){var axis=this._axis;if(value!==axis){axis.copyFrom(value);}this._nativeJoint.setAxis(axis);}/**
       * The swing offset.
       */},{key:"swingOffset",get:function get(){return this._collider.localPosition;},set:function set(value){var swingOffset=this._collider.localPosition;if(value!==swingOffset){swingOffset.copyFrom(value);}this._nativeJoint.setSwingOffset(swingOffset);}/**
       * The current angle in degrees of the joint relative to its rest position.
       */},{key:"angle",get:function get(){return this._nativeJoint.getAngle();}/**
       * The angular velocity of the joint in degrees per second.
       */},{key:"velocity",get:function get(){return this._nativeJoint.getVelocity();}/**
       * Enables the joint's limits. Disabled by default.
       */},{key:"useLimits",get:function get(){return (this._hingeFlags&HingeJointFlag.LimitEnabled)==HingeJointFlag.LimitEnabled;},set:function set(value){if(value!==this.useLimits){this._hingeFlags|=HingeJointFlag.LimitEnabled;}this._nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled,value);}/**
       * Enables the joint's motor. Disabled by default.
       */},{key:"useMotor",get:function get(){return (this._hingeFlags&HingeJointFlag.DriveEnabled)==HingeJointFlag.DriveEnabled;},set:function set(value){if(value!==this.useMotor){this._hingeFlags|=HingeJointFlag.DriveEnabled;}this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled,value);}/**
       * Enables the joint's spring. Disabled by default.
       */},{key:"useSpring",get:function get(){return this._useSpring;},set:function set(value){this._useSpring=value;this.limits=this._limits;}/**
       * The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.
       */},{key:"motor",get:function get(){return this._jointMonitor;},set:function set(value){this._jointMonitor=value;this._nativeJoint.setDriveVelocity(value.targetVelocity);this._nativeJoint.setDriveForceLimit(value.forceLimit);this._nativeJoint.setDriveGearRatio(value.gearRation);this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin,value.freeSpin);}/**
       * Limit of angular rotation (in degrees) on the hinge joint.
       */},{key:"limits",get:function get(){return this._limits;},set:function set(value){this._limits=value;if(this.useSpring){this._nativeJoint.setSoftLimit(value.min,value.max,value.stiffness,value.damping);}else {this._nativeJoint.setHardLimit(value.min,value.max,value.contactDistance);}}}]);return HingeJoint;}(Joint);/**
   * A joint that maintains an upper or lower bound (or both) on the distance between two points on different objects.
   */var SpringJoint=/*#__PURE__*/function(_Joint){_inheritsLoose$2(SpringJoint,_Joint);function SpringJoint(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Joint.call.apply(_Joint,[this].concat(args))||this;_this._minDistance=0;_this._maxDistance=0;_this._tolerance=0.25;_this._stiffness=0;_this._damping=0;return _this;}var _proto=SpringJoint.prototype;/**
     * @override
     * @internal
     */_proto._onAwake=function _onAwake(){var collider=this._collider;collider.localPosition=new Vector3();collider.collider=this.entity.getComponent(Collider);this._nativeJoint=PhysicsManager._nativePhysics.createSpringJoint(collider.collider._nativeCollider);};_createClass$3(SpringJoint,[{key:"swingOffset",get:/**
       * The swing offset.
       */function get(){return this._collider.localPosition;},set:function set(value){var swingOffset=this._collider.localPosition;if(value!==swingOffset){swingOffset.copyFrom(value);}this._nativeJoint.setSwingOffset(value);}/**
       * The minimum distance.
       */},{key:"minDistance",get:function get(){return this._minDistance;},set:function set(value){this._minDistance=value;this._nativeJoint.setMinDistance(value);}/**
       * The maximum distance.
       */},{key:"maxDistance",get:function get(){return this._maxDistance;},set:function set(value){this._maxDistance=value;this._nativeJoint.setMaxDistance(value);}/**
       * The distance beyond the allowed range at which the joint becomes active.
       */},{key:"tolerance",get:function get(){return this._tolerance;},set:function set(value){this._tolerance=value;this._nativeJoint.setTolerance(value);}/**
       * The spring strength of the joint.
       */},{key:"stiffness",get:function get(){return this._stiffness;},set:function set(value){this._stiffness=value;this._nativeJoint.setStiffness(value);}/**
       * The degree of damping of the joint spring of the joint.
       */},{key:"damping",get:function get(){return this._damping;},set:function set(value){this._damping=value;this._nativeJoint.setDamping(value);}}]);return SpringJoint;}(Joint);/**
   * JointLimits is used to limit the joints angle.
   */var JointLimits=function JointLimits(){this.max=0;this.min=0;this.contactDistance=-1;this.stiffness=0;this.damping=0;};/**
   * The JointMotor is used to motorize a joint.
   */var JointMotor=function JointMotor(){this.targetVelocity=0;this.forceLimit=Number.MAX_VALUE;this.gearRation=1.0;this.freeSpin=false;};/**
   * The up axis of the collider shape.
   */exports.ControllerCollisionFlag = void 0;(function(ControllerCollisionFlag){ControllerCollisionFlag[ControllerCollisionFlag["Sides"]=1]="Sides";ControllerCollisionFlag[ControllerCollisionFlag["Up"]=2]="Up";ControllerCollisionFlag[ControllerCollisionFlag["Down"]=4]="Down";})(exports.ControllerCollisionFlag||(exports.ControllerCollisionFlag={}));/**
   * A static collider component that will not move.
   * @remarks Mostly used for object which always stays at the same place and never moves around.
   */var StaticCollider=/*#__PURE__*/function(_Collider){_inheritsLoose$2(StaticCollider,_Collider);/**
     * @internal
     */function StaticCollider(entity){var _this;_this=_Collider.call(this,entity)||this;var transform=_this.entity.transform;_this._nativeCollider=PhysicsManager._nativePhysics.createStaticCollider(transform.worldPosition,transform.worldRotationQuaternion);return _this;}return StaticCollider;}(Collider);/**
   * A dynamic collider can act with self-defined movement or physical force.
   */var DynamicCollider=/*#__PURE__*/function(_Collider){_inheritsLoose$2(DynamicCollider,_Collider);/**
     * @internal
     */function DynamicCollider(entity){var _this;_this=_Collider.call(this,entity)||this;_this._linearDamping=0;_this._angularDamping=0;_this._linearVelocity=new Vector3();_this._angularVelocity=new Vector3();_this._mass=0;_this._centerOfMass=new Vector3();_this._inertiaTensor=new Vector3();_this._maxAngularVelocity=0;_this._maxDepenetrationVelocity=0;_this._sleepThreshold=0;_this._solverIterations=0;_this._isKinematic=false;_this._constraints=0;_this._collisionDetectionMode=exports.CollisionDetectionMode.Discrete;var transform=_this.entity.transform;_this._nativeCollider=PhysicsManager._nativePhysics.createDynamicCollider(transform.worldPosition,transform.worldRotationQuaternion);return _this;}/**
     * Apply a force to the DynamicCollider.
     * @param force - The force make the collider move
     */var _proto=DynamicCollider.prototype;_proto.applyForce=function applyForce(force){this._nativeCollider.addForce(force);}/**
     * Apply a torque to the DynamicCollider.
     * @param torque - The force make the collider rotate
     */;_proto.applyTorque=function applyTorque(torque){this._nativeCollider.addTorque(torque);}/**
     * Moves kinematically controlled dynamic actors through the game world.
     * @param position - The desired position for the kinematic actor
     */;_proto.move=function move(positionOrRotation,rotation){this._nativeCollider.move(positionOrRotation,rotation);}/**
     * Forces a collider to sleep at least one frame.
     */;_proto.sleep=function sleep(){this._nativeCollider.sleep();}/**
     * Forces a collider to wake up.
     */;_proto.wakeUp=function wakeUp(){this._nativeCollider.wakeUp();}/**
     * @override
     * @internal
     */;_proto._onLateUpdate=function _onLateUpdate(){var transform=this.entity.transform;var worldPosition=transform.worldPosition,worldRotationQuaternion=transform.worldRotationQuaternion;this._nativeCollider.getWorldTransform(worldPosition,worldRotationQuaternion);this._updateFlag.flag=false;};_createClass$3(DynamicCollider,[{key:"linearDamping",get:/**
       * The linear damping of the dynamic collider.
       */function get(){return this._linearDamping;},set:function set(value){this._linearDamping=value;this._nativeCollider.setLinearDamping(value);}/**
       * The angular damping of the dynamic collider.
       */},{key:"angularDamping",get:function get(){return this._angularDamping;},set:function set(value){this._angularDamping=value;this._nativeCollider.setAngularDamping(value);}/**
       * The linear velocity vector of the dynamic collider measured in world unit per second.
       */},{key:"linearVelocity",get:function get(){return this._linearVelocity;},set:function set(value){if(this._linearVelocity!==value){this._linearVelocity.copyFrom(value);}this._nativeCollider.setLinearVelocity(this._linearVelocity);}/**
       * The angular velocity vector of the dynamic collider measured in radians per second.
       */},{key:"angularVelocity",get:function get(){return this._angularVelocity;},set:function set(value){if(this._angularVelocity!==value){this._angularVelocity.copyFrom(value);}this._nativeCollider.setAngularVelocity(this._angularVelocity);}/**
       * The mass of the dynamic collider.
       */},{key:"mass",get:function get(){return this._mass;},set:function set(value){this._mass=value;this._nativeCollider.setMass(value);}/**
       * The center of mass relative to the transform's origin.
       */},{key:"centerOfMass",get:function get(){return this._centerOfMass;},set:function set(value){if(this._centerOfMass!==value){this._centerOfMass.copyFrom(value);}this._nativeCollider.setCenterOfMass(this._centerOfMass);}/**
       * The diagonal inertia tensor of mass relative to the center of mass.
       */},{key:"inertiaTensor",get:function get(){return this._inertiaTensor;},set:function set(value){if(this._inertiaTensor!==value){this._inertiaTensor.copyFrom(value);}this._nativeCollider.setInertiaTensor(this._inertiaTensor);}/**
       * The maximum angular velocity of the collider measured in radians per second. (Default 7) range { 0, infinity }.
       */},{key:"maxAngularVelocity",get:function get(){return this._maxAngularVelocity;},set:function set(value){this._maxAngularVelocity=value;this._nativeCollider.setMaxAngularVelocity(value);}/**
       * Maximum velocity of a collider when moving out of penetrating state.
       */},{key:"maxDepenetrationVelocity",get:function get(){return this._maxDepenetrationVelocity;},set:function set(value){this._maxDepenetrationVelocity=value;this._nativeCollider.setMaxDepenetrationVelocity(value);}/**
       * The mass-normalized energy threshold, below which objects start going to sleep.
       */},{key:"sleepThreshold",get:function get(){return this._sleepThreshold;},set:function set(value){this._sleepThreshold=value;this._nativeCollider.setSleepThreshold(value);}/**
       * The solverIterations determines how accurately collider joints and collision contacts are resolved.
       */},{key:"solverIterations",get:function get(){return this._solverIterations;},set:function set(value){this._solverIterations=value;this._nativeCollider.setSolverIterations(value);}/**
       * Controls whether physics affects the dynamic collider.
       */},{key:"isKinematic",get:function get(){return this._isKinematic;},set:function set(value){this._isKinematic=value;this._nativeCollider.setIsKinematic(value);}/**
       * The particular rigid dynamic lock flag.
       */},{key:"constraints",get:function get(){return this._constraints;},set:function set(value){this._constraints=value;this._nativeCollider.setConstraints(value);}/**
       * The colliders' collision detection mode.
       */},{key:"collisionDetectionMode",get:function get(){return this._collisionDetectionMode;},set:function set(value){this._collisionDetectionMode=value;this._nativeCollider.setCollisionDetectionMode(value);}}]);return DynamicCollider;}(Collider);/**
   * The collision detection mode constants.
   */exports.CollisionDetectionMode = void 0;/**
   * Use these flags to constrain motion of dynamic collider.
   */(function(CollisionDetectionMode){CollisionDetectionMode[CollisionDetectionMode["Discrete"]=0]="Discrete";CollisionDetectionMode[CollisionDetectionMode["Continuous"]=1]="Continuous";CollisionDetectionMode[CollisionDetectionMode["ContinuousDynamic"]=2]="ContinuousDynamic";CollisionDetectionMode[CollisionDetectionMode["ContinuousSpeculative"]=3]="ContinuousSpeculative";})(exports.CollisionDetectionMode||(exports.CollisionDetectionMode={}));exports.DynamicColliderConstraints = void 0;(function(DynamicColliderConstraints){DynamicColliderConstraints[DynamicColliderConstraints["None"]=0]="None";DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionX"]=1]="FreezePositionX";DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionY"]=2]="FreezePositionY";DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionZ"]=4]="FreezePositionZ";DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationX"]=8]="FreezeRotationX";DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationY"]=16]="FreezeRotationY";DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationZ"]=32]="FreezeRotationZ";})(exports.DynamicColliderConstraints||(exports.DynamicColliderConstraints={}));/**
   *  The current phase of the pointer.
   */exports.PointerPhase = void 0;(function(PointerPhase){PointerPhase[PointerPhase["Down"]=0]="Down";PointerPhase[PointerPhase["Move"]=1]="Move";PointerPhase[PointerPhase["Up"]=2]="Up";PointerPhase[PointerPhase["Leave"]=3]="Leave";})(exports.PointerPhase||(exports.PointerPhase={}));/**
   * Defines values that specify the buttons on a pointer device.
   * Refer to the W3C standards.(https://www.w3.org/TR/uievents/#dom-mouseevent-button)
   * Refer to Microsoft's documentation.(https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mousebutton?view=windowsdesktop-6.0)
   */exports.PointerButton = void 0;(function(PointerButton){PointerButton[PointerButton["Primary"]=0]="Primary";PointerButton[PointerButton["Auxiliary"]=1]="Auxiliary";PointerButton[PointerButton["Secondary"]=2]="Secondary";PointerButton[PointerButton["XButton1"]=3]="XButton1";PointerButton[PointerButton["XButton2"]=4]="XButton2";PointerButton[PointerButton["XButton3"]=5]="XButton3";PointerButton[PointerButton["XButton4"]=6]="XButton4";PointerButton[PointerButton["XButton5"]=7]="XButton5";PointerButton[PointerButton["XButton6"]=8]="XButton6";PointerButton[PointerButton["XButton7"]=9]="XButton7";PointerButton[PointerButton["XButton8"]=10]="XButton8";})(exports.PointerButton||(exports.PointerButton={}));/**
   * Pointer.
   */var Pointer=/**
   * Unique id.
   * @remarks Start from 0.
   */ /** The phase of pointer. */ /** The position of the pointer in screen space pixel coordinates. */ /** @internal */ /**
   * @internal
   */function Pointer(id){this.id=void 0;this.phase=exports.PointerPhase.Leave;this.position=new Vector2();this._uniqueID=void 0;this.id=id;};/**
   * Pointer Manager.
   * @internal
   */var PointerManager=/*#__PURE__*/function(){/** Refer to the W3C standards.(https://www.w3.org/TR/uievents/#dom-mouseevent-buttons) */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
     * Create a PointerManager.
     * @param engine - The current engine instance
     * @param htmlCanvas - HTMLCanvasElement
     */function PointerManager(engine,htmlCanvas){this._pointers=[];this._movingDelta=new Vector2();this._multiPointerEnabled=true;this._buttons=0x0;this._upMap=[];this._downMap=[];this._downList=new DisorderedArray();this._upList=new DisorderedArray();this._currentPosition=new Vector2();this._currentPressedEntity=void 0;this._currentEnteredEntity=void 0;this._engine=void 0;this._canvas=void 0;this._htmlCanvas=void 0;this._nativeEvents=[];this._pointerPool=void 0;this._keyEventList=[];this._keyEventCount=0;this._needOverallPointers=false;this._hadListener=false;this._lastPositionFrameCount=0;this._engine=engine;this._canvas=engine.canvas;this._htmlCanvas=htmlCanvas;htmlCanvas.oncontextmenu=function(event){return false;};var onPointerEvent=this._onPointerEvent=this._onPointerEvent.bind(this);htmlCanvas.addEventListener("pointerdown",onPointerEvent);htmlCanvas.addEventListener("pointerup",onPointerEvent);htmlCanvas.addEventListener("pointerout",onPointerEvent);htmlCanvas.addEventListener("pointermove",onPointerEvent);this._hadListener=true;// If there are no compatibility issues, navigator.maxTouchPoints should be used here.
  this._pointerPool=new Array(11);}/**
     * @internal
     */var _proto=PointerManager.prototype;_proto._update=function _update(frameCount){this._needOverallPointers&&this._overallPointers();this._downList.length=0;this._upList.length=0;this._movingDelta.set(0,0);this._nativeEvents.length>0&&this._handlePointerEvent(this._nativeEvents,frameCount);this._pointers.length>0&&(this._lastPositionFrameCount=frameCount);if(this._engine.physicsManager._initialized){var rayCastEntity=this._pointerRayCast();var keyEventCount=this._keyEventCount;if(keyEventCount>0){var keyEventList=this._keyEventList;for(var i=0;i<keyEventCount;i++){switch(keyEventList[i]){case PointerKeyEvent.Down:this._firePointerDown(rayCastEntity);break;case PointerKeyEvent.Up:this._firePointerUpAndClick(rayCastEntity);break;}}this._firePointerExitAndEnter(rayCastEntity);keyEventList[keyEventCount-1]===PointerKeyEvent.Leave&&(this._currentPressedEntity=null);this._keyEventCount=0;}else {this._firePointerDrag();this._firePointerExitAndEnter(rayCastEntity);}}}/**
     * @internal
     */;_proto._onFocus=function _onFocus(){if(!this._hadListener){var htmlCanvas=this._htmlCanvas,onPointerEvent=this._onPointerEvent;htmlCanvas.addEventListener("pointerdown",onPointerEvent);htmlCanvas.addEventListener("pointerup",onPointerEvent);htmlCanvas.addEventListener("pointerout",onPointerEvent);htmlCanvas.addEventListener("pointermove",onPointerEvent);this._hadListener=true;}}/**
     * @internal
     */;_proto._onBlur=function _onBlur(){if(this._hadListener){var htmlCanvas=this._htmlCanvas,onPointerEvent=this._onPointerEvent;htmlCanvas.removeEventListener("pointerdown",onPointerEvent);htmlCanvas.removeEventListener("pointerup",onPointerEvent);htmlCanvas.removeEventListener("pointerout",onPointerEvent);htmlCanvas.removeEventListener("pointermove",onPointerEvent);this._nativeEvents.length=0;this._pointerPool.length=0;this._currentEnteredEntity=null;this._currentPressedEntity=null;this._downList.length=0;this._upList.length=0;this._hadListener=false;}}/**
     * @internal
     */;_proto._destroy=function _destroy(){// @ts-ignore
  if(this._hadListener){var htmlCanvas=this._htmlCanvas,onPointerEvent=this._onPointerEvent;htmlCanvas.removeEventListener("pointerdown",onPointerEvent);htmlCanvas.removeEventListener("pointerup",onPointerEvent);htmlCanvas.removeEventListener("pointerout",onPointerEvent);htmlCanvas.removeEventListener("pointermove",onPointerEvent);this._hadListener=false;}this._nativeEvents.length=0;this._pointerPool.length=0;this._pointers.length=0;this._currentPosition=null;this._currentEnteredEntity=null;this._currentPressedEntity=null;this._engine=null;this._canvas=null;};_proto._onPointerEvent=function _onPointerEvent(evt){evt.cancelable&&evt.preventDefault();evt.type==="pointerdown"&&this._htmlCanvas.focus();this._nativeEvents.push(evt);};_proto._overallPointers=function _overallPointers(){var pointers=this._pointers;var deleteCount=0;var totalCount=pointers.length;for(var i=0;i<totalCount;i++){if(pointers[i].phase===exports.PointerPhase.Leave){deleteCount++;}else {if(deleteCount>0){pointers[i-deleteCount]=pointers[i];}}}pointers.length=totalCount-deleteCount;this._needOverallPointers=false;};_proto._getIndexByPointerID=function _getIndexByPointerID(pointerId){var pointers=this._pointers;for(var i=pointers.length-1;i>=0;i--){if(pointers[i]._uniqueID===pointerId){return i;}}return -1;};_proto._addPointer=function _addPointer(pointerId,x,y,phase){var pointers=this._pointers;var lastCount=pointers.length;if(lastCount===0||this._multiPointerEnabled){var pointerPool=this._pointerPool;// Get Pointer smallest index.
  var i=0;for(;i<lastCount;i++){if(pointers[i].id>i){break;}}var pointer=pointerPool[i];if(!pointer){pointer=pointerPool[i]=new Pointer(i);}pointer._uniqueID=pointerId;pointer.position.set(x,y);pointer.phase=phase;pointers.splice(i,0,pointer);}};_proto._removePointer=function _removePointer(pointerIndex){var leavePointer=this._pointers[pointerIndex];leavePointer.phase=exports.PointerPhase.Leave;};_proto._updatePointer=function _updatePointer(pointerIndex,x,y,phase){var updatedPointer=this._pointers[pointerIndex];updatedPointer.position.set(x,y);updatedPointer.phase=phase;};_proto._handlePointerEvent=function _handlePointerEvent(nativeEvents,frameCount){var pointers=this._pointers,keyEventList=this._keyEventList,upMap=this._upMap,downMap=this._downMap,upList=this._upList,downList=this._downList;var activePointerCount=pointers.length;var pixelRatioW=this._canvas.width/this._htmlCanvas.clientWidth;var pixelRatioH=this._canvas.height/this._htmlCanvas.clientHeight;var nativeEventsLen=nativeEvents.length;for(var i=0;i<nativeEventsLen;i++){var evt=nativeEvents[i];var pointerButton=evt.button|exports.PointerButton.Primary;var pointerIndex=this._getIndexByPointerID(evt.pointerId);switch(evt.type){case"pointerdown":if(pointerIndex===-1){this._addPointer(evt.pointerId,evt.offsetX*pixelRatioW,evt.offsetY*pixelRatioH,exports.PointerPhase.Down);activePointerCount++;}else {this._updatePointer(pointerIndex,evt.offsetX*pixelRatioW,evt.offsetY*pixelRatioH,exports.PointerPhase.Down);}activePointerCount===1&&(keyEventList[this._keyEventCount++]=PointerKeyEvent.Down);downList.add(pointerButton);downMap[pointerButton]=frameCount;break;case"pointerup":if(pointerIndex>=0){this._updatePointer(pointerIndex,evt.offsetX*pixelRatioW,evt.offsetY*pixelRatioH,exports.PointerPhase.Up);activePointerCount===1&&(keyEventList[this._keyEventCount++]=PointerKeyEvent.Up);}upList.add(pointerButton);upMap[pointerButton]=frameCount;break;case"pointermove":if(pointerIndex===-1){this._addPointer(evt.pointerId,evt.offsetX*pixelRatioW,evt.offsetY*pixelRatioH,exports.PointerPhase.Move);activePointerCount++;}else {this._updatePointer(pointerIndex,evt.offsetX*pixelRatioW,evt.offsetY*pixelRatioH,exports.PointerPhase.Move);}break;case"pointerout":if(pointerIndex>=0){this._removePointer(pointerIndex);--activePointerCount===0&&(keyEventList[this._keyEventCount++]=PointerKeyEvent.Leave);this._needOverallPointers=true;}break;}}this._buttons=nativeEvents[nativeEventsLen-1].buttons;var pointerCount=pointers.length;if(pointerCount>0){var currentPosition=this._currentPosition;var lastX=currentPosition.x,lastY=currentPosition.y;if(activePointerCount===0){// Get the pointer coordinates when leaving, and use it to correctly dispatch the click event.
  var lastNativeEvent=nativeEvents[nativeEventsLen-1];currentPosition.set(lastNativeEvent.offsetX*pixelRatioW,lastNativeEvent.offsetY*pixelRatioH);}else {currentPosition.set(0,0);for(var _i=0;_i<pointerCount;_i++){currentPosition.add(pointers[_i].position);}currentPosition.scale(1/pointerCount);}// Update pointer moving delta.
  if(this._lastPositionFrameCount===frameCount-1){this._movingDelta.set(currentPosition.x-lastX,currentPosition.y-lastY);}}nativeEvents.length=0;};_proto._pointerRayCast=function _pointerRayCast(){if(this._pointers.length>0){var point=PointerManager._tempPoint,ray=PointerManager._tempRay,hitResult=PointerManager._tempHitResult;var cameras=this._engine.sceneManager.activeScene._activeCameras;var x=this._currentPosition.x/this._canvas.width;var y=this._currentPosition.y/this._canvas.height;for(var i=cameras.length-1;i>=0;i--){var camera=cameras[i];if(!camera.enabled||camera.renderTarget){continue;}var _camera$viewport=camera.viewport,vpX=_camera$viewport.x,vpY=_camera$viewport.y,vpW=_camera$viewport.z,vpH=_camera$viewport.w;if(x>=vpX&&y>=vpY&&x-vpX<=vpW&&y-vpY<=vpH){point.set((x-vpX)/vpW,(y-vpY)/vpH);// TODO: Only check which colliders have listened to the input.
  if(this._engine.physicsManager.raycast(camera.viewportPointToRay(point,ray),Number.MAX_VALUE,camera.cullingMask,hitResult)){return hitResult.entity;}else if(camera.clearFlags&exports.CameraClearFlags.Color){return null;}}}}return null;};_proto._firePointerDrag=function _firePointerDrag(){if(this._currentPressedEntity){var scripts=this._currentPressedEntity._scripts;for(var i=scripts.length-1;i>=0;i--){var script=scripts.get(i);script._waitHandlingInValid||script.onPointerDrag();}}};_proto._firePointerExitAndEnter=function _firePointerExitAndEnter(rayCastEntity){if(this._currentEnteredEntity!==rayCastEntity){if(this._currentEnteredEntity){var scripts=this._currentEnteredEntity._scripts;for(var i=scripts.length-1;i>=0;i--){var script=scripts.get(i);script._waitHandlingInValid||script.onPointerExit();}}if(rayCastEntity){var _scripts=rayCastEntity._scripts;for(var _i2=_scripts.length-1;_i2>=0;_i2--){var _script=_scripts.get(_i2);_script._waitHandlingInValid||_script.onPointerEnter();}}this._currentEnteredEntity=rayCastEntity;}};_proto._firePointerDown=function _firePointerDown(rayCastEntity){if(rayCastEntity){var scripts=rayCastEntity._scripts;for(var i=scripts.length-1;i>=0;i--){var script=scripts.get(i);script._waitHandlingInValid||script.onPointerDown();}}this._currentPressedEntity=rayCastEntity;};_proto._firePointerUpAndClick=function _firePointerUpAndClick(rayCastEntity){var pressedEntity=this._currentPressedEntity;if(pressedEntity){var sameTarget=pressedEntity===rayCastEntity;var scripts=pressedEntity._scripts;for(var i=scripts.length-1;i>=0;i--){var script=scripts.get(i);if(!script._waitHandlingInValid){sameTarget&&script.onPointerClick();script.onPointerUp();}}this._currentPressedEntity=null;}};return PointerManager;}();/**
   * @internal
   */PointerManager.Buttons=[0x1,0x4,0x2,0x8,0x10,0x20,0x40,0x80,0x100,0x200,0x400];PointerManager._tempRay=new Ray();PointerManager._tempPoint=new Vector2();PointerManager._tempHitResult=new HitResult();var PointerKeyEvent;(function(PointerKeyEvent){PointerKeyEvent[PointerKeyEvent["Down"]=0]="Down";PointerKeyEvent[PointerKeyEvent["Up"]=1]="Up";PointerKeyEvent[PointerKeyEvent["Leave"]=2]="Leave";})(PointerKeyEvent||(PointerKeyEvent={}));/**
   * Wheel Manager.
   * @internal
   */var WheelManager=/*#__PURE__*/function(){/** @internal */ /**
     * Create a KeyboardManager.
     */function WheelManager(htmlCanvas){this._delta=new Vector3();this._nativeEvents=[];this._canvas=void 0;this._hadListener=void 0;this._onWheelEvent=this._onWheelEvent.bind(this);htmlCanvas.addEventListener("wheel",this._onWheelEvent);this._canvas=htmlCanvas;this._hadListener=true;}/**
     * @internal
     */var _proto=WheelManager.prototype;_proto._update=function _update(){var delta=this._delta;delta.set(0,0,0);var nativeEvents=this._nativeEvents;if(nativeEvents.length>0){for(var i=nativeEvents.length-1;i>=0;i--){var evt=nativeEvents[i];delta.x+=evt.deltaX;delta.y+=evt.deltaY;delta.z+=evt.deltaZ;}nativeEvents.length=0;}}/**
     * @internal
     */;_proto._onFocus=function _onFocus(){if(!this._hadListener){this._canvas.addEventListener("wheel",this._onWheelEvent);this._hadListener=true;}}/**
     * @internal
     */;_proto._onBlur=function _onBlur(){if(this._hadListener){this._canvas.removeEventListener("wheel",this._onWheelEvent);this._nativeEvents.length=0;this._delta.set(0,0,0);this._hadListener=false;}}/**
     * @internal
     */;_proto._destroy=function _destroy(){if(this._hadListener){this._canvas.removeEventListener("wheel",this._onWheelEvent);this._hadListener=false;}this._nativeEvents=null;};_proto._onWheelEvent=function _onWheelEvent(evt){evt.cancelable&&evt.preventDefault();this._nativeEvents.push(evt);};return WheelManager;}();/**
   * InputManager manages device input such as mouse, touch, keyboard, etc.
   */var InputManager=/*#__PURE__*/function(){var _proto=InputManager.prototype;/**
     * Whether the key is being held down, if there is no parameter, return whether any key is being held down.
     * @param key - The keys of the keyboard
     * @returns Whether the key is being held down
     */_proto.isKeyHeldDown=function isKeyHeldDown(key){if(this._initialized){if(key===undefined){return this._keyboardManager._curFrameHeldDownList.length>0;}else {return this._keyboardManager._curHeldDownKeyToIndexMap[key]!=null;}}else {return false;}}/**
     * Whether the key starts to be pressed down during the current frame, if there is no parameter, return whether any key starts to be pressed down during the current frame.
     * @param key - The keys of the keyboard
     * @returns Whether the key starts to be pressed down during the current frame
     */;_proto.isKeyDown=function isKeyDown(key){if(this._initialized){if(key===undefined){return this._keyboardManager._curFrameDownList.length>0;}else {return this._keyboardManager._downKeyToFrameCountMap[key]===this._curFrameCount;}}else {return false;}}/**
     * Whether the key is released during the current frame, if there is no parameter, return whether any key released during the current frame.
     * @param key - The keys of the keyboard
     * @returns Whether the key is released during the current frame
     */;_proto.isKeyUp=function isKeyUp(key){if(this._initialized){if(key===undefined){return this._keyboardManager._curFrameUpList.length>0;}else {return this._keyboardManager._upKeyToFrameCountMap[key]===this._curFrameCount;}}else {return false;}}/**
     * Whether the pointer is being held down, if there is no parameter, return whether any pointer is being held down.
     * @param pointerButton - The pointerButton on a pointer device
     * @returns Whether the pointer is being held down
     */;_proto.isPointerHeldDown=function isPointerHeldDown(pointerButton){if(this._initialized){if(pointerButton===undefined){return this._pointerManager._buttons!==0;}else {return (this._pointerManager._buttons&PointerManager.Buttons[pointerButton])!==0;}}else {return false;}}/**
     * Whether the pointer starts to be pressed down during the current frame, if there is no parameter, return whether any pointer starts to be pressed down during the current frame.
     * @param pointerButton - The pointerButton on a pointer device
     * @returns Whether the pointer starts to be pressed down during the current frame
     */;_proto.isPointerDown=function isPointerDown(pointerButton){if(this._initialized){if(pointerButton===undefined){return this._pointerManager._downList.length>0;}else {return this._pointerManager._downMap[pointerButton]===this._curFrameCount;}}else {return false;}}/**
     * Whether the pointer is released during the current frame, if there is no parameter, return whether any pointer released during the current frame.
     * @param pointerButton - The pointerButtons on a mouse device
     * @returns Whether the pointer is released during the current frame
     */;_proto.isPointerUp=function isPointerUp(pointerButton){if(this._initialized){if(pointerButton===undefined){return this._pointerManager._upList.length>0;}else {return this._pointerManager._upMap[pointerButton]===this._curFrameCount;}}else {return false;}}/**
     * @internal
     */;function InputManager(engine){this._initialized=false;this._curFrameCount=0;this._wheelManager=void 0;this._pointerManager=void 0;this._keyboardManager=void 0;// @ts-ignore
  var canvas=engine._canvas._webCanvas;if(typeof OffscreenCanvas==="undefined"||!(canvas instanceof OffscreenCanvas)){this._wheelManager=new WheelManager(canvas);this._pointerManager=new PointerManager(engine,canvas);this._keyboardManager=new KeyboardManager(canvas);this._onBlur=this._onBlur.bind(this);window.addEventListener("blur",this._onBlur);this._onFocus=this._onFocus.bind(this);window.addEventListener("focus",this._onFocus);this._initialized=true;}}/**
     * @internal
     */_proto._update=function _update(){if(this._initialized){++this._curFrameCount;this._wheelManager._update();this._pointerManager._update(this._curFrameCount);this._keyboardManager._update(this._curFrameCount);}}/**
     * @internal
     */;_proto._destroy=function _destroy(){if(this._initialized){window.removeEventListener("blur",this._onBlur);window.removeEventListener("focus",this._onFocus);this._wheelManager._destroy();this._pointerManager._destroy();this._keyboardManager._destroy();}};_proto._onBlur=function _onBlur(){this._wheelManager._onBlur();this._pointerManager._onBlur();this._keyboardManager._onBlur();};_proto._onFocus=function _onFocus(){this._wheelManager._onFocus();this._pointerManager._onFocus();this._keyboardManager._onFocus();};_createClass$3(InputManager,[{key:"pointers",get:/** Sometimes the input module will not be initialized, such as off-screen rendering. */ /**
       * Pointer List.
       */function get(){return this._initialized?this._pointerManager._pointers:null;}/**
       *  Whether to handle multi-pointer.
       */},{key:"multiPointerEnabled",get:function get(){return this._initialized?this._pointerManager._multiPointerEnabled:false;},set:function set(enabled){this._initialized&&(this._pointerManager._multiPointerEnabled=enabled);}/**
       * Get the change of the scroll wheel on the x-axis.
       * @returns Change value
       */},{key:"wheelDelta",get:function get(){return this._initialized?this._wheelManager._delta:null;}/**
       * Get the change of the pointer.
       * @returns Change value
       */},{key:"pointerMovingDelta",get:function get(){return this._initialized?this._pointerManager._movingDelta:null;}/**
       * Get the position of the pointer.
       * @returns The position of the pointer
       */},{key:"pointerPosition",get:function get(){return this._initialized&&this._pointerManager._pointers.length>0?this._pointerManager._currentPosition:null;}}]);return InputManager;}();/**
   * Render queue type.
   */exports.RenderQueueType = void 0;(function(RenderQueueType){RenderQueueType[RenderQueueType["Opaque"]=0]="Opaque";RenderQueueType[RenderQueueType["AlphaTest"]=1]="AlphaTest";RenderQueueType[RenderQueueType["Transparent"]=2]="Transparent";})(exports.RenderQueueType||(exports.RenderQueueType={}));/**
   * The base class of assets, with reference counting capability.
   */var RefObject=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(RefObject,_EngineObject);function RefObject(engine){var _this;_this=_EngineObject.call(this,engine)||this;_this.isGCIgnored=false;_this._refCount=0;engine.resourceManager._addRefObject(_this.instanceId,_assertThisInitialized(_this));return _this;}/**
     * Destroy self.
     * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
     * @returns Whether the release was successful.
     */var _proto=RefObject.prototype;_proto.destroy=function destroy(force){if(force===void 0){force=false;}if(this._destroyed)return true;if(!force&&this._refCount!==0)return false;var resourceManager=this._engine.resourceManager;// resourceManager maybe null,because engine has destroyed.
  // TODO:the right way to fix this is to ensure destroy all when call engine.destroy,thus don't need to add this project.
  if(resourceManager){_EngineObject.prototype.destroy.call(this);resourceManager._deleteRefObject(this.instanceId);}var refCount=this._getRefCount();if(refCount>0){this._addRefCount(-refCount);}this._engine=null;this._onDestroy();return true;}/**
     * @internal
     */;_proto._getRefCount=function _getRefCount(){return this._refCount;}/**
     * @internal
     */;_proto._addRefCount=function _addRefCount(value){this._refCount+=value;}/**
     * @internal
     */;_proto._addToResourceManager=function _addToResourceManager(path){this._engine.resourceManager._addAsset(path,this);}/**
     * Called when the resource is destroyed.
     * Subclasses can override this function.
     */;_createClass$3(RefObject,[{key:"refCount",get:/** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */ /**
       * Counted by valid references.
       */function get(){return this._refCount;}}]);return RefObject;}(EngineObject);/**
   * Shader data grouping.
   */var ShaderDataGroup;(function(ShaderDataGroup){ShaderDataGroup[ShaderDataGroup["Scene"]=0]="Scene";ShaderDataGroup[ShaderDataGroup["Camera"]=1]="Camera";ShaderDataGroup[ShaderDataGroup["Renderer"]=2]="Renderer";ShaderDataGroup[ShaderDataGroup["Material"]=3]="Material";})(ShaderDataGroup||(ShaderDataGroup={}));/**
   * The base class of texture, contains some common functions of texture-related classes.
   */var Texture=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Texture,_RefObject);function Texture(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_RefObject.call.apply(_RefObject,[this].concat(args))||this;_this.name=void 0;_this._platformTexture=void 0;_this._mipmap=void 0;_this._format=void 0;_this._width=void 0;_this._height=void 0;_this._mipmapCount=void 0;_this._wrapModeU=void 0;_this._wrapModeV=void 0;_this._filterMode=void 0;_this._anisoLevel=1;return _this;}var _proto=Texture.prototype;/**
     * Generate multi-level textures based on the 0th level data.
     */_proto.generateMipmaps=function generateMipmaps(){if(!this._mipmap)return;this._platformTexture.generateMipmaps();}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){this._platformTexture.destroy();this._platformTexture=null;}/**
     * Get the maximum mip level of the corresponding size:rounding down.
     * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
     */;_proto._getMaxMiplevel=function _getMaxMiplevel(size){return Math.floor(Math.log2(size));};_proto._getMipmapCount=function _getMipmapCount(){return this._mipmap?Math.floor(Math.log2(Math.max(this._width,this._height)))+1:1;};_createClass$3(Texture,[{key:"format",get:/**
       * Texture format.
       */function get(){return this._format;}/**
       * The width of the texture.
       */},{key:"width",get:function get(){return this._width;}/**
       * The height of the texture.
       */},{key:"height",get:function get(){return this._height;}/**
       * Wrapping mode for texture coordinate S.
       */},{key:"wrapModeU",get:function get(){return this._wrapModeU;},set:function set(value){if(value===this._wrapModeU)return;this._wrapModeU=value;this._platformTexture.wrapModeU=value;}/**
       * Wrapping mode for texture coordinate T.
       */},{key:"wrapModeV",get:function get(){return this._wrapModeV;},set:function set(value){if(value===this._wrapModeV)return;this._wrapModeV=value;this._platformTexture.wrapModeV=value;}/**
       * Texture mipmapping count.
       */},{key:"mipmapCount",get:function get(){return this._mipmapCount;}/**
       * Filter mode for texture.
       */},{key:"filterMode",get:function get(){return this._filterMode;},set:function set(value){if(value===this._filterMode)return;this._filterMode=value;this._platformTexture.filterMode=value;}/**
       * Anisotropic level for texture.
       */},{key:"anisoLevel",get:function get(){return this._anisoLevel;},set:function set(value){var max=this._engine._hardwareRenderer.capability.maxAnisoLevel;if(value>max){Logger.warn("anisoLevel:"+value+", exceeds the limit and is automatically downgraded to:"+max);value=max;}if(value<1){Logger.warn("anisoLevel:"+value+", must be greater than 0, and is automatically downgraded to 1");value=1;}if(value===this._anisoLevel)return;this._anisoLevel=value;this._platformTexture.anisoLevel=value;}}]);return Texture;}(RefObject);/**
   * Shader Property type.
   */exports.ShaderPropertyType = void 0;(function(ShaderPropertyType){ShaderPropertyType[ShaderPropertyType["Float"]=0]="Float";ShaderPropertyType[ShaderPropertyType["Int"]=1]="Int";ShaderPropertyType[ShaderPropertyType["Vector2"]=2]="Vector2";ShaderPropertyType[ShaderPropertyType["Vector3"]=3]="Vector3";ShaderPropertyType[ShaderPropertyType["Vector4"]=4]="Vector4";ShaderPropertyType[ShaderPropertyType["Matrix"]=5]="Matrix";ShaderPropertyType[ShaderPropertyType["Color"]=6]="Color";ShaderPropertyType[ShaderPropertyType["Texture"]=7]="Texture";ShaderPropertyType[ShaderPropertyType["FloatArray"]=8]="FloatArray";ShaderPropertyType[ShaderPropertyType["IntArray"]=9]="IntArray";ShaderPropertyType[ShaderPropertyType["TextureArray"]=10]="TextureArray";})(exports.ShaderPropertyType||(exports.ShaderPropertyType={}));var common="#define GLSLIFY 1\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2(float x){return x*x;}vec4 RGBMToLinear(vec4 value,float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 gammaToLinear(vec4 srgbIn){return vec4(pow(srgbIn.rgb,vec3(2.2)),srgbIn.a);}vec4 linearToGamma(vec4 linearIn){return vec4(pow(linearIn.rgb,vec3(1.0/2.2)),linearIn.a);}";// eslint-disable-line
  var common_vert="#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_UV1\nattribute vec2 TEXCOORD_1;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;uniform vec4 u_tilingOffset;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n";// eslint-disable-line
  var common_frag="#define GLSLIFY 1\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;";// eslint-disable-line
  var color_share="#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n";// eslint-disable-line
  var normal_share="#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nvarying vec3 v_normal;\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvarying mat3 v_TBN;\n#endif\n#endif\n#endif\n";// eslint-disable-line
  var uv_share="#define GLSLIFY 1\nvarying vec2 v_uv;\n#ifdef O3_HAS_UV1\nvarying vec2 v_uv1;\n#endif\n";// eslint-disable-line
  var worldpos_share="#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvarying vec3 v_pos;\n#endif\n";// eslint-disable-line
  var shadow_share="#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n";// eslint-disable-line
  var fog_share="#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform float u_fogDensity;\n#else\nuniform float u_fogNear;uniform float u_fogFar;\n#endif\n#endif\n";// eslint-disable-line
  var begin_normal_vert="#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#endif\n#ifdef O3_HAS_TANGENT\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n";// eslint-disable-line
  var begin_position_vert="#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);";// eslint-disable-line
  var position_vert="#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n";// eslint-disable-line
  var color_vert="#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n";// eslint-disable-line
  var normal_vert="#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nv_normal=normalize(mat3(u_normalMat)*normal);\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#endif\n#endif\n#endif\n";// eslint-disable-line
  var skinning_vert="#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n";// eslint-disable-line
  var blendShape_input="#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nuniform mediump sampler2DArray u_blendShapeTexture;uniform ivec3 u_blendShapeTextureInfo;uniform float u_blendShapeWeights[OASIS_BLENDSHAPE_COUNT];\n#else\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;attribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#if defined( OASIS_BLENDSHAPE_NORMAL ) || defined( OASIS_BLENDSHAPE_TANGENT )\n#ifdef OASIS_BLENDSHAPE_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef OASIS_BLENDSHAPE_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\nuniform float u_blendShapeWeights[4];\n#else\nattribute vec3 POSITION_BS4;attribute vec3 POSITION_BS5;attribute vec3 POSITION_BS6;attribute vec3 POSITION_BS7;uniform float u_blendShapeWeights[8];\n#endif\n#endif\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nvec3 getBlendShapeVertexElement(int blendShapeIndex,int vertexElementIndex){int y=vertexElementIndex/u_blendShapeTextureInfo.y;int x=vertexElementIndex-y*u_blendShapeTextureInfo.y;ivec3 uv=ivec3(x,y,blendShapeIndex);return texelFetch(u_blendShapeTexture,uv,0).xyz;}\n#endif\n#endif\n";// eslint-disable-line
  var blendShape_vert="#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nint vertexOffset=gl_VertexID*u_blendShapeTextureInfo.x;for(int i=0;i<OASIS_BLENDSHAPE_COUNT;i++){int vertexElementOffset=vertexOffset;float weight=u_blendShapeWeights[i];position.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#ifndef OMIT_NORMAL\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nvertexElementOffset+=1;normal+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#if defined( O3_HAS_TANGENT ) && defined(OASIS_BLENDSHAPE_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvertexElementOffset+=1;tangent.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#endif\n}\n#else\nposition.xyz+=POSITION_BS0*u_blendShapeWeights[0];position.xyz+=POSITION_BS1*u_blendShapeWeights[1];position.xyz+=POSITION_BS2*u_blendShapeWeights[2];position.xyz+=POSITION_BS3*u_blendShapeWeights[3];\n#if defined( OASIS_BLENDSHAPE_NORMAL ) || defined( OASIS_BLENDSHAPE_TANGENT )\n#ifndef OMIT_NORMAL\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nnormal+=NORMAL_BS0*u_blendShapeWeights[0];normal+=NORMAL_BS1*u_blendShapeWeights[1];normal+=NORMAL_BS2*u_blendShapeWeights[2];normal+=NORMAL_BS3*u_blendShapeWeights[3];\n#endif\n#if defined( O3_HAS_TANGENT ) && defined(OASIS_BLENDSHAPE_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\ntangent.xyz+=TANGENT_BS0*u_blendShapeWeights[0];tangent.xyz+=TANGENT_BS1*u_blendShapeWeights[1];tangent.xyz+=TANGENT_BS2*u_blendShapeWeights[2];tangent.xyz+=TANGENT_BS3*u_blendShapeWeights[3];\n#endif\n#endif\n#else\nposition.xyz+=POSITION_BS4*u_blendShapeWeights[4];position.xyz+=POSITION_BS5*u_blendShapeWeights[5];position.xyz+=POSITION_BS6*u_blendShapeWeights[6];position.xyz+=POSITION_BS7*u_blendShapeWeights[7];\n#endif\n#endif\n#endif\n";// eslint-disable-line
  var uv_vert="#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef O3_HAS_UV1\nv_uv1=TEXCOORD_1;\n#endif\n#ifdef O3_NEED_TILINGOFFSET\nv_uv=v_uv*u_tilingOffset.xy+u_tilingOffset.zw;\n#endif\n";// eslint-disable-line
  var worldpos_vert="#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n";// eslint-disable-line
  var shadow_vert="#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n";// eslint-disable-line
  var fog_vert="#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n";// eslint-disable-line
  var light_frag_define="#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngleCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];\n#endif\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_SH\nuniform vec3 u_env_sh[9];\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n";// eslint-disable-line
  var mobile_material_frag="#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_baseColor;uniform vec4 u_specularColor;uniform float u_shininess;uniform float u_normalIntensity;uniform float u_alphaCutoff;\n#ifdef EMISSIVETEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n#ifdef NORMALTEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n";// eslint-disable-line
  var fog_frag="#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n";// eslint-disable-line
  var begin_mobile_frag="#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_baseColor;vec4 specular=u_specularColor;\n#ifdef EMISSIVETEXTURE\nvec4 emissiveTextureColor=texture2D(u_emissiveTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nemissiveTextureColor=gammaToLinear(emissiveTextureColor);\n#endif\nemission*=emissiveTextureColor;\n#endif\n#ifdef BASETEXTURE\nvec4 diffuseTextureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\ndiffuseTextureColor=gammaToLinear(diffuseTextureColor);\n#endif\ndiffuse*=diffuseTextureColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nvec4 specularTextureColor=texture2D(u_specularTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nspecularTextureColor=gammaToLinear(specularTextureColor);\n#endif\nspecular*=specularTextureColor;\n#endif\nambient=vec4(u_envMapLight.diffuse*u_envMapLight.diffuseIntensity,1.0)*diffuse;";// eslint-disable-line
  var begin_viewdir_frag="#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n";// eslint-disable-line
  var mobile_blinnphong_frag="#define GLSLIFY 1\n#ifdef NORMALTEXTURE\nmat3 tbn=getTBN();vec3 N=getNormalByNormalTexture(tbn,u_normalTexture,u_normalIntensity,v_uv);\n#else\nvec3 N=getNormal();\n#endif\nvec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef ALPHA_CUTOFF\nif(diffuse.a<u_alphaCutoff){discard;}\n#endif\n";// eslint-disable-line
  var noise_common="#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n";// eslint-disable-line
  var noise_cellular_2D="#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}";// eslint-disable-line
  var noise_cellular_2x2="#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}";// eslint-disable-line
  var noise_cellular_2x2x2="#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}";// eslint-disable-line
  var noise_cellular_3D="#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}";// eslint-disable-line
  var noise_cellular="#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";// eslint-disable-line
  var noise_perlin_2D="#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}";// eslint-disable-line
  var noise_perlin_3D="#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";// eslint-disable-line
  var noise_perlin_4D="#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}";// eslint-disable-line
  var noise_perlin="#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";// eslint-disable-line
  var noise_psrd_2D="#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}";// eslint-disable-line
  var noise_simplex_2D="#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}";// eslint-disable-line
  var noise_simplex_3D_grad="#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}";// eslint-disable-line
  var noise_simplex_3D="#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";// eslint-disable-line
  var noise_simplex_4D="#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}";// eslint-disable-line
  var noise_simplex="#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";// eslint-disable-line
  var pbr_frag_define="#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_PBRSpecularColor;uniform float u_glossiness;uniform vec3 u_emissiveColor;\n#ifdef CLEARCOAT\nuniform float u_clearCoat;uniform float u_clearCoatRoughness;\n#endif\nuniform float u_normalIntensity;uniform float u_occlusionIntensity;uniform float u_occlusionTextureCoord;\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\n#ifdef NORMALTEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef EMISSIVETEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef ROUGHNESSMETALLICTEXTURE\nuniform sampler2D u_roughnessMetallicTexture;\n#endif\n#ifdef SPECULARGLOSSINESSTEXTURE\nuniform sampler2D u_specularGlossinessTexture;\n#endif\n#ifdef OCCLUSIONTEXTURE\nuniform sampler2D u_occlusionTexture;\n#endif\n#ifdef HAS_CLEARCOATTEXTURE\nuniform sampler2D u_clearCoatTexture;\n#endif\n#ifdef HAS_CLEARCOATROUGHNESSTEXTURE\nuniform sampler2D u_clearCoatRoughnessTexture;\n#endif\n#ifdef HAS_CLEARCOATNORMALTEXTURE\nuniform sampler2D u_clearCoatNormalTexture;\n#endif\nstruct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct Geometry{vec3 position;vec3 normal;vec3 viewDir;float dotNV;\n#ifdef CLEARCOAT\nvec3 clearCoatNormal;float clearCoatDotNV;\n#endif\n};struct Material{vec3 diffuseColor;float roughness;vec3 specularColor;float opacity;\n#ifdef CLEARCOAT\nfloat clearCoat;float clearCoatRoughness;\n#endif\n};";// eslint-disable-line
  var pbr_helper="#define GLSLIFY 1\n#include <normal_get>\nfloat computeSpecularOcclusion(float ambientOcclusion,float roughness,float dotNV){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}float getAARoughnessFactor(vec3 normal){\n#ifdef HAS_DERIVATIVES\nvec3 dxy=max(abs(dFdx(normal)),abs(dFdy(normal)));return 0.04+max(max(dxy.x,dxy.y),dxy.z);\n#else\nreturn 0.04;\n#endif\n}void initGeometry(out Geometry geometry){geometry.position=v_pos;geometry.viewDir=normalize(u_cameraPos-v_pos);\n#if defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE)\nmat3 tbn=getTBN();\n#endif\n#ifdef NORMALTEXTURE\ngeometry.normal=getNormalByNormalTexture(tbn,u_normalTexture,u_normalIntensity,v_uv);\n#else\ngeometry.normal=getNormal();\n#endif\ngeometry.dotNV=saturate(dot(geometry.normal,geometry.viewDir));\n#ifdef CLEARCOAT\n#ifdef HAS_CLEARCOATNORMALTEXTURE\ngeometry.clearCoatNormal=getNormalByNormalTexture(tbn,u_clearCoatNormalTexture,u_normalIntensity,v_uv);\n#else\ngeometry.clearCoatNormal=getNormal();\n#endif\ngeometry.clearCoatDotNV=saturate(dot(geometry.clearCoatNormal,geometry.viewDir));\n#endif\n}void initMaterial(out Material material,const in Geometry geometry){vec4 baseColor=u_baseColor;float metal=u_metal;float roughness=u_roughness;vec3 specularColor=u_PBRSpecularColor;float glossiness=u_glossiness;float alphaCutoff=u_alphaCutoff;\n#ifdef BASETEXTURE\nvec4 baseTextureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nbaseTextureColor=gammaToLinear(baseTextureColor);\n#endif\nbaseColor*=baseTextureColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nbaseColor*=v_color;\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<alphaCutoff){discard;}\n#endif\n#ifdef ROUGHNESSMETALLICTEXTURE\nvec4 metalRoughMapColor=texture2D(u_roughnessMetallicTexture,v_uv);roughness*=metalRoughMapColor.g;metal*=metalRoughMapColor.b;\n#endif\n#ifdef SPECULARGLOSSINESSTEXTURE\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nspecularGlossinessColor=gammaToLinear(specularGlossinessColor);\n#endif\nspecularColor*=specularGlossinessColor.rgb;glossiness*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=baseColor.rgb*(1.0-metal);material.specularColor=mix(vec3(0.04),baseColor.rgb,metal);material.roughness=roughness;\n#else\nfloat specularStrength=max(max(specularColor.r,specularColor.g),specularColor.b);material.diffuseColor=baseColor.rgb*(1.0-specularStrength);material.specularColor=specularColor;material.roughness=1.0-glossiness;\n#endif\nmaterial.roughness=max(material.roughness,getAARoughnessFactor(geometry.normal));\n#ifdef CLEARCOAT\nmaterial.clearCoat=u_clearCoat;material.clearCoatRoughness=u_clearCoatRoughness;\n#ifdef HAS_CLEARCOATTEXTURE\nmaterial.clearCoat*=texture2D(u_clearCoatTexture,v_uv).r;\n#endif\n#ifdef HAS_CLEARCOATROUGHNESSTEXTURE\nmaterial.clearCoatRoughness*=texture2D(u_clearCoatRoughnessTexture,v_uv).g;\n#endif\nmaterial.clearCoat=saturate(material.clearCoat);material.clearCoatRoughness=max(material.clearCoatRoughness,getAARoughnessFactor(geometry.clearCoatNormal));\n#endif\nmaterial.opacity=baseColor.a;}\n#include <brdf>\n#include <direct_irradiance_frag_define>\n#include <ibl_frag_define>\n";// eslint-disable-line
  var brdf="#define GLSLIFY 1\nfloat F_Schlick(float dotLH){return 0.04+0.96*(pow(1.0-dotLH,5.0));}vec3 F_Schlick(vec3 specularColor,float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(float alpha,float dotNL,float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(float alpha,float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(vec3 incidentDirection,vec3 viewDir,vec3 normal,vec3 specularColor,float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentDirection+viewDir);float dotNL=saturate(dot(normal,incidentDirection));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotLH=saturate(dot(incidentDirection,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}vec3 BRDF_Diffuse_Lambert(vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}";// eslint-disable-line
  var direct_irradiance_frag_define="#define GLSLIFY 1\nvoid addDirectRadiance(vec3 incidentDirection,vec3 color,Geometry geometry,Material material,inout ReflectedLight reflectedLight){float attenuation=1.0;\n#ifdef CLEARCOAT\nfloat clearCoatDotNL=saturate(dot(geometry.clearCoatNormal,incidentDirection));vec3 clearCoatIrradiance=clearCoatDotNL*color;reflectedLight.directSpecular+=material.clearCoat*clearCoatIrradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.clearCoatNormal,vec3(0.04),material.clearCoatRoughness);attenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nfloat dotNL=saturate(dot(geometry.normal,incidentDirection));vec3 irradiance=dotNL*color*PI;reflectedLight.directSpecular+=attenuation*irradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.normal,material.specularColor,material.roughness);reflectedLight.directDiffuse+=attenuation*irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid addDirectionalDirectLightRadiance(DirectLight directionalLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 color=directionalLight.color;vec3 direction=-directionalLight.direction;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid addPointDirectLightRadiance(PointLight pointLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=pointLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);vec3 color=pointLight.color;color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid addSpotDirectLightRadiance(SpotLight spotLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=spotLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);vec3 color=spotLight.color;color*=spotEffect*decayEffect;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\nvoid addTotalDirectRadiance(Geometry geometry,Material material,inout ReflectedLight reflectedLight){\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];addDirectionalDirectLightRadiance(directionalLight,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];addPointDirectLightRadiance(pointLight,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];addSpotDirectLightRadiance(spotLight,geometry,material,reflectedLight);}\n#endif\n}";// eslint-disable-line
  var ibl_frag_define="#define GLSLIFY 1\nvec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){normal.x=-normal.x;vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}vec3 envBRDFApprox(vec3 specularColor,float roughness,float dotNV){const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(float roughness,int maxMIPLevel){return roughness*float(maxMIPLevel);}vec3 getLightProbeRadiance(vec3 viewDir,vec3 normal,float roughness,int maxMIPLevel,float specularIntensity){\n#ifndef O3_USE_SPECULAR_ENV\nreturn vec3(0);\n#else\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec.x=-reflectVec.x;float specularMIPLevel=getSpecularMIPLevel(roughness,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\n#ifdef O3_DECODE_ENV_RGBM\nenvMapColor.rgb=RGBMToLinear(envMapColor,5.0).rgb;\n#ifdef OASIS_COLORSPACE_GAMMA\nenvMapColor=linearToGamma(envMapColor);\n#endif\n#else\n#ifndef OASIS_COLORSPACE_GAMMA\nenvMapColor=gammaToLinear(envMapColor);\n#endif\n#endif\nreturn envMapColor.rgb*specularIntensity;\n#endif\n}";// eslint-disable-line
  var pbr_frag="#define GLSLIFY 1\nGeometry geometry;Material material;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));initGeometry(geometry);initMaterial(material,geometry);addTotalDirectRadiance(geometry,material,reflectedLight);\n#ifdef O3_USE_SH\nvec3 irradiance=getLightProbeIrradiance(u_env_sh,geometry.normal);\n#ifdef OASIS_COLORSPACE_GAMMA\nirradiance=linearToGamma(vec4(irradiance,1.0)).rgb;\n#endif\nirradiance*=u_envMapLight.diffuseIntensity;\n#else\nvec3 irradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;irradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);vec3 radiance=getLightProbeRadiance(geometry.viewDir,geometry.normal,material.roughness,int(u_envMapLight.mipMapLevel),u_envMapLight.specularIntensity);float radianceAttenuation=1.0;\n#ifdef CLEARCOAT\nvec3 clearCoatRadiance=getLightProbeRadiance(geometry.viewDir,geometry.clearCoatNormal,material.clearCoatRoughness,int(u_envMapLight.mipMapLevel),u_envMapLight.specularIntensity);reflectedLight.indirectSpecular+=clearCoatRadiance*material.clearCoat*envBRDFApprox(vec3(0.04),material.clearCoatRoughness,geometry.clearCoatDotNV);radianceAttenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nreflectedLight.indirectSpecular+=radianceAttenuation*radiance*envBRDFApprox(material.specularColor,material.roughness,geometry.dotNV);\n#ifdef OCCLUSIONTEXTURE\nvec2 aoUV=v_uv;\n#ifdef O3_HAS_UV1\nif(u_occlusionTextureCoord==1.0){aoUV=v_uv1;}\n#endif\nfloat ambientOcclusion=(texture2D(u_occlusionTexture,aoUV).r-1.0)*u_occlusionIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#ifdef O3_USE_SPECULAR_ENV\nreflectedLight.indirectSpecular*=computeSpecularOcclusion(ambientOcclusion,material.roughness,geometry.dotNV);\n#endif\n#endif\nvec3 emissiveRadiance=u_emissiveColor;\n#ifdef EMISSIVETEXTURE\nvec4 emissiveColor=texture2D(u_emissiveTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nemissiveColor=gammaToLinear(emissiveColor);\n#endif\nemissiveRadiance*=emissiveColor.rgb;\n#endif\nvec3 totalRadiance=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+emissiveRadiance;vec4 targetColor=vec4(totalRadiance,material.opacity);\n#ifndef OASIS_COLORSPACE_GAMMA\ntargetColor=linearToGamma(targetColor);\n#endif\ngl_FragColor=targetColor;";// eslint-disable-line
  var PBRShaderLib={pbr_frag_define:pbr_frag_define,pbr_helper:pbr_helper,brdf:brdf,direct_irradiance_frag_define:direct_irradiance_frag_define,ibl_frag_define:ibl_frag_define,pbr_frag:pbr_frag};var normal_get="#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_HAS_NORMAL\nvec3 normal=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 normal=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 normal=vec3(0,0,1);\n#endif\nnormal*=float(gl_FrontFacing)*2.0-1.0;return normal;}vec3 getNormalByNormalTexture(mat3 tbn,sampler2D normalTexture,float normalIntensity,vec2 uv){vec3 normal=texture2D(normalTexture,uv).rgb;normal=normalize(tbn*((2.0*normal-1.0)*vec3(normalIntensity,normalIntensity,1.0)));normal*=float(gl_FrontFacing)*2.0-1.0;return normal;}mat3 getTBN(){\n#if defined(O3_HAS_NORMAL) && defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nmat3 tbn=v_TBN;\n#else\nvec3 normal=getNormal();vec3 position=v_pos;vec2 uv=gl_FrontFacing? v_uv:-v_uv;\n#ifdef HAS_DERIVATIVES\nvec3 dp1=dFdx(position);vec3 dp2=dFdy(position);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));mat3 tbn=mat3(tangent*invmax,binormal*invmax,normal);\n#else\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),normal);\n#endif\n#endif\nreturn tbn;}";// eslint-disable-line
  var ShaderLib=_objectSpread2$2(_objectSpread2$2({common:common,common_vert:common_vert,common_frag:common_frag,color_share:color_share,normal_share:normal_share,uv_share:uv_share,worldpos_share:worldpos_share,shadow_share:shadow_share,fog_share:fog_share,begin_normal_vert:begin_normal_vert,begin_position_vert:begin_position_vert,position_vert:position_vert,color_vert:color_vert,normal_vert:normal_vert,skinning_vert:skinning_vert,blendShape_input:blendShape_input,blendShape_vert:blendShape_vert,uv_vert:uv_vert,worldpos_vert:worldpos_vert,shadow_vert:shadow_vert,fog_vert:fog_vert,light_frag_define:light_frag_define,mobile_material_frag:mobile_material_frag,fog_frag:fog_frag,begin_mobile_frag:begin_mobile_frag,begin_viewdir_frag:begin_viewdir_frag,mobile_blinnphong_frag:mobile_blinnphong_frag,noise_common:noise_common,noise_cellular_2D:noise_cellular_2D,noise_cellular_2x2:noise_cellular_2x2,noise_cellular_2x2x2:noise_cellular_2x2x2,noise_cellular_3D:noise_cellular_3D,noise_cellular:noise_cellular,noise_perlin_2D:noise_perlin_2D,noise_perlin_3D:noise_perlin_3D,noise_perlin_4D:noise_perlin_4D,noise_perlin:noise_perlin,noise_psrd_2D:noise_psrd_2D,noise_simplex_2D:noise_simplex_2D,noise_simplex_3D_grad:noise_simplex_3D_grad,noise_simplex_3D:noise_simplex_3D,noise_simplex_4D:noise_simplex_4D,noise_simplex:noise_simplex},PBRShaderLib),{},{normal_get:normal_get});var ShaderFactory=/*#__PURE__*/function(){function ShaderFactory(){}ShaderFactory.parseCustomMacros=function parseCustomMacros(macros){return macros.map(function(m){return "#define "+m+"\n";}).join("");};ShaderFactory.parseIncludes=function parseIncludes(src){var regex=/^[ \t]*#include +<([\w\d.]+)>/gm;function replace(match,slice){var replace=ShaderLib[slice];if(replace===undefined){Logger.error("Shader slice \""+match.trim()+"\" not founded.");return "";}return ShaderFactory.parseIncludes(replace);}return src.replace(regex,replace);}/**
     * GLSL extension.
     * @param extensions - such as ["GL_EXT_shader_texture_lod"]
     * */;ShaderFactory.parseExtension=function parseExtension(extensions){return extensions.map(function(e){return "#extension "+e+" : enable\n";}).join("");}/**
     * Convert lower GLSL version to GLSL 300 es.
     * @param shader - code
     * @param isFrag - Whether it is a fragment shader.
     * */;ShaderFactory.convertTo300=function convertTo300(shader,isFrag){/** replace attribute and in */shader=shader.replace(/\battribute\b/g,"in");shader=shader.replace(/\bvarying\b/g,isFrag?"in":"out");/** replace api */shader=shader.replace(/\btexture(2D|Cube)\b/g,"texture");shader=shader.replace(/\btexture(2D|Cube)LodEXT\b/g,"textureLod");if(isFrag){var isMRT=/\bgl_FragData\[.+?\]/g.test(shader);if(isMRT){shader=shader.replace(/\bgl_FragColor\b/g,"gl_FragData[0]");var result=shader.match(/\bgl_FragData\[.+?\]/g);shader=this._replaceMRTShader(shader,result);}else {shader=shader.replace(/void\s+?main\s*\(/g,"out vec4 glFragColor;\nvoid main(");shader=shader.replace(/\bgl_FragColor\b/g,"glFragColor");}}return shader;};ShaderFactory._replaceMRTShader=function _replaceMRTShader(shader,result){var declaration="";var mrtIndexSet=new Set();for(var i=0;i<result.length;i++){var res=result[i].match(/\bgl_FragData\[(.+?)\]/);mrtIndexSet.add(res[1]);}mrtIndexSet.forEach(function(index){declaration+="layout(location="+index+") out vec4 fragOutColor"+index+";\n";});declaration+="void main(";shader=shader.replace(/\bgl_FragData\[(.+?)\]/g,"fragOutColor$1");shader=shader.replace(/void\s+?main\s*\(/g,declaration);return shader;};return ShaderFactory;}();/**
   * Shader macroã€‚
   */var ShaderMacro=/** @internal */ /** Name. */ /** Value. */ /** @internal */ /** @internal */ /** @internal */ /**
   * @internal
   */function ShaderMacro(name,value,maskIndex,maskValue){this.name=void 0;this.value=void 0;this._nameId=void 0;this._maskIndex=void 0;this._maskValue=void 0;this.name=name;this._maskIndex=maskIndex;this._maskValue=maskValue;this.value=value;var macroNameIDMap=ShaderMacro._macroNameIdMap;var nameID=macroNameIDMap[name];if(macroNameIDMap[name]===undefined){macroNameIDMap[name]=nameID=ShaderMacro._macroNameCounter++;}this._nameId=nameID;};ShaderMacro._macroNameIdMap=Object.create(null);ShaderMacro._macroNameCounter=0;/**
   * Color Space.
   */exports.ColorSpace = void 0;(function(ColorSpace){ColorSpace[ColorSpace["Linear"]=0]="Linear";ColorSpace[ColorSpace["Gamma"]=1]="Gamma";})(exports.ColorSpace||(exports.ColorSpace={}));/**
   * Shader uniformã€‚
   * @internal
   */var ShaderUniform=/*#__PURE__*/function(){function ShaderUniform(engine){this.name=void 0;this.propertyId=void 0;this.location=void 0;this.applyFunc=void 0;this.cacheValue=void 0;this.textureIndex=void 0;this.textureDefault=void 0;this._rhi=void 0;this._gl=void 0;this._colorSpace=void 0;var rhi=engine._hardwareRenderer;this._rhi=rhi;this._gl=rhi.gl;this._colorSpace=engine.settings.colorSpace;}var _proto=ShaderUniform.prototype;_proto.upload1f=function upload1f(shaderUniform,value){if(this.cacheValue!==value){this._gl.uniform1f(shaderUniform.location,value);this.cacheValue=value;}};_proto.upload1fv=function upload1fv(shaderUniform,value){this._gl.uniform1fv(shaderUniform.location,value);};_proto.upload2f=function upload2f(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g){if(this._colorSpace===exports.ColorSpace.Linear){this._gl.uniform2f(shaderUniform.location,Color.gammaToLinearSpace(value.r),Color.gammaToLinearSpace(value.g));}else {this._gl.uniform2f(shaderUniform.location,value.r,value.g);}cacheValue.x=value.r;cacheValue.y=value.g;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y){this._gl.uniform2f(shaderUniform.location,value.x,value.y);cacheValue.x=value.x;cacheValue.y=value.y;}}};_proto.upload2fv=function upload2fv(shaderUniform,value){this._gl.uniform2fv(shaderUniform.location,value);};_proto.upload3f=function upload3f(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b){if(this._colorSpace===exports.ColorSpace.Linear){this._gl.uniform3f(shaderUniform.location,Color.gammaToLinearSpace(value.r),Color.gammaToLinearSpace(value.g),Color.gammaToLinearSpace(value.b));}else {this._gl.uniform3f(shaderUniform.location,value.r,value.g,value.b);}cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z){this._gl.uniform3f(shaderUniform.location,value.x,value.y,value.z);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;}}};_proto.upload3fv=function upload3fv(shaderUniform,value){this._gl.uniform3fv(shaderUniform.location,value);};_proto.upload4f=function upload4f(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b||cacheValue.w!==value.a){if(this._colorSpace===exports.ColorSpace.Linear){this._gl.uniform4f(shaderUniform.location,Color.gammaToLinearSpace(value.r),Color.gammaToLinearSpace(value.g),Color.gammaToLinearSpace(value.b),value.a);}else {this._gl.uniform4f(shaderUniform.location,value.r,value.g,value.b,value.a);}cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;cacheValue.w=value.a;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z||cacheValue.w!==value.w){this._gl.uniform4f(shaderUniform.location,value.x,value.y,value.z,value.w);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;cacheValue.w=value.w;}}};_proto.upload4fv=function upload4fv(shaderUniform,value){this._gl.uniform4fv(shaderUniform.location,value);};_proto.upload1i=function upload1i(shaderUniform,value){if(this.cacheValue!==value){this._gl.uniform1i(shaderUniform.location,value);this.cacheValue=value;}};_proto.upload1iv=function upload1iv(shaderUniform,value){this._gl.uniform1iv(shaderUniform.location,value);};_proto.upload2i=function upload2i(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g){this._gl.uniform2i(shaderUniform.location,value.r,value.g);cacheValue.x=value.r;cacheValue.y=value.g;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y){this._gl.uniform2i(shaderUniform.location,value.x,value.y);cacheValue.x=value.x;cacheValue.y=value.y;}}};_proto.upload2iv=function upload2iv(shaderUniform,value){this._gl.uniform2iv(shaderUniform.location,value);};_proto.upload3i=function upload3i(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b){this._gl.uniform3i(shaderUniform.location,value.r,value.g,value.b);cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z){this._gl.uniform3i(shaderUniform.location,value.x,value.y,value.z);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;}}};_proto.upload3iv=function upload3iv(shaderUniform,value){this._gl.uniform3iv(shaderUniform.location,value);};_proto.upload4i=function upload4i(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b||cacheValue.w!==value.a){this._gl.uniform4i(shaderUniform.location,value.r,value.g,value.b,value.a);cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;cacheValue.w=value.a;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z||cacheValue.w!==value.w){this._gl.uniform4i(shaderUniform.location,value.x,value.y,value.z,value.w);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;cacheValue.w=value.w;}}};_proto.upload4iv=function upload4iv(shaderUniform,value){this._gl.uniform4iv(shaderUniform.location,value);};_proto.uploadMat4=function uploadMat4(shaderUniform,value){this._gl.uniformMatrix4fv(shaderUniform.location,false,value.elements);};_proto.uploadMat4v=function uploadMat4v(shaderUniform,value){this._gl.uniformMatrix4fv(shaderUniform.location,false,value);};_proto.uploadTexture=function uploadTexture(shaderUniform,value){var rhi=this._rhi;rhi.activeTexture(shaderUniform.textureIndex);rhi.bindTexture(value._platformTexture);};_proto.uploadTextureArray=function uploadTextureArray(shaderUniform,value){var rhi=this._rhi;var textureIndices=shaderUniform.textureIndex;for(var i=0;i<value.length;i++){var texture=value[i];rhi.activeTexture(textureIndices[i]);rhi.bindTexture(texture._platformTexture);}};return ShaderUniform;}();/**
   * Shader uniform block.
   * @internal
   */var ShaderUniformBlock=function ShaderUniformBlock(){this.constUniforms=[];this.textureUniforms=[];};/**
   * Shader program, corresponding to the GPU shader program.
   * @internal
   */var ShaderProgram=/*#__PURE__*/function(){ShaderProgram._addLineNum=function _addLineNum(str){var lines=str.split("\n");var limitLength=(lines.length+1).toString().length+6;var prefix;return lines.map(function(line,index){prefix="0:"+(index+1);if(prefix.length>=limitLength)return prefix.substring(0,limitLength)+line;for(var i=0;i<limitLength-prefix.length;i++){prefix+=" ";}return prefix+line;}).join("\n");};function ShaderProgram(engine,vertexSource,fragmentSource){this.id=void 0;this.sceneUniformBlock=new ShaderUniformBlock();this.cameraUniformBlock=new ShaderUniformBlock();this.rendererUniformBlock=new ShaderUniformBlock();this.materialUniformBlock=new ShaderUniformBlock();this.otherUniformBlock=new ShaderUniformBlock();this._uploadRenderCount=-1;this._uploadCamera=void 0;this._uploadRenderer=void 0;this._uploadMaterial=void 0;this.attributeLocation=Object.create(null);this._isValid=void 0;this._engine=void 0;this._gl=void 0;this._vertexShader=void 0;this._fragmentShader=void 0;this._glProgram=void 0;this._activeTextureUint=0;this._engine=engine;this._gl=engine._hardwareRenderer.gl;this._glProgram=this._createProgram(vertexSource,fragmentSource);if(this._glProgram){this._isValid=true;this._recordLocation();}else {this._isValid=false;}this.id=ShaderProgram._counter++;}/**
     * Upload all shader data in shader uniform block.
     * @param uniformBlock - shader Uniform block
     * @param shaderData - shader data
     */var _proto=ShaderProgram.prototype;_proto.uploadAll=function uploadAll(uniformBlock,shaderData){this.uploadUniforms(uniformBlock,shaderData);this.uploadTextures(uniformBlock,shaderData);}/**
     * Upload constant shader data in shader uniform block.
     * @param uniformBlock - shader Uniform block
     * @param shaderData - shader data
     */;_proto.uploadUniforms=function uploadUniforms(uniformBlock,shaderData){var propertyValueMap=shaderData._propertyValueMap;var constUniforms=uniformBlock.constUniforms;for(var i=0,n=constUniforms.length;i<n;i++){var uniform=constUniforms[i];var data=propertyValueMap[uniform.propertyId];data!=null&&uniform.applyFunc(uniform,data);}}/**
     * Upload texture shader data in shader uniform block.
     * @param uniformBlock - shader Uniform block
     * @param shaderData - shader data
     */;_proto.uploadTextures=function uploadTextures(uniformBlock,shaderData){var propertyValueMap=shaderData._propertyValueMap;var textureUniforms=uniformBlock.textureUniforms;// textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
  if(textureUniforms){for(var i=0,n=textureUniforms.length;i<n;i++){var uniform=textureUniforms[i];var texture=propertyValueMap[uniform.propertyId];if(texture&&!texture.destroyed){uniform.applyFunc(uniform,texture);}else {uniform.applyFunc(uniform,uniform.textureDefault);}}}}/**
     * Upload ungroup texture shader data in shader uniform block.
     */;_proto.uploadUnGroupTextures=function uploadUnGroupTextures(){var textureUniforms=this.otherUniformBlock.textureUniforms;// textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
  if(textureUniforms){for(var i=0,n=textureUniforms.length;i<n;i++){var uniform=textureUniforms[i];uniform.applyFunc(uniform,uniform.textureDefault);}}}/**
     * Grouping other data.
     */;_proto.groupingOtherUniformBlock=function groupingOtherUniformBlock(){var _this$otherUniformBlo=this.otherUniformBlock,constUniforms=_this$otherUniformBlo.constUniforms,textureUniforms=_this$otherUniformBlo.textureUniforms;constUniforms.length>0&&this._groupingSubOtherUniforms(constUniforms,false);textureUniforms.length>0&&this._groupingSubOtherUniforms(textureUniforms,true);}/**
     * Bind this shader program.
     * @returns Whether the shader program is switched.
     */;_proto.bind=function bind(){var rhi=this._engine._hardwareRenderer;if(rhi._currentBind!==this){this._gl.useProgram(this._glProgram);rhi._currentBind=this;return true;}else {return false;}}/**
     * Destroy this shader program.
     */;_proto.destroy=function destroy(){var gl=this._gl;this._vertexShader&&gl.deleteShader(this._vertexShader);this._fragmentShader&&gl.deleteShader(this._fragmentShader);this._glProgram&&gl.deleteProgram(this._glProgram);};_proto._groupingSubOtherUniforms=function _groupingSubOtherUniforms(uniforms,isTexture){for(var i=uniforms.length-1;i>=0;i--){var uniform=uniforms[i];var group=Shader._getShaderPropertyGroup(uniform.name);if(group!==undefined){uniforms.splice(uniforms.indexOf(uniform),1);this._groupingUniform(uniform,group,isTexture);}}};_proto._groupingUniform=function _groupingUniform(uniform,group,isTexture){switch(group){case ShaderDataGroup.Scene:if(isTexture){this.sceneUniformBlock.textureUniforms.push(uniform);}else {this.sceneUniformBlock.constUniforms.push(uniform);}break;case ShaderDataGroup.Camera:if(isTexture){this.cameraUniformBlock.textureUniforms.push(uniform);}else {this.cameraUniformBlock.constUniforms.push(uniform);}break;case ShaderDataGroup.Renderer:if(isTexture){this.rendererUniformBlock.textureUniforms.push(uniform);}else {this.rendererUniformBlock.constUniforms.push(uniform);}break;case ShaderDataGroup.Material:if(isTexture){this.materialUniformBlock.textureUniforms.push(uniform);}else {this.materialUniformBlock.constUniforms.push(uniform);}break;default:if(isTexture){this.otherUniformBlock.textureUniforms.push(uniform);}else {this.otherUniformBlock.constUniforms.push(uniform);}}}/**
     * init and link program with shader.
     */;_proto._createProgram=function _createProgram(vertexSource,fragmentSource){var gl=this._gl;// create and compile shader
  var vertexShader=this._createShader(gl.VERTEX_SHADER,vertexSource);if(!vertexShader){return null;}var fragmentShader=this._createShader(gl.FRAGMENT_SHADER,fragmentSource);if(!fragmentShader){return null;}// link program and shader
  var program=gl.createProgram();gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);gl.validateProgram(program);if(gl.isContextLost()){Logger.error("Context lost while linking program.");gl.deleteShader(vertexShader);gl.deleteShader(fragmentShader);return null;}if(Logger.isEnabled&&!gl.getProgramParameter(program,gl.LINK_STATUS)){Logger.error("Could not link WebGL program. \n"+gl.getProgramInfoLog(program));gl.deleteProgram(program);return null;}this._vertexShader=vertexShader;this._fragmentShader=fragmentShader;return program;};_proto._createShader=function _createShader(shaderType,shaderSource){var gl=this._gl;var shader=gl.createShader(shaderType);if(!shader){Logger.error("Context lost while create shader.");return null;}gl.shaderSource(shader,shaderSource);gl.compileShader(shader);if(gl.isContextLost()){Logger.error("Context lost while compiling shader.");gl.deleteShader(shader);return null;}if(Logger.isEnabled&&!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){Logger.error("Could not compile WebGL shader.\n"+gl.getShaderInfoLog(shader),ShaderProgram._addLineNum(shaderSource));gl.deleteShader(shader);return null;}return shader;}/**
     * record the location of uniform/attribute.
     */;_proto._recordLocation=function _recordLocation(){var _this=this;var gl=this._gl;var program=this._glProgram;var uniformInfos=this._getUniformInfos();var attributeInfos=this._getAttributeInfos();uniformInfos.forEach(function(_ref){var name=_ref.name,size=_ref.size,type=_ref.type;var shaderUniform=new ShaderUniform(_this._engine);var isArray=false;var isTexture=false;if(name.indexOf("[0]")>0){name=name.substr(0,name.length-3);isArray=true;}var location=gl.getUniformLocation(program,name);shaderUniform.name=name;shaderUniform.propertyId=Shader.getPropertyByName(name)._uniqueId;shaderUniform.location=location;switch(type){case gl.FLOAT:if(isArray){shaderUniform.applyFunc=shaderUniform.upload1fv;}else {shaderUniform.applyFunc=shaderUniform.upload1f;shaderUniform.cacheValue=0;}break;case gl.FLOAT_VEC2:if(isArray){shaderUniform.applyFunc=shaderUniform.upload2fv;}else {shaderUniform.applyFunc=shaderUniform.upload2f;shaderUniform.cacheValue=new Vector2(0,0);}break;case gl.FLOAT_VEC3:if(isArray){shaderUniform.applyFunc=shaderUniform.upload3fv;}else {shaderUniform.applyFunc=shaderUniform.upload3f;shaderUniform.cacheValue=new Vector3(0,0,0);}break;case gl.FLOAT_VEC4:if(isArray){shaderUniform.applyFunc=shaderUniform.upload4fv;}else {shaderUniform.applyFunc=shaderUniform.upload4f;shaderUniform.cacheValue=new Vector4(0,0,0,0);}break;case gl.BOOL:case gl.INT:if(isArray){shaderUniform.applyFunc=shaderUniform.upload1iv;}else {shaderUniform.applyFunc=shaderUniform.upload1i;shaderUniform.cacheValue=0;}break;case gl.BOOL_VEC2:case gl.INT_VEC2:if(isArray){shaderUniform.applyFunc=shaderUniform.upload2iv;}else {shaderUniform.applyFunc=shaderUniform.upload2i;shaderUniform.cacheValue=new Vector2(0,0);}break;case gl.BOOL_VEC3:case gl.INT_VEC3:shaderUniform.applyFunc=isArray?shaderUniform.upload3iv:shaderUniform.upload3i;shaderUniform.cacheValue=new Vector3(0,0,0);break;case gl.BOOL_VEC4:case gl.INT_VEC4:if(isArray){shaderUniform.applyFunc=shaderUniform.upload4iv;}else {shaderUniform.applyFunc=shaderUniform.upload4i;shaderUniform.cacheValue=new Vector4(0,0,0);}break;case gl.FLOAT_MAT4:shaderUniform.applyFunc=isArray?shaderUniform.uploadMat4v:shaderUniform.uploadMat4;break;case gl.SAMPLER_2D:case gl.SAMPLER_CUBE:case gl.SAMPLER_2D_ARRAY:var defaultTexture;switch(type){case gl.SAMPLER_2D:defaultTexture=_this._engine._magentaTexture2D;break;case gl.SAMPLER_CUBE:defaultTexture=_this._engine._magentaTextureCube;break;case gl.SAMPLER_2D_ARRAY:defaultTexture=_this._engine._magentaTexture2DArray;break;default:throw new Error("Unsupported texture type.");}isTexture=true;if(isArray){var defaultTextures=new Array(size);var textureIndices=new Int32Array(size);var glTextureIndices=new Array(size);for(var i=0;i<size;i++){defaultTextures[i]=defaultTexture;textureIndices[i]=_this._activeTextureUint;glTextureIndices[i]=gl.TEXTURE0+_this._activeTextureUint++;}shaderUniform.textureDefault=defaultTextures;shaderUniform.textureIndex=glTextureIndices;shaderUniform.applyFunc=shaderUniform.uploadTextureArray;_this.bind();gl.uniform1iv(location,textureIndices);shaderUniform.uploadTextureArray(shaderUniform,defaultTextures);}else {var textureIndex=gl.TEXTURE0+_this._activeTextureUint;shaderUniform.textureDefault=defaultTexture;shaderUniform.textureIndex=textureIndex;shaderUniform.applyFunc=shaderUniform.uploadTexture;_this.bind();gl.uniform1i(location,_this._activeTextureUint++);shaderUniform.uploadTexture(shaderUniform,defaultTexture);}break;}var group=Shader._getShaderPropertyGroup(name);_this._groupingUniform(shaderUniform,group,isTexture);});attributeInfos.forEach(function(_ref2){var name=_ref2.name;_this.attributeLocation[name]=gl.getAttribLocation(program,name);});};_proto._getUniformInfos=function _getUniformInfos(){var gl=this._gl;var program=this._glProgram;var uniformInfos=new Array();var uniformCount=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i<uniformCount;++i){var info=gl.getActiveUniform(program,i);uniformInfos[i]=info;}return uniformInfos;};_proto._getAttributeInfos=function _getAttributeInfos(){var gl=this._gl;var program=this._glProgram;var attributeInfos=new Array();var attributeCount=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<attributeCount;++i){var info=gl.getActiveAttrib(program,i);attributeInfos[i]=info;}return attributeInfos;};_createClass$3(ShaderProgram,[{key:"isValid",get:/**
       * Whether this shader program is valid.
       */function get(){return this._isValid;}}]);return ShaderProgram;}();ShaderProgram._counter=0;/**
   * Shader property.
   */var ShaderProperty=/*#__PURE__*/function(){/**
     * @internal
     */function ShaderProperty(name){this._uniqueId=void 0;this._group=void 0;this._type=void 0;this.name=void 0;this.name=name;this._uniqueId=ShaderProperty._propertyNameCounter++;}_createClass$3(ShaderProperty,[{key:"type",get:/** @internal */ /** @internal */ /** @internal */ /** Shader property name. */ /**
       * Shader property type.
       */function get(){return this._type;}}]);return ShaderProperty;}();ShaderProperty._propertyNameCounter=0;/**
   * Shader containing vertex and fragment source.
   */var Shader=/*#__PURE__*/function(){/** @internal */ /** @internal */ /**
     * Create a shader.
     * @param name - Name of the shader
     * @param vertexSource - Vertex source code
     * @param fragmentSource - Fragment source code
     */Shader.create=function create(name,vertexSource,fragmentSource){var shaderMap=Shader._shaderMap;if(shaderMap[name]){throw "Shader named \""+name+"\" already exists.";}return shaderMap[name]=new Shader(name,vertexSource,fragmentSource);}/**
     * Find a shader by name.
     * @param name - Name of the shader
     */;Shader.find=function find(name){return Shader._shaderMap[name];}/**
     * Get shader macro by name.
     * @param name - Name of the shader macro
     * @returns Shader macro
     */;Shader.getMacroByName=function getMacroByName(name,value){var key=value?name+" "+value:name;var macro=Shader._macroMap[key];if(!macro){var maskMap=Shader._macroMaskMap;var counter=Shader._macroCounter;var index=Math.floor(counter/32);var bit=counter%32;macro=new ShaderMacro(name,value,index,1<<bit);Shader._macroMap[key]=macro;if(index==maskMap.length){maskMap.length++;maskMap[index]=new Array(32);}maskMap[index][bit]=key;Shader._macroCounter++;}return macro;}/**
     * Get shader property by name.
     * @param name - Name of the shader property
     * @returns Shader property
     */;Shader.getPropertyByName=function getPropertyByName(name){var propertyNameMap=Shader._propertyNameMap;if(propertyNameMap[name]!=null){return propertyNameMap[name];}else {var property=new ShaderProperty(name);propertyNameMap[name]=property;Shader._propertyIdMap[property._uniqueId]=property;return property;}}/**
     * @internal
     */;Shader._getShaderPropertyGroup=function _getShaderPropertyGroup(propertyName){var shaderProperty=Shader._propertyNameMap[propertyName];return shaderProperty===null||shaderProperty===void 0?void 0:shaderProperty._group;};Shader._getNamesByMacros=function _getNamesByMacros(macros,out){var maskMap=Shader._macroMaskMap;var mask=macros._mask;out.length=0;for(var i=0,n=macros._length;i<n;i++){var subMaskMap=maskMap[i];var subMask=mask[i];var _n=subMask<0?32:Math.floor(Math.log2(subMask))+1;// if is negative must contain 1 << 31.
  for(var j=0;j<_n;j++){if(subMask&1<<j){out.push(subMaskMap[j]);}}}}/** The name of shader. */;function Shader(name,vertexSource,fragmentSource){this.name=void 0;this._shaderId=0;this._vertexSource=void 0;this._fragmentSource=void 0;this._shaderId=Shader._shaderCounter++;this.name=name;this._vertexSource=vertexSource;this._fragmentSource=fragmentSource;}/**
     * Compile shader variant by macro name list.
     *
     * @remarks
     * Usually a shader contains some macros,any combination of macros is called shader variant.
     *
     * @param engine - Engine to which the shader variant belongs
     * @param macros - Macro name list
     * @returns Is the compiled shader variant valid
     */var _proto=Shader.prototype;_proto.compileVariant=function compileVariant(engine,macros){var compileMacros=Shader._compileMacros;compileMacros.clear();for(var i=0,n=macros.length;i<n;i++){compileMacros.enable(Shader.getMacroByName(macros[i]));}return this._getShaderProgram(engine,compileMacros).isValid;}/**
     * @internal
     */;_proto._getShaderProgram=function _getShaderProgram(engine,macroCollection){var shaderProgramPool=engine._getShaderProgramPool(this);var shaderProgram=shaderProgramPool.get(macroCollection);if(shaderProgram){return shaderProgram;}var isWebGL2=engine._hardwareRenderer.isWebGL2;var macroNameList=[];Shader._getNamesByMacros(macroCollection,macroNameList);var macroNameStr=ShaderFactory.parseCustomMacros(macroNameList);var versionStr=isWebGL2?"#version 300 es":"#version 100";var precisionStr="\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n    #else\n      precision mediump float;\n      precision mediump int;\n    #endif\n    ";if(engine._hardwareRenderer.canIUse(exports.GLCapabilityType.shaderTextureLod)){precisionStr+="#define HAS_TEX_LOD\n";}if(engine._hardwareRenderer.canIUse(exports.GLCapabilityType.standardDerivatives)){precisionStr+="#define HAS_DERIVATIVES\n";}var vertexSource=ShaderFactory.parseIncludes(" "+versionStr+"\n        "+precisionStr+"\n        "+macroNameStr+"\n        "+this._vertexSource);var fragmentSource=ShaderFactory.parseIncludes(" "+versionStr+"\n        "+(isWebGL2?"":ShaderFactory.parseExtension(Shader._shaderExtension))+"\n        "+precisionStr+"\n        "+macroNameStr+"\n      "+this._fragmentSource);if(isWebGL2){vertexSource=ShaderFactory.convertTo300(vertexSource);fragmentSource=ShaderFactory.convertTo300(fragmentSource,true);}shaderProgram=new ShaderProgram(engine,vertexSource,fragmentSource);shaderProgramPool.cache(shaderProgram);return shaderProgram;};return Shader;}();Shader._compileMacros=new ShaderMacroCollection();Shader._propertyIdMap=Object.create(null);Shader._shaderCounter=0;Shader._shaderMap=Object.create(null);Shader._propertyNameMap=Object.create(null);Shader._macroMaskMap=[];Shader._macroCounter=0;Shader._macroMap=Object.create(null);Shader._shaderExtension=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives","GL_EXT_draw_buffers"];/**
   * Shader data collection,Correspondence includes shader properties data and macros data.
   */var ShaderData=/*#__PURE__*/function(){/** @internal */ /** @internal */ /** @internal */ /**
     * @internal
     */function ShaderData(group){this._group=void 0;this._propertyValueMap=Object.create(null);this._macroCollection=new ShaderMacroCollection();this._macroMap=Object.create(null);this._refCount=0;this._group=group;}/**
     * Get float by shader property name.
     * @param propertyName - Shader property name
     * @returns Float
     */var _proto=ShaderData.prototype;_proto.getFloat=function getFloat(property){return this.getPropertyValue(property);}/**
     * Set float by shader property name.
     * @remarks Corresponding float shader property type.
     * @param propertyName - Shader property name
     * @param value - Float
     */;_proto.setFloat=function setFloat(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Float,value);}/**
     * Get int by shader property name.
     * @param propertyName - Shader property name
     * @returns Int
     */;_proto.getInt=function getInt(property){return this.getPropertyValue(property);}/**
     * Set int by shader property name.
     * @remarks Correspondence includes int and bool shader property type.
     * @param propertyName - Shader property name
     * @param value - Int
     */;_proto.setInt=function setInt(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Int,value);}/**
     * Get float array by shader property name.
     * @param propertyName - Shader property name
     * @returns Float array
     */;_proto.getFloatArray=function getFloatArray(property){return this.getPropertyValue(property);}/**
     * Set float array by shader property name.
     * @remarks Correspondence includes float arrayã€vec2 arrayã€vec3 arrayã€vec4 array and matrix array shader property type.
     * @param propertyName - Shader property name
     * @param value - Float array
     */;_proto.setFloatArray=function setFloatArray(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.FloatArray,value);}/**
     * Get int array by shader property name.
     * @param propertyName - Shader property name
     * @returns Int Array
     */;_proto.getIntArray=function getIntArray(property){return this.getPropertyValue(property);}/**
     * Set int array by shader property name.
     * @remarks Correspondence includes bool arrayã€int arrayã€bvec2 arrayã€bvec3 arrayã€bvec4 arrayã€ivec2 arrayã€ivec3 array and ivec4 array shader property type.
     * @param propertyName - Shader property name
     * @param value - Int Array
     */;_proto.setIntArray=function setIntArray(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.IntArray,value);}/**
     * Get two-dimensional from shader property name.
     * @param propertyName - Shader property name
     * @returns Two-dimensional vector
     */;_proto.getVector2=function getVector2(property){return this.getPropertyValue(property);}/**
     * Set two-dimensional vector from shader property name.
     * @remarks Correspondence includes vec2ã€ivec2 and bvec2 shader property type.
     * @param property - Shader property name
     * @param value - Two-dimensional vector
     */;_proto.setVector2=function setVector2(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Vector2,value);}/**
     * Get vector3 by shader property name.
     * @param propertyName - Shader property name
     * @returns Three-dimensional vector
     */;_proto.getVector3=function getVector3(property){return this.getPropertyValue(property);}/**
     * Set three dimensional vector by shader property name.
     * @remarks Correspondence includes vec3ã€ivec3 and bvec3 shader property type.
     * @param property - Shader property name
     * @param value - Three-dimensional vector
     */;_proto.setVector3=function setVector3(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Vector3,value);}/**
     * Get vector4 by shader property name.
     * @param propertyName - Shader property name
     * @returns Four-dimensional vector
     */;_proto.getVector4=function getVector4(property){return this.getPropertyValue(property);}/**
     * Set four-dimensional vector by shader property name.
     * @remarks Correspondence includes vec4ã€ivec4 and bvec4 shader property type.
     * @param property - Shader property name
     * @param value - Four-dimensional vector
     */;_proto.setVector4=function setVector4(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Vector4,value);}/**
     * Get matrix by shader property name.
     * @param propertyName - Shader property name
     * @returns Matrix
     */;_proto.getMatrix=function getMatrix(property){return this.getPropertyValue(property);}/**
     * Set matrix by shader property name.
     * @remarks Correspondence includes matrix shader property type.
     * @param propertyName - Shader property name
     * @param value - Matrix
     */;_proto.setMatrix=function setMatrix(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Matrix,value);}/**
     * Get color by shader property name.
     * @param propertyName - Shader property name
     * @returns Color
     */;_proto.getColor=function getColor(property){return this.getPropertyValue(property);}/**
     * Set color by shader property name.
     * @remarks Correspondence includes vec4 shader property type.
     * @param propertyName - Shader property name
     * @param value - Color
     */;_proto.setColor=function setColor(property,value){this._setPropertyValue(property,exports.ShaderPropertyType.Color,value);}/**
     * Get texture by shader property name.
     * @param propertyName - Shader property name
     * @returns Texture
     */;_proto.getTexture=function getTexture(property){return this.getPropertyValue(property);}/**
     * Set texture by shader property name.
     * @param propertyName - Shader property name
     * @param value - Texture
     */;_proto.setTexture=function setTexture(property,value){if(this._getRefCount()>0){var lastValue=this.getPropertyValue(property);lastValue&&lastValue._addRefCount(-1);value&&value._addRefCount(1);}this._setPropertyValue(property,exports.ShaderPropertyType.Texture,value);}/**
     * Get texture array by shader property name.
     * @param propertyName - Shader property name
     * @returns Texture array
     */;_proto.getTextureArray=function getTextureArray(property){return this.getPropertyValue(property);}/**
     * Set texture array by shader property name.
     * @param propertyName - Shader property name
     * @param value - Texture array
     */;_proto.setTextureArray=function setTextureArray(property,value){if(this._getRefCount()>0){var lastValue=this.getPropertyValue(property);if(lastValue){for(var i=0,n=lastValue.length;i<n;i++){lastValue[i]._addRefCount(-1);}}if(value){for(var _i=0,_n=value.length;_i<_n;_i++){value[_i]._addRefCount(1);}}}this._setPropertyValue(property,exports.ShaderPropertyType.TextureArray,value);}/**
     * Get shader property value set on this shaderData.
     * @param property - Shader property
     * @returns Property value
     */;_proto.getPropertyValue=function getPropertyValue(property){if(typeof property==="string"){property=Shader.getPropertyByName(property);}return this._propertyValueMap[property._uniqueId];}/**
     * Enable macro with name.
     * @param macroName - Macro name
     */;_proto.enableMacro=function enableMacro(macro,value){if(typeof macro==="string"){macro=Shader.getMacroByName(macro,value);}var nameID=macro._nameId;var lastMacro=this._macroMap[nameID];if(lastMacro!==macro){var macroCollection=this._macroCollection;lastMacro&&macroCollection.disable(lastMacro);macroCollection.enable(macro);this._macroMap[nameID]=macro;}}/**
     * Disable macro.
     * @param macroName - Macro name
     */;_proto.disableMacro=function disableMacro(macro){var nameID;if(typeof macro==="string"){nameID=ShaderMacro._macroNameIdMap[macro];if(nameID===undefined){return;}}else {nameID=macro._nameId;}var currentMacro=this._macroMap[nameID];if(currentMacro){this._macroCollection.disable(currentMacro);delete this._macroMap[nameID];}}/**
     * Get shader macro array that are currently enabled for ShaderData.
     */;_proto.getMacros=function getMacros(out){if(out){var macroMap=this._macroMap;out.length=0;for(var key in macroMap){out.push(macroMap[key]);}}else {return Object.values(this._macroMap);}}/**
     * Get all shader properties that have been set on this shaderData
     * @returns  All shader properties
     */;_proto.getProperties=function getProperties(out){var properties;if(out){out.length=0;properties=out;}else {properties=[];}var propertyValueMap=this._propertyValueMap;var propertyIdMap=Shader._propertyIdMap;for(var key in propertyValueMap){properties.push(propertyIdMap[key]);}if(!out){return properties;}};_proto.clone=function clone(){var shaderData=new ShaderData(this._group);this.cloneTo(shaderData);return shaderData;};_proto.cloneTo=function cloneTo(target){CloneManager.deepCloneObject(this._macroCollection,target._macroCollection);_extends(target._macroMap,this._macroMap);var propertyValueMap=this._propertyValueMap;var targetPropertyValueMap=target._propertyValueMap;var keys=Object.keys(propertyValueMap);for(var i=0,n=keys.length;i<n;i++){var k=keys[i];var _property=propertyValueMap[k];if(_property!=null){if(typeof _property==="number"){targetPropertyValueMap[k]=_property;}else if(_property instanceof Texture){targetPropertyValueMap[k]=_property;}else if(_property instanceof Array||_property instanceof Float32Array||_property instanceof Int32Array){targetPropertyValueMap[k]=_property.slice();}else {var targetProperty=targetPropertyValueMap[k];if(targetProperty){targetProperty.copyFrom(_property);}else {targetPropertyValueMap[k]=_property.clone();}}}else {targetPropertyValueMap[k]=_property;}}}/**
     * @internal
     */;_proto._setPropertyValue=function _setPropertyValue(property,type,value){if(typeof property==="string"){property=Shader.getPropertyByName(property);}if(property._group!==this._group){if(property._group===undefined){property._group=this._group;}else {throw "Shader property "+property.name+" has been used as "+ShaderDataGroup[property._group]+" group.";}}if(property._type!==type){if(property._type===undefined){property._type=type;}else {throw "Shader property "+property.name+" has been used as "+exports.ShaderPropertyType[property._type]+" type.";}}this._propertyValueMap[property._uniqueId]=value;}/**
     * @internal
     */;_proto._getRefCount=function _getRefCount(){return this._refCount;}/**
     * @internal
     */;_proto._addRefCount=function _addRefCount(value){this._refCount+=value;var properties=this._propertyValueMap;for(var k in properties){var _property2=properties[k];// @todo: Separate array to speed performance.
  if(_property2&&_property2 instanceof Texture){_property2._addRefCount(value);}}};return ShaderData;}();/**
   * Blend factor.
   * @remarks defines which function is used for blending pixel arithmetic
   */exports.BlendFactor = void 0;(function(BlendFactor){BlendFactor[BlendFactor["Zero"]=0]="Zero";BlendFactor[BlendFactor["One"]=1]="One";BlendFactor[BlendFactor["SourceColor"]=2]="SourceColor";BlendFactor[BlendFactor["OneMinusSourceColor"]=3]="OneMinusSourceColor";BlendFactor[BlendFactor["DestinationColor"]=4]="DestinationColor";BlendFactor[BlendFactor["OneMinusDestinationColor"]=5]="OneMinusDestinationColor";BlendFactor[BlendFactor["SourceAlpha"]=6]="SourceAlpha";BlendFactor[BlendFactor["OneMinusSourceAlpha"]=7]="OneMinusSourceAlpha";BlendFactor[BlendFactor["DestinationAlpha"]=8]="DestinationAlpha";BlendFactor[BlendFactor["OneMinusDestinationAlpha"]=9]="OneMinusDestinationAlpha";BlendFactor[BlendFactor["SourceAlphaSaturate"]=10]="SourceAlphaSaturate";BlendFactor[BlendFactor["BlendColor"]=11]="BlendColor";BlendFactor[BlendFactor["OneMinusBlendColor"]=12]="OneMinusBlendColor";})(exports.BlendFactor||(exports.BlendFactor={}));/**
   * Blend operation function.
   * @remarks defines how a new pixel is combined with a pixel.
   */exports.BlendOperation = void 0;(function(BlendOperation){BlendOperation[BlendOperation["Add"]=0]="Add";BlendOperation[BlendOperation["Subtract"]=1]="Subtract";BlendOperation[BlendOperation["ReverseSubtract"]=2]="ReverseSubtract";BlendOperation[BlendOperation["Min"]=3]="Min";BlendOperation[BlendOperation["Max"]=4]="Max";})(exports.BlendOperation||(exports.BlendOperation={}));/**
   * Set which color channels can be rendered to frame buffer.
   * @remarks enumeration can be combined using bit operations.
   */exports.ColorWriteMask = void 0;(function(ColorWriteMask){ColorWriteMask[ColorWriteMask["None"]=0]="None";ColorWriteMask[ColorWriteMask["Red"]=1]="Red";ColorWriteMask[ColorWriteMask["Green"]=2]="Green";ColorWriteMask[ColorWriteMask["Blue"]=4]="Blue";ColorWriteMask[ColorWriteMask["Alpha"]=8]="Alpha";ColorWriteMask[ColorWriteMask["All"]=15]="All";})(exports.ColorWriteMask||(exports.ColorWriteMask={}));/**
   * The blend state of the render target.
   */var RenderTargetBlendState=function RenderTargetBlendState(){this.enabled=false;this.colorBlendOperation=exports.BlendOperation.Add;this.alphaBlendOperation=exports.BlendOperation.Add;this.sourceColorBlendFactor=exports.BlendFactor.One;this.sourceAlphaBlendFactor=exports.BlendFactor.One;this.destinationColorBlendFactor=exports.BlendFactor.Zero;this.destinationAlphaBlendFactor=exports.BlendFactor.Zero;this.colorWriteMask=exports.ColorWriteMask.All;};/**
   * Blend state.
   */var BlendState=/*#__PURE__*/function(){function BlendState(){this.targetBlendState=new RenderTargetBlendState();this.blendColor=new Color(0,0,0,0);this.alphaToCoverage=false;}BlendState._getGLBlendFactor=function _getGLBlendFactor(rhi,blendFactor){var gl=rhi.gl;switch(blendFactor){case exports.BlendFactor.Zero:return gl.ZERO;case exports.BlendFactor.One:return gl.ONE;case exports.BlendFactor.SourceColor:return gl.SRC_COLOR;case exports.BlendFactor.OneMinusSourceColor:return gl.ONE_MINUS_SRC_COLOR;case exports.BlendFactor.DestinationColor:return gl.DST_COLOR;case exports.BlendFactor.OneMinusDestinationColor:return gl.ONE_MINUS_DST_COLOR;case exports.BlendFactor.SourceAlpha:return gl.SRC_ALPHA;case exports.BlendFactor.OneMinusSourceAlpha:return gl.ONE_MINUS_SRC_ALPHA;case exports.BlendFactor.DestinationAlpha:return gl.DST_ALPHA;case exports.BlendFactor.OneMinusDestinationAlpha:return gl.ONE_MINUS_DST_ALPHA;case exports.BlendFactor.SourceAlphaSaturate:return gl.SRC_ALPHA_SATURATE;case exports.BlendFactor.BlendColor:return gl.CONSTANT_COLOR;case exports.BlendFactor.OneMinusBlendColor:return gl.ONE_MINUS_CONSTANT_COLOR;}};BlendState._getGLBlendOperation=function _getGLBlendOperation(rhi,blendOperation){var gl=rhi.gl;switch(blendOperation){case exports.BlendOperation.Add:return gl.FUNC_ADD;case exports.BlendOperation.Subtract:return gl.FUNC_SUBTRACT;case exports.BlendOperation.ReverseSubtract:return gl.FUNC_REVERSE_SUBTRACT;case exports.BlendOperation.Min:if(!rhi.canIUse(exports.GLCapabilityType.blendMinMax)){throw new Error("BlendOperation.Min is not supported in this context");}return gl.MIN;// in webgl1.0 is an extension
  case exports.BlendOperation.Max:if(!rhi.canIUse(exports.GLCapabilityType.blendMinMax)){throw new Error("BlendOperation.Max is not supported in this context");}return gl.MAX;// in webgl1.0 is an extension
  }}/** The blend state of the render target. */;var _proto=BlendState.prototype;/**
     * @internal
     * Apply the current blend state by comparing with the last blend state.
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.blendState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var lastTargetBlendState=lastState.targetBlendState;var _this$targetBlendStat=this.targetBlendState,enabled=_this$targetBlendStat.enabled,colorBlendOperation=_this$targetBlendStat.colorBlendOperation,alphaBlendOperation=_this$targetBlendStat.alphaBlendOperation,sourceColorBlendFactor=_this$targetBlendStat.sourceColorBlendFactor,destinationColorBlendFactor=_this$targetBlendStat.destinationColorBlendFactor,sourceAlphaBlendFactor=_this$targetBlendStat.sourceAlphaBlendFactor,destinationAlphaBlendFactor=_this$targetBlendStat.destinationAlphaBlendFactor,colorWriteMask=_this$targetBlendStat.colorWriteMask;if(enabled!==lastTargetBlendState.enabled){if(enabled){gl.enable(gl.BLEND);}else {gl.disable(gl.BLEND);}lastTargetBlendState.enabled=enabled;}if(enabled){// apply blend factor.
  if(sourceColorBlendFactor!==lastTargetBlendState.sourceColorBlendFactor||destinationColorBlendFactor!==lastTargetBlendState.destinationColorBlendFactor||sourceAlphaBlendFactor!==lastTargetBlendState.sourceAlphaBlendFactor||destinationAlphaBlendFactor!==lastTargetBlendState.destinationAlphaBlendFactor){gl.blendFuncSeparate(BlendState._getGLBlendFactor(rhi,sourceColorBlendFactor),BlendState._getGLBlendFactor(rhi,destinationColorBlendFactor),BlendState._getGLBlendFactor(rhi,sourceAlphaBlendFactor),BlendState._getGLBlendFactor(rhi,destinationAlphaBlendFactor));lastTargetBlendState.sourceColorBlendFactor=sourceColorBlendFactor;lastTargetBlendState.destinationColorBlendFactor=destinationColorBlendFactor;lastTargetBlendState.sourceAlphaBlendFactor=sourceAlphaBlendFactor;lastTargetBlendState.destinationAlphaBlendFactor=destinationAlphaBlendFactor;}// apply blend operation.
  if(colorBlendOperation!==lastTargetBlendState.colorBlendOperation||alphaBlendOperation!==lastTargetBlendState.alphaBlendOperation){gl.blendEquationSeparate(BlendState._getGLBlendOperation(rhi,colorBlendOperation),BlendState._getGLBlendOperation(rhi,alphaBlendOperation));lastTargetBlendState.colorBlendOperation=colorBlendOperation;lastTargetBlendState.alphaBlendOperation=alphaBlendOperation;}// apply blend color.
  var blendColor=this.blendColor;if(!Color.equals(lastState.blendColor,blendColor)){gl.blendColor(blendColor.r,blendColor.g,blendColor.b,blendColor.a);lastState.blendColor.copyFrom(blendColor);}}// apply color mask.
  if(colorWriteMask!==lastTargetBlendState.colorWriteMask){gl.colorMask((colorWriteMask&exports.ColorWriteMask.Red)!==0,(colorWriteMask&exports.ColorWriteMask.Green)!==0,(colorWriteMask&exports.ColorWriteMask.Blue)!==0,(colorWriteMask&exports.ColorWriteMask.Alpha)!==0);lastTargetBlendState.colorWriteMask=colorWriteMask;}// apply alpha to coverage.
  var alphaToCoverage=this.alphaToCoverage;if(alphaToCoverage!==lastState.alphaToCoverage){if(alphaToCoverage){gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);}else {gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);}lastState.alphaToCoverage=alphaToCoverage;}};return BlendState;}();/**
   * Depth/Stencil comparison function.
   * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.
   */exports.CompareFunction = void 0;(function(CompareFunction){CompareFunction[CompareFunction["Never"]=0]="Never";CompareFunction[CompareFunction["Less"]=1]="Less";CompareFunction[CompareFunction["Equal"]=2]="Equal";CompareFunction[CompareFunction["LessEqual"]=3]="LessEqual";CompareFunction[CompareFunction["Greater"]=4]="Greater";CompareFunction[CompareFunction["NotEqual"]=5]="NotEqual";CompareFunction[CompareFunction["GreaterEqual"]=6]="GreaterEqual";CompareFunction[CompareFunction["Always"]=7]="Always";})(exports.CompareFunction||(exports.CompareFunction={}));/**
   * Depth state.
   */var DepthState=/*#__PURE__*/function(){function DepthState(){this.enabled=true;this.writeEnabled=true;this.compareFunction=exports.CompareFunction.Less;}DepthState._getGLCompareFunction=function _getGLCompareFunction(rhi,compareFunction){var gl=rhi.gl;switch(compareFunction){case exports.CompareFunction.Never:return gl.NEVER;case exports.CompareFunction.Less:return gl.LESS;case exports.CompareFunction.Equal:return gl.EQUAL;case exports.CompareFunction.LessEqual:return gl.LEQUAL;case exports.CompareFunction.Greater:return gl.GREATER;case exports.CompareFunction.NotEqual:return gl.NOTEQUAL;case exports.CompareFunction.GreaterEqual:return gl.GEQUAL;case exports.CompareFunction.Always:return gl.ALWAYS;}}/** Whether to enable the depth test. */;var _proto=DepthState.prototype;/**
     * @internal
     * Apply the current depth state by comparing with the last depth state.
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.depthState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var enabled=this.enabled,compareFunction=this.compareFunction,writeEnabled=this.writeEnabled;if(enabled!=lastState.enabled){if(enabled){gl.enable(gl.DEPTH_TEST);}else {gl.disable(gl.DEPTH_TEST);}lastState.enabled=enabled;}if(enabled){// apply compare func.
  if(compareFunction!=lastState.compareFunction){gl.depthFunc(DepthState._getGLCompareFunction(rhi,compareFunction));lastState.compareFunction=compareFunction;}// apply write enabled.
  if(writeEnabled!=lastState.writeEnabled){gl.depthMask(writeEnabled);lastState.writeEnabled=writeEnabled;}}};return DepthState;}();/**
   * Culling mode.
   * @remarks specifies whether or not front- and/or back-facing polygons can be culled.
   */exports.CullMode = void 0;(function(CullMode){CullMode[CullMode["Off"]=0]="Off";CullMode[CullMode["Front"]=1]="Front";CullMode[CullMode["Back"]=2]="Back";})(exports.CullMode||(exports.CullMode={}));/**
   * Raster state.
   */var RasterState=/*#__PURE__*/function(){function RasterState(){this.cullMode=exports.CullMode.Back;this.depthBias=0;this.slopeScaledDepthBias=0;this._cullFaceEnable=true;this._frontFaceInvert=false;}var _proto=RasterState.prototype;/**
     * @internal
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState,frontFaceInvert){this._platformApply(hardwareRenderer,lastRenderState.rasterState,frontFaceInvert);};_proto._platformApply=function _platformApply(rhi,lastState,frontFaceInvert){var gl=rhi.gl;var cullMode=this.cullMode,depthBias=this.depthBias,slopeScaledDepthBias=this.slopeScaledDepthBias;var cullFaceEnable=cullMode!==exports.CullMode.Off;if(cullFaceEnable!==lastState._cullFaceEnable){if(cullFaceEnable){gl.enable(gl.CULL_FACE);}else {gl.disable(gl.CULL_FACE);}lastState._cullFaceEnable=cullFaceEnable;}// apply front face.
  if(cullFaceEnable){if(cullMode!==lastState.cullMode){if(cullMode==exports.CullMode.Back){gl.cullFace(gl.BACK);}else {gl.cullFace(gl.FRONT);}lastState.cullMode=cullMode;}}if(frontFaceInvert!==lastState._frontFaceInvert){if(frontFaceInvert){gl.frontFace(gl.CW);}else {gl.frontFace(gl.CCW);}lastState._frontFaceInvert=frontFaceInvert;}// apply polygonOffset.
  if(depthBias!==lastState.depthBias||slopeScaledDepthBias!==lastState.slopeScaledDepthBias){if(depthBias!==0||slopeScaledDepthBias!==0){gl.enable(gl.POLYGON_OFFSET_FILL);gl.polygonOffset(slopeScaledDepthBias,depthBias);}else {gl.disable(gl.POLYGON_OFFSET_FILL);}lastState.depthBias=depthBias;lastState.slopeScaledDepthBias=slopeScaledDepthBias;}};return RasterState;}();/**
   * Stencil operation mode.
   * @remarks sets the front and/or back-facing stencil test actions.
   */exports.StencilOperation = void 0;(function(StencilOperation){StencilOperation[StencilOperation["Keep"]=0]="Keep";StencilOperation[StencilOperation["Zero"]=1]="Zero";StencilOperation[StencilOperation["Replace"]=2]="Replace";StencilOperation[StencilOperation["IncrementSaturate"]=3]="IncrementSaturate";StencilOperation[StencilOperation["DecrementSaturate"]=4]="DecrementSaturate";StencilOperation[StencilOperation["Invert"]=5]="Invert";StencilOperation[StencilOperation["IncrementWrap"]=6]="IncrementWrap";StencilOperation[StencilOperation["DecrementWrap"]=7]="DecrementWrap";})(exports.StencilOperation||(exports.StencilOperation={}));/**
   * Stencil state.
   */var StencilState=/*#__PURE__*/function(){function StencilState(){this.enabled=false;this.referenceValue=0;this.mask=0xff;this.writeMask=0xff;this.compareFunctionFront=exports.CompareFunction.Always;this.compareFunctionBack=exports.CompareFunction.Always;this.passOperationFront=exports.StencilOperation.Keep;this.passOperationBack=exports.StencilOperation.Keep;this.failOperationFront=exports.StencilOperation.Keep;this.failOperationBack=exports.StencilOperation.Keep;this.zFailOperationFront=exports.StencilOperation.Keep;this.zFailOperationBack=exports.StencilOperation.Keep;}StencilState._getGLCompareFunction=function _getGLCompareFunction(rhi,compareFunction){var gl=rhi.gl;switch(compareFunction){case exports.CompareFunction.Never:return gl.NEVER;case exports.CompareFunction.Less:return gl.LESS;case exports.CompareFunction.Equal:return gl.EQUAL;case exports.CompareFunction.LessEqual:return gl.LEQUAL;case exports.CompareFunction.Greater:return gl.GREATER;case exports.CompareFunction.NotEqual:return gl.NOTEQUAL;case exports.CompareFunction.GreaterEqual:return gl.GEQUAL;case exports.CompareFunction.Always:return gl.ALWAYS;}};StencilState._getGLStencilOperation=function _getGLStencilOperation(rhi,compareFunction){var gl=rhi.gl;switch(compareFunction){case exports.StencilOperation.Keep:return gl.KEEP;case exports.StencilOperation.Zero:return gl.ZERO;case exports.StencilOperation.Replace:return gl.REPLACE;case exports.StencilOperation.IncrementSaturate:return gl.INCR;case exports.StencilOperation.DecrementSaturate:return gl.DECR;case exports.StencilOperation.Invert:return gl.INVERT;case exports.StencilOperation.IncrementWrap:return gl.INCR_WRAP;case exports.StencilOperation.DecrementWrap:return gl.DECR_WRAP;}}/** Whether to enable stencil test. */;var _proto=StencilState.prototype;/**
     * @internal
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.stencilState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var enabled=this.enabled,referenceValue=this.referenceValue,mask=this.mask,compareFunctionFront=this.compareFunctionFront,compareFunctionBack=this.compareFunctionBack,failOperationFront=this.failOperationFront,zFailOperationFront=this.zFailOperationFront,passOperationFront=this.passOperationFront,failOperationBack=this.failOperationBack,zFailOperationBack=this.zFailOperationBack,passOperationBack=this.passOperationBack,writeMask=this.writeMask;if(enabled!=lastState.enabled){if(enabled){gl.enable(gl.STENCIL_TEST);}else {gl.disable(gl.STENCIL_TEST);}lastState.enabled=enabled;}if(enabled){// apply stencil func.
  var referenceOrMaskChange=referenceValue!==lastState.referenceValue||mask!==lastState.mask;if(referenceOrMaskChange||compareFunctionFront!==lastState.compareFunctionFront){gl.stencilFuncSeparate(gl.FRONT,StencilState._getGLCompareFunction(rhi,compareFunctionFront),referenceValue,mask);lastState.compareFunctionFront=compareFunctionFront;}if(referenceOrMaskChange||compareFunctionBack!==lastState.compareFunctionBack){gl.stencilFuncSeparate(gl.BACK,StencilState._getGLCompareFunction(rhi,compareFunctionBack),referenceValue,mask);lastState.compareFunctionBack=this.compareFunctionBack;}if(referenceOrMaskChange){lastState.referenceValue=this.referenceValue;lastState.mask=this.mask;}// apply stencil operation.
  if(failOperationFront!==lastState.failOperationFront||zFailOperationFront!==lastState.zFailOperationFront||passOperationFront!==lastState.passOperationFront){gl.stencilOpSeparate(gl.FRONT,StencilState._getGLStencilOperation(rhi,failOperationFront),StencilState._getGLStencilOperation(rhi,zFailOperationFront),StencilState._getGLStencilOperation(rhi,passOperationFront));lastState.failOperationFront=failOperationFront;lastState.zFailOperationFront=zFailOperationFront;lastState.passOperationFront=passOperationFront;}if(failOperationBack!==lastState.failOperationBack||zFailOperationBack!==lastState.zFailOperationBack||passOperationBack!==lastState.passOperationBack){gl.stencilOpSeparate(gl.BACK,StencilState._getGLStencilOperation(rhi,failOperationBack),StencilState._getGLStencilOperation(rhi,zFailOperationBack),StencilState._getGLStencilOperation(rhi,passOperationBack));lastState.failOperationBack=failOperationBack;lastState.zFailOperationBack=zFailOperationBack;lastState.passOperationBack=passOperationBack;}// apply write mask.
  if(writeMask!==lastState.writeMask){gl.stencilMask(writeMask);lastState.writeMask=writeMask;}}};return StencilState;}();/**
   * Render state.
   */var RenderState=/*#__PURE__*/function(){function RenderState(){this.blendState=new BlendState();this.depthState=new DepthState();this.stencilState=new StencilState();this.rasterState=new RasterState();}var _proto=RenderState.prototype;/**
     * @internal
     */_proto._apply=function _apply(engine,frontFaceInvert){var hardwareRenderer=engine._hardwareRenderer;var lastRenderState=engine._lastRenderState;this.blendState._apply(hardwareRenderer,lastRenderState);this.depthState._apply(hardwareRenderer,lastRenderState);this.stencilState._apply(hardwareRenderer,lastRenderState);this.rasterState._apply(hardwareRenderer,lastRenderState,frontFaceInvert);};return RenderState;}();/**
   * Material.
   */var Material=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Material,_RefObject);/** Name. */ /** Shader used by the material. */ /** Render queue type. */ /** Shader data. */ /** Render state. */ // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.
  /**
     * Create a material instance.
     * @param engine - Engine to which the material belongs
     * @param shader - Shader used by the material
     */function Material(engine,shader){var _this;_this=_RefObject.call(this,engine)||this;_this.name=void 0;_this.shader=void 0;_this.renderQueueType=exports.RenderQueueType.Opaque;_this.shaderData=new ShaderData(ShaderDataGroup.Material);_this.renderState=new RenderState();_this.shader=shader;return _this;}/**
     * Clone and return the instance.
     */var _proto=Material.prototype;_proto.clone=function clone(){var dest=new Material(this._engine,this.shader);this.cloneTo(dest);return dest;}/**
     * Clone to the target material.
     * @param target - target material
     */;_proto.cloneTo=function cloneTo(target){target.shader=this.shader;target.renderQueueType=this.renderQueueType;this.shaderData.cloneTo(target.shaderData);CloneManager.deepCloneObject(this.renderState,target.renderState);}/**
     * @override
     */;_proto._addRefCount=function _addRefCount(value){_RefObject.prototype._addRefCount.call(this,value);this.shaderData._addRefCount(value);}/**
     * @internal
     * @todo:temporary solution
     */;_proto._preRender=function _preRender(renderElement){}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){};return Material;}(RefObject);/**
   * Class pool utils.
   */var ClassPool=/*#__PURE__*/function(){function ClassPool(type){this._elementPoolIndex=0;this._elementPool=[];this._type=void 0;this._type=type;}/**
     * Get element from pool.
     */var _proto=ClassPool.prototype;_proto.getFromPool=function getFromPool(){var index=this._elementPoolIndex,pool=this._elementPool;this._elementPoolIndex++;if(pool.length===index){var element=new this._type();pool.push(element);return element;}else {return pool[index];}}/**
     * Reset pool.
     */;_proto.resetPool=function resetPool(){this._elementPoolIndex=0;};return ClassPool;}();var RenderElement=function RenderElement(){this.component=void 0;this.material=void 0;this.multiRenderData=void 0;};/**
   * Render element.
   */var MeshRenderElement=/*#__PURE__*/function(_RenderElement){_inheritsLoose$2(MeshRenderElement,_RenderElement);function MeshRenderElement(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_RenderElement.call.apply(_RenderElement,[this].concat(args))||this;_this.mesh=void 0;_this.subMesh=void 0;return _this;}var _proto=MeshRenderElement.prototype;_proto.setValue=function setValue(component,mesh,subMesh,material){this.component=component;this.mesh=mesh;this.subMesh=subMesh;this.material=material;};return MeshRenderElement;}(RenderElement);/**
   * Rendering context.
   */var RenderContext=/*#__PURE__*/function(){function RenderContext(){this._camera=void 0;this._viewProjectMatrix=new Matrix();}var _proto=RenderContext.prototype;/**
     * @internal
     */_proto._setContext=function _setContext(camera){this._camera=camera;Matrix.multiply(camera.projectionMatrix,camera.viewMatrix,this._viewProjectMatrix);};return RenderContext;}();var SpriteElement=/*#__PURE__*/function(_RenderElement){_inheritsLoose$2(SpriteElement,_RenderElement);function SpriteElement(){var _this;_this=_RenderElement.call(this)||this;_this.renderData=void 0;_this.texture=void 0;_this.multiRenderData=false;return _this;}var _proto=SpriteElement.prototype;_proto.setValue=function setValue(component,renderDate,material,texture){this.component=component;this.renderData=renderDate;this.material=material;this.texture=texture;};return SpriteElement;}(RenderElement);var SpriteMaskElement=/*#__PURE__*/function(_RenderElement){_inheritsLoose$2(SpriteMaskElement,_RenderElement);function SpriteMaskElement(){var _this;_this=_RenderElement.call(this)||this;_this.renderData=void 0;_this.isAdd=true;_this.multiRenderData=false;return _this;}var _proto=SpriteMaskElement.prototype;_proto.setValue=function setValue(component,renderData,material){this.component=component;this.renderData=renderData;this.material=material;};return SpriteMaskElement;}(RenderElement);/**
   * Sprite mask interaction.
   */exports.SpriteMaskInteraction = void 0;(function(SpriteMaskInteraction){SpriteMaskInteraction[SpriteMaskInteraction["None"]=0]="None";SpriteMaskInteraction[SpriteMaskInteraction["VisibleInsideMask"]=1]="VisibleInsideMask";SpriteMaskInteraction[SpriteMaskInteraction["VisibleOutsideMask"]=2]="VisibleOutsideMask";})(exports.SpriteMaskInteraction||(exports.SpriteMaskInteraction={}));var _dec$3$1,_class$a$1,_class2$9,_descriptor$8,_descriptor2$8,_descriptor3$7,_descriptor4$7,_descriptor5$7,_descriptor6$7,_descriptor7$7,_descriptor8$7,_descriptor9$6,_descriptor10$3,_descriptor11$3,_descriptor12$3,_descriptor13$2,_descriptor14$1,_descriptor15$1,_descriptor16$1,_class3$1;/**
   * Basis for all renderers.
   * @decorator `@dependentComponents(Transform)`
   */var Renderer=(_dec$3$1=dependentComponents(Transform),_dec$3$1(_class$a$1=(_class2$9=(_class3$1=/*#__PURE__*/function(_Component){_inheritsLoose$2(Renderer,_Component);/**
     * @internal
     */function Renderer(entity){var _this;_this=_Component.call(this,entity)||this;_initializerDefineProperty(_this,"shaderData",_descriptor$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"isCulled",_descriptor2$8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_distanceForSort",_descriptor3$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onUpdateIndex",_descriptor4$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_rendererIndex",_descriptor5$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_globalShaderMacro",_descriptor6$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_transformChangeFlag",_descriptor7$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_bounds",_descriptor8$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_overrideUpdate",_descriptor9$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_materials",_descriptor10$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_mvMatrix",_descriptor11$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_mvpMatrix",_descriptor12$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_mvInvMatrix",_descriptor13$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_normalMatrix",_descriptor14$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_materialsInstanced",_descriptor15$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_priority",_descriptor16$1,_assertThisInitialized(_this));var prototype=Renderer.prototype;_this._overrideUpdate=_this.update!==prototype.update;_this._transformChangeFlag=_this.entity.transform.registerWorldChangeFlag();_this.shaderData._addRefCount(1);return _this;}/**
     * Get the first instance material.
     * @returns The first instance material
     */var _proto=Renderer.prototype;_proto.getInstanceMaterial=function getInstanceMaterial(index){if(index===void 0){index=0;}var materials=this._materials;if(materials.length>index){var _material=materials[index];if(_material){if(this._materialsInstanced[index]){return _material;}else {return this._createInstanceMaterial(_material,index);}}}return null;}/**
     * Get the first material.
     * @returns The first material
     */;_proto.getMaterial=function getMaterial(index){if(index===void 0){index=0;}return this._materials[index]||null;}/**
     * Set the first material.
     * @param material - The first material
     */;_proto.setMaterial=function setMaterial(indexOrMaterial,material){if(material===void 0){material=null;}if(typeof indexOrMaterial==="number"){this._setMaterial(indexOrMaterial,material);}else {this._setMaterial(0,indexOrMaterial);}}/**
     * Get all instance materials.
     * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.
     * @returns All instance materials
     */;_proto.getInstanceMaterials=function getInstanceMaterials(){var materials=this._materials;var materialsInstance=this._materialsInstanced;for(var i=0,n=materials.length;i<n;i++){if(!materialsInstance[i]){this._createInstanceMaterial(this._materials[i],i);}}return materials;}/**
     * Get all materials.
     * @returns All materials
     */;_proto.getMaterials=function getMaterials(){return this._materials;}/**
     * Set all materials.
     * @param materials - All materials
     */;_proto.setMaterials=function setMaterials(materials){var count=materials.length;var internalMaterials=this._materials;var materialsInstanced=this._materialsInstanced;for(var i=count,n=internalMaterials.length;i<n;i++){var internalMaterial=internalMaterials[i];internalMaterial&&internalMaterial._addRefCount(-1);}internalMaterials.length!==count&&(internalMaterials.length=count);materialsInstanced.length!==0&&(materialsInstanced.length=0);for(var _i=0;_i<count;_i++){var _internalMaterial=internalMaterials[_i];var _material2=materials[_i];if(_internalMaterial!==_material2){internalMaterials[_i]=_material2;_internalMaterial&&_internalMaterial._addRefCount(-1);_material2&&_material2._addRefCount(1);}}};_proto.update=function update(deltaTime){}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(context){var shaderData=this.shaderData;var worldMatrix=this.entity.transform.worldMatrix;var mvMatrix=this._mvMatrix;var mvpMatrix=this._mvpMatrix;var mvInvMatrix=this._mvInvMatrix;var normalMatrix=this._normalMatrix;Matrix.multiply(context._camera.viewMatrix,worldMatrix,mvMatrix);Matrix.multiply(context._viewProjectMatrix,worldMatrix,mvpMatrix);Matrix.invert(mvMatrix,mvInvMatrix);Matrix.invert(worldMatrix,normalMatrix);normalMatrix.transpose();shaderData.setMatrix(Renderer._localMatrixProperty,this.entity.transform.localMatrix);shaderData.setMatrix(Renderer._worldMatrixProperty,worldMatrix);shaderData.setMatrix(Renderer._mvMatrixProperty,mvMatrix);shaderData.setMatrix(Renderer._mvpMatrixProperty,mvpMatrix);shaderData.setMatrix(Renderer._mvInvMatrixProperty,mvInvMatrix);shaderData.setMatrix(Renderer._normalMatrixProperty,normalMatrix);};_proto._onEnable=function _onEnable(){var componentsManager=this.engine._componentsManager;if(this._overrideUpdate){componentsManager.addOnUpdateRenderers(this);}componentsManager.addRenderer(this);};_proto._onDisable=function _onDisable(){var componentsManager=this.engine._componentsManager;if(this._overrideUpdate){componentsManager.removeOnUpdateRenderers(this);}componentsManager.removeRenderer(this);}/**
     * @internal
     */;_proto._render=function _render(camera){throw "not implement";}/**
     * @internal
     */;_proto._onDestroy=function _onDestroy(){var flag=this._transformChangeFlag;if(flag){flag.destroy();this._transformChangeFlag=null;}this.shaderData._addRefCount(-1);var materials=this._materials;for(var i=0,n=materials.length;i<n;i++){var _materials$i;(_materials$i=materials[i])===null||_materials$i===void 0?void 0:_materials$i._addRefCount(-1);}};_proto._updateBounds=function _updateBounds(worldBounds){};_proto._createInstanceMaterial=function _createInstanceMaterial(material,index){var insMaterial=material.clone();insMaterial.name=insMaterial.name+"(Instance)";material._addRefCount(-1);insMaterial._addRefCount(1);this._materialsInstanced[index]=true;this._materials[index]=insMaterial;return insMaterial;};_proto._setMaterial=function _setMaterial(index,material){var materials=this._materials;if(index>=materials.length){materials.length=index+1;}var internalMaterial=materials[index];if(internalMaterial!==material){var materialsInstance=this._materialsInstanced;index<materialsInstance.length&&(materialsInstance[index]=false);internalMaterial&&internalMaterial._addRefCount(-1);material&&material._addRefCount(1);materials[index]=material;}};_createClass$3(Renderer,[{key:"materialCount",get:/** ShaderData related to renderer. */ /** Whether it is clipped by the frustum, needs to be turned on camera.enableFrustumCulling. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
       * Material count.
       */function get(){return this._materials.length;},set:function set(value){var materials=this._materials;var materialsInstanced=this._materialsInstanced;materials.length!==value&&(materials.length=value);materialsInstanced.length>value&&(materialsInstanced.length=value);}/**
       * The bounding volume of the renderer.
       */},{key:"bounds",get:function get(){var changeFlag=this._transformChangeFlag;if(changeFlag.flag){this._updateBounds(this._bounds);changeFlag.flag=false;}return this._bounds;}/**
       * The render priority of the renderer, lower values are rendered first and higher values are rendered last.
       */},{key:"priority",get:function get(){return this._priority;},set:function set(value){this._priority=value;}}]);return Renderer;}(Component),_class3$1._localMatrixProperty=Shader.getPropertyByName("u_localMat"),_class3$1._worldMatrixProperty=Shader.getPropertyByName("u_modelMat"),_class3$1._mvMatrixProperty=Shader.getPropertyByName("u_MVMat"),_class3$1._mvpMatrixProperty=Shader.getPropertyByName("u_MVPMat"),_class3$1._mvInvMatrixProperty=Shader.getPropertyByName("u_MVInvMat"),_class3$1._normalMatrixProperty=Shader.getPropertyByName("u_normalMat"),_class3$1),(_descriptor$8=_applyDecoratedDescriptor(_class2$9.prototype,"shaderData",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ShaderData(ShaderDataGroup.Renderer);}}),_descriptor2$8=_applyDecoratedDescriptor(_class2$9.prototype,"isCulled",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor3$7=_applyDecoratedDescriptor(_class2$9.prototype,"_distanceForSort",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$7=_applyDecoratedDescriptor(_class2$9.prototype,"_onUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor5$7=_applyDecoratedDescriptor(_class2$9.prototype,"_rendererIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor6$7=_applyDecoratedDescriptor(_class2$9.prototype,"_globalShaderMacro",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ShaderMacroCollection();}}),_descriptor7$7=_applyDecoratedDescriptor(_class2$9.prototype,"_transformChangeFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor8$7=_applyDecoratedDescriptor(_class2$9.prototype,"_bounds",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new BoundingBox();}}),_descriptor9$6=_applyDecoratedDescriptor(_class2$9.prototype,"_overrideUpdate",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor10$3=_applyDecoratedDescriptor(_class2$9.prototype,"_materials",[shallowClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor11$3=_applyDecoratedDescriptor(_class2$9.prototype,"_mvMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor12$3=_applyDecoratedDescriptor(_class2$9.prototype,"_mvpMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor13$2=_applyDecoratedDescriptor(_class2$9.prototype,"_mvInvMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor14$1=_applyDecoratedDescriptor(_class2$9.prototype,"_normalMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor15$1=_applyDecoratedDescriptor(_class2$9.prototype,"_materialsInstanced",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor16$1=_applyDecoratedDescriptor(_class2$9.prototype,"_priority",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}})),_class2$9))||_class$a$1);/**
   *  Static interface implement decorator.
   *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
   */function StaticInterfaceImplement(){return function(constructor){};}var _dec$2$1,_class$9$1,_class2$8;/**
   * @internal
   */var SimpleSpriteAssembler=(_dec$2$1=StaticInterfaceImplement(),_dec$2$1(_class$9$1=(_class2$8=/*#__PURE__*/function(){function SimpleSpriteAssembler(){}SimpleSpriteAssembler.resetData=function resetData(renderer){var renderData=renderer._renderData;var vertexCount=renderData.vertexCount=4;var positions=renderData.positions,uvs=renderData.uvs;if(positions.length<vertexCount){for(var i=positions.length;i<vertexCount;i++){positions.push(new Vector3());uvs.push(new Vector2());}}renderData.triangles=SimpleSpriteAssembler._rectangleTriangles;};SimpleSpriteAssembler.updatePositions=function updatePositions(renderer){var width=renderer.width,height=renderer.height,sprite=renderer.sprite;var _sprite$pivot=sprite.pivot,pivotX=_sprite$pivot.x,pivotY=_sprite$pivot.y;// Renderer's worldMatrix;
  var worldMatrix=SimpleSpriteAssembler._worldMatrix;var wE=worldMatrix.elements;// Parent's worldMatrix.
  var pWE=renderer.entity.transform.worldMatrix.elements;var sx=renderer.flipX?-width:width;var sy=renderer.flipY?-height:height;wE[0]=pWE[0]*sx,wE[1]=pWE[1]*sx,wE[2]=pWE[2]*sx;wE[4]=pWE[4]*sy,wE[5]=pWE[5]*sy,wE[6]=pWE[6]*sy;wE[8]=pWE[8],wE[9]=pWE[9],wE[10]=pWE[10];wE[12]=pWE[12]-pivotX*wE[0]-pivotY*wE[4];wE[13]=pWE[13]-pivotX*wE[1]-pivotY*wE[5];wE[14]=pWE[14]-pivotX*wE[2]-pivotY*wE[6];// ---------------
  //  2 - 3
  //  |   |
  //  0 - 1
  // ---------------
  // Update positions.
  var spritePositions=sprite._getPositions();var positions=renderer._renderData.positions;for(var i=0;i<4;i++){var _spritePositions$i=spritePositions[i],x=_spritePositions$i.x,y=_spritePositions$i.y;positions[i].set(wE[0]*x+wE[4]*y+wE[12],wE[1]*x+wE[5]*y+wE[13],wE[2]*x+wE[6]*y+wE[14]);}BoundingBox.transform(sprite._getBounds(),worldMatrix,renderer._bounds);};SimpleSpriteAssembler.updateUVs=function updateUVs(renderer){var spriteUVs=renderer.sprite._getUVs();var renderUVs=renderer._renderData.uvs;var _spriteUVs$=spriteUVs[0],left=_spriteUVs$.x,bottom=_spriteUVs$.y;var _spriteUVs$2=spriteUVs[3],right=_spriteUVs$2.x,top=_spriteUVs$2.y;renderUVs[0].set(left,bottom);renderUVs[1].set(right,bottom);renderUVs[2].set(left,top);renderUVs[3].set(right,top);};return SimpleSpriteAssembler;}(),_class2$8._rectangleTriangles=[0,1,2,2,1,3],_class2$8._worldMatrix=new Matrix(),_class2$8))||_class$9$1);/**
   * @internal
   */var RenderData2D=function RenderData2D(vertexCount,positions,uvs,triangles,color){if(triangles===void 0){triangles=null;}if(color===void 0){color=null;}this.vertexCount=vertexCount;this.positions=positions;this.uvs=uvs;this.triangles=triangles;this.color=color;};/**
   * Sprite Property Dirty Flag.
   */var SpritePropertyDirtyFlag;(function(SpritePropertyDirtyFlag){SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["texture"]=1]="texture";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["size"]=2]="size";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["atlasRotate"]=4]="atlasRotate";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["atlasRegion"]=8]="atlasRegion";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["atlasRegionOffset"]=16]="atlasRegionOffset";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["region"]=32]="region";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["pivot"]=64]="pivot";SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["border"]=128]="border";})(SpritePropertyDirtyFlag||(SpritePropertyDirtyFlag={}));/**
   * Sprite mask layer.
   */exports.SpriteMaskLayer = void 0;(function(SpriteMaskLayer){SpriteMaskLayer[SpriteMaskLayer["Layer0"]=1]="Layer0";SpriteMaskLayer[SpriteMaskLayer["Layer1"]=2]="Layer1";SpriteMaskLayer[SpriteMaskLayer["Layer2"]=4]="Layer2";SpriteMaskLayer[SpriteMaskLayer["Layer3"]=8]="Layer3";SpriteMaskLayer[SpriteMaskLayer["Layer4"]=16]="Layer4";SpriteMaskLayer[SpriteMaskLayer["Layer5"]=32]="Layer5";SpriteMaskLayer[SpriteMaskLayer["Layer6"]=64]="Layer6";SpriteMaskLayer[SpriteMaskLayer["Layer7"]=128]="Layer7";SpriteMaskLayer[SpriteMaskLayer["Layer8"]=256]="Layer8";SpriteMaskLayer[SpriteMaskLayer["Layer9"]=512]="Layer9";SpriteMaskLayer[SpriteMaskLayer["Layer10"]=1024]="Layer10";SpriteMaskLayer[SpriteMaskLayer["Layer11"]=2048]="Layer11";SpriteMaskLayer[SpriteMaskLayer["Layer12"]=4096]="Layer12";SpriteMaskLayer[SpriteMaskLayer["Layer13"]=8192]="Layer13";SpriteMaskLayer[SpriteMaskLayer["Layer14"]=16384]="Layer14";SpriteMaskLayer[SpriteMaskLayer["Layer15"]=32768]="Layer15";SpriteMaskLayer[SpriteMaskLayer["Layer16"]=65536]="Layer16";SpriteMaskLayer[SpriteMaskLayer["Layer17"]=131072]="Layer17";SpriteMaskLayer[SpriteMaskLayer["Layer18"]=262144]="Layer18";SpriteMaskLayer[SpriteMaskLayer["Layer19"]=524288]="Layer19";SpriteMaskLayer[SpriteMaskLayer["Layer20"]=1048576]="Layer20";SpriteMaskLayer[SpriteMaskLayer["Layer21"]=2097152]="Layer21";SpriteMaskLayer[SpriteMaskLayer["Layer22"]=4194304]="Layer22";SpriteMaskLayer[SpriteMaskLayer["Layer23"]=8388608]="Layer23";SpriteMaskLayer[SpriteMaskLayer["Layer24"]=16777216]="Layer24";SpriteMaskLayer[SpriteMaskLayer["Layer25"]=33554432]="Layer25";SpriteMaskLayer[SpriteMaskLayer["Layer26"]=67108864]="Layer26";SpriteMaskLayer[SpriteMaskLayer["Layer27"]=134217728]="Layer27";SpriteMaskLayer[SpriteMaskLayer["Layer28"]=268435456]="Layer28";SpriteMaskLayer[SpriteMaskLayer["Layer29"]=536870912]="Layer29";SpriteMaskLayer[SpriteMaskLayer["Layer30"]=1073741824]="Layer30";SpriteMaskLayer[SpriteMaskLayer["Layer31"]=2147483648]="Layer31";SpriteMaskLayer[SpriteMaskLayer["Everything"]=4294967295]="Everything";})(exports.SpriteMaskLayer||(exports.SpriteMaskLayer={}));var _class$8$1,_descriptor$7,_descriptor2$7,_descriptor3$6,_descriptor4$6,_descriptor5$6,_descriptor6$6,_descriptor7$6,_descriptor8$6,_descriptor9$5,_class2$7;/**
   * A component for masking Sprites.
   */var SpriteMask=(_class$8$1=(_class2$7=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(SpriteMask,_Renderer);/**
     * @internal
     */function SpriteMask(entity){var _this;_this=_Renderer.call(this,entity)||this;_initializerDefineProperty(_this,"influenceLayers",_descriptor$7,_assertThisInitialized(_this));_this._maskElement=void 0;_this._renderData=void 0;_initializerDefineProperty(_this,"_sprite",_descriptor2$7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_width",_descriptor3$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_height",_descriptor4$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_flipX",_descriptor5$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_flipY",_descriptor6$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_alphaCutoff",_descriptor7$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_dirtyFlag",_descriptor8$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_spriteChangeFlag",_descriptor9$5,_assertThisInitialized(_this));_this._renderData=new RenderData2D(4,[],[]);SimpleSpriteAssembler.resetData(_assertThisInitialized(_this));_this.setMaterial(_this._engine._spriteMaskDefaultMaterial);_this.shaderData.setFloat(SpriteMask._alphaCutoffProperty,_this._alphaCutoff);_this._onSpriteChange=_this._onSpriteChange.bind(_assertThisInitialized(_this));return _this;}/**
     * @override
     * @inheritdoc
     */var _proto=SpriteMask.prototype;_proto._onDestroy=function _onDestroy(){this._sprite=null;this._renderData=null;if(this._spriteChangeFlag){this._spriteChangeFlag.destroy();this._spriteChangeFlag=null;}_Renderer.prototype._onDestroy.call(this);}/**
     * @override
     * @inheritdoc
     */;_proto._render=function _render(camera){var _this$sprite;if(!((_this$sprite=this.sprite)!==null&&_this$sprite!==void 0&&_this$sprite.texture)||!this.width||!this.height){return;}// Update position.
  if(this._transformChangeFlag.flag||this._dirtyFlag&DirtyFlag$3.Position){SimpleSpriteAssembler.updatePositions(this);this._dirtyFlag&=~DirtyFlag$3.Position;this._transformChangeFlag.flag=false;}// Update uv.
  if(this._dirtyFlag&DirtyFlag$3.UV){SimpleSpriteAssembler.updateUVs(this);this._dirtyFlag&=~DirtyFlag$3.UV;}var spriteMaskElementPool=this._engine._spriteMaskElementPool;var maskElement=spriteMaskElementPool.getFromPool();maskElement.setValue(this,this._renderData,this.getMaterial());camera._renderPipeline._allSpriteMasks.add(this);this._maskElement=maskElement;}/**
     * @internal
     */;_proto._cloneTo=function _cloneTo(target){target.sprite=this._sprite;};_proto._onSpriteChange=function _onSpriteChange(dirtyFlag){switch(dirtyFlag){case SpritePropertyDirtyFlag.texture:this.shaderData.setTexture(SpriteMask._textureProperty,this.sprite.texture);break;case SpritePropertyDirtyFlag.region:case SpritePropertyDirtyFlag.atlasRegionOffset:this._dirtyFlag|=DirtyFlag$3.All;break;case SpritePropertyDirtyFlag.atlasRegion:this._dirtyFlag|=DirtyFlag$3.UV;break;}};_createClass$3(SpriteMask,[{key:"width",get:/** @internal */ /** @internal */ /** The mask layers the sprite mask influence to. */ /** @internal */ /** @internal */ /**
       * Render width.
       */function get(){if(this._width===undefined&&this._sprite){this.width=this._sprite.width;}return this._width;},set:function set(value){if(this._width!==value){this._width=value;this._dirtyFlag|=DirtyFlag$3.Position;}}/**
       * Render height.
       */},{key:"height",get:function get(){if(this._height===undefined&&this._sprite){this.height=this._sprite.height;}return this._height;},set:function set(value){if(this._height!==value){this._height=value;this._dirtyFlag|=DirtyFlag$3.Position;}}/**
       * Flips the sprite on the X axis.
       */},{key:"flipX",get:function get(){return this._flipX;},set:function set(value){if(this._flipX!==value){this._flipX=value;this._dirtyFlag|=DirtyFlag$3.Position;}}/**
       * Flips the sprite on the Y axis.
       */},{key:"flipY",get:function get(){return this._flipY;},set:function set(value){if(this._flipY!==value){this._flipY=value;this._dirtyFlag|=DirtyFlag$3.Position;}}/**
       * The Sprite to render.
       */},{key:"sprite",get:function get(){return this._sprite;},set:function set(value){if(this._sprite!==value){this._sprite=value;this._spriteChangeFlag&&this._spriteChangeFlag.destroy();if(value){this._spriteChangeFlag=value._registerUpdateFlag();this._spriteChangeFlag.listener=this._onSpriteChange;this._dirtyFlag|=DirtyFlag$3.All;this.shaderData.setTexture(SpriteMask._textureProperty,value.texture);}else {this._spriteChangeFlag=null;this.shaderData.setTexture(SpriteMask._textureProperty,null);}}}/**
       * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.
       */},{key:"alphaCutoff",get:function get(){return this._alphaCutoff;},set:function set(value){if(this._alphaCutoff!==value){this._alphaCutoff=value;this.shaderData.setFloat(SpriteMask._alphaCutoffProperty,value);}}/**
       * The bounding volume of the spriteRenderer.
       */},{key:"bounds",get:function get(){var _this$sprite2;if(!((_this$sprite2=this.sprite)!==null&&_this$sprite2!==void 0&&_this$sprite2.texture)||!this.width||!this.height){return Engine._defaultBoundingBox;}else if(this._transformChangeFlag.flag||this._dirtyFlag&DirtyFlag$3.Position){SimpleSpriteAssembler.updatePositions(this);this._dirtyFlag&=~DirtyFlag$3.Position;this._transformChangeFlag.flag=false;}return this._bounds;}}]);return SpriteMask;}(Renderer),_class2$7._textureProperty=Shader.getPropertyByName("u_maskTexture"),_class2$7._alphaCutoffProperty=Shader.getPropertyByName("u_maskAlphaCutoff"),_class2$7),(_descriptor$7=_applyDecoratedDescriptor(_class$8$1.prototype,"influenceLayers",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskLayer.Everything;}}),_descriptor2$7=_applyDecoratedDescriptor(_class$8$1.prototype,"_sprite",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor3$6=_applyDecoratedDescriptor(_class$8$1.prototype,"_width",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return undefined;}}),_descriptor4$6=_applyDecoratedDescriptor(_class$8$1.prototype,"_height",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return undefined;}}),_descriptor5$6=_applyDecoratedDescriptor(_class$8$1.prototype,"_flipX",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor6$6=_applyDecoratedDescriptor(_class$8$1.prototype,"_flipY",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor7$6=_applyDecoratedDescriptor(_class$8$1.prototype,"_alphaCutoff",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0.5;}}),_descriptor8$6=_applyDecoratedDescriptor(_class$8$1.prototype,"_dirtyFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}}),_descriptor9$5=_applyDecoratedDescriptor(_class$8$1.prototype,"_spriteChangeFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}})),_class$8$1);var DirtyFlag$3;(function(DirtyFlag){DirtyFlag[DirtyFlag["Position"]=1]="Position";DirtyFlag[DirtyFlag["UV"]=2]="UV";DirtyFlag[DirtyFlag["All"]=3]="All";})(DirtyFlag$3||(DirtyFlag$3={}));/**
   * Vertex element format.
   */exports.VertexElementFormat = void 0;(function(VertexElementFormat){VertexElementFormat[VertexElementFormat["Float"]=0]="Float";VertexElementFormat[VertexElementFormat["Vector2"]=1]="Vector2";VertexElementFormat[VertexElementFormat["Vector3"]=2]="Vector3";VertexElementFormat[VertexElementFormat["Vector4"]=3]="Vector4";VertexElementFormat[VertexElementFormat["Byte4"]=4]="Byte4";VertexElementFormat[VertexElementFormat["UByte4"]=5]="UByte4";VertexElementFormat[VertexElementFormat["NormalizedByte4"]=6]="NormalizedByte4";VertexElementFormat[VertexElementFormat["NormalizedUByte4"]=7]="NormalizedUByte4";VertexElementFormat[VertexElementFormat["Short2"]=8]="Short2";VertexElementFormat[VertexElementFormat["UShort2"]=9]="UShort2";VertexElementFormat[VertexElementFormat["NormalizedShort2"]=10]="NormalizedShort2";VertexElementFormat[VertexElementFormat["NormalizedUShort2"]=11]="NormalizedUShort2";VertexElementFormat[VertexElementFormat["Short4"]=12]="Short4";VertexElementFormat[VertexElementFormat["UShort4"]=13]="UShort4";VertexElementFormat[VertexElementFormat["NormalizedShort4"]=14]="NormalizedShort4";VertexElementFormat[VertexElementFormat["NormalizedUShort4"]=15]="NormalizedUShort4";})(exports.VertexElementFormat||(exports.VertexElementFormat={}));/**
   * Buffer usage.
   */exports.BufferUsage = void 0;(function(BufferUsage){BufferUsage[BufferUsage["Static"]=0]="Static";BufferUsage[BufferUsage["Dynamic"]=1]="Dynamic";BufferUsage[BufferUsage["Stream"]=2]="Stream";})(exports.BufferUsage||(exports.BufferUsage={}));/**
   * Index format.
   */exports.IndexFormat = void 0;(function(IndexFormat){IndexFormat[IndexFormat["UInt8"]=0]="UInt8";IndexFormat[IndexFormat["UInt16"]=1]="UInt16";IndexFormat[IndexFormat["UInt32"]=2]="UInt32";})(exports.IndexFormat||(exports.IndexFormat={}));var BufferUtil=/*#__PURE__*/function(){function BufferUtil(){}/**
     * @internal
     */BufferUtil._getGLBufferUsage=function _getGLBufferUsage(gl,bufferUsage){switch(bufferUsage){case exports.BufferUsage.Static:return gl.STATIC_DRAW;case exports.BufferUsage.Dynamic:return gl.DYNAMIC_DRAW;case exports.BufferUsage.Stream:return gl.STREAM_DRAW;}};BufferUtil._getGLIndexType=function _getGLIndexType(indexFormat){switch(indexFormat){case exports.IndexFormat.UInt8:return exports.DataType.UNSIGNED_BYTE;case exports.IndexFormat.UInt16:return exports.DataType.UNSIGNED_SHORT;case exports.IndexFormat.UInt32:return exports.DataType.UNSIGNED_INT;}};BufferUtil._getGLIndexByteCount=function _getGLIndexByteCount(indexFormat){switch(indexFormat){case exports.IndexFormat.UInt8:return 1;case exports.IndexFormat.UInt16:return 2;case exports.IndexFormat.UInt32:return 4;}}/**
     * @internal
     */;BufferUtil._getElementInfo=function _getElementInfo(format){var size;var type;var normalized=false;switch(format){case exports.VertexElementFormat.Float:size=1;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Vector2:size=2;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Vector3:size=3;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Vector4:size=4;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Byte4:size=4;type=exports.DataType.BYTE;break;case exports.VertexElementFormat.UByte4:size=4;type=exports.DataType.UNSIGNED_BYTE;break;case exports.VertexElementFormat.NormalizedByte4:size=4;type=exports.DataType.BYTE;normalized=true;break;case exports.VertexElementFormat.NormalizedUByte4:size=4;type=exports.DataType.UNSIGNED_BYTE;normalized=true;break;case exports.VertexElementFormat.Short2:size=2;type=exports.DataType.SHORT;break;case exports.VertexElementFormat.UShort2:size=2;type=exports.DataType.UNSIGNED_SHORT;break;case exports.VertexElementFormat.NormalizedShort2:size=2;type=exports.DataType.SHORT;normalized=true;break;case exports.VertexElementFormat.NormalizedUShort2:size=2;type=exports.DataType.UNSIGNED_SHORT;normalized=true;break;case exports.VertexElementFormat.Short4:size=4;type=exports.DataType.SHORT;break;case exports.VertexElementFormat.UShort4:size=4;type=exports.DataType.UNSIGNED_SHORT;break;case exports.VertexElementFormat.NormalizedShort4:size=4;type=exports.DataType.SHORT;normalized=true;break;case exports.VertexElementFormat.NormalizedUShort4:size=4;type=exports.DataType.UNSIGNED_SHORT;normalized=true;break;}return {size:size,type:type,normalized:normalized};};return BufferUtil;}();/**
   * Vertex element.
   */var VertexElement=/*#__PURE__*/function(){/**
     * Create vertex element.
     * @param semantic - Input vertex semantic
     * @param offset - Vertex data byte offset
     * @param format - Vertex data format
     * @param bindingIndex - Vertex buffer binding index
     * @param instanceStepRate - Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
     */function VertexElement(semantic,offset,format,bindingIndex,instanceStepRate){if(instanceStepRate===void 0){instanceStepRate=0;}this._glElementInfo=void 0;this._semantic=void 0;this._offset=void 0;this._format=void 0;this._bindingIndex=void 0;this._instanceStepRate=void 0;this._semantic=semantic;this._offset=offset;this._format=format;this._bindingIndex=bindingIndex;this._glElementInfo=BufferUtil._getElementInfo(this.format);this._instanceStepRate=Math.floor(instanceStepRate);}_createClass$3(VertexElement,[{key:"semantic",get:/**
       * Vertex semantic.
       */function get(){return this._semantic;}/**
       * Vertex data byte offset.
       */},{key:"offset",get:function get(){return this._offset;},set:function set(value){this._offset=value;}/**
       * Vertex data format.
       */},{key:"format",get:function get(){return this._format;}/**
       * Vertex buffer binding index.
       */},{key:"bindingIndex",get:function get(){return this._bindingIndex;},set:function set(value){this._bindingIndex=value;}/**
       * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
       */},{key:"instanceStepRate",get:function get(){return this._instanceStepRate;}}]);return VertexElement;}();/**
   * Buffer binding flag.
   */exports.BufferBindFlag = void 0;(function(BufferBindFlag){BufferBindFlag[BufferBindFlag["VertexBuffer"]=0]="VertexBuffer";BufferBindFlag[BufferBindFlag["IndexBuffer"]=1]="IndexBuffer";})(exports.BufferBindFlag||(exports.BufferBindFlag={}));/**
   * Define update strategy when call bufferData/bufferSubData func.
   */exports.SetDataOptions = void 0;(function(SetDataOptions){SetDataOptions[SetDataOptions["None"]=0]="None";SetDataOptions[SetDataOptions["Discard"]=1]="Discard";})(exports.SetDataOptions||(exports.SetDataOptions={}));/**
   * Buffer.
   */var Buffer=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Buffer,_RefObject);function Buffer(engine,type,byteLengthOrData,bufferUsage){var _this;if(bufferUsage===void 0){bufferUsage=exports.BufferUsage.Static;}_this=_RefObject.call(this,engine)||this;_this._glBindTarget=void 0;_this._glBufferUsage=void 0;_this._nativeBuffer=void 0;_this._hardwareRenderer=void 0;_this._type=void 0;_this._byteLength=void 0;_this._bufferUsage=void 0;_this._engine=engine;_this._type=type;_this._bufferUsage=bufferUsage;var hardwareRenderer=engine._hardwareRenderer;var gl=hardwareRenderer.gl;var glBufferUsage=BufferUtil._getGLBufferUsage(gl,bufferUsage);var glBindTarget=type===exports.BufferBindFlag.VertexBuffer?gl.ARRAY_BUFFER:gl.ELEMENT_ARRAY_BUFFER;_this._nativeBuffer=gl.createBuffer();_this._hardwareRenderer=hardwareRenderer;_this._glBufferUsage=glBufferUsage;_this._glBindTarget=glBindTarget;_this.bind();if(typeof byteLengthOrData==="number"){_this._byteLength=byteLengthOrData;gl.bufferData(glBindTarget,byteLengthOrData,glBufferUsage);}else {_this._byteLength=byteLengthOrData.byteLength;gl.bufferData(glBindTarget,byteLengthOrData,glBufferUsage);}gl.bindBuffer(glBindTarget,null);return _this;}/**
     * Bind buffer.
     */var _proto=Buffer.prototype;_proto.bind=function bind(){var gl=this._hardwareRenderer.gl;gl.bindBuffer(this._glBindTarget,this._nativeBuffer);}/**
     * Set buffer data.
     * @param data - Input buffer data
     */;_proto.setData=function setData(data,bufferByteOffset,dataOffset,dataLength,options){if(bufferByteOffset===void 0){bufferByteOffset=0;}if(dataOffset===void 0){dataOffset=0;}if(options===void 0){options=exports.SetDataOptions.None;}var gl=this._hardwareRenderer.gl;var isWebGL2=this._hardwareRenderer.isWebGL2;var glBindTarget=this._glBindTarget;this.bind();if(options===exports.SetDataOptions.Discard){gl.bufferData(glBindTarget,this._byteLength,this._glBufferUsage);}// TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1
  var byteSize=data.BYTES_PER_ELEMENT||1;var dataByteLength=dataLength?byteSize*dataLength:data.byteLength;if(dataOffset!==0||dataByteLength<data.byteLength){var isArrayBufferView=data.byteOffset!==undefined;if(isWebGL2&&isArrayBufferView){gl.bufferSubData(glBindTarget,bufferByteOffset,data,dataOffset,dataByteLength/byteSize);}else {var subData=new Uint8Array(isArrayBufferView?data.buffer:data,dataOffset*byteSize,dataByteLength);gl.bufferSubData(glBindTarget,bufferByteOffset,subData);}}else {gl.bufferSubData(glBindTarget,bufferByteOffset,data);}gl.bindBuffer(glBindTarget,null);}/**
     * Get buffer data.
     * @param data - Output buffer data
     */;_proto.getData=function getData(data,bufferByteOffset,dataOffset,dataLength){if(bufferByteOffset===void 0){bufferByteOffset=0;}if(dataOffset===void 0){dataOffset=0;}var isWebGL2=this._hardwareRenderer.isWebGL2;if(isWebGL2){var gl=this._hardwareRenderer.gl;this.bind();gl.getBufferSubData(this._glBindTarget,bufferByteOffset,data,dataOffset,dataLength);}else {throw "Buffer is write-only on WebGL1.0 platforms.";}}/**
     * @override
     * Destroy.
     */;_proto._onDestroy=function _onDestroy(){var gl=this._hardwareRenderer.gl;gl.deleteBuffer(this._nativeBuffer);this._nativeBuffer=null;this._hardwareRenderer=null;}/**
     * @deprecated
     */;_proto.resize=function resize(dataLength){this.bind();var gl=this._hardwareRenderer.gl;gl.bufferData(this._glBindTarget,dataLength,this._glBufferUsage);this._byteLength=dataLength;};_createClass$3(Buffer,[{key:"type",get:/**
       * Buffer binding flag.
       */function get(){return this._type;}/**
       * Byte length.
       */},{key:"byteLength",get:function get(){return this._byteLength;}/**
       * Buffer usage.
       */},{key:"bufferUsage",get:function get(){return this._bufferUsage;}/**
       * Create Buffer.
       * @param engine - Engine
       * @param type - Buffer binding flag
       * @param byteLength - Byte length
       * @param bufferUsage - Buffer usage
       */}]);return Buffer;}(RefObject);/**
   * Mesh topology.
   */exports.MeshTopology = void 0;(function(MeshTopology){MeshTopology[MeshTopology["Points"]=0]="Points";MeshTopology[MeshTopology["Lines"]=1]="Lines";MeshTopology[MeshTopology["LineLoop"]=2]="LineLoop";MeshTopology[MeshTopology["LineStrip"]=3]="LineStrip";MeshTopology[MeshTopology["Triangles"]=4]="Triangles";MeshTopology[MeshTopology["TriangleStrip"]=5]="TriangleStrip";MeshTopology[MeshTopology["TriangleFan"]=6]="TriangleFan";})(exports.MeshTopology||(exports.MeshTopology={}));/**
   * Index buffer binding.
   */var IndexBufferBinding=/*#__PURE__*/function(){/**
     * Create index buffer binding.
     * @param buffer - Index buffer
     * @param format - Index buffer format
     */function IndexBufferBinding(buffer,format){this._buffer=void 0;this._format=void 0;this._buffer=buffer;this._format=format;}_createClass$3(IndexBufferBinding,[{key:"buffer",get:/** @internal */ /** @internal */ /**
       * Index buffer.
       */function get(){return this._buffer;}/**
       * Index buffer format.
       */},{key:"format",get:function get(){return this._format;}}]);return IndexBufferBinding;}();/**
   * Sub-mesh, mainly contains drawing information.
   */var SubMesh=/** Start drawing offset. */ /** Drawing count. */ /** Drawing topology. */ /**
   * Create a sub-mesh.
   * @param start - Start drawing offset
   * @param count - Drawing count
   * @param topology - Drawing topology
   */function SubMesh(start,count,topology){if(start===void 0){start=0;}if(count===void 0){count=0;}if(topology===void 0){topology=exports.MeshTopology.Triangles;}this.start=void 0;this.count=void 0;this.topology=void 0;this.start=start;this.count=count;this.topology=topology;};/**
   * Mesh.
   */var Mesh=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Mesh,_RefObject);/**
     * Create mesh.
     * @param engine - Engine
     * @param name - Mesh name
     */function Mesh(engine,name){var _this;_this=_RefObject.call(this,engine)||this;_this.name=void 0;_this.bounds=new BoundingBox();_this._vertexElementMap={};_this._glIndexType=void 0;_this._glIndexByteCount=void 0;_this._platformPrimitive=void 0;_this._instanceCount=0;_this._vertexBufferBindings=[];_this._indexBufferBinding=null;_this._vertexElements=[];_this._enableVAO=true;_this._subMeshes=[];_this._updateFlagManager=new UpdateFlagManager();_this.name=name;_this._platformPrimitive=_this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));return _this;}/**
     * Add sub-mesh, each sub-mesh can correspond to an independent material.
     * @param subMesh - Start drawing offset, if the index buffer is set, it means the offset in the index buffer, if not set, it means the offset in the vertex buffer
     * @returns Sub-mesh
     */var _proto=Mesh.prototype;_proto.addSubMesh=function addSubMesh(startOrSubMesh,count,topology){if(topology===void 0){topology=exports.MeshTopology.Triangles;}if(typeof startOrSubMesh==="number"){startOrSubMesh=new SubMesh(startOrSubMesh,count,topology);}this._subMeshes.push(startOrSubMesh);return startOrSubMesh;}/**
     * Remove sub-mesh.
     * @param subMesh - Sub-mesh needs to be removed
     */;_proto.removeSubMesh=function removeSubMesh(subMesh){var subMeshes=this._subMeshes;var index=subMeshes.indexOf(subMesh);if(index!==-1){subMeshes.splice(index,1);}}/**
     * Clear all sub-mesh.
     */;_proto.clearSubMesh=function clearSubMesh(){this._subMeshes.length=0;}/**
     * Register update flag, update flag will be true if the vertex element changes.
     * @returns Update flag
     */;_proto.registerUpdateFlag=function registerUpdateFlag(){return this._updateFlagManager.createFlag(BoolUpdateFlag);}/**
     * @internal
     */;_proto._clearVertexElements=function _clearVertexElements(){this._vertexElements.length=0;var vertexElementMap=this._vertexElementMap;for(var k in vertexElementMap){delete vertexElementMap[k];}}/**
     * @internal
     */;_proto._addVertexElement=function _addVertexElement(element){var semantic=element.semantic;this._vertexElementMap[semantic]=element;this._vertexElements.push(element);this._updateFlagManager.dispatch();}/**
     * @internal
     */;_proto._setVertexBufferBinding=function _setVertexBufferBinding(index,binding){if(this._getRefCount()>0){var lastBinding=this._vertexBufferBindings[index];lastBinding&&lastBinding._buffer._addRefCount(-1);binding._buffer._addRefCount(1);}this._vertexBufferBindings[index]=binding;}/**
     * @internal
     */;_proto._draw=function _draw(shaderProgram,subMesh){this._platformPrimitive.draw(shaderProgram,subMesh);}/**
     * @override
     */;_proto._addRefCount=function _addRefCount(value){_RefObject.prototype._addRefCount.call(this,value);var vertexBufferBindings=this._vertexBufferBindings;for(var i=0,n=vertexBufferBindings.length;i<n;i++){vertexBufferBindings[i]._buffer._addRefCount(value);}}/**
     * @override
     * Destroy.
     */;_proto._onDestroy=function _onDestroy(){this._vertexBufferBindings=null;this._indexBufferBinding=null;this._vertexElements=null;this._vertexElementMap=null;this._platformPrimitive.destroy();};_proto._setVertexElements=function _setVertexElements(elements){this._clearVertexElements();for(var i=0,n=elements.length;i<n;i++){this._addVertexElement(elements[i]);}};_proto._setIndexBufferBinding=function _setIndexBufferBinding(binding){if(binding){this._indexBufferBinding=binding;this._glIndexType=BufferUtil._getGLIndexType(binding.format);this._glIndexByteCount=BufferUtil._getGLIndexByteCount(binding.format);}else {this._indexBufferBinding=null;this._glIndexType=undefined;}};_createClass$3(Mesh,[{key:"subMesh",get:/** Name. */ /** The bounding volume of the mesh. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
       * First sub-mesh. Rendered using the first material.
       */function get(){return this._subMeshes[0]||null;}/**
       * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.
       */},{key:"subMeshes",get:function get(){return this._subMeshes;}}]);return Mesh;}(RefObject);/**
   * Vertex buffer binding.
   */var VertexBufferBinding=/*#__PURE__*/function(){/**
     * Create vertex buffer.
     * @param buffer - Vertex buffer
     * @param stride - Vertex buffer stride
     */function VertexBufferBinding(buffer,stride){this._buffer=void 0;this._stride=void 0;this._buffer=buffer;this._stride=stride;}_createClass$3(VertexBufferBinding,[{key:"buffer",get:/** @internal */ /** @internal */ /**
       * Vertex buffer.
       */function get(){return this._buffer;}/**
       * Vertex buffer stride.
       */},{key:"stride",get:function get(){return this._stride;}}]);return VertexBufferBinding;}();/**
   * Render buffer depth format enumeration.
   */exports.RenderBufferDepthFormat = void 0;(function(RenderBufferDepthFormat){RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"]=0]="Depth";RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"]=1]="DepthStencil";RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"]=2]="Stencil";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"]=3]="Depth16";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"]=4]="Depth24";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"]=5]="Depth32";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"]=6]="Depth24Stencil8";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"]=7]="Depth32Stencil8";})(exports.RenderBufferDepthFormat||(exports.RenderBufferDepthFormat={}));/**
   * Define the face of the cube texture.
   */exports.TextureCubeFace = void 0;(function(TextureCubeFace){TextureCubeFace[TextureCubeFace["PositiveX"]=0]="PositiveX";TextureCubeFace[TextureCubeFace["NegativeX"]=1]="NegativeX";TextureCubeFace[TextureCubeFace["PositiveY"]=2]="PositiveY";TextureCubeFace[TextureCubeFace["NegativeY"]=3]="NegativeY";TextureCubeFace[TextureCubeFace["PositiveZ"]=4]="PositiveZ";TextureCubeFace[TextureCubeFace["NegativeZ"]=5]="NegativeZ";})(exports.TextureCubeFace||(exports.TextureCubeFace={}));/**
   * The filter mode of the texture.
   */exports.TextureFilterMode = void 0;(function(TextureFilterMode){TextureFilterMode[TextureFilterMode["Point"]=0]="Point";TextureFilterMode[TextureFilterMode["Bilinear"]=1]="Bilinear";TextureFilterMode[TextureFilterMode["Trilinear"]=2]="Trilinear";})(exports.TextureFilterMode||(exports.TextureFilterMode={}));/**
   * Texture format enumeration.
   */exports.TextureFormat = void 0;(function(TextureFormat){TextureFormat[TextureFormat["R8G8B8"]=0]="R8G8B8";TextureFormat[TextureFormat["R8G8B8A8"]=1]="R8G8B8A8";TextureFormat[TextureFormat["R4G4B4A4"]=2]="R4G4B4A4";TextureFormat[TextureFormat["R5G5B5A1"]=3]="R5G5B5A1";TextureFormat[TextureFormat["R5G6B5"]=4]="R5G6B5";TextureFormat[TextureFormat["Alpha8"]=5]="Alpha8";TextureFormat[TextureFormat["LuminanceAlpha"]=6]="LuminanceAlpha";TextureFormat[TextureFormat["R16G16B16A16"]=7]="R16G16B16A16";TextureFormat[TextureFormat["R32G32B32A32"]=8]="R32G32B32A32";TextureFormat[TextureFormat["DXT1"]=9]="DXT1";TextureFormat[TextureFormat["DXT5"]=10]="DXT5";TextureFormat[TextureFormat["ETC1_RGB"]=11]="ETC1_RGB";TextureFormat[TextureFormat["ETC2_RGB"]=12]="ETC2_RGB";TextureFormat[TextureFormat["ETC2_RGBA5"]=13]="ETC2_RGBA5";TextureFormat[TextureFormat["ETC2_RGBA8"]=14]="ETC2_RGBA8";TextureFormat[TextureFormat["PVRTC_RGB2"]=15]="PVRTC_RGB2";TextureFormat[TextureFormat["PVRTC_RGBA2"]=16]="PVRTC_RGBA2";TextureFormat[TextureFormat["PVRTC_RGB4"]=17]="PVRTC_RGB4";TextureFormat[TextureFormat["PVRTC_RGBA4"]=18]="PVRTC_RGBA4";TextureFormat[TextureFormat["ASTC_4x4"]=19]="ASTC_4x4";TextureFormat[TextureFormat["ASTC_5x5"]=20]="ASTC_5x5";TextureFormat[TextureFormat["ASTC_6x6"]=21]="ASTC_6x6";TextureFormat[TextureFormat["ASTC_8x8"]=22]="ASTC_8x8";TextureFormat[TextureFormat["ASTC_10x10"]=23]="ASTC_10x10";TextureFormat[TextureFormat["ASTC_12x12"]=24]="ASTC_12x12";TextureFormat[TextureFormat["Depth"]=25]="Depth";TextureFormat[TextureFormat["DepthStencil"]=26]="DepthStencil";TextureFormat[TextureFormat["Stencil"]=27]="Stencil";TextureFormat[TextureFormat["Depth16"]=28]="Depth16";TextureFormat[TextureFormat["Depth24"]=29]="Depth24";TextureFormat[TextureFormat["Depth32"]=30]="Depth32";TextureFormat[TextureFormat["Depth24Stencil8"]=31]="Depth24Stencil8";TextureFormat[TextureFormat["Depth32Stencil8"]=32]="Depth32Stencil8";})(exports.TextureFormat||(exports.TextureFormat={}));/**
   * Wrapping mode of the texture.
   */exports.TextureWrapMode = void 0;(function(TextureWrapMode){TextureWrapMode[TextureWrapMode["Clamp"]=0]="Clamp";TextureWrapMode[TextureWrapMode["Repeat"]=1]="Repeat";TextureWrapMode[TextureWrapMode["Mirror"]=2]="Mirror";})(exports.TextureWrapMode||(exports.TextureWrapMode={}));/**
   * The render target used for off-screen rendering.
   */var RenderTarget=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(RenderTarget,_EngineObject);/**
     * @internal
     */function RenderTarget(engine,width,height,renderTexture,depth,antiAliasing){var _this;if(depth===void 0){depth=exports.RenderBufferDepthFormat.Depth;}if(antiAliasing===void 0){antiAliasing=1;}_this=_EngineObject.call(this,engine)||this;_this._platformRenderTarget=void 0;_this._depth=void 0;_this._antiAliasing=void 0;_this._autoGenerateMipmaps=true;_this._width=void 0;_this._height=void 0;_this._colorTextures=void 0;_this._depthTexture=void 0;_this._width=width;_this._height=height;_this._antiAliasing=antiAliasing;_this._depth=depth;if(renderTexture){_this._colorTextures=renderTexture instanceof Array?renderTexture.slice():[renderTexture];}else {_this._colorTextures=[];}if(depth instanceof Texture){_this._depthTexture=depth;}_this._platformRenderTarget=engine._hardwareRenderer.createPlatformRenderTarget(_assertThisInitialized(_this));return _this;}/**
     *
     * Get the render color texture by index.
     * @param index
     */var _proto=RenderTarget.prototype;_proto.getColorTexture=function getColorTexture(index){if(index===void 0){index=0;}return this._colorTextures[index];}/**
     * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
     */;_proto.generateMipmaps=function generateMipmaps(){if(this._autoGenerateMipmaps){var _colorTextures=this._colorTextures;for(var i=0,n=_colorTextures.length;i<n;i++){var _colorTexture=_colorTextures[i];_colorTexture.generateMipmaps();}this._depthTexture&&this._depthTexture.generateMipmaps();}}/**
     * Destroy render target.
     */;_proto.destroy=function destroy(){this._platformRenderTarget.destroy();this._colorTextures.length=0;this._depthTexture=null;this._depth=null;}/**
     * @internal
     */;_proto._setRenderTargetInfo=function _setRenderTargetInfo(faceIndex,mipLevel){this._platformRenderTarget.setRenderTargetInfo(faceIndex,mipLevel);}/**
     * @internal
     */;_proto._blitRenderTarget=function _blitRenderTarget(){this._platformRenderTarget.blitRenderTarget();};_createClass$3(RenderTarget,[{key:"autoGenerateMipmaps",get:/** @internal */ /** @internal */ /** @internal */ /**
       * Whether to automatically generate multi-level textures.
       */function get(){return this._autoGenerateMipmaps;},set:function set(value){this._autoGenerateMipmaps=value;}/**
       * Render target width.
       */},{key:"width",get:function get(){return this._width;}/**
       * Render target height.
       */},{key:"height",get:function get(){return this._height;}/**
       * Render color texture count.
       */},{key:"colorTextureCount",get:function get(){return this._colorTextures.length;}/**
       * Depth texture.
       */},{key:"depthTexture",get:function get(){return this._depthTexture;}/**
       * Anti-aliasing level.
       * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
       */},{key:"antiAliasing",get:function get(){return this._antiAliasing;}/**
       * Create a render target through color texture and depth format.
       * @param engine - Define the engine to use for this off-screen rendering
       * @param width - Render target width
       * @param height - Render target height
       * @param colorTexture - Render color texture
       * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
       * @param antiAliasing - Anti-aliasing level, default is 1
       */}]);return RenderTarget;}(EngineObject);/**
   * Two-dimensional texture.
   */var Texture2D=/*#__PURE__*/function(_Texture){_inheritsLoose$2(Texture2D,_Texture);/**
     * Create Texture2D.
     * @param engine - Define the engine to use to render this texture
     * @param width - Texture width
     * @param height - Texture height
     * @param format - Texture format. default  `TextureFormat.R8G8B8A8`
     * @param mipmap - Whether to use multi-level texture
     */function Texture2D(engine,width,height,format,mipmap){var _this;if(format===void 0){format=exports.TextureFormat.R8G8B8A8;}if(mipmap===void 0){mipmap=true;}_this=_Texture.call(this,engine)||this;_this._mipmap=mipmap;_this._width=width;_this._height=height;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformTexture2D(_assertThisInitialized(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Repeat;return _this;}/**
     * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */var _proto=Texture2D.prototype;_proto.setPixelBuffer=function setPixelBuffer(colorBuffer,mipLevel,x,y,width,height){if(mipLevel===void 0){mipLevel=0;}if(x===void 0){x=0;}if(y===void 0){y=0;}this._platformTexture.setPixelBuffer(colorBuffer,mipLevel,x,y,width,height);}/**
     * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */;_proto.setImageSource=function setImageSource(imageSource,mipLevel,flipY,premultiplyAlpha,x,y){if(mipLevel===void 0){mipLevel=0;}if(flipY===void 0){flipY=false;}if(premultiplyAlpha===void 0){premultiplyAlpha=false;}if(x===void 0){x=0;}if(y===void 0){y=0;}this._platformTexture.setImageSource(imageSource,mipLevel,flipY,premultiplyAlpha,x,y);}/**
     * Get pixel color buffer.
     * @param out - Color buffer
     */;_proto.getPixelBuffer=function getPixelBuffer(xOrMipLevelOrOut,yOrMipLevel,width,height,mipLevelOrOut,out){var argsLength=arguments.length;if(argsLength===1){this._platformTexture.getPixelBuffer(0,0,this._width,this._height,0,xOrMipLevelOrOut);}else if(argsLength===2){this._platformTexture.getPixelBuffer(0,0,this._width>>xOrMipLevelOrOut,this._height>>xOrMipLevelOrOut,xOrMipLevelOrOut,yOrMipLevel);}else if(argsLength===5){this._platformTexture.getPixelBuffer(xOrMipLevelOrOut,yOrMipLevel,width,height,0,mipLevelOrOut);}else if(argsLength===6){this._platformTexture.getPixelBuffer(xOrMipLevelOrOut,yOrMipLevel,width,height,mipLevelOrOut,out);}};return Texture2D;}(Texture);/**
   * Two-dimensional texture array.
   */var Texture2DArray=/*#__PURE__*/function(_Texture){_inheritsLoose$2(Texture2DArray,_Texture);/**
     * Create Texture2D Array.
     * @param engine - Define the engine to use to render this texture
     * @param width - Texture width
     * @param height - Texture height
     * @param length - Texture length
     * @param format - Texture format. default `TextureFormat.R8G8B8A8`
     * @param mipmap - Whether to use multi-level texture
     */function Texture2DArray(engine,width,height,length,format,mipmap){var _this;if(format===void 0){format=exports.TextureFormat.R8G8B8A8;}if(mipmap===void 0){mipmap=true;}_this=_Texture.call(this,engine)||this;_this._length=void 0;_this._mipmap=mipmap;_this._width=width;_this._height=height;_this._length=length;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformTexture2DArray(_assertThisInitialized(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Repeat;return _this;}/**
     * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
     * @param offsetIndex - The texture array element offset index
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     * @param length - Data length. if it's empty, length is the length of Texture2DArray.length
     */var _proto=Texture2DArray.prototype;_proto.setPixelBuffer=function setPixelBuffer(offsetIndex,colorBuffer,mipLevel,x,y,width,height,length){if(mipLevel===void 0){mipLevel=0;}if(x===void 0){x=0;}if(y===void 0){y=0;}this._platformTexture.setPixelBuffer(offsetIndex,colorBuffer,mipLevel,x,y,width,height,length);}/**
     * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
     * @param elementIndex - The texture array element index
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */;_proto.setImageSource=function setImageSource(elementIndex,imageSource,mipLevel,flipY,premultiplyAlpha,x,y){if(mipLevel===void 0){mipLevel=0;}if(flipY===void 0){flipY=false;}if(premultiplyAlpha===void 0){premultiplyAlpha=false;}if(x===void 0){x=0;}if(y===void 0){y=0;}this._platformTexture.setImageSource(elementIndex,imageSource,mipLevel,flipY,premultiplyAlpha,x,y);}/**
     * Get pixel color buffer.
     * @param elementIndex - The texture array element index
     * @param out - Color buffer
     */;_proto.getPixelBuffer=function getPixelBuffer(elementIndex,xOrMipLevelOrOut,yOrMipLevel,width,height,mipLevelOrOut,out){var argsLength=arguments.length;if(argsLength===1){this._platformTexture.getPixelBuffer(elementIndex,0,0,this._width,this._height,0,xOrMipLevelOrOut);}else if(argsLength===2){this._platformTexture.getPixelBuffer(elementIndex,0,0,this._width>>xOrMipLevelOrOut,this._height>>xOrMipLevelOrOut,xOrMipLevelOrOut,yOrMipLevel);}else if(argsLength===5){this._platformTexture.getPixelBuffer(elementIndex,xOrMipLevelOrOut,yOrMipLevel,width,height,0,mipLevelOrOut);}else if(argsLength===6){this._platformTexture.getPixelBuffer(elementIndex,xOrMipLevelOrOut,yOrMipLevel,width,height,mipLevelOrOut,out);}};_createClass$3(Texture2DArray,[{key:"length",get:/**
       * The length of the texture.
       */function get(){return this._length;}}]);return Texture2DArray;}(Texture);/**
   * Cube texture.
   */var TextureCube=/*#__PURE__*/function(_Texture){_inheritsLoose$2(TextureCube,_Texture);/**
     * Create TextureCube.
     * @param engine - Define the engine to use to render this texture
     * @param size - Texture size. texture width must be equal to height in cube texture
     * @param format - Texture format,default TextureFormat.R8G8B8A8
     * @param mipmap - Whether to use multi-level texture
     */function TextureCube(engine,size,format,mipmap){var _this;if(format===void 0){format=exports.TextureFormat.R8G8B8A8;}if(mipmap===void 0){mipmap=true;}_this=_Texture.call(this,engine)||this;_this._mipmap=mipmap;_this._width=size;_this._height=size;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformTextureCube(_assertThisInitialized(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Clamp;return _this;}/**
     * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
     * @param face - Cube face
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y -  Y coordinate of area start
     * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */var _proto=TextureCube.prototype;_proto.setPixelBuffer=function setPixelBuffer(face,colorBuffer,mipLevel,x,y,width,height){if(mipLevel===void 0){mipLevel=0;}if(x===void 0){x=0;}if(y===void 0){y=0;}this._platformTexture.setPixelBuffer(face,colorBuffer,mipLevel,x,y,width,height);}/**
     * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
     * @param face - Cube face
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */;_proto.setImageSource=function setImageSource(face,imageSource,mipLevel,flipY,premultiplyAlpha,x,y){if(mipLevel===void 0){mipLevel=0;}if(flipY===void 0){flipY=false;}if(premultiplyAlpha===void 0){premultiplyAlpha=false;}if(x===void 0){x=0;}if(y===void 0){y=0;}this._platformTexture.setImageSource(face,imageSource,mipLevel,flipY,premultiplyAlpha,x,y);}/**
     * Get pixel color buffer.
     * @param out - Color buffer
     */;_proto.getPixelBuffer=function getPixelBuffer(face,xOrMipLevelOrOut,yOrMipLevel,width,height,mipLevelOrOut,out){var argsLength=arguments.length;if(argsLength===2){this._platformTexture.getPixelBuffer(face,0,0,this._width,this._height,0,xOrMipLevelOrOut);}else if(argsLength===3){this._platformTexture.getPixelBuffer(face,0,0,this._width>>xOrMipLevelOrOut,this._height>>xOrMipLevelOrOut,xOrMipLevelOrOut,yOrMipLevel);}else if(argsLength===6){this._platformTexture.getPixelBuffer(face,xOrMipLevelOrOut,yOrMipLevel,width,height,0,mipLevelOrOut);}else if(argsLength===7){this._platformTexture.getPixelBuffer(face,xOrMipLevelOrOut,yOrMipLevel,width,height,mipLevelOrOut,out);}};return TextureCube;}(Texture);/**
   * @internal
   */var BlendShapeManager=/*#__PURE__*/function(){/** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */function BlendShapeManager(engine,modelMesh){this._blendShapeCount=0;this._blendShapes=[];this._blendShapeNames=void 0;this._layoutDirtyListener=new ListenerUpdateFlag();this._subDataDirtyFlags=[];this._vertexTexture=void 0;this._vertexBuffers=[];this._vertices=void 0;this._useBlendNormal=false;this._useBlendTangent=false;this._vertexElementCount=0;this._vertexElementOffset=void 0;this._storeInVertexBufferInfo=[];this._maxCountSingleVertexBuffer=0;this._engine=void 0;this._modelMesh=void 0;this._lastCreateHostInfo=new Vector3(0,0,0);this._canUseTextureStoreData=true;this._dataTextureInfo=new Vector3();this._engine=engine;this._modelMesh=modelMesh;this._canUseTextureStoreData=this._engine._hardwareRenderer.capability.canUseFloatTextureBlendShape;this._layoutDirtyListener.listener=this._updateLayoutChange.bind(this);}/**
     * @internal
     */var _proto=BlendShapeManager.prototype;_proto._addBlendShape=function _addBlendShape(blendShape){this._blendShapes.push(blendShape);this._blendShapeCount++;blendShape._addLayoutChangeFlag(this._layoutDirtyListener);this._updateLayoutChange(blendShape);this._subDataDirtyFlags.push(blendShape._createSubDataDirtyFlag());}/**
     * @internal
     */;_proto._clearBlendShapes=function _clearBlendShapes(){this._useBlendNormal=false;this._useBlendTangent=false;this._vertexElementCount=0;this._blendShapes.length=0;this._blendShapeCount=0;this._layoutDirtyListener.clearFromManagers();var subDataDirtyFlags=this._subDataDirtyFlags;for(var i=0,n=subDataDirtyFlags.length;i<n;i++){subDataDirtyFlags[i].destroy();}subDataDirtyFlags.length=0;}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(shaderData,skinnedMeshRenderer){var blendShapeCount=this._blendShapeCount;if(blendShapeCount>0){shaderData.enableMacro(BlendShapeManager._blendShapeMacro);if(this._useTextureMode()){shaderData.enableMacro(BlendShapeManager._blendShapeTextureMacro);shaderData.setTexture(BlendShapeManager._blendShapeTextureProperty,this._vertexTexture);shaderData.setVector3(BlendShapeManager._blendShapeTextureInfoProperty,this._dataTextureInfo);shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty,skinnedMeshRenderer.blendShapeWeights);}else {var maxBlendCount=this._getVertexBufferModeSupportCount();if(blendShapeCount>maxBlendCount){var condensedBlendShapeWeights=skinnedMeshRenderer._condensedBlendShapeWeights;if(!condensedBlendShapeWeights){condensedBlendShapeWeights=new Float32Array(maxBlendCount);skinnedMeshRenderer._condensedBlendShapeWeights=condensedBlendShapeWeights;}this._filterCondensedBlendShapeWeights(skinnedMeshRenderer.blendShapeWeights,condensedBlendShapeWeights);shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty,condensedBlendShapeWeights);this._modelMesh._enableVAO=false;blendShapeCount=maxBlendCount;}else {shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty,skinnedMeshRenderer.blendShapeWeights);this._modelMesh._enableVAO=true;}shaderData.disableMacro(BlendShapeManager._blendShapeTextureMacro);}shaderData.enableMacro("OASIS_BLENDSHAPE_COUNT",blendShapeCount.toString());if(this._useBlendNormal){shaderData.enableMacro(BlendShapeManager._blendShapeNormalMacro);}else {shaderData.disableMacro(BlendShapeManager._blendShapeNormalMacro);}if(this._useBlendTangent){shaderData.enableMacro(BlendShapeManager._blendShapeTangentMacro);}else {shaderData.disableMacro(BlendShapeManager._blendShapeTangentMacro);}}else {shaderData.disableMacro(BlendShapeManager._blendShapeMacro);shaderData.disableMacro("OASIS_BLENDSHAPE_COUNT");}}/**
     * @internal
     */;_proto._useTextureMode=function _useTextureMode(){if(!this._canUseTextureStoreData){return false;}return this._blendShapeCount>this._getVertexBufferModeSupportCount();}/**
     * @internal
     */;_proto._layoutOrCountChange=function _layoutOrCountChange(){var last=this._lastCreateHostInfo;return last.x!==this._blendShapeCount||!!last.y!==this._useBlendNormal||!!last.z!==this._useBlendTangent;}/**
     * @internal
     */;_proto._vertexElementsNeedUpdate=function _vertexElementsNeedUpdate(){var maxSupportCount=this._getVertexBufferModeSupportCount();var info=this._lastCreateHostInfo;return Math.min(info.x,maxSupportCount)!==Math.min(this._blendShapeCount,maxSupportCount)||!!info.y!==this._useBlendNormal||!!info.z!==this._useBlendTangent;}/**
     * @internal
     */;_proto._needUpdateData=function _needUpdateData(){var subDataDirtyFlags=this._subDataDirtyFlags;for(var i=0,n=subDataDirtyFlags.length;i<n;i++){if(subDataDirtyFlags[i].flag){return true;}}return false;}/**
     * @internal
     */;_proto._addVertexElements=function _addVertexElements(modelMesh){var offset=0;this._vertexElementOffset=modelMesh._vertexElements.length;for(var i=0,n=Math.min(this._blendShapeCount,this._getVertexBufferModeSupportCount());i<n;i++){modelMesh._addVertexElement(new VertexElement("POSITION_BS"+i,offset,exports.VertexElementFormat.Vector3,1));offset+=12;if(this._useBlendNormal){modelMesh._addVertexElement(new VertexElement("NORMAL_BS"+i,offset,exports.VertexElementFormat.Vector3,1));offset+=12;}if(this._useBlendTangent){modelMesh._addVertexElement(new VertexElement("TANGENT_BS"+i,offset,exports.VertexElementFormat.Vector3,1));offset+=12;}}}/**
     * @internal
     */;_proto._update=function _update(vertexCountChange,noLongerAccessible){var vertexCount=this._modelMesh.vertexCount;var useTexture=this._useTextureMode();var createHost=this._layoutOrCountChange()||vertexCountChange;if(createHost){if(useTexture){this._createTextureArray(vertexCount);}else {this._createVertexBuffers(vertexCount,noLongerAccessible);}this._lastCreateHostInfo.set(this._blendShapeCount,+this._useBlendNormal,+this._useBlendTangent);}if(this._needUpdateData()){if(useTexture){this._updateTextureArray(vertexCount,createHost);}else {this._updateVertexBuffers(vertexCount,createHost);}}}/**
     * @internal
     */;_proto._releaseMemoryCache=function _releaseMemoryCache(){var blendShapes=this._blendShapes;var blendShapeCount=blendShapes.length;var blendShapeNamesMap=new Array(blendShapeCount);for(var i=0;i<blendShapeCount;i++){blendShapeNamesMap[i]=blendShapes[i].name;}this._blendShapeNames=blendShapeNamesMap;this._layoutDirtyListener.destroy();var dataChangedFlags=this._subDataDirtyFlags;for(var _i=0,n=dataChangedFlags.length;_i<n;_i++){dataChangedFlags[_i].destroy();}this._layoutDirtyListener=null;this._subDataDirtyFlags=null;this._blendShapes=null;this._vertices=null;};_proto._createVertexBuffers=function _createVertexBuffers(vertexCount,noLongerAccessible){var engine=this._engine,modelMesh=this._modelMesh,blendShapeCount=this._blendShapeCount,vertexBuffers=this._vertexBuffers;var vertexFloatCount=this._vertexElementCount*3;var vertexByteCount=vertexFloatCount*4;var maxCountSingleBuffer=Math.floor(255/vertexByteCount);// 255: Attribute MaxStride
  var bufferCount=Math.ceil(blendShapeCount/maxCountSingleBuffer);var floatCount=vertexFloatCount*vertexCount*Math.min(maxCountSingleBuffer,blendShapeCount);vertexBuffers.length=bufferCount;this._vertices=new Float32Array(floatCount);this._maxCountSingleVertexBuffer=maxCountSingleBuffer;this._storeInVertexBufferInfo.length=blendShapeCount;for(var i=0;i<bufferCount;i++){var lastIndex=bufferCount-1;var containCount=i===lastIndex?blendShapeCount-lastIndex*maxCountSingleBuffer:maxCountSingleBuffer;var stride=containCount*vertexByteCount;var byteLength=stride*vertexCount;var usage=noLongerAccessible?exports.BufferUsage.Static:exports.BufferUsage.Dynamic;var blendShapeBuffer=new Buffer(engine,exports.BufferBindFlag.VertexBuffer,byteLength,usage);modelMesh._setVertexBufferBinding(i+1,new VertexBufferBinding(blendShapeBuffer,stride));vertexBuffers[i]=blendShapeBuffer;}};_proto._createTextureArray=function _createTextureArray(vertexCount){var maxTextureSize=this._engine._hardwareRenderer.capability.maxTextureSize;var vertexPixelStride=this._vertexElementCount;var textureWidth=vertexPixelStride*vertexCount;var textureHeight=1;if(textureWidth>maxTextureSize){textureHeight=Math.ceil(textureWidth/maxTextureSize);textureWidth=maxTextureSize;}var blendShapeDataTexture=this._vertexTexture;var blendShapeCount=this._blendShapes.length;blendShapeDataTexture&&blendShapeDataTexture.destroy();blendShapeDataTexture=new Texture2DArray(this._engine,textureWidth,textureHeight,blendShapeCount,exports.TextureFormat.R32G32B32A32,false);blendShapeDataTexture.filterMode=exports.TextureFilterMode.Point;this._vertices=new Float32Array(blendShapeCount*textureWidth*textureHeight*4);this._vertexTexture=blendShapeDataTexture;this._dataTextureInfo.set(vertexPixelStride,textureWidth,textureHeight);}/**
     * @internal
     */;_proto._updateVertexBuffers=function _updateVertexBuffers(vertexCount,force){var blendShapes=this._blendShapes,maxCountSingleBuffer=this._maxCountSingleVertexBuffer;var vertices=this._vertices,vertexBuffers=this._vertexBuffers,storeInfos=this._storeInVertexBufferInfo;var subDataDirtyFlags=this._subDataDirtyFlags;var blendShapeFloatStride=this._vertexElementCount*3;var blendShapeByteStride=blendShapeFloatStride*4;// @todo: should fix bug when dataChangedFlag is true
  for(var i=0,n=blendShapes.length;i<n;i++){var dataChangedFlag=subDataDirtyFlags[i];if(force||dataChangedFlag.flag){var frames=blendShapes[i].frames;var frameCount=frames.length;var endFrame=frames[frameCount-1];if(frameCount>0&&endFrame.deltaPositions.length!==vertexCount){throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";}var bufferIndex=Math.floor(i/maxCountSingleBuffer);var indexInBuffer=i%maxCountSingleBuffer;var buffer=vertexBuffers[bufferIndex];var bufferFloatStride=buffer.byteLength/(vertexCount*4);var offset=indexInBuffer*blendShapeFloatStride;var storeInfo=storeInfos[i];storeInfo||(storeInfos[i]=storeInfo=new Vector2());storeInfo.set(bufferIndex+1,indexInBuffer*blendShapeByteStride);// BlendShape buffer is start from 1
  var _endFrame=endFrame,deltaPositions=_endFrame.deltaPositions;for(var j=0;j<vertexCount;j++){var start=offset+bufferFloatStride*j;var deltaPosition=deltaPositions[j];if(deltaPosition){vertices[start]=deltaPosition.x;vertices[start+1]=deltaPosition.y;vertices[start+2]=deltaPosition.z;}}offset+=3;if(this._useBlendNormal){var _endFrame2=endFrame,deltaNormals=_endFrame2.deltaNormals;if(deltaNormals){for(var _j=0;_j<vertexCount;_j++){var _start=offset+bufferFloatStride*_j;var deltaNormal=deltaNormals[_j];if(deltaNormal){vertices[_start]=deltaNormal.x;vertices[_start+1]=deltaNormal.y;vertices[_start+2]=deltaNormal.z;}}}offset+=3;}if(this._useBlendTangent){var _endFrame3=endFrame,deltaTangents=_endFrame3.deltaTangents;if(deltaTangents){for(var _j2=0;_j2<vertexCount;_j2++){var _start2=offset+bufferFloatStride*_j2;var deltaTangent=deltaTangents[_j2];if(deltaTangent){vertices[_start2]=deltaTangent.x;vertices[_start2+1]=deltaTangent.y;vertices[_start2+2]=deltaTangent.z;}}}offset+=3;}if(indexInBuffer===maxCountSingleBuffer-1||i===n-1){// @todo: can optimize in setData
  buffer.setData(vertices,0,0,buffer.byteLength/4);}dataChangedFlag.flag=false;}}};_proto._updateTextureArray=function _updateTextureArray(vertexCount,force){var blendShapes=this._blendShapes,vertexTexture=this._vertexTexture,vertices=this._vertices,subDataDirtyFlags=this._subDataDirtyFlags;for(var i=0,n=blendShapes.length;i<n;i++){var subDirtyFlag=subDataDirtyFlags[i];var subBlendShapeDataStride=vertexTexture.width*vertexTexture.height*4;if(force||subDirtyFlag.flag){var frames=blendShapes[i].frames;var frameCount=frames.length;var endFrame=frames[frameCount-1];if(frameCount>0&&endFrame.deltaPositions.length!==vertexCount){throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";}var _endFrame4=endFrame,deltaPositions=_endFrame4.deltaPositions,deltaNormals=_endFrame4.deltaNormals,deltaTangents=_endFrame4.deltaTangents;var offset=i*subBlendShapeDataStride;for(var j=0;j<vertexCount;j++){var position=deltaPositions[j];vertices[offset]=position.x;vertices[offset+1]=position.y;vertices[offset+2]=position.z;offset+=4;if(deltaNormals){var normal=deltaNormals[j];vertices[offset]=normal.x;vertices[offset+1]=normal.y;vertices[offset+2]=normal.z;offset+=4;}if(deltaTangents){var tangent=deltaTangents[j];vertices[offset]=tangent.x;vertices[offset+1]=tangent.y;vertices[offset+2]=tangent.z;offset+=4;}}subDirtyFlag.flag=false;}}vertexTexture.setPixelBuffer(0,vertices);};_proto._updateLayoutChange=function _updateLayoutChange(blendShape){var notFirst=this._blendShapeCount>1;var vertexElementCount=1;var useBlendNormal=blendShape._useBlendShapeNormal;var useBlendTangent=blendShape._useBlendShapeTangent;if(notFirst){useBlendNormal&&(useBlendNormal=this._useBlendNormal);useBlendTangent&&(useBlendTangent=this._useBlendTangent);}useBlendNormal&&vertexElementCount++;useBlendTangent&&vertexElementCount++;this._useBlendNormal=useBlendNormal;this._useBlendTangent=useBlendTangent;this._vertexElementCount=vertexElementCount;};_proto._attributeModeUpdateVertexElement=function _attributeModeUpdateVertexElement(vertexElements,vertexBufferStoreInfo,index,condensedIndex){var elementOffset=this._vertexElementOffset+this._vertexElementCount*condensedIndex;var _vertexBufferStoreInf=vertexBufferStoreInfo[index],bufferIndex=_vertexBufferStoreInf.x,offset=_vertexBufferStoreInf.y;var vertexElement=vertexElements[elementOffset];vertexElement.bindingIndex=bufferIndex;vertexElement.offset=offset;if(this._useBlendNormal){var _vertexElement=vertexElements[++elementOffset];offset+=12;_vertexElement.bindingIndex=bufferIndex;_vertexElement.offset=offset;}if(this._useBlendTangent){var _vertexElement2=vertexElements[++elementOffset];offset+=12;_vertexElement2.bindingIndex=bufferIndex;_vertexElement2.offset=offset;}};_proto._getVertexBufferModeSupportCount=function _getVertexBufferModeSupportCount(){if(this._useBlendNormal||this._useBlendTangent){return 4;}else {return 8;}};_proto._filterCondensedBlendShapeWeights=function _filterCondensedBlendShapeWeights(blendShapeWeights,condensedBlendShapeWeights){var condensedWeightsCount=condensedBlendShapeWeights.length;var vertexElements=this._modelMesh._vertexElements;var vertexBufferStoreInfo=this._storeInVertexBufferInfo;var thresholdWeight=Number.POSITIVE_INFINITY;var thresholdIndex;for(var i=0,n=Math.min(blendShapeWeights.length,this._blendShapeCount);i<n;i++){var weight=blendShapeWeights[i];if(i<condensedWeightsCount){this._attributeModeUpdateVertexElement(vertexElements,vertexBufferStoreInfo,i,i);condensedBlendShapeWeights[i]=weight;if(weight<thresholdWeight){thresholdWeight=weight;thresholdIndex=i;}}else if(weight>thresholdWeight){this._attributeModeUpdateVertexElement(vertexElements,vertexBufferStoreInfo,i,thresholdIndex);condensedBlendShapeWeights[thresholdIndex]=weight;thresholdWeight=Number.POSITIVE_INFINITY;for(var j=0;j<condensedWeightsCount;j++){var condensedWeight=condensedBlendShapeWeights[j];if(condensedWeight<thresholdWeight){thresholdWeight=condensedWeight;thresholdIndex=j;}}}}};return BlendShapeManager;}();BlendShapeManager._blendShapeMacro=Shader.getMacroByName("OASIS_BLENDSHAPE");BlendShapeManager._blendShapeTextureMacro=Shader.getMacroByName("OASIS_BLENDSHAPE_TEXTURE");BlendShapeManager._blendShapeNormalMacro=Shader.getMacroByName("OASIS_BLENDSHAPE_NORMAL");BlendShapeManager._blendShapeTangentMacro=Shader.getMacroByName("OASIS_BLENDSHAPE_TANGENT");BlendShapeManager._blendShapeWeightsProperty=Shader.getPropertyByName("u_blendShapeWeights");BlendShapeManager._blendShapeTextureProperty=Shader.getPropertyByName("u_blendShapeTexture");BlendShapeManager._blendShapeTextureInfoProperty=Shader.getPropertyByName("u_blendShapeTextureInfo");/**
   * Mesh containing common vertex elements of the model.
   */var ModelMesh=/*#__PURE__*/function(_Mesh){_inheritsLoose$2(ModelMesh,_Mesh);/**
     * Create a model mesh.
     * @param engine - Engine to which the mesh belongs
     * @param name - Mesh name
     */function ModelMesh(engine,name){var _this;_this=_Mesh.call(this,engine)||this;_this._blendShapeManager=void 0;_this._vertexCount=0;_this._accessible=true;_this._verticesFloat32=null;_this._verticesUint8=null;_this._indices=null;_this._indicesFormat=null;_this._vertexSlotChanged=true;_this._vertexChangeFlag=0;_this._indicesChangeFlag=false;_this._vertexStrideFloat=0;_this._lastUploadVertexCount=-1;_this._positions=[];_this._normals=null;_this._colors=null;_this._tangents=null;_this._uv=null;_this._uv1=null;_this._uv2=null;_this._uv3=null;_this._uv4=null;_this._uv5=null;_this._uv6=null;_this._uv7=null;_this._boneWeights=null;_this._boneIndices=null;_this.name=name;_this._blendShapeManager=new BlendShapeManager(engine,_assertThisInitialized(_this));return _this;}/**
     * Set positions for the mesh.
     * @param positions - The positions for the mesh.
     */var _proto=ModelMesh.prototype;_proto.setPositions=function setPositions(positions){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}this._positions=positions;this._vertexCount=positions.length;this._vertexChangeFlag|=ValueChanged.Position;}/**
     * Get positions for the mesh.
     * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.
     */;_proto.getPositions=function getPositions(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._positions;}/**
     * Set per-vertex normals for the mesh.
     * @param normals - The normals for the mesh.
     */;_proto.setNormals=function setNormals(normals){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(normals.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._normals!==!!normals;this._vertexChangeFlag|=ValueChanged.Normal;this._normals=normals;}/**
     * Get normals for the mesh.
     * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.
     */;_proto.getNormals=function getNormals(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._normals;}/**
     * Set per-vertex colors for the mesh.
     * @param colors - The colors for the mesh.
     */;_proto.setColors=function setColors(colors){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(colors.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._colors!==!!colors;this._vertexChangeFlag|=ValueChanged.Color;this._colors=colors;}/**
     * Get colors for the mesh.
     * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.
     */;_proto.getColors=function getColors(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._colors;}/**
     * Set per-vertex bone weights for the mesh.
     * @param boneWeights - The bone weights for the mesh.
     */;_proto.setBoneWeights=function setBoneWeights(boneWeights){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(boneWeights.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=boneWeights!=null;this._vertexChangeFlag|=ValueChanged.BoneWeight;this._boneWeights=boneWeights;}/**
     * Get weights for the mesh.
     * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.
     */;_proto.getBoneWeights=function getBoneWeights(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._boneWeights;}/**
     * Set per-vertex bone indices for the mesh.
     * @param boneIndices - The bone indices for the mesh.
     */;_proto.setBoneIndices=function setBoneIndices(boneIndices){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(boneIndices.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._boneIndices!==!!boneIndices;this._vertexChangeFlag|=ValueChanged.BoneIndex;this._boneIndices=boneIndices;}/**
     * Get joints for the mesh.
     * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.
     */;_proto.getBoneIndices=function getBoneIndices(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._boneIndices;}/**
     * Set per-vertex tangents for the mesh.
     * @param tangents - The tangents for the mesh.
     */;_proto.setTangents=function setTangents(tangents){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(tangents.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._tangents!==!!tangents;this._vertexChangeFlag|=ValueChanged.Tangent;this._tangents=tangents;}/**
     * Get tangents for the mesh.
     * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.
     */;_proto.getTangents=function getTangents(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._tangents;}/**
     * Set per-vertex uv for the mesh.
     * @param uv - The uv for the mesh.
     */;_proto.setUVs=function setUVs(uv,channelIndex){var _channelIndex;if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(uv.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}channelIndex=(_channelIndex=channelIndex)!=null?_channelIndex:0;switch(channelIndex){case 0:this._vertexSlotChanged=!!this._uv!==!!uv;this._vertexChangeFlag|=ValueChanged.UV;this._uv=uv;break;case 1:this._vertexSlotChanged=!!this._uv1!==!!uv;this._vertexChangeFlag|=ValueChanged.UV1;this._uv1=uv;break;case 2:this._vertexSlotChanged=!!this._uv2!==!!uv;this._vertexChangeFlag|=ValueChanged.UV2;this._uv2=uv;break;case 3:this._vertexSlotChanged=!!this._uv3!==!!uv;this._vertexChangeFlag|=ValueChanged.UV3;this._uv3=uv;break;case 4:this._vertexSlotChanged=!!this._uv4!==!!uv;this._vertexChangeFlag|=ValueChanged.UV4;this._uv4=uv;break;case 5:this._vertexSlotChanged=!!this._uv5!==!!uv;this._vertexChangeFlag|=ValueChanged.UV5;this._uv5=uv;break;case 6:this._vertexSlotChanged=!!this._uv6!==!!uv;this._vertexChangeFlag|=ValueChanged.UV6;this._uv6=uv;break;case 7:this._vertexSlotChanged=!!this._uv7!==!!uv;this._vertexChangeFlag|=ValueChanged.UV7;this._uv7=uv;break;default:throw "The index of channel needs to be in range [0 - 7].";}}/**
     * Get uv for the mesh.
     * @remarks Please call the setUV() method after modification to ensure that the modification takes effect.
     */;_proto.getUVs=function getUVs(channelIndex){var _channelIndex2;if(!this._accessible){throw "Not allowed to access data while accessible is false.";}channelIndex=(_channelIndex2=channelIndex)!=null?_channelIndex2:0;switch(channelIndex){case 0:return this._uv;case 1:return this._uv1;case 2:return this._uv2;case 3:return this._uv3;case 4:return this._uv4;case 5:return this._uv5;case 6:return this._uv6;case 7:return this._uv7;}throw "The index of channel needs to be in range [0 - 7].";}/**
     * Set indices for the mesh.
     * @param indices - The indices for the mesh.
     */;_proto.setIndices=function setIndices(indices){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(this._indices!==indices){this._indices=indices;if(indices instanceof Uint8Array){this._indicesFormat=exports.IndexFormat.UInt8;}else if(indices instanceof Uint16Array){this._indicesFormat=exports.IndexFormat.UInt16;}else if(indices instanceof Uint32Array){this._indicesFormat=exports.IndexFormat.UInt32;}}this._indicesChangeFlag=true;}/**
     * Get indices for the mesh.
     */;_proto.getIndices=function getIndices(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._indices;}/**
     * Add a BlendShape for this ModelMesh.
     * @param blendShape - The BlendShape
     */;_proto.addBlendShape=function addBlendShape(blendShape){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}this._blendShapeManager._addBlendShape(blendShape);}/**
     * Clear all BlendShapes.
     */;_proto.clearBlendShapes=function clearBlendShapes(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}this._blendShapeManager._clearBlendShapes();}/**
     * Get name of BlendShape by given index.
     * @param index - The index of BlendShape
     * @returns The name of BlendShape
     */;_proto.getBlendShapeName=function getBlendShapeName(index){if(this._accessible){var blendShapes=this._blendShapeManager._blendShapes;return blendShapes[index].name;}else {return this._blendShapeManager._blendShapeNames[index];}}/**
     * Upload Mesh Data to GPU.
     * @param noLongerAccessible - Whether to access data later. If true, you'll never access data anymore (free memory cache)
     */;_proto.uploadData=function uploadData(noLongerAccessible){var _this$_vertexBufferBi,_this$_indexBufferBin;if(!this._accessible){throw "Not allowed to access data while accessible is false.";}var vertexCount=this._vertexCount;var vertexElementChanged=this._updateVertexElements();var vertexCountChange=this._lastUploadVertexCount!==vertexCount;// Vertex count change
  var vertexBuffer=(_this$_vertexBufferBi=this._vertexBufferBindings[0])===null||_this$_vertexBufferBi===void 0?void 0:_this$_vertexBufferBi._buffer;if(vertexCountChange){vertexBuffer===null||vertexBuffer===void 0?void 0:vertexBuffer.destroy();var elementCount=this._vertexStrideFloat;var vertexFloatCount=elementCount*vertexCount;var vertices=new Float32Array(vertexFloatCount);this._verticesFloat32=vertices;this._verticesUint8=new Uint8Array(vertices.buffer);this._updateVertices(vertices,true);var newVertexBuffer=new Buffer(this._engine,exports.BufferBindFlag.VertexBuffer,vertices,noLongerAccessible?exports.BufferUsage.Static:exports.BufferUsage.Dynamic);this._setVertexBufferBinding(0,new VertexBufferBinding(newVertexBuffer,elementCount*4));this._lastUploadVertexCount=vertexCount;}else {if(this._vertexChangeFlag&ValueChanged.All){var _vertices=this._verticesFloat32;this._updateVertices(_vertices,vertexElementChanged);vertexBuffer.setData(_vertices);}}var indices=this._indices;var indexBuffer=(_this$_indexBufferBin=this._indexBufferBinding)===null||_this$_indexBufferBin===void 0?void 0:_this$_indexBufferBin._buffer;if(indices){if(!indexBuffer||indices.byteLength!=indexBuffer.byteLength){indexBuffer===null||indexBuffer===void 0?void 0:indexBuffer.destroy();var newIndexBuffer=new Buffer(this._engine,exports.BufferBindFlag.IndexBuffer,indices);this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer,this._indicesFormat));this._indicesChangeFlag=false;}else if(this._indicesChangeFlag){indexBuffer.setData(indices);if(this._indexBufferBinding._format!==this._indicesFormat){this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer,this._indicesFormat));}this._indicesChangeFlag=false;}}else if(indexBuffer){indexBuffer.destroy();this._setIndexBufferBinding(null);}var blendShapeManager=this._blendShapeManager;blendShapeManager._blendShapeCount>0&&blendShapeManager._update(vertexCountChange,noLongerAccessible);if(noLongerAccessible){this._accessible=false;this._releaseCache();}}/**
     * @override
     * @internal
     */;_proto._onDestroy=function _onDestroy(){_Mesh.prototype._onDestroy.call(this);this._accessible&&this._releaseCache();};_proto._updateVertexElements=function _updateVertexElements(){var blendShapeManager=this._blendShapeManager;var attributeMode=!blendShapeManager._useTextureMode();if(this._vertexSlotChanged||attributeMode&&blendShapeManager._vertexElementsNeedUpdate()){var offset=12;var elementCount=3;this._clearVertexElements();this._addVertexElement(POSITION_VERTEX_ELEMENT);if(this._normals){this._addVertexElement(new VertexElement("NORMAL",offset,exports.VertexElementFormat.Vector3,0));offset+=12;elementCount+=3;}if(this._colors){this._addVertexElement(new VertexElement("COLOR_0",offset,exports.VertexElementFormat.Vector4,0));offset+=16;elementCount+=4;}if(this._boneWeights){this._addVertexElement(new VertexElement("WEIGHTS_0",offset,exports.VertexElementFormat.Vector4,0));offset+=16;elementCount+=4;}if(this._boneIndices){this._addVertexElement(new VertexElement("JOINTS_0",offset,exports.VertexElementFormat.UByte4,0));offset+=4;elementCount+=1;}if(this._tangents){this._addVertexElement(new VertexElement("TANGENT",offset,exports.VertexElementFormat.Vector4,0));offset+=16;elementCount+=4;}if(this._uv){this._addVertexElement(new VertexElement("TEXCOORD_0",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv1){this._addVertexElement(new VertexElement("TEXCOORD_1",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv2){this._addVertexElement(new VertexElement("TEXCOORD_2",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv3){this._addVertexElement(new VertexElement("TEXCOORD_3",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv4){this._addVertexElement(new VertexElement("TEXCOORD_4",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv5){this._addVertexElement(new VertexElement("TEXCOORD_5",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv6){this._addVertexElement(new VertexElement("TEXCOORD_6",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv7){this._addVertexElement(new VertexElement("TEXCOORD_7",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(attributeMode){blendShapeManager._blendShapeCount>0&&blendShapeManager._addVertexElements(this);}this._vertexSlotChanged=false;this._vertexStrideFloat=elementCount;return true;}return false;};_proto._updateVertices=function _updateVertices(vertices,force){// prettier-ignore
  var _vertexStrideFloat=this._vertexStrideFloat,_vertexCount=this._vertexCount,_positions=this._positions,_normals=this._normals,_colors=this._colors,_vertexChangeFlag=this._vertexChangeFlag,_boneWeights=this._boneWeights,_boneIndices=this._boneIndices,_tangents=this._tangents,_uv=this._uv,_uv1=this._uv1,_uv2=this._uv2,_uv3=this._uv3,_uv4=this._uv4,_uv5=this._uv5,_uv6=this._uv6,_uv7=this._uv7;force&&(this._vertexChangeFlag=ValueChanged.All);if(_vertexChangeFlag&ValueChanged.Position){for(var i=0;i<_vertexCount;i++){var start=_vertexStrideFloat*i;var position=_positions[i];vertices[start]=position.x;vertices[start+1]=position.y;vertices[start+2]=position.z;}}var offset=3;if(_normals){if(_vertexChangeFlag&ValueChanged.Normal){for(var _i=0;_i<_vertexCount;_i++){var _start=_vertexStrideFloat*_i+offset;var normal=_normals[_i];if(normal){vertices[_start]=normal.x;vertices[_start+1]=normal.y;vertices[_start+2]=normal.z;}}}offset+=3;}if(_colors){if(_vertexChangeFlag&ValueChanged.Color){for(var _i2=0;_i2<_vertexCount;_i2++){var _start2=_vertexStrideFloat*_i2+offset;var color=_colors[_i2];if(color){vertices[_start2]=color.r;vertices[_start2+1]=color.g;vertices[_start2+2]=color.b;vertices[_start2+3]=color.a;}}}offset+=4;}if(_boneWeights){if(_vertexChangeFlag&ValueChanged.BoneWeight){for(var _i3=0;_i3<_vertexCount;_i3++){var _start3=_vertexStrideFloat*_i3+offset;var weight=_boneWeights[_i3];if(weight){vertices[_start3]=weight.x;vertices[_start3+1]=weight.y;vertices[_start3+2]=weight.z;vertices[_start3+3]=weight.w;}}}offset+=4;}if(_boneIndices){if(_vertexChangeFlag&ValueChanged.BoneIndex){var _verticesUint8=this._verticesUint8;for(var _i4=0;_i4<_vertexCount;_i4++){var _start4=_vertexStrideFloat*_i4+offset;var joint=_boneIndices[_i4];if(joint){var internalStart=_start4*4;_verticesUint8[internalStart]=joint.x;_verticesUint8[internalStart+1]=joint.y;_verticesUint8[internalStart+2]=joint.z;_verticesUint8[internalStart+3]=joint.w;}}}offset+=1;}if(_tangents){if(_vertexChangeFlag&ValueChanged.Tangent){for(var _i5=0;_i5<_vertexCount;_i5++){var _start5=_vertexStrideFloat*_i5+offset;var tangent=_tangents[_i5];if(tangent){vertices[_start5]=tangent.x;vertices[_start5+1]=tangent.y;vertices[_start5+2]=tangent.z;vertices[_start5+3]=tangent.w;}}}offset+=4;}if(_uv){if(_vertexChangeFlag&ValueChanged.UV){for(var _i6=0;_i6<_vertexCount;_i6++){var _start6=_vertexStrideFloat*_i6+offset;var _uv8=_uv[_i6];if(_uv8){vertices[_start6]=_uv8.x;vertices[_start6+1]=_uv8.y;}}}offset+=2;}if(_uv1){if(_vertexChangeFlag&ValueChanged.UV1){for(var _i7=0;_i7<_vertexCount;_i7++){var _start7=_vertexStrideFloat*_i7+offset;var _uv9=_uv1[_i7];if(_uv9){vertices[_start7]=_uv9.x;vertices[_start7+1]=_uv9.y;}}}offset+=2;}if(_uv2){if(_vertexChangeFlag&ValueChanged.UV2){for(var _i8=0;_i8<_vertexCount;_i8++){var _start8=_vertexStrideFloat*_i8+offset;var _uv10=_uv2[_i8];if(_uv10){vertices[_start8]=_uv10.x;vertices[_start8+1]=_uv10.y;}}}offset+=2;}if(_uv3){if(_vertexChangeFlag&ValueChanged.UV3){for(var _i9=0;_i9<_vertexCount;_i9++){var _start9=_vertexStrideFloat*_i9+offset;var _uv11=_uv3[_i9];if(_uv11){vertices[_start9]=_uv11.x;vertices[_start9+1]=_uv11.y;}}}offset+=2;}if(_uv4){if(_vertexChangeFlag&ValueChanged.UV4){for(var _i10=0;_i10<_vertexCount;_i10++){var _start10=_vertexStrideFloat*_i10+offset;var _uv12=_uv4[_i10];if(_uv12){vertices[_start10]=_uv12.x;vertices[_start10+1]=_uv12.y;}}}offset+=2;}if(_uv5){if(_vertexChangeFlag&ValueChanged.UV5){for(var _i11=0;_i11<_vertexCount;_i11++){var _start11=_vertexStrideFloat*_i11+offset;var _uv13=_uv5[_i11];if(_uv13){vertices[_start11]=_uv13.x;vertices[_start11+1]=_uv13.y;}}}offset+=2;}if(_uv6){if(_vertexChangeFlag&ValueChanged.UV6){for(var _i12=0;_i12<_vertexCount;_i12++){var _start12=_vertexStrideFloat*_i12+offset;var _uv14=_uv6[_i12];if(_uv14){vertices[_start12]=_uv14.x;vertices[_start12+1]=_uv14.y;}}}offset+=2;}if(_uv7){if(_vertexChangeFlag&ValueChanged.UV7){for(var _i13=0;_i13<_vertexCount;_i13++){var _start13=_vertexStrideFloat*_i13+offset;var _uv15=_uv7[_i13];if(_uv15){vertices[_start13]=_uv15.x;vertices[_start13+1]=_uv15.y;}}}offset+=2;}this._vertexChangeFlag=0;};_proto._releaseCache=function _releaseCache(){this._verticesUint8=null;this._indices=null;this._verticesFloat32=null;this._positions.length=0;this._tangents=null;this._normals=null;this._colors=null;this._uv=null;this._uv1=null;this._uv2=null;this._uv3=null;this._uv4=null;this._uv5=null;this._uv6=null;this._uv7=null;this._blendShapeManager._releaseMemoryCache();};_createClass$3(ModelMesh,[{key:"accessible",get:/** @internal */ /**
       * Whether to access data of the mesh.
       */function get(){return this._accessible;}/**
       * Vertex count of current mesh.
       */},{key:"vertexCount",get:function get(){return this._vertexCount;}/**
       * BlendShapes of this ModelMesh.
       */},{key:"blendShapes",get:function get(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._blendShapeManager._blendShapes;}/**
       * BlendShape count of this ModelMesh.
       */},{key:"blendShapeCount",get:function get(){return this._blendShapeManager._blendShapeCount;}}]);return ModelMesh;}(Mesh);var POSITION_VERTEX_ELEMENT=new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0);var ValueChanged;(function(ValueChanged){ValueChanged[ValueChanged["Position"]=1]="Position";ValueChanged[ValueChanged["Normal"]=2]="Normal";ValueChanged[ValueChanged["Color"]=4]="Color";ValueChanged[ValueChanged["Tangent"]=8]="Tangent";ValueChanged[ValueChanged["BoneWeight"]=16]="BoneWeight";ValueChanged[ValueChanged["BoneIndex"]=32]="BoneIndex";ValueChanged[ValueChanged["UV"]=64]="UV";ValueChanged[ValueChanged["UV1"]=128]="UV1";ValueChanged[ValueChanged["UV2"]=256]="UV2";ValueChanged[ValueChanged["UV3"]=512]="UV3";ValueChanged[ValueChanged["UV4"]=1024]="UV4";ValueChanged[ValueChanged["UV5"]=2048]="UV5";ValueChanged[ValueChanged["UV6"]=4096]="UV6";ValueChanged[ValueChanged["UV7"]=8192]="UV7";ValueChanged[ValueChanged["All"]=65535]="All";})(ValueChanged||(ValueChanged={}));/**
   * Mesh skin data, equal glTF skins define
   */var Skin=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Skin,_EngineObject);/**
     * Constructor of skin
     * @param name - name
     */function Skin(name){var _this;_this=_EngineObject.call(this,null)||this;_this.name=name;_this.inverseBindMatrices=void 0;_this.joints=void 0;_this.skeleton=void 0;_this.inverseBindMatrices=[];// inverse bind matrix array
  _this.joints=[];// joints name array, element type: string
  _this.skeleton="none";// root bone name
  return _this;}return Skin;}(EngineObject);var _class$7$1,_descriptor$6,_descriptor2$6,_class2$6;/**
   * MeshRenderer Component.
   */var MeshRenderer=(_class$7$1=(_class2$6=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(MeshRenderer,_Renderer);/** @internal */ /**
     * @internal
     */function MeshRenderer(entity){var _this;_this=_Renderer.call(this,entity)||this;_initializerDefineProperty(_this,"_mesh",_descriptor$6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_meshUpdateFlag",_descriptor2$6,_assertThisInitialized(_this));return _this;}/**
     * Mesh assigned to the renderer.
     */var _proto=MeshRenderer.prototype;/**
     * @internal
     */_proto._render=function _render(camera){var mesh=this._mesh;if(mesh){if(this._meshUpdateFlag.flag){var shaderData=this.shaderData;var vertexElements=mesh._vertexElements;shaderData.disableMacro(MeshRenderer._uvMacro);shaderData.disableMacro(MeshRenderer._uv1Macro);shaderData.disableMacro(MeshRenderer._normalMacro);shaderData.disableMacro(MeshRenderer._tangentMacro);shaderData.disableMacro(MeshRenderer._vertexColorMacro);for(var i=0,n=vertexElements.length;i<n;i++){var semantic=vertexElements[i].semantic;switch(semantic){case"TEXCOORD_0":shaderData.enableMacro(MeshRenderer._uvMacro);break;case"TEXCOORD_1":shaderData.enableMacro(MeshRenderer._uv1Macro);break;case"NORMAL":shaderData.enableMacro(MeshRenderer._normalMacro);break;case"TANGENT":shaderData.enableMacro(MeshRenderer._tangentMacro);break;case"COLOR_0":shaderData.enableMacro(MeshRenderer._vertexColorMacro);break;}}this._meshUpdateFlag.flag=false;}var subMeshes=mesh.subMeshes;var renderPipeline=camera._renderPipeline;var renderElementPool=this._engine._renderElementPool;for(var _i=0,_n=subMeshes.length;_i<_n;_i++){var material=this._materials[_i];if(material){var element=renderElementPool.getFromPool();element.setValue(this,mesh,subMeshes[_i],material);renderPipeline.pushPrimitive(element);}}}else {Logger.error("mesh is null.");}}/**
     * @internal
     * @override
     */;_proto._onDestroy=function _onDestroy(){_Renderer.prototype._onDestroy.call(this);var mesh=this._mesh;if(mesh&&!mesh.destroyed){mesh._addRefCount(-1);this._mesh=null;}}/**
     * @internal
     */;_proto._cloneTo=function _cloneTo(target){target.mesh=this._mesh;}/**
     * @override
     */;_proto._updateBounds=function _updateBounds(worldBounds){var mesh=this._mesh;if(mesh){var localBounds=mesh.bounds;var worldMatrix=this._entity.transform.worldMatrix;BoundingBox.transform(localBounds,worldMatrix,worldBounds);}else {worldBounds.min.set(0,0,0);worldBounds.max.set(0,0,0);}};_proto._setMesh=function _setMesh(mesh){var lastMesh=this._mesh;if(lastMesh){lastMesh._addRefCount(-1);this._meshUpdateFlag.destroy();}if(mesh){mesh._addRefCount(1);this._meshUpdateFlag=mesh.registerUpdateFlag();}this._mesh=mesh;};_createClass$3(MeshRenderer,[{key:"mesh",get:function get(){return this._mesh;},set:function set(mesh){if(this._mesh!==mesh){this._setMesh(mesh);}}}]);return MeshRenderer;}(Renderer),_class2$6._uvMacro=Shader.getMacroByName("O3_HAS_UV"),_class2$6._uv1Macro=Shader.getMacroByName("O3_HAS_UV1"),_class2$6._normalMacro=Shader.getMacroByName("O3_HAS_NORMAL"),_class2$6._tangentMacro=Shader.getMacroByName("O3_HAS_TANGENT"),_class2$6._vertexColorMacro=Shader.getMacroByName("O3_HAS_VERTEXCOLOR"),_class2$6),(_descriptor$6=_applyDecoratedDescriptor(_class$7$1.prototype,"_mesh",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$6=_applyDecoratedDescriptor(_class$7$1.prototype,"_meshUpdateFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null})),_class$7$1);var _class$6$1,_descriptor$5,_descriptor2$5,_descriptor3$5,_descriptor4$5,_descriptor5$5,_descriptor6$5,_descriptor7$5,_descriptor8$5,_class2$5;/**
   * SkinnedMeshRenderer.
   */var SkinnedMeshRenderer=(_class$6$1=(_class2$5=/*#__PURE__*/function(_MeshRenderer){_inheritsLoose$2(SkinnedMeshRenderer,_MeshRenderer);/**
     * Constructor of SkinnedMeshRenderer
     * @param entity - Entity
     */function SkinnedMeshRenderer(entity){var _this;_this=_MeshRenderer.call(this,entity)||this;_initializerDefineProperty(_this,"matrixPalette",_descriptor$5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"jointNodes",_descriptor2$5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"jointTexture",_descriptor3$5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_hasInitJoints",_descriptor4$5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_mat",_descriptor5$5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_useJointTexture",_descriptor6$5,_assertThisInitialized(_this));_this._skin=void 0;_initializerDefineProperty(_this,"_blendShapeWeights",_descriptor7$5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_condensedBlendShapeWeights",_descriptor8$5,_assertThisInitialized(_this));_this._mat=new Matrix();_this._skin=null;return _this;}/**
     * @internal
     */var _proto=SkinnedMeshRenderer.prototype;_proto._updateShaderData=function _updateShaderData(context){_MeshRenderer.prototype._updateShaderData.call(this,context);var shaderData=this.shaderData;if(!this._useJointTexture&&this.matrixPalette){shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty,this.matrixPalette);}var mesh=this.mesh;mesh._blendShapeManager._updateShaderData(shaderData,this);}/**
     * Skin Object.
     */;_proto._initJoints=function _initJoints(){if(!this._skin)return;var skin=this._skin;var joints=skin.joints;var jointNodes=[];for(var i=joints.length-1;i>=0;i--){jointNodes[i]=this.findByNodeName(this.entity,joints[i]);}// end of for
  this.matrixPalette=new Float32Array(jointNodes.length*16);this.jointNodes=jointNodes;/** Whether to use a skeleton texture */var rhi=this.entity.engine._hardwareRenderer;if(!rhi)return;var maxAttribUniformVec4=rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);var maxJoints=Math.floor((maxAttribUniformVec4-30)/4);var shaderData=this.shaderData;var jointCount=jointNodes.length;if(jointCount){shaderData.enableMacro("O3_HAS_SKIN");shaderData.setInt(SkinnedMeshRenderer._jointCountProperty,jointCount);if(jointCount>maxJoints){if(rhi.canIUseMoreJoints){this._useJointTexture=true;}else {Logger.error("component's joints count("+jointCount+") greater than device's MAX_VERTEX_UNIFORM_VECTORS number "+maxAttribUniformVec4+", and don't support jointTexture in this device. suggest joint count less than "+maxJoints+".",this);}}else {var _maxJoints=Math.max(SkinnedMeshRenderer._maxJoints,jointCount);SkinnedMeshRenderer._maxJoints=_maxJoints;shaderData.disableMacro("O3_USE_JOINT_TEXTURE");shaderData.enableMacro("O3_JOINTS_NUM",_maxJoints.toString());}}else {shaderData.disableMacro("O3_HAS_SKIN");}};_proto.findByNodeName=function findByNodeName(entity,nodeName){if(!entity)return null;var n=entity.findByName(nodeName);if(n)return n;return this.findByNodeName(entity.parent,nodeName);}/**
     * @internal
     */;_proto.update=function update(){if(!this._hasInitJoints){this._initJoints();this._hasInitJoints=true;}if(this._skin){var joints=this.jointNodes;var ibms=this._skin.inverseBindMatrices;var matrixPalette=this.matrixPalette;var worldToLocal=this.entity.getInvModelMatrix();var mat=this._mat;for(var i=joints.length-1;i>=0;i--){mat.identity();if(joints[i]){Matrix.multiply(joints[i].transform.worldMatrix,ibms[i],mat);}else {mat.copyFrom(ibms[i]);}Matrix.multiply(worldToLocal,mat,mat);matrixPalette.set(mat.elements,i*16);}if(this._useJointTexture){this.createJointTexture();}}}/**
     * Generate joint texture.
     * Format: (4 * RGBA) * jointCont
     */;_proto.createJointTexture=function createJointTexture(){if(!this.jointTexture){var engine=this.engine;var rhi=engine._hardwareRenderer;if(!rhi)return;this.jointTexture=new Texture2D(engine,4,this.jointNodes.length,exports.TextureFormat.R32G32B32A32,false);this.jointTexture.filterMode=exports.TextureFilterMode.Point;this.shaderData.enableMacro("O3_USE_JOINT_TEXTURE");this.shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty,this.jointTexture);}this.jointTexture.setPixelBuffer(this.matrixPalette);}/**
     * @internal
     */;_proto._cloneTo=function _cloneTo(target){_MeshRenderer.prototype._cloneTo.call(this,target);this._blendShapeWeights&&(target._blendShapeWeights=this._blendShapeWeights.slice());};_proto._checkBlendShapeWeightLength=function _checkBlendShapeWeightLength(){var mesh=this._mesh;var newBlendShapeCount=mesh?mesh.blendShapeCount:0;var lastBlendShapeWeights=this._blendShapeWeights;if(lastBlendShapeWeights){if(lastBlendShapeWeights.length!==newBlendShapeCount){var newBlendShapeWeights=new Float32Array(newBlendShapeCount);if(newBlendShapeCount>lastBlendShapeWeights.length){newBlendShapeWeights.set(lastBlendShapeWeights);}else {for(var i=0,n=lastBlendShapeWeights.length;i<n;i++){lastBlendShapeWeights[i]=newBlendShapeWeights[i];}}this._blendShapeWeights=newBlendShapeWeights;}}else {this._blendShapeWeights=new Float32Array(newBlendShapeCount);}};_createClass$3(SkinnedMeshRenderer,[{key:"blendShapeWeights",get:/** @internal */ /**
       * The weights of the BlendShapes.
       * @remarks Array index is BlendShape index.
       */function get(){this._checkBlendShapeWeightLength();return this._blendShapeWeights;},set:function set(value){this._checkBlendShapeWeightLength();var blendShapeWeights=this._blendShapeWeights;if(value.length<=blendShapeWeights.length){blendShapeWeights.set(value);}else {for(var i=0,n=blendShapeWeights.length;i<n;i++){blendShapeWeights[i]=value[i];}}}},{key:"skin",get:function get(){return this._skin;},set:function set(skin){this._skin=skin;}}]);return SkinnedMeshRenderer;}(MeshRenderer),_class2$5._jointCountProperty=Shader.getPropertyByName("u_jointCount"),_class2$5._jointSamplerProperty=Shader.getPropertyByName("u_jointSampler"),_class2$5._jointMatrixProperty=Shader.getPropertyByName("u_jointMatrix"),_class2$5._maxJoints=0,_class2$5),(_descriptor$5=_applyDecoratedDescriptor(_class$6$1.prototype,"matrixPalette",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$5=_applyDecoratedDescriptor(_class$6$1.prototype,"jointNodes",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3$5=_applyDecoratedDescriptor(_class$6$1.prototype,"jointTexture",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$5=_applyDecoratedDescriptor(_class$6$1.prototype,"_hasInitJoints",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor5$5=_applyDecoratedDescriptor(_class$6$1.prototype,"_mat",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor6$5=_applyDecoratedDescriptor(_class$6$1.prototype,"_useJointTexture",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor7$5=_applyDecoratedDescriptor(_class$6$1.prototype,"_blendShapeWeights",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor8$5=_applyDecoratedDescriptor(_class$6$1.prototype,"_condensedBlendShapeWeights",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null})),_class$6$1);/**
   * Used to generate common primitive meshes.
   */var PrimitiveMesh=/*#__PURE__*/function(){function PrimitiveMesh(){}/**
     * Create a sphere mesh.
     * @param engine - Engine
     * @param radius - Sphere radius
     * @param segments - Number of segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Sphere model mesh
     */PrimitiveMesh.createSphere=function createSphere(engine,radius,segments,noLongerAccessible){if(radius===void 0){radius=0.5;}if(segments===void 0){segments=18;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);segments=Math.max(2,Math.floor(segments));var count=segments+1;var vertexCount=count*count;var rectangleCount=segments*segments;var indices=PrimitiveMesh._generateIndices(engine,vertexCount,rectangleCount*6);var thetaRange=Math.PI;var alphaRange=thetaRange*2;var countReciprocal=1.0/count;var segmentsReciprocal=1.0/segments;var positions=new Array(vertexCount);var normals=new Array(vertexCount);var uvs=new Array(vertexCount);for(var i=0;i<vertexCount;++i){var x=i%count;var y=i*countReciprocal|0;var u=x*segmentsReciprocal;var v=y*segmentsReciprocal;var alphaDelta=u*alphaRange;var thetaDelta=v*thetaRange;var sinTheta=Math.sin(thetaDelta);var posX=-radius*Math.cos(alphaDelta)*sinTheta;var posY=radius*Math.cos(thetaDelta);var posZ=radius*Math.sin(alphaDelta)*sinTheta;// Position
  positions[i]=new Vector3(posX,posY,posZ);// Normal
  normals[i]=new Vector3(posX,posY,posZ);// Texcoord
  uvs[i]=new Vector2(u,v);}var offset=0;for(var _i=0;_i<rectangleCount;++_i){var _x=_i%segments;var _y=_i*segmentsReciprocal|0;var a=_y*count+_x;var b=a+1;var c=a+count;var d=c+1;indices[offset++]=b;indices[offset++]=a;indices[offset++]=d;indices[offset++]=a;indices[offset++]=c;indices[offset++]=d;}var bounds=mesh.bounds;bounds.min.set(-radius,-radius,-radius);bounds.max.set(radius,radius,radius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a cuboid mesh.
     * @param engine - Engine
     * @param width - Cuboid width
     * @param height - Cuboid height
     * @param depth - Cuboid depth
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Cuboid model mesh
     */;PrimitiveMesh.createCuboid=function createCuboid(engine,width,height,depth,noLongerAccessible){if(width===void 0){width=1;}if(height===void 0){height=1;}if(depth===void 0){depth=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);var halfWidth=width/2;var halfHeight=height/2;var halfDepth=depth/2;var positions=new Array(24);var normals=new Array(24);var uvs=new Array(24);// Up
  positions[0]=new Vector3(-halfWidth,halfHeight,-halfDepth);positions[1]=new Vector3(halfWidth,halfHeight,-halfDepth);positions[2]=new Vector3(halfWidth,halfHeight,halfDepth);positions[3]=new Vector3(-halfWidth,halfHeight,halfDepth);normals[0]=new Vector3(0,1,0);normals[1]=new Vector3(0,1,0);normals[2]=new Vector3(0,1,0);normals[3]=new Vector3(0,1,0);uvs[0]=new Vector2(0,0);uvs[1]=new Vector2(1,0);uvs[2]=new Vector2(1,1);uvs[3]=new Vector2(0,1);// Down
  positions[4]=new Vector3(-halfWidth,-halfHeight,-halfDepth);positions[5]=new Vector3(halfWidth,-halfHeight,-halfDepth);positions[6]=new Vector3(halfWidth,-halfHeight,halfDepth);positions[7]=new Vector3(-halfWidth,-halfHeight,halfDepth);normals[4]=new Vector3(0,-1,0);normals[5]=new Vector3(0,-1,0);normals[6]=new Vector3(0,-1,0);normals[7]=new Vector3(0,-1,0);uvs[4]=new Vector2(0,1);uvs[5]=new Vector2(1,1);uvs[6]=new Vector2(1,0);uvs[7]=new Vector2(0,0);// Left
  positions[8]=new Vector3(-halfWidth,halfHeight,-halfDepth);positions[9]=new Vector3(-halfWidth,halfHeight,halfDepth);positions[10]=new Vector3(-halfWidth,-halfHeight,halfDepth);positions[11]=new Vector3(-halfWidth,-halfHeight,-halfDepth);normals[8]=new Vector3(-1,0,0);normals[9]=new Vector3(-1,0,0);normals[10]=new Vector3(-1,0,0);normals[11]=new Vector3(-1,0,0);uvs[8]=new Vector2(0,0);uvs[9]=new Vector2(1,0);uvs[10]=new Vector2(1,1);uvs[11]=new Vector2(0,1);// Right
  positions[12]=new Vector3(halfWidth,halfHeight,-halfDepth);positions[13]=new Vector3(halfWidth,halfHeight,halfDepth);positions[14]=new Vector3(halfWidth,-halfHeight,halfDepth);positions[15]=new Vector3(halfWidth,-halfHeight,-halfDepth);normals[12]=new Vector3(1,0,0);normals[13]=new Vector3(1,0,0);normals[14]=new Vector3(1,0,0);normals[15]=new Vector3(1,0,0);uvs[12]=new Vector2(1,0);uvs[13]=new Vector2(0,0);uvs[14]=new Vector2(0,1);uvs[15]=new Vector2(1,1);// Front
  positions[16]=new Vector3(-halfWidth,halfHeight,halfDepth);positions[17]=new Vector3(halfWidth,halfHeight,halfDepth);positions[18]=new Vector3(halfWidth,-halfHeight,halfDepth);positions[19]=new Vector3(-halfWidth,-halfHeight,halfDepth);normals[16]=new Vector3(0,0,1);normals[17]=new Vector3(0,0,1);normals[18]=new Vector3(0,0,1);normals[19]=new Vector3(0,0,1);uvs[16]=new Vector2(0,0);uvs[17]=new Vector2(1,0);uvs[18]=new Vector2(1,1);uvs[19]=new Vector2(0,1);// Back
  positions[20]=new Vector3(-halfWidth,halfHeight,-halfDepth);positions[21]=new Vector3(halfWidth,halfHeight,-halfDepth);positions[22]=new Vector3(halfWidth,-halfHeight,-halfDepth);positions[23]=new Vector3(-halfWidth,-halfHeight,-halfDepth);normals[20]=new Vector3(0,0,-1);normals[21]=new Vector3(0,0,-1);normals[22]=new Vector3(0,0,-1);normals[23]=new Vector3(0,0,-1);uvs[20]=new Vector2(1,0);uvs[21]=new Vector2(0,0);uvs[22]=new Vector2(0,1);uvs[23]=new Vector2(1,1);var indices=new Uint16Array(36);// prettier-ignore
  // Up
  indices[0]=0,indices[1]=2,indices[2]=1,indices[3]=2,indices[4]=0,indices[5]=3,// Down
  indices[6]=4,indices[7]=6,indices[8]=7,indices[9]=6,indices[10]=4,indices[11]=5,// Left
  indices[12]=8,indices[13]=10,indices[14]=9,indices[15]=10,indices[16]=8,indices[17]=11,// Right
  indices[18]=12,indices[19]=14,indices[20]=15,indices[21]=14,indices[22]=12,indices[23]=13,// Front
  indices[24]=16,indices[25]=18,indices[26]=17,indices[27]=18,indices[28]=16,indices[29]=19,// Back
  indices[30]=20,indices[31]=22,indices[32]=23,indices[33]=22,indices[34]=20,indices[35]=21;var bounds=mesh.bounds;bounds.min.set(-halfWidth,-halfHeight,-halfDepth);bounds.max.set(halfWidth,halfHeight,halfDepth);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a plane mesh.
     * @param engine - Engine
     * @param width - Plane width
     * @param height - Plane height
     * @param horizontalSegments - Plane horizontal segments
     * @param verticalSegments - Plane vertical segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Plane model mesh
     */;PrimitiveMesh.createPlane=function createPlane(engine,width,height,horizontalSegments,verticalSegments,noLongerAccessible){if(width===void 0){width=1;}if(height===void 0){height=1;}if(horizontalSegments===void 0){horizontalSegments=1;}if(verticalSegments===void 0){verticalSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);horizontalSegments=Math.max(1,Math.floor(horizontalSegments));verticalSegments=Math.max(1,Math.floor(verticalSegments));var horizontalCount=horizontalSegments+1;var verticalCount=verticalSegments+1;var halfWidth=width/2;var halfHeight=height/2;var gridWidth=width/horizontalSegments;var gridHeight=height/verticalSegments;var vertexCount=horizontalCount*verticalCount;var rectangleCount=verticalSegments*horizontalSegments;var indices=PrimitiveMesh._generateIndices(engine,vertexCount,rectangleCount*6);var horizontalCountReciprocal=1.0/horizontalCount;var horizontalSegmentsReciprocal=1.0/horizontalSegments;var verticalSegmentsReciprocal=1.0/verticalSegments;var positions=new Array(vertexCount);var normals=new Array(vertexCount);var uvs=new Array(vertexCount);for(var i=0;i<vertexCount;++i){var x=i%horizontalCount;var z=i*horizontalCountReciprocal|0;// Position
  positions[i]=new Vector3(x*gridWidth-halfWidth,0,z*gridHeight-halfHeight);// Normal
  normals[i]=new Vector3(0,1,0);// Texcoord
  uvs[i]=new Vector2(x*horizontalSegmentsReciprocal,z*verticalSegmentsReciprocal);}var offset=0;for(var _i2=0;_i2<rectangleCount;++_i2){var _x2=_i2%horizontalSegments;var y=_i2*horizontalSegmentsReciprocal|0;var a=y*horizontalCount+_x2;var b=a+1;var c=a+horizontalCount;var d=c+1;indices[offset++]=a;indices[offset++]=c;indices[offset++]=b;indices[offset++]=c;indices[offset++]=d;indices[offset++]=b;}var bounds=mesh.bounds;bounds.min.set(-halfWidth,0,-halfHeight);bounds.max.set(halfWidth,0,halfHeight);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a cylinder mesh.
     * @param engine - Engine
     * @param radiusTop - The radius of top cap
     * @param radiusBottom - The radius of bottom cap
     * @param height - The height of torso
     * @param radialSegments - Cylinder radial segments
     * @param heightSegments - Cylinder height segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Cylinder model mesh
     */;PrimitiveMesh.createCylinder=function createCylinder(engine,radiusTop,radiusBottom,height,radialSegments,heightSegments,noLongerAccessible){if(radiusTop===void 0){radiusTop=0.5;}if(radiusBottom===void 0){radiusBottom=0.5;}if(height===void 0){height=2;}if(radialSegments===void 0){radialSegments=20;}if(heightSegments===void 0){heightSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);var radialCount=radialSegments+1;var verticalCount=heightSegments+1;var halfHeight=height*0.5;var unitHeight=height/heightSegments;var torsoVertexCount=radialCount*verticalCount;var torsoRectangleCount=radialSegments*heightSegments;var capTriangleCount=radialSegments*2;var totalVertexCount=torsoVertexCount+2+capTriangleCount;var indices=PrimitiveMesh._generateIndices(engine,totalVertexCount,torsoRectangleCount*6+capTriangleCount*3);var radialCountReciprocal=1.0/radialCount;var radialSegmentsReciprocal=1.0/radialSegments;var heightSegmentsReciprocal=1.0/heightSegments;var positions=new Array(totalVertexCount);var normals=new Array(totalVertexCount);var uvs=new Array(totalVertexCount);var indicesOffset=0;// Create torso
  var thetaStart=Math.PI;var thetaRange=Math.PI*2;var radiusDiff=radiusBottom-radiusTop;var slope=radiusDiff/height;var radiusSlope=radiusDiff/heightSegments;for(var i=0;i<torsoVertexCount;++i){var x=i%radialCount;var y=i*radialCountReciprocal|0;var u=x*radialSegmentsReciprocal;var v=y*heightSegmentsReciprocal;var theta=thetaStart+u*thetaRange;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);var radius=radiusBottom-y*radiusSlope;var posX=radius*sinTheta;var posY=y*unitHeight-halfHeight;var posZ=radius*cosTheta;// Position
  positions[i]=new Vector3(posX,posY,posZ);// Normal
  normals[i]=new Vector3(sinTheta,slope,cosTheta);// Texcoord
  uvs[i]=new Vector2(u,1-v);}for(var _i3=0;_i3<torsoRectangleCount;++_i3){var _x3=_i3%radialSegments;var _y2=_i3*radialSegmentsReciprocal|0;var a=_y2*radialCount+_x3;var b=a+1;var c=a+radialCount;var d=c+1;indices[indicesOffset++]=b;indices[indicesOffset++]=c;indices[indicesOffset++]=a;indices[indicesOffset++]=b;indices[indicesOffset++]=d;indices[indicesOffset++]=c;}// Bottom position
  positions[torsoVertexCount]=new Vector3(0,-halfHeight,0);// Bottom normal
  normals[torsoVertexCount]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[torsoVertexCount]=new Vector2(0.5,0.5);// Top position
  positions[torsoVertexCount+1]=new Vector3(0,halfHeight,0);// Top normal
  normals[torsoVertexCount+1]=new Vector3(0,1,0);// Top texcoord
  uvs[torsoVertexCount+1]=new Vector2(0.5,0.5);// Add cap vertices
  var offset=torsoVertexCount+2;var diameterTopReciprocal=1.0/(radiusTop*2);var diameterBottomReciprocal=1.0/(radiusBottom*2);var positionStride=radialCount*heightSegments;for(var _i4=0;_i4<radialSegments;++_i4){var curPosBottom=positions[_i4];var curPosX=curPosBottom.x;var curPosZ=curPosBottom.z;// Bottom position
  positions[offset]=new Vector3(curPosX,-halfHeight,curPosZ);// Bottom normal
  normals[offset]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[offset++]=new Vector2(curPosX*diameterBottomReciprocal+0.5,0.5-curPosZ*diameterBottomReciprocal);var curPosTop=positions[_i4+positionStride];curPosX=curPosTop.x;curPosZ=curPosTop.z;// Top position
  positions[offset]=new Vector3(curPosX,halfHeight,curPosZ);// Top normal
  normals[offset]=new Vector3(0,1,0);// Top texcoord
  uvs[offset++]=new Vector2(curPosX*diameterTopReciprocal+0.5,curPosZ*diameterTopReciprocal+0.5);}// Add cap indices
  var topCapIndex=torsoVertexCount+1;var bottomIndiceIndex=torsoVertexCount+2;var topIndiceIndex=bottomIndiceIndex+1;for(var _i5=0;_i5<radialSegments;++_i5){var firstStride=_i5*2;var secondStride=_i5===radialSegments-1?0:firstStride+2;// Bottom
  indices[indicesOffset++]=torsoVertexCount;indices[indicesOffset++]=bottomIndiceIndex+secondStride;indices[indicesOffset++]=bottomIndiceIndex+firstStride;// Top
  indices[indicesOffset++]=topCapIndex;indices[indicesOffset++]=topIndiceIndex+firstStride;indices[indicesOffset++]=topIndiceIndex+secondStride;}var bounds=mesh.bounds;var radiusMax=Math.max(radiusTop,radiusBottom);bounds.min.set(-radiusMax,-halfHeight,-radiusMax);bounds.max.set(radiusMax,halfHeight,radiusMax);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a torus mesh.
     * @param engine - Engine
     * @param radius - Torus radius
     * @param tubeRadius - Torus tube
     * @param radialSegments - Torus radial segments
     * @param tubularSegments - Torus tubular segments
     * @param arc - Central angle
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Torus model mesh
     */;PrimitiveMesh.createTorus=function createTorus(engine,radius,tubeRadius,radialSegments,tubularSegments,arc,noLongerAccessible){if(radius===void 0){radius=0.5;}if(tubeRadius===void 0){tubeRadius=0.1;}if(radialSegments===void 0){radialSegments=30;}if(tubularSegments===void 0){tubularSegments=30;}if(arc===void 0){arc=360;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.floor(radialSegments);tubularSegments=Math.floor(tubularSegments);var vertexCount=(radialSegments+1)*(tubularSegments+1);var rectangleCount=radialSegments*tubularSegments;var indices=PrimitiveMesh._generateIndices(engine,vertexCount,rectangleCount*6);var positions=new Array(vertexCount);var normals=new Array(vertexCount);var uvs=new Array(vertexCount);arc=arc/180*Math.PI;var offset=0;for(var i=0;i<=radialSegments;i++){for(var j=0;j<=tubularSegments;j++){var u=j/tubularSegments*arc;var v=i/radialSegments*Math.PI*2;var cosV=Math.cos(v);var sinV=Math.sin(v);var cosU=Math.cos(u);var sinU=Math.sin(u);var position=new Vector3((radius+tubeRadius*cosV)*cosU,(radius+tubeRadius*cosV)*sinU,tubeRadius*sinV);positions[offset]=position;var centerX=radius*cosU;var centerY=radius*sinU;normals[offset]=new Vector3(position.x-centerX,position.y-centerY,position.z).normalize();uvs[offset++]=new Vector2(j/tubularSegments,i/radialSegments);}}offset=0;for(var _i6=1;_i6<=radialSegments;_i6++){for(var _j=1;_j<=tubularSegments;_j++){var a=(tubularSegments+1)*_i6+_j-1;var b=(tubularSegments+1)*(_i6-1)+_j-1;var c=(tubularSegments+1)*(_i6-1)+_j;var d=(tubularSegments+1)*_i6+_j;indices[offset++]=a;indices[offset++]=b;indices[offset++]=d;indices[offset++]=b;indices[offset++]=c;indices[offset++]=d;}}var bounds=mesh.bounds;var outerRadius=radius+tubeRadius;bounds.min.set(-outerRadius,-outerRadius,-tubeRadius);bounds.max.set(outerRadius,outerRadius,tubeRadius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a cone mesh.
     * @param engine - Engine
     * @param radius - The radius of cap
     * @param height - The height of torso
     * @param radialSegments - Cylinder radial segments
     * @param heightSegments - Cylinder height segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Cone model mesh
     */;PrimitiveMesh.createCone=function createCone(engine,radius,height,radialSegments,heightSegments,noLongerAccessible){if(radius===void 0){radius=0.5;}if(height===void 0){height=2;}if(radialSegments===void 0){radialSegments=20;}if(heightSegments===void 0){heightSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);var radialCount=radialSegments+1;var verticalCount=heightSegments+1;var halfHeight=height*0.5;var unitHeight=height/heightSegments;var torsoVertexCount=radialCount*verticalCount;var torsoRectangleCount=radialSegments*heightSegments;var totalVertexCount=torsoVertexCount+1+radialSegments;var indices=PrimitiveMesh._generateIndices(engine,totalVertexCount,torsoRectangleCount*6+radialSegments*3);var radialCountReciprocal=1.0/radialCount;var radialSegmentsReciprocal=1.0/radialSegments;var heightSegmentsReciprocal=1.0/heightSegments;var positions=new Array(totalVertexCount);var normals=new Array(totalVertexCount);var uvs=new Array(totalVertexCount);var indicesOffset=0;// Create torso
  var thetaStart=Math.PI;var thetaRange=Math.PI*2;var slope=radius/height;for(var i=0;i<torsoVertexCount;++i){var x=i%radialCount;var y=i*radialCountReciprocal|0;var u=x*radialSegmentsReciprocal;var v=y*heightSegmentsReciprocal;var theta=thetaStart+u*thetaRange;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);var curRadius=radius-y*radius;var posX=curRadius*sinTheta;var posY=y*unitHeight-halfHeight;var posZ=curRadius*cosTheta;// Position
  positions[i]=new Vector3(posX,posY,posZ);// Normal
  normals[i]=new Vector3(sinTheta,slope,cosTheta);// Texcoord
  uvs[i]=new Vector2(u,1-v);}for(var _i7=0;_i7<torsoRectangleCount;++_i7){var _x4=_i7%radialSegments;var _y3=_i7*radialSegmentsReciprocal|0;var a=_y3*radialCount+_x4;var b=a+1;var c=a+radialCount;var d=c+1;indices[indicesOffset++]=b;indices[indicesOffset++]=c;indices[indicesOffset++]=a;indices[indicesOffset++]=b;indices[indicesOffset++]=d;indices[indicesOffset++]=c;}// Bottom position
  positions[torsoVertexCount]=new Vector3(0,-halfHeight,0);// Bottom normal
  normals[torsoVertexCount]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[torsoVertexCount]=new Vector2(0.5,0.5);// Add bottom cap vertices
  var offset=torsoVertexCount+1;var diameterBottomReciprocal=1.0/(radius*2);for(var _i8=0;_i8<radialSegments;++_i8){var curPos=positions[_i8];var curPosX=curPos.x;var curPosZ=curPos.z;// Bottom position
  positions[offset]=new Vector3(curPosX,-halfHeight,curPosZ);// Bottom normal
  normals[offset]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[offset++]=new Vector2(curPosX*diameterBottomReciprocal+0.5,0.5-curPosZ*diameterBottomReciprocal);}var bottomIndiceIndex=torsoVertexCount+1;for(var _i9=0;_i9<radialSegments;++_i9){var firstStride=_i9;var secondStride=_i9===radialSegments-1?0:firstStride+1;// Bottom
  indices[indicesOffset++]=torsoVertexCount;indices[indicesOffset++]=bottomIndiceIndex+secondStride;indices[indicesOffset++]=bottomIndiceIndex+firstStride;}var bounds=mesh.bounds;bounds.min.set(-radius,-halfHeight,-radius);bounds.max.set(radius,halfHeight,radius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a capsule mesh.
     * @param engine - Engine
     * @param radius - The radius of the two hemispherical ends
     * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
     * @param radialSegments - Hemispherical end radial segments
     * @param heightSegments - Cylindrical part height segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Capsule model mesh
     */;PrimitiveMesh.createCapsule=function createCapsule(engine,radius,height,radialSegments,heightSegments,noLongerAccessible){if(radius===void 0){radius=0.5;}if(height===void 0){height=2;}if(radialSegments===void 0){radialSegments=6;}if(heightSegments===void 0){heightSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.max(2,Math.floor(radialSegments));heightSegments=Math.floor(heightSegments);var radialCount=radialSegments+1;var verticalCount=heightSegments+1;var halfHeight=height*0.5;var unitHeight=height/heightSegments;var torsoVertexCount=radialCount*verticalCount;var torsoRectangleCount=radialSegments*heightSegments;var capVertexCount=radialCount*radialCount;var capRectangleCount=radialSegments*radialSegments;var totalVertexCount=torsoVertexCount+2*capVertexCount;var indices=PrimitiveMesh._generateIndices(engine,totalVertexCount,(torsoRectangleCount+2*capRectangleCount)*6);var radialCountReciprocal=1.0/radialCount;var radialSegmentsReciprocal=1.0/radialSegments;var heightSegmentsReciprocal=1.0/heightSegments;var thetaStart=Math.PI;var thetaRange=Math.PI*2;var positions=new Array(totalVertexCount);var normals=new Array(totalVertexCount);var uvs=new Array(totalVertexCount);var indicesOffset=0;// create torso
  for(var i=0;i<torsoVertexCount;++i){var x=i%radialCount;var y=i*radialCountReciprocal|0;var u=x*radialSegmentsReciprocal;var v=y*heightSegmentsReciprocal;var theta=thetaStart+u*thetaRange;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);positions[i]=new Vector3(radius*sinTheta,y*unitHeight-halfHeight,radius*cosTheta);normals[i]=new Vector3(sinTheta,0,cosTheta);uvs[i]=new Vector2(u,1-v);}for(var _i10=0;_i10<torsoRectangleCount;++_i10){var _x5=_i10%radialSegments;var _y4=_i10*radialSegmentsReciprocal|0;var a=_y4*radialCount+_x5;var b=a+1;var c=a+radialCount;var d=c+1;indices[indicesOffset++]=b;indices[indicesOffset++]=c;indices[indicesOffset++]=a;indices[indicesOffset++]=b;indices[indicesOffset++]=d;indices[indicesOffset++]=c;}PrimitiveMesh._createCapsuleCap(radius,height,radialSegments,thetaRange,torsoVertexCount,1,positions,normals,uvs,indices,indicesOffset);PrimitiveMesh._createCapsuleCap(radius,height,radialSegments,-thetaRange,torsoVertexCount+capVertexCount,-1,positions,normals,uvs,indices,indicesOffset+6*capRectangleCount);var bounds=mesh.bounds;bounds.min.set(-radius,-radius-halfHeight,-radius);bounds.max.set(radius,radius+halfHeight,radius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;};PrimitiveMesh._initialize=function _initialize(mesh,positions,normals,uvs,indices,noLongerAccessible){mesh.setPositions(positions);mesh.setNormals(normals);mesh.setUVs(uvs);mesh.setIndices(indices);mesh.uploadData(noLongerAccessible);mesh.addSubMesh(0,indices.length);};PrimitiveMesh._generateIndices=function _generateIndices(engine,vertexCount,indexCount){var indices=null;if(vertexCount>65535){if(engine._hardwareRenderer.canIUse(exports.GLCapabilityType.elementIndexUint)){indices=new Uint32Array(indexCount);}else {throw Error("The vertex count is over limit.");}}else {indices=new Uint16Array(indexCount);}return indices;};PrimitiveMesh._createCapsuleCap=function _createCapsuleCap(radius,height,radialSegments,capAlphaRange,offset,posIndex,positions,normals,uvs,indices,indicesOffset){var radialCount=radialSegments+1;var halfHeight=height*0.5*posIndex;var capVertexCount=radialCount*radialCount;var capRectangleCount=radialSegments*radialSegments;var radialCountReciprocal=1.0/radialCount;var radialSegmentsReciprocal=1.0/radialSegments;for(var i=0;i<capVertexCount;++i){var x=i%radialCount;var y=i*radialCountReciprocal|0;var u=x*radialSegmentsReciprocal;var v=y*radialSegmentsReciprocal;var alphaDelta=u*capAlphaRange;var thetaDelta=v*Math.PI/2;var sinTheta=Math.sin(thetaDelta);var posX=-radius*Math.cos(alphaDelta)*sinTheta;var posY=radius*Math.cos(thetaDelta)*posIndex+halfHeight;var posZ=radius*Math.sin(alphaDelta)*sinTheta;var index=i+offset;positions[index]=new Vector3(posX,posY,posZ);normals[index]=new Vector3(posX,posY-halfHeight,posZ);uvs[index]=new Vector2(u,v);}for(var _i11=0;_i11<capRectangleCount;++_i11){var _x6=_i11%radialSegments;var _y5=_i11*radialSegmentsReciprocal|0;var a=_y5*radialCount+_x6+offset;var b=a+1;var c=a+radialCount;var d=c+1;indices[indicesOffset++]=b;indices[indicesOffset++]=a;indices[indicesOffset++]=d;indices[indicesOffset++]=a;indices[indicesOffset++]=c;indices[indicesOffset++]=d;}};return PrimitiveMesh;}();/**
   * BufferMesh.
   */var BufferMesh=/*#__PURE__*/function(_Mesh){_inheritsLoose$2(BufferMesh,_Mesh);function BufferMesh(){return _Mesh.apply(this,arguments)||this;}var _proto=BufferMesh.prototype;/**
     * Set vertex elements.
     * @param elements - Vertex element collection
     */_proto.setVertexElements=function setVertexElements(elements){this._setVertexElements(elements);}/**
     * Set vertex buffer binding.
     * @param vertexBufferBindings - Vertex buffer binding
     * @param index - Vertex buffer index, the default value is 0
     */;_proto.setVertexBufferBinding=function setVertexBufferBinding(bufferOrBinding,strideOrFirstIndex,index){if(strideOrFirstIndex===void 0){strideOrFirstIndex=0;}if(index===void 0){index=0;}var binding=bufferOrBinding;var isBinding=binding.buffer!==undefined;isBinding||(binding=new VertexBufferBinding(bufferOrBinding,strideOrFirstIndex));var bindings=this._vertexBufferBindings;bindings.length<=index&&(bindings.length=index+1);this._setVertexBufferBinding(isBinding?strideOrFirstIndex:index,binding);}/**
     * Set vertex buffer binding.
     * @param vertexBufferBindings - Vertex buffer binding
     * @param firstIndex - First vertex buffer index, the default value is 0
     */;_proto.setVertexBufferBindings=function setVertexBufferBindings(vertexBufferBindings,firstIndex){if(firstIndex===void 0){firstIndex=0;}var bindings=this._vertexBufferBindings;var count=vertexBufferBindings.length;var needLength=firstIndex+count;bindings.length<needLength&&(bindings.length=needLength);for(var i=0;i<count;i++){this._setVertexBufferBinding(firstIndex+i,vertexBufferBindings[i]);}}/**
     * Set index buffer binding.
     * @param buffer - Index buffer
     * @param format - Index buffer format
     */;_proto.setIndexBufferBinding=function setIndexBufferBinding(bufferOrBinding,format){var binding=bufferOrBinding;if(binding){var isBinding=binding.buffer!==undefined;isBinding||(binding=new IndexBufferBinding(bufferOrBinding,format));}this._setIndexBufferBinding(binding);};_createClass$3(BufferMesh,[{key:"instanceCount",get:/**
       * Instanced count, disable instanced drawing when set zero.
       */function get(){return this._instanceCount;},set:function set(value){this._instanceCount=value;}/**
       * Vertex buffer binding collection.
       */},{key:"vertexBufferBindings",get:function get(){return this._vertexBufferBindings;}/**
       * Index buffer binding.
       */},{key:"indexBufferBinding",get:function get(){return this._indexBufferBinding;}/**
       * Vertex element collection.
       */},{key:"vertexElements",get:function get(){return this._vertexElements;}}]);return BufferMesh;}(Mesh);/**
   * BlendShapeFrame.
   */var BlendShapeFrame=/** Weight of BlendShapeFrame. */ /** Delta positions for the frame being added. */ /** Delta normals for the frame being added. */ /** Delta tangents for the frame being added. */ /**
   * Create a BlendShapeFrame.
   * @param weight - Weight of BlendShapeFrame
   * @param deltaPositions - Delta positions for the frame being added
   * @param deltaNormals - Delta normals for the frame being added
   * @param deltaTangents - Delta tangents for the frame being added
   */function BlendShapeFrame(weight,deltaPositions,deltaNormals,deltaTangents){if(deltaNormals===void 0){deltaNormals=null;}if(deltaTangents===void 0){deltaTangents=null;}this.weight=void 0;this.deltaPositions=void 0;this.deltaNormals=void 0;this.deltaTangents=void 0;if(deltaNormals&&deltaNormals.length!==deltaPositions.length){throw "deltaNormals length must same with deltaPositions length.";}if(deltaTangents&&deltaTangents.length!==deltaPositions.length){throw "deltaTangents length must same with deltaPositions length.";}this.weight=weight;this.deltaPositions=deltaPositions;this.deltaNormals=deltaNormals;this.deltaTangents=deltaTangents;};/**
   * BlendShape.
   */var BlendShape=/*#__PURE__*/function(){/**
     * Create a BlendShape.
     * @param name - BlendShape name.
     */function BlendShape(name){this.name=void 0;this._useBlendShapeNormal=true;this._useBlendShapeTangent=true;this._layoutChangeManager=new UpdateFlagManager();this._dataChangeManager=new UpdateFlagManager();this._frames=[];this.name=name;}/**
     * Add a BlendShapeFrame by weight, deltaPositions, deltaNormals and deltaTangents.
     * @param weight - Weight of BlendShapeFrame
     * @param deltaPositions - Delta positions for the frame being added
     * @param deltaNormals - Delta normals for the frame being added
     * @param deltaTangents - Delta tangents for the frame being added
     */var _proto=BlendShape.prototype;_proto.addFrame=function addFrame(frameOrWeight,deltaPositions,deltaNormals,deltaTangents){if(typeof frameOrWeight==="number"){var _frame=new BlendShapeFrame(frameOrWeight,deltaPositions,deltaNormals,deltaTangents);this._addFrame(_frame);return _frame;}else {this._addFrame(frameOrWeight);}}/**
     * Clear all frames.
     */;_proto.clearFrames=function clearFrames(){this._frames.length=0;this._updateUseNormalAndTangent(true,true);this._dataChangeManager.dispatch();}/**
     * @internal
     */;_proto._addLayoutChangeFlag=function _addLayoutChangeFlag(flag){this._layoutChangeManager.addFlag(flag);}/**
     * @internal
     */;_proto._addDataDirtyFlag=function _addDataDirtyFlag(flag){this._dataChangeManager.addFlag(flag);}/**
     * @internal
     */;_proto._createSubDataDirtyFlag=function _createSubDataDirtyFlag(){return this._dataChangeManager.createFlag(BoolUpdateFlag);};_proto._addFrame=function _addFrame(frame){var frames=this._frames;var frameCount=frames.length;if(frameCount>0&&frame.deltaPositions.length!==frames[frameCount-1].deltaPositions.length){throw "Frame's deltaPositions length must same with before frame deltaPositions length.";}this._frames.push(frame);this._updateUseNormalAndTangent(!!frame.deltaNormals,!!frame.deltaTangents);this._dataChangeManager.dispatch();};_proto._updateUseNormalAndTangent=function _updateUseNormalAndTangent(useNormal,useTangent){var useBlendShapeNormal=this._useBlendShapeNormal&&useNormal;var useBlendShapeTangent=this._useBlendShapeTangent&&useTangent;if(this._useBlendShapeNormal!==useBlendShapeNormal||this._useBlendShapeTangent!==useBlendShapeTangent){this._useBlendShapeNormal=useBlendShapeNormal;this._useBlendShapeTangent=useBlendShapeTangent;this._layoutChangeManager.dispatch(this);}};_createClass$3(BlendShape,[{key:"frames",get:/** Name of BlendShape. */ /** @internal */ /** @internal */ /**
       * Frames of BlendShape.
       */function get(){return this._frames;}}]);return BlendShape;}();var Basic2DBatcher=/*#__PURE__*/function(){/** The maximum number of vertex. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */function Basic2DBatcher(engine){this._engine=void 0;this._subMeshPool=new ClassPool(SubMesh);this._batchedQueue=[];this._meshes=[];this._meshCount=1;this._vertexBuffers=[];this._indiceBuffers=[];this._vertices=void 0;this._indices=void 0;this._flushId=0;this._vertexCount=0;this._elementCount=0;this._engine=engine;var MAX_VERTEX_COUNT=Basic2DBatcher.MAX_VERTEX_COUNT;this._vertices=new Float32Array(MAX_VERTEX_COUNT*9);this._indices=new Uint16Array(MAX_VERTEX_COUNT*3);var _meshes=this._meshes,_meshCount=this._meshCount;for(var i=0;i<_meshCount;i++){_meshes[i]=this._createMesh(engine,i);}}var _proto=Basic2DBatcher.prototype;_proto.drawElement=function drawElement(element,camera,replaceMaterial){if(element.multiRenderData){var elements=element.charElements;for(var i=0,n=elements.length;i<n;++i){this._drawSubElement(elements[i],camera,replaceMaterial);}}else {this._drawSubElement(element,camera,replaceMaterial);}};_proto._drawSubElement=function _drawSubElement(element,camera,replaceMaterial){var len=element.renderData.vertexCount;if(this._vertexCount+len>Basic2DBatcher.MAX_VERTEX_COUNT){this.flush(camera,replaceMaterial);}this._vertexCount+=len;this._batchedQueue[this._elementCount++]=element;};_proto.flush=function flush(camera,replaceMaterial){var batchedQueue=this._batchedQueue;if(batchedQueue.length===0){return;}this._updateData(this._engine);this.drawBatches(camera,replaceMaterial);if(!Basic2DBatcher._canUploadSameBuffer){this._flushId++;}batchedQueue.length=0;this._subMeshPool.resetPool();this._vertexCount=0;this._elementCount=0;};_proto.clear=function clear(){this._flushId=0;this._vertexCount=0;this._elementCount=0;this._batchedQueue.length=0;};_proto.destroy=function destroy(){this._batchedQueue=null;var meshes=this._meshes,vertexBuffers=this._vertexBuffers,indiceBuffers=this._indiceBuffers;for(var i=0,n=meshes.length;i<n;++i){meshes[i].destroy();}this._meshes=null;for(var _i=0,_n=vertexBuffers.length;_i<_n;++_i){vertexBuffers[_i].destroy();}this._vertexBuffers=null;for(var _i2=0,_n2=indiceBuffers.length;_i2<_n2;++_i2){indiceBuffers[_i2].destroy();}this._indiceBuffers=null;};_proto._createMesh=function _createMesh(engine,index){var MAX_VERTEX_COUNT=Basic2DBatcher.MAX_VERTEX_COUNT;var mesh=new BufferMesh(engine,"BufferMesh"+index);var vertexElements=[];var vertexStride=this.createVertexElements(vertexElements);// vertices
  this._vertexBuffers[index]=new Buffer(engine,exports.BufferBindFlag.VertexBuffer,MAX_VERTEX_COUNT*4*vertexStride,exports.BufferUsage.Dynamic);// indices
  this._indiceBuffers[index]=new Buffer(engine,exports.BufferBindFlag.IndexBuffer,MAX_VERTEX_COUNT*3,exports.BufferUsage.Dynamic);mesh.setVertexBufferBinding(this._vertexBuffers[index],vertexStride);mesh.setIndexBufferBinding(this._indiceBuffers[index],exports.IndexFormat.UInt16);mesh.setVertexElements(vertexElements);return mesh;};_proto._updateData=function _updateData(engine){var _meshes=this._meshes,_flushId=this._flushId;if(!Basic2DBatcher._canUploadSameBuffer&&this._meshCount<=_flushId){this._meshCount++;_meshes[_flushId]=this._createMesh(engine,_flushId);}var batchedQueue=this._batchedQueue,vertices=this._vertices,indices=this._indices;var mesh=_meshes[_flushId];mesh.clearSubMesh();var vertexIndex=0;var indiceIndex=0;var vertexStartIndex=0;var vertexCount=0;var curIndiceStartIndex=0;var curMeshIndex=0;var preElement=null;for(var i=0,len=batchedQueue.length;i<len;i++){var _curElement=batchedQueue[i];// Batch vertex
  vertexIndex=this.updateVertices(_curElement,vertices,vertexIndex);// Batch indice
  var triangles=_curElement.renderData.triangles;var triangleNum=triangles.length;for(var j=0;j<triangleNum;j++){indices[indiceIndex++]=triangles[j]+curIndiceStartIndex;}curIndiceStartIndex+=_curElement.renderData.vertexCount;if(preElement===null){vertexCount+=triangleNum;}else {if(this.canBatch(preElement,_curElement)){vertexCount+=triangleNum;}else {mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex,vertexCount));vertexStartIndex+=vertexCount;vertexCount=triangleNum;batchedQueue[curMeshIndex++]=preElement;}}preElement=_curElement;}mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex,vertexCount));batchedQueue[curMeshIndex]=preElement;this._vertexBuffers[_flushId].setData(vertices,0,0,vertexIndex);this._indiceBuffers[_flushId].setData(indices,0,0,indiceIndex);};_proto._getSubMeshFromPool=function _getSubMeshFromPool(start,count){var subMesh=this._subMeshPool.getFromPool();subMesh.start=start;subMesh.count=count;subMesh.topology=exports.MeshTopology.Triangles;return subMesh;}/**
     * @internal
     */;return Basic2DBatcher;}();Basic2DBatcher.MAX_VERTEX_COUNT=4096;Basic2DBatcher._canUploadSameBuffer=true;var SpriteMaskBatcher=/*#__PURE__*/function(_Basic2DBatcher){_inheritsLoose$2(SpriteMaskBatcher,_Basic2DBatcher);function SpriteMaskBatcher(){return _Basic2DBatcher.apply(this,arguments)||this;}var _proto=SpriteMaskBatcher.prototype;_proto.createVertexElements=function createVertexElements(vertexElements){vertexElements[0]=new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0);vertexElements[1]=new VertexElement("TEXCOORD_0",12,exports.VertexElementFormat.Vector2,0);return 20;};_proto.canBatch=function canBatch(preElement,curElement){if(preElement.isAdd!==curElement.isAdd){return false;}// Compare renderer property
  var preShaderData=preElement.component.shaderData;var curShaderData=curElement.component.shaderData;var textureProperty=SpriteMask._textureProperty;var alphaCutoffProperty=SpriteMask._alphaCutoffProperty;return preShaderData.getTexture(textureProperty)===curShaderData.getTexture(textureProperty)&&preShaderData.getTexture(alphaCutoffProperty)===curShaderData.getTexture(alphaCutoffProperty);};_proto.updateVertices=function updateVertices(element,vertices,vertexIndex){var _element$renderData=element.renderData,positions=_element$renderData.positions,uvs=_element$renderData.uvs,vertexCount=_element$renderData.vertexCount;for(var i=0;i<vertexCount;i++){var curPos=positions[i];var curUV=uvs[i];vertices[vertexIndex++]=curPos.x;vertices[vertexIndex++]=curPos.y;vertices[vertexIndex++]=curPos.z;vertices[vertexIndex++]=curUV.x;vertices[vertexIndex++]=curUV.y;}return vertexIndex;};_proto.drawBatches=function drawBatches(camera){var engine=this._engine,batchedQueue=this._batchedQueue;var mesh=this._meshes[this._flushId];var subMeshes=mesh.subMeshes;var sceneData=camera.scene.shaderData;var cameraData=camera.shaderData;for(var i=0,len=subMeshes.length;i<len;i++){var subMesh=subMeshes[i];var spriteMaskElement=batchedQueue[i];if(!subMesh||!spriteMaskElement){return;}var renderer=spriteMaskElement.component;var material=spriteMaskElement.material;var compileMacros=Shader._compileMacros;// union render global macro and material self macro.
  ShaderMacroCollection.unionCollection(renderer._globalShaderMacro,material.shaderData._macroCollection,compileMacros);// Update stencil state
  var stencilState=material.renderState.stencilState;var op=spriteMaskElement.isAdd?exports.StencilOperation.IncrementSaturate:exports.StencilOperation.DecrementSaturate;stencilState.passOperationFront=op;stencilState.passOperationBack=op;var program=material.shader._getShaderProgram(engine,compileMacros);if(!program.isValid){return;}program.bind();program.groupingOtherUniformBlock();program.uploadAll(program.sceneUniformBlock,sceneData);program.uploadAll(program.cameraUniformBlock,cameraData);program.uploadAll(program.rendererUniformBlock,renderer.shaderData);program.uploadAll(program.materialUniformBlock,material.shaderData);material.renderState._apply(engine,false);engine._hardwareRenderer.drawPrimitive(mesh,subMesh,program);}};return SpriteMaskBatcher;}(Basic2DBatcher);/**
   * @internal
   */var SpriteMaskManager=/*#__PURE__*/function(){function SpriteMaskManager(engine){this._batcher=void 0;this._preMaskLayer=0;this._batcher=new SpriteMaskBatcher(engine);}var _proto=SpriteMaskManager.prototype;_proto.clear=function clear(){this._preMaskLayer=0;this._batcher.clear();};_proto.preRender=function preRender(camera,renderer){if(renderer.maskInteraction===exports.SpriteMaskInteraction.None){return;}this._batcher.clear();this._processMasksDiff(camera,renderer);this._batcher.flush(camera,null);};_proto.postRender=function postRender(renderer){if(renderer.maskInteraction===exports.SpriteMaskInteraction.None){return;}this._preMaskLayer=renderer.maskLayer;};_proto.destroy=function destroy(){this._batcher.destroy();this._batcher=null;};_proto._processMasksDiff=function _processMasksDiff(camera,renderer){var preMaskLayer=this._preMaskLayer;var curMaskLayer=renderer.maskLayer;if(preMaskLayer!==curMaskLayer){var allMasks=camera._renderPipeline._allSpriteMasks;var commonLayer=preMaskLayer&curMaskLayer;var addLayer=curMaskLayer&~preMaskLayer;var reduceLayer=preMaskLayer&~curMaskLayer;var allMaskElements=allMasks._elements;for(var i=0,n=allMasks.length;i<n;i++){var mask=allMaskElements[i];var influenceLayers=mask.influenceLayers;if(influenceLayers&commonLayer){continue;}if(influenceLayers&addLayer){var maskRenderElement=mask._maskElement;maskRenderElement.isAdd=true;this._batcher.drawElement(maskRenderElement,camera,null);continue;}if(influenceLayers&reduceLayer){var _maskRenderElement=mask._maskElement;_maskRenderElement.isAdd=false;this._batcher.drawElement(_maskRenderElement,camera,null);}}}};return SpriteMaskManager;}();var TextRenderElement=/*#__PURE__*/function(_RenderElement){_inheritsLoose$2(TextRenderElement,_RenderElement);function TextRenderElement(){var _this;_this=_RenderElement.call(this)||this;_this.charElements=[];_this.multiRenderData=true;return _this;}return TextRenderElement;}(RenderElement);/**
   * The Background mode enumeration.
   */exports.BackgroundMode = void 0;(function(BackgroundMode){BackgroundMode[BackgroundMode["SolidColor"]=0]="SolidColor";BackgroundMode[BackgroundMode["Sky"]=1]="Sky";BackgroundMode[BackgroundMode["Texture"]=2]="Texture";})(exports.BackgroundMode||(exports.BackgroundMode={}));/**
   * Filling mode of background texture.
   */exports.BackgroundTextureFillMode = void 0;(function(BackgroundTextureFillMode){BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitWidth"]=0]="AspectFitWidth";BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitHeight"]=1]="AspectFitHeight";BackgroundTextureFillMode[BackgroundTextureFillMode["Fill"]=2]="Fill";})(exports.BackgroundTextureFillMode||(exports.BackgroundTextureFillMode={}));/**
   * Sky.
   */var Sky=function Sky(){this.material=void 0;this.mesh=void 0;this._matrix=new Matrix();};/**
   * Background of scene.
   */var Background=/*#__PURE__*/function(){/**
     * Constructor of Background.
     * @param _engine Engine Which the background belongs to.
     */function Background(_engine){this._engine=_engine;this.mode=exports.BackgroundMode.SolidColor;this.solidColor=new Color(0.25,0.25,0.25,1.0);this.sky=new Sky();this._textureFillMode=exports.BackgroundTextureFillMode.AspectFitHeight;this._mesh=void 0;this._texture=null;this._mesh=this._createPlane(_engine);}/**
     * @internal
     */var _proto=Background.prototype;_proto._resizeBackgroundTexture=function _resizeBackgroundTexture(){if(!this._texture){return;}var canvas=this._engine.canvas;var width=canvas.width,height=canvas.height;var _backgroundTextureMesh=this._mesh;var positions=_backgroundTextureMesh.getPositions();switch(this._textureFillMode){case exports.BackgroundTextureFillMode.Fill:positions[0].set(-1,-1,1);positions[1].set(1,-1,1);positions[2].set(-1,1,1);positions[3].set(1,1,1);break;case exports.BackgroundTextureFillMode.AspectFitWidth:var fitWidthScale=this._texture.height*width/this.texture.width/height;positions[0].set(-1,-fitWidthScale,1);positions[1].set(1,-fitWidthScale,1);positions[2].set(-1,fitWidthScale,1);positions[3].set(1,fitWidthScale,1);break;case exports.BackgroundTextureFillMode.AspectFitHeight:var fitHeightScale=this._texture.width*height/this.texture.height/width;positions[0].set(-fitHeightScale,-1,1);positions[1].set(fitHeightScale,-1,1);positions[2].set(-fitHeightScale,1,1);positions[3].set(fitHeightScale,1,1);break;}_backgroundTextureMesh.setPositions(positions);_backgroundTextureMesh.uploadData(false);};_proto._createPlane=function _createPlane(engine){var mesh=new ModelMesh(engine);mesh.isGCIgnored=true;var indices=new Uint8Array([1,2,0,1,3,2]);var positions=new Array(4);var uvs=new Array(4);for(var i=0;i<4;++i){positions[i]=new Vector3();uvs[i]=new Vector2(i%2,1-(i*0.5|0));}mesh.setPositions(positions);mesh.setUVs(uvs);mesh.setIndices(indices);mesh.uploadData(false);mesh.addSubMesh(0,indices.length);return mesh;};_createClass$3(Background,[{key:"texture",get:/**
       * Background mode.
       * @defaultValue `BackgroundMode.SolidColor`
       * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.
       */ /**
       * Background solid color.
       * @defaultValue `new Color(0.25, 0.25, 0.25, 1.0)`
       * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.
       */ /**
       * Background sky.
       * @remarks When `mode` is `BackgroundMode.Sky`, the property will take effects.
       */ /** @internal */ /** @internal */ /**
       * Background texture.
       * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
       */function get(){return this._texture;},set:function set(value){if(this._texture!==value){this._texture=value;this._engine._backgroundTextureMaterial.shaderData.setTexture("u_baseTexture",value);}}/**
       * @internal
       * Background texture fill mode.
       * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
       * @defaultValue `BackgroundTextureFillMode.FitHeight`
       */},{key:"textureFillMode",get:function get(){return this._textureFillMode;},set:function set(value){if(value!==this._textureFillMode){this._textureFillMode=value;this._resizeBackgroundTexture();}}}]);return Background;}();/**
   * Diffuse mode.
   */exports.DiffuseMode = void 0;(function(DiffuseMode){DiffuseMode[DiffuseMode["SolidColor"]=0]="SolidColor";DiffuseMode[DiffuseMode["SphericalHarmonics"]=1]="SphericalHarmonics";})(exports.DiffuseMode||(exports.DiffuseMode={}));/**
   * Ambient light.
   */var AmbientLight=/*#__PURE__*/function(){function AmbientLight(){this._diffuseSphericalHarmonics=void 0;this._diffuseSolidColor=new Color(0.212,0.227,0.259);this._diffuseIntensity=1.0;this._specularTexture=void 0;this._specularIntensity=1.0;this._diffuseMode=exports.DiffuseMode.SolidColor;this._shArray=new Float32Array(27);this._scenes=[];this._specularTextureDecodeRGBM=false;}var _proto=AmbientLight.prototype;/**
     * @internal
     */_proto._addToScene=function _addToScene(scene){this._scenes.push(scene);var shaderData=scene.shaderData;shaderData.setColor(AmbientLight._diffuseColorProperty,this._diffuseSolidColor);shaderData.setFloat(AmbientLight._diffuseIntensityProperty,this._diffuseIntensity);shaderData.setFloat(AmbientLight._specularIntensityProperty,this._specularIntensity);shaderData.setFloatArray(AmbientLight._diffuseSHProperty,this._shArray);this._setDiffuseMode(shaderData);this._setSpecularTextureDecodeRGBM(shaderData);this._setSpecularTexture(shaderData);}/**
     * @internal
     */;_proto._removeFromScene=function _removeFromScene(scene){var scenes=this._scenes;var index=scenes.indexOf(scene);scenes.splice(index,1);};_proto._setDiffuseMode=function _setDiffuseMode(sceneShaderData){if(this._diffuseMode===exports.DiffuseMode.SphericalHarmonics){sceneShaderData.enableMacro(AmbientLight._shMacro);}else {sceneShaderData.disableMacro(AmbientLight._shMacro);}};_proto._setSpecularTexture=function _setSpecularTexture(sceneShaderData){if(this._specularTexture){sceneShaderData.setTexture(AmbientLight._specularTextureProperty,this._specularTexture);sceneShaderData.setFloat(AmbientLight._mipLevelProperty,this._specularTexture.mipmapCount-1);sceneShaderData.enableMacro(AmbientLight._specularMacro);}else {sceneShaderData.disableMacro(AmbientLight._specularMacro);}};_proto._setSpecularTextureDecodeRGBM=function _setSpecularTextureDecodeRGBM(sceneShaderData){if(this._specularTextureDecodeRGBM){sceneShaderData.enableMacro(AmbientLight._decodeRGBMMacro);}else {sceneShaderData.disableMacro(AmbientLight._decodeRGBMMacro);}};_proto._preComputeSH=function _preComputeSH(sh,out){/**
       * Basis constants
       *
       * 0: 1/2 * Math.sqrt(1 / Math.PI)
       *
       * 1: -1/2 * Math.sqrt(3 / Math.PI)
       * 2: 1/2 * Math.sqrt(3 / Math.PI)
       * 3: -1/2 * Math.sqrt(3 / Math.PI)
       *
       * 4: 1/2 * Math.sqrt(15 / Math.PI)
       * 5: -1/2 * Math.sqrt(15 / Math.PI)
       * 6: 1/4 * Math.sqrt(5 / Math.PI)
       * 7: -1/2 * Math.sqrt(15 / Math.PI)
       * 8: 1/4 * Math.sqrt(15 / Math.PI)
       */ /**
       * Convolution kernel
       *
       * 0: Math.PI
       * 1: (2 * Math.PI) / 3
       * 2: Math.PI / 4
       */var src=sh.coefficients;// l0
  out[0]=src[0]*0.886227;// kernel0 * basis0 = 0.886227
  out[1]=src[1]*0.886227;out[2]=src[2]*0.886227;// l1
  out[3]=src[3]*-1.023327;// kernel1 * basis1 = -1.023327;
  out[4]=src[4]*-1.023327;out[5]=src[5]*-1.023327;out[6]=src[6]*1.023327;// kernel1 * basis2 = 1.023327
  out[7]=src[7]*1.023327;out[8]=src[8]*1.023327;out[9]=src[9]*-1.023327;// kernel1 * basis3 = -1.023327
  out[10]=src[10]*-1.023327;out[11]=src[11]*-1.023327;// l2
  out[12]=src[12]*0.858086;// kernel2 * basis4 = 0.858086
  out[13]=src[13]*0.858086;out[14]=src[14]*0.858086;out[15]=src[15]*-0.858086;// kernel2 * basis5 = -0.858086
  out[16]=src[16]*-0.858086;out[17]=src[17]*-0.858086;out[18]=src[18]*0.247708;// kernel2 * basis6 = 0.247708
  out[19]=src[19]*0.247708;out[20]=src[20]*0.247708;out[21]=src[21]*-0.858086;// kernel2 * basis7 = -0.858086
  out[22]=src[22]*-0.858086;out[23]=src[23]*-0.858086;out[24]=src[24]*0.429042;// kernel2 * basis8 = 0.429042
  out[25]=src[25]*0.429042;out[26]=src[26]*0.429042;};_createClass$3(AmbientLight,[{key:"specularTextureDecodeRGBM",get:/**
       * Whether to decode from specularTexture with RGBM format.
       */function get(){return this._specularTextureDecodeRGBM;},set:function set(value){this._specularTextureDecodeRGBM=value;var scenes=this._scenes;for(var i=0,n=scenes.length;i<n;i++){this._setSpecularTextureDecodeRGBM(scenes[i].shaderData);}}/**
       * Diffuse mode of ambient light.
       */},{key:"diffuseMode",get:function get(){return this._diffuseMode;},set:function set(value){this._diffuseMode=value;var scenes=this._scenes;for(var i=0,n=scenes.length;i<n;i++){this._setDiffuseMode(scenes[i].shaderData);}}/**
       * Diffuse reflection solid color.
       * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.
       */},{key:"diffuseSolidColor",get:function get(){return this._diffuseSolidColor;},set:function set(value){if(value!==this._diffuseSolidColor){this._diffuseSolidColor.copyFrom(value);}}/**
       * Diffuse reflection spherical harmonics 3.
       * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.
       */},{key:"diffuseSphericalHarmonics",get:function get(){return this._diffuseSphericalHarmonics;},set:function set(value){this._diffuseSphericalHarmonics=value;if(value){this._preComputeSH(value,this._shArray);var scenes=this._scenes;for(var i=0,n=scenes.length;i<n;i++){scenes[i].shaderData.setFloatArray(AmbientLight._diffuseSHProperty,this._shArray);}}}/**
       * Diffuse reflection intensity.
       */},{key:"diffuseIntensity",get:function get(){return this._diffuseIntensity;},set:function set(value){this._diffuseIntensity=value;var scenes=this._scenes;for(var i=0,n=scenes.length;i<n;i++){scenes[i].shaderData.setFloat(AmbientLight._diffuseIntensityProperty,value);}}/**
       * Specular reflection texture.
       * @remarks This texture must be baked from @oasis-engine/baker
       */},{key:"specularTexture",get:function get(){return this._specularTexture;},set:function set(value){this._specularTexture=value;var scenes=this._scenes;for(var i=0,n=scenes.length;i<n;i++){this._setSpecularTexture(scenes[i].shaderData);}}/**
       * Specular reflection intensity.
       */},{key:"specularIntensity",get:function get(){return this._specularIntensity;},set:function set(value){this._specularIntensity=value;for(var i=0,n=this._scenes.length;i<n;i++){this._scenes[i].shaderData.setFloat(AmbientLight._specularIntensityProperty,value);}}}]);return AmbientLight;}();AmbientLight._shMacro=Shader.getMacroByName("O3_USE_SH");AmbientLight._specularMacro=Shader.getMacroByName("O3_USE_SPECULAR_ENV");AmbientLight._decodeRGBMMacro=Shader.getMacroByName("O3_DECODE_ENV_RGBM");AmbientLight._diffuseColorProperty=Shader.getPropertyByName("u_envMapLight.diffuse");AmbientLight._diffuseSHProperty=Shader.getPropertyByName("u_env_sh");AmbientLight._diffuseIntensityProperty=Shader.getPropertyByName("u_envMapLight.diffuseIntensity");AmbientLight._specularTextureProperty=Shader.getPropertyByName("u_env_specularSampler");AmbientLight._specularIntensityProperty=Shader.getPropertyByName("u_envMapLight.specularIntensity");AmbientLight._mipLevelProperty=Shader.getPropertyByName("u_envMapLight.mipMapLevel");/**
   * Scene feature plug-in.
   * @deprecated
   */var SceneFeature=/*#__PURE__*/function(){function SceneFeature(){}var _proto=SceneFeature.prototype;/**
     * Callback before every scene update.
     * @param scene - Scene
     */_proto.preUpdate=function preUpdate(scene){}/**
     * Callback after every scene update.
     * @param scene - Scene
     */;_proto.postUpdate=function postUpdate(scene){}/**
     * Callback before scene rendering.
     * @param scene - Scene
     * @param camera - Camera
     */;_proto.preRender=function preRender(scene,camera){}/**
     * Callback after scene rendering.
     * @param scene - Scene
     * @param camera - Camera
     */;_proto.postRender=function postRender(scene,camera){}/**
     * Callback after the scene is destroyed.
     * @param scene - Scene
     */;_proto.destroy=function destroy(scene){};return SceneFeature;}();/**
   * Light base class.
   */var Light=/*#__PURE__*/function(_Component){_inheritsLoose$2(Light,_Component);function Light(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Component.call.apply(_Component,[this].concat(args))||this;_this._viewMat=void 0;_this._inverseViewMat=void 0;return _this;}var _proto=Light.prototype;/**
     * Mount to the current Scene.
     * @internal
     * @override
     */_proto._onEnable=function _onEnable(){this.scene.findFeature(LightFeature).attachRenderLight(this);}/**
     * Unmount from the current Scene.
     * @internal
     * @override
     */;_proto._onDisable=function _onDisable(){this.scene.findFeature(LightFeature).detachRenderLight(this);}/**
     * View matrix.
     */;_createClass$3(Light,[{key:"viewMatrix",get:function get(){if(!this._viewMat)this._viewMat=new Matrix();Matrix.invert(this.entity.transform.worldMatrix,this._viewMat);return this._viewMat;}/**
       * Inverse view matrix.
       */},{key:"inverseViewMatrix",get:function get(){if(!this._inverseViewMat)this._inverseViewMat=new Matrix();Matrix.invert(this.viewMatrix,this._inverseViewMat);return this._inverseViewMat;}}]);return Light;}(Component);Light._maxLight=10;/**
   * Directional light.
   */var DirectLight=/*#__PURE__*/function(_Light){_inheritsLoose$2(DirectLight,_Light);function DirectLight(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Light.call.apply(_Light,[this].concat(args))||this;_this.color=new Color(1,1,1,1);_this.intensity=1;_this._forward=new Vector3();_this._lightColor=new Color(1,1,1,1);_this._reverseDirection=new Vector3();return _this;}/**
     * @internal
     */DirectLight._updateShaderData=function _updateShaderData(shaderData){var data=DirectLight._combinedData;shaderData.setFloatArray(DirectLight._colorProperty,data.color);shaderData.setFloatArray(DirectLight._directionProperty,data.direction);};var _proto=DirectLight.prototype;/**
     * @internal
     */_proto._appendData=function _appendData(lightIndex){var colorStart=lightIndex*3;var directionStart=lightIndex*3;var lightColor=this.lightColor;var direction=this.direction;var data=DirectLight._combinedData;data.color[colorStart]=lightColor.r;data.color[colorStart+1]=lightColor.g;data.color[colorStart+2]=lightColor.b;data.direction[directionStart]=direction.x;data.direction[directionStart+1]=direction.y;data.direction[directionStart+2]=direction.z;};_createClass$3(DirectLight,[{key:"direction",get:/**
       * Get direction.
       */function get(){this.entity.transform.getWorldForward(this._forward);return this._forward;}/**
       * Get the final light color.
       */},{key:"lightColor",get:function get(){this._lightColor.r=this.color.r*this.intensity;this._lightColor.g=this.color.g*this.intensity;this._lightColor.b=this.color.b*this.intensity;this._lightColor.a=this.color.a*this.intensity;return this._lightColor;}/**
       * Get the opposite direction of the directional light direction.
       */},{key:"reverseDirection",get:function get(){Vector3.scale(this.direction,-1,this._reverseDirection);return this._reverseDirection;}}]);return DirectLight;}(Light);DirectLight._colorProperty=Shader.getPropertyByName("u_directLightColor");DirectLight._directionProperty=Shader.getPropertyByName("u_directLightDirection");DirectLight._combinedData={color:new Float32Array(3*Light._maxLight),direction:new Float32Array(3*Light._maxLight)};/**
   * Point light.
   */var PointLight=/*#__PURE__*/function(_Light){_inheritsLoose$2(PointLight,_Light);function PointLight(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Light.call.apply(_Light,[this].concat(args))||this;_this.color=new Color(1,1,1,1);_this.intensity=1.0;_this.distance=100;_this._lightColor=new Color(1,1,1,1);return _this;}/**
     * @internal
     */PointLight._updateShaderData=function _updateShaderData(shaderData){var data=PointLight._combinedData;shaderData.setFloatArray(PointLight._colorProperty,data.color);shaderData.setFloatArray(PointLight._positionProperty,data.position);shaderData.setFloatArray(PointLight._distanceProperty,data.distance);}/** Light color. */;var _proto=PointLight.prototype;/**
     * @internal
     */_proto._appendData=function _appendData(lightIndex){var colorStart=lightIndex*3;var positionStart=lightIndex*3;var distanceStart=lightIndex;var lightColor=this.lightColor;var lightPosition=this.position;var data=PointLight._combinedData;data.color[colorStart]=lightColor.r;data.color[colorStart+1]=lightColor.g;data.color[colorStart+2]=lightColor.b;data.position[positionStart]=lightPosition.x;data.position[positionStart+1]=lightPosition.y;data.position[positionStart+2]=lightPosition.z;data.distance[distanceStart]=this.distance;};_createClass$3(PointLight,[{key:"position",get:/**
       * Get light position.
       */function get(){return this.entity.transform.worldPosition;}/**
       * Get the final light color.
       */},{key:"lightColor",get:function get(){this._lightColor.r=this.color.r*this.intensity;this._lightColor.g=this.color.g*this.intensity;this._lightColor.b=this.color.b*this.intensity;this._lightColor.a=this.color.a*this.intensity;return this._lightColor;}}]);return PointLight;}(Light);PointLight._colorProperty=Shader.getPropertyByName("u_pointLightColor");PointLight._positionProperty=Shader.getPropertyByName("u_pointLightPosition");PointLight._distanceProperty=Shader.getPropertyByName("u_pointLightDistance");PointLight._combinedData={color:new Float32Array(3*Light._maxLight),position:new Float32Array(3*Light._maxLight),distance:new Float32Array(Light._maxLight)};/**
   * Spot light.
   */var SpotLight=/*#__PURE__*/function(_Light){_inheritsLoose$2(SpotLight,_Light);function SpotLight(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Light.call.apply(_Light,[this].concat(args))||this;_this.color=new Color(1,1,1,1);_this.intensity=1.0;_this.distance=100;_this.angle=Math.PI/6;_this.penumbra=Math.PI/12;_this._forward=new Vector3();_this._lightColor=new Color(1,1,1,1);_this._inverseDirection=new Vector3();return _this;}/**
     * @internal
     */SpotLight._updateShaderData=function _updateShaderData(shaderData){var data=SpotLight._combinedData;shaderData.setFloatArray(SpotLight._colorProperty,data.color);shaderData.setFloatArray(SpotLight._positionProperty,data.position);shaderData.setFloatArray(SpotLight._directionProperty,data.direction);shaderData.setFloatArray(SpotLight._distanceProperty,data.distance);shaderData.setFloatArray(SpotLight._angleCosProperty,data.angleCos);shaderData.setFloatArray(SpotLight._penumbraCosProperty,data.penumbraCos);}/** Light color. */;var _proto=SpotLight.prototype;/**
     * @internal
     */_proto._appendData=function _appendData(lightIndex){var colorStart=lightIndex*3;var positionStart=lightIndex*3;var directionStart=lightIndex*3;var distanceStart=lightIndex;var penumbraCosStart=lightIndex;var angleCosStart=lightIndex;var color=this.lightColor;var position=this.position;var direction=this.direction;var data=SpotLight._combinedData;data.color[colorStart]=color.r;data.color[colorStart+1]=color.g;data.color[colorStart+2]=color.b;data.position[positionStart]=position.x;data.position[positionStart+1]=position.y;data.position[positionStart+2]=position.z;data.direction[directionStart]=direction.x;data.direction[directionStart+1]=direction.y;data.direction[directionStart+2]=direction.z;data.distance[distanceStart]=this.distance;data.angleCos[angleCosStart]=Math.cos(this.angle);data.penumbraCos[penumbraCosStart]=Math.cos(this.angle+this.penumbra);};_createClass$3(SpotLight,[{key:"position",get:/**
       * Get light position.
       */function get(){return this.entity.transform.worldPosition;}/**
       * Get light direction.
       */},{key:"direction",get:function get(){this.entity.transform.getWorldForward(this._forward);return this._forward;}/**
       * Get the opposite direction of the spotlight.
       */},{key:"reverseDirection",get:function get(){Vector3.scale(this.direction,-1,this._inverseDirection);return this._inverseDirection;}/**
       * Get the final light color.
       */},{key:"lightColor",get:function get(){this._lightColor.r=this.color.r*this.intensity;this._lightColor.g=this.color.g*this.intensity;this._lightColor.b=this.color.b*this.intensity;this._lightColor.a=this.color.a*this.intensity;return this._lightColor;}}]);return SpotLight;}(Light);SpotLight._colorProperty=Shader.getPropertyByName("u_spotLightColor");SpotLight._positionProperty=Shader.getPropertyByName("u_spotLightPosition");SpotLight._directionProperty=Shader.getPropertyByName("u_spotLightDirection");SpotLight._distanceProperty=Shader.getPropertyByName("u_spotLightDistance");SpotLight._angleCosProperty=Shader.getPropertyByName("u_spotLightAngleCos");SpotLight._penumbraCosProperty=Shader.getPropertyByName("u_spotLightPenumbraCos");SpotLight._combinedData={color:new Float32Array(3*Light._maxLight),position:new Float32Array(3*Light._maxLight),direction:new Float32Array(3*Light._maxLight),distance:new Float32Array(Light._maxLight),angleCos:new Float32Array(Light._maxLight),penumbraCos:new Float32Array(Light._maxLight)};/**
   * Determine whether there are lights in the scene.
   * @returns Has light
   */function hasLight(){return this.findFeature(LightFeature).visibleLights.length>0;}/**
   * Light plug-in.
   */var LightFeature=/*#__PURE__*/function(_SceneFeature){_inheritsLoose$2(LightFeature,_SceneFeature);function LightFeature(){var _this;_this=_SceneFeature.call(this)||this;_this.visibleLights=void 0;_this.visibleLights=[];return _this;}/**
     * Register a light object to the current scene.
     * @param light
     */var _proto=LightFeature.prototype;_proto.attachRenderLight=function attachRenderLight(light){var index=this.visibleLights.indexOf(light);if(index==-1){this.visibleLights.push(light);}else {Logger.warn("Light already attached.");}}/**
     * Remove a light object from the current scene.
     * @param light
     */;_proto.detachRenderLight=function detachRenderLight(light){var index=this.visibleLights.indexOf(light);if(index!=-1){this.visibleLights.splice(index,1);}}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(shaderData){/**
       * ambientLight and envMapLight only use the last one in the scene
       * */var directLightCount=0;var pointLightCount=0;var spotLightCount=0;var lights=this.visibleLights;for(var i=0,len=lights.length;i<len;i++){var light=lights[i];if(light instanceof DirectLight){light._appendData(directLightCount++);}else if(light instanceof PointLight){light._appendData(pointLightCount++);}else if(light instanceof SpotLight){light._appendData(spotLightCount++);}}if(directLightCount){DirectLight._updateShaderData(shaderData);shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT",directLightCount.toString());}else {shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");}if(pointLightCount){PointLight._updateShaderData(shaderData);shaderData.enableMacro("O3_POINT_LIGHT_COUNT",pointLightCount.toString());}else {shaderData.disableMacro("O3_POINT_LIGHT_COUNT");}if(spotLightCount){SpotLight._updateShaderData(shaderData);shaderData.enableMacro("O3_SPOT_LIGHT_COUNT",spotLightCount.toString());}else {shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");}};return LightFeature;}(SceneFeature);/**
   * Scene.
   */var Scene=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Scene,_EngineObject);/**
     * Create scene.
     * @param engine - Engine
     * @param name - Name
     */function Scene(engine,name){var _this;_this=_EngineObject.call(this,engine)||this;_this.name=void 0;_this.background=new Background(_this._engine);_this.shaderData=new ShaderData(ShaderDataGroup.Scene);_this._activeCameras=[];_this._isActiveInEngine=false;_this._globalShaderMacro=new ShaderMacroCollection();_this._rootEntities=[];_this._ambientLight=void 0;_this.features=[];_this.name=name||"";var shaderData=_this.shaderData;Scene.sceneFeatureManager.addObject(_assertThisInitialized(_this));shaderData._addRefCount(1);_this.ambientLight=new AmbientLight();engine.sceneManager._allScenes.push(_assertThisInitialized(_this));return _this;}/**
     * Create root entity.
     * @param name - Entity name
     * @returns Entity
     */var _proto=Scene.prototype;_proto.createRootEntity=function createRootEntity(name){var entity=new Entity(this._engine,name);this.addRootEntity(entity);return entity;}/**
     * Append an entity.
     * @param entity - The root entity to add
     */;_proto.addRootEntity=function addRootEntity(indexOrChild,entity){var index;if(typeof indexOrChild==="number"){index=indexOrChild;}else {index=undefined;entity=indexOrChild;}var isRoot=entity._isRoot;// let entity become root
  if(!isRoot){entity._isRoot=true;entity._removeFromParent();}// add or remove from scene's rootEntities
  var oldScene=entity._scene;if(oldScene!==this){if(oldScene&&isRoot){oldScene._removeFromEntityList(entity);}this._addToRootEntityList(index,entity);Entity._traverseSetOwnerScene(entity,this);}else if(!isRoot){this._addToRootEntityList(index,entity);}// process entity active/inActive
  if(this._isActiveInEngine){!entity._isActiveInHierarchy&&entity._isActive&&entity._processActive();}else {entity._isActiveInHierarchy&&entity._processInActive();}}/**
     * Remove an entity.
     * @param entity - The root entity to remove
     */;_proto.removeRootEntity=function removeRootEntity(entity){if(entity._isRoot&&entity._scene==this){this._removeFromEntityList(entity);entity._isRoot=false;this._isActiveInEngine&&entity._isActiveInHierarchy&&entity._processInActive();Entity._traverseSetOwnerScene(entity,null);}}/**
     * Get root entity from index.
     * @param index - Index
     * @returns Entity
     */;_proto.getRootEntity=function getRootEntity(index){if(index===void 0){index=0;}return this._rootEntities[index];}/**
     * Find entity globally by name.
     * @param name - Entity name
     * @returns Entity
     */;_proto.findEntityByName=function findEntityByName(name){var children=this._rootEntities;for(var i=children.length-1;i>=0;i--){var child=children[i];if(child.name===name){return child;}}for(var _i=children.length-1;_i>=0;_i--){var _child=children[_i];var _entity=_child.findByName(name);if(_entity){return _entity;}}return null;}/**
     * Find entity globally by name,use â€˜/â€™ symbol as a path separator.
     * @param path - Entity's path
     * @returns Entity
     */;_proto.findEntityByPath=function findEntityByPath(path){var splits=path.split("/").filter(Boolean);for(var i=0,n=this.rootEntitiesCount;i<n;i++){var findEntity=this.getRootEntity(i);if(findEntity.name!=splits[0])continue;for(var j=1,m=splits.length;j<m;++j){findEntity=Entity._findChildByName(findEntity,splits[j]);if(!findEntity)break;}return findEntity;}return null;}/**
     * Destroy this scene.
     */;_proto.destroy=function destroy(){if(this._destroyed){return;}this._destroy();var allScenes=this.engine.sceneManager._allScenes;allScenes.splice(allScenes.indexOf(this),1);}/**
     * @internal
     */;_proto._attachRenderCamera=function _attachRenderCamera(camera){var index=this._activeCameras.indexOf(camera);if(index===-1){this._activeCameras.push(camera);}else {Logger.warn("Camera already attached.");}}/**
     * @internal
     */;_proto._detachRenderCamera=function _detachRenderCamera(camera){var index=this._activeCameras.indexOf(camera);if(index!==-1){this._activeCameras.splice(index,1);}}/**
     * @internal
     */;_proto._processActive=function _processActive(active){this._isActiveInEngine=active;var rootEntities=this._rootEntities;for(var i=rootEntities.length-1;i>=0;i--){var _entity2=rootEntities[i];if(_entity2._isActive){active?_entity2._processActive():_entity2._processInActive();}}}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(){this.findFeature(LightFeature)._updateShaderData(this.shaderData);// union scene and camera macro.
  ShaderMacroCollection.unionCollection(this.engine._macroCollection,this.shaderData._macroCollection,this._globalShaderMacro);}/**
     * @internal
     */;_proto._removeFromEntityList=function _removeFromEntityList(entity){var rootEntities=this._rootEntities;var index=entity._siblingIndex;rootEntities.splice(index,1);for(var n=rootEntities.length;index<n;index++){rootEntities[index]._siblingIndex--;}entity._siblingIndex=-1;}/**
     * @internal
     */;_proto._destroy=function _destroy(){this._isActiveInEngine&&(this._engine.sceneManager.activeScene=null);Scene.sceneFeatureManager.callFeatureMethod(this,"destroy",[this]);for(var i=0,n=this.rootEntitiesCount;i<n;i++){this._rootEntities[i].destroy();}this._rootEntities.length=0;this._activeCameras.length=0;Scene.sceneFeatureManager._objects=[];this.shaderData._addRefCount(-1);};_proto._addToRootEntityList=function _addToRootEntityList(index,rootEntity){var rootEntities=this._rootEntities;var rootEntityCount=rootEntities.length;if(index===undefined){rootEntity._siblingIndex=rootEntityCount;rootEntities.push(rootEntity);}else {if(index<0||index>rootEntityCount){throw "The index "+index+" is out of child list bounds "+rootEntityCount;}rootEntity._siblingIndex=index;rootEntities.splice(index,0,rootEntity);for(var i=index+1,n=rootEntityCount+1;i<n;i++){rootEntities[i]._siblingIndex++;}}}//-----------------------------------------@deprecated-----------------------------------
  ;Scene.registerFeature=function registerFeature(Feature){Scene.sceneFeatureManager.registerFeature(Feature);};_proto.findFeature=function findFeature(Feature){return Scene.sceneFeatureManager.findFeature(this,Feature);};_createClass$3(Scene,[{key:"ambientLight",get:/** Scene name. */ /** The background of the scene. */ /** Scene-related shader data. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
       * Ambient light.
       */function get(){return this._ambientLight;},set:function set(value){if(!value){Logger.warn("The scene must have one ambient light");return;}var lastAmbientLight=this._ambientLight;if(lastAmbientLight!==value){lastAmbientLight&&lastAmbientLight._removeFromScene(this);value._addToScene(this);this._ambientLight=value;}}/**
       * Count of root entities.
       */},{key:"rootEntitiesCount",get:function get(){return this._rootEntities.length;}/**
       * Root entity collection.
       */},{key:"rootEntities",get:function get(){return this._rootEntities;}}]);return Scene;}(EngineObject);Scene.sceneFeatureManager=new FeatureManager();/**
   * Scene manager.
   */var SceneManager=/*#__PURE__*/function(){/**
     * @internal
     */function SceneManager(engine){this.engine=engine;this._allScenes=[];this._activeScene=void 0;}/**
     * Load and activate scene.
     * @param url - the path of the scene
     * @param destroyOldScene - whether to destroy old scene information
     * @returns scene promise
     */var _proto=SceneManager.prototype;_proto.loadScene=function loadScene(url,destroyOldScene){var _this=this;if(destroyOldScene===void 0){destroyOldScene=true;}var scenePromise=this.engine.resourceManager.load(url);scenePromise.then(function(scene){var oldScene=_this._activeScene;_this.activeScene=scene;if(oldScene&&destroyOldScene){oldScene.destroy();}});return scenePromise;}/**
     * Merge the source scene into the target scene.
     * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.
     * @param sourceScene - source scene
     * @param destScene - target scene
     */;_proto.mergeScenes=function mergeScenes(sourceScene,destScene){var oldRootEntities=sourceScene.rootEntities;for(var i=0,n=oldRootEntities.length;i<n;i++){destScene.addRootEntity(oldRootEntities[i]);}}/**
     * @internal
     */;_proto._destroyAllScene=function _destroyAllScene(){var allScenes=this._allScenes;for(var i=0,n=allScenes.length;i<n;i++){allScenes[i]._destroy();}allScenes.length=0;};_createClass$3(SceneManager,[{key:"activeScene",get:/** @internal */ /** @internal */ /**
       * Get the activated scene.
       */function get(){return this._activeScene;},set:function set(scene){var oldScene=this._activeScene;if(oldScene!==scene){oldScene&&oldScene._processActive(false);scene&&scene._processActive(true);this._activeScene=scene;}}}]);return SceneManager;}();var blinnPhongFs="#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <mobile_material_frag>\n#include <fog_share>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#ifndef OASIS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n#include <fog_frag>\n}";// eslint-disable-line
  var blinnPhongVs="#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";// eslint-disable-line
  var particleFs="#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}";// eslint-disable-line
  var particleVs="#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}";// eslint-disable-line
  var pbrFs="#define GLSLIFY 1\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <common_frag>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <fog_frag>\n}";// eslint-disable-line
  var pbrSpecularFs="#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <fog_frag>\n}";// eslint-disable-line
  var pbrVs="#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";// eslint-disable-line
  var shadowMapFs="#define GLSLIFY 1\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}";// eslint-disable-line
  var shadowMapVs="#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}";// eslint-disable-line
  var shadowFs="#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}";// eslint-disable-line
  var skyboxFs="#define GLSLIFY 1\n#include <common>\nuniform samplerCube u_cube;varying vec3 v_cubeUV;uniform vec4 u_cubeDecodeParam;void main(){vec4 textureColor=textureCube(u_cube,v_cubeUV);if(u_cubeDecodeParam.x>0.0){textureColor=RGBMToLinear(textureColor,u_cubeDecodeParam.y);textureColor=linearToGamma(textureColor);}gl_FragColor=textureColor;}";// eslint-disable-line
  var skyboxVs="#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=vec3(-POSITION.x,POSITION.yz);gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}";// eslint-disable-line
  var spriteMaskFs="#define GLSLIFY 1\nuniform sampler2D u_maskTexture;uniform float u_maskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(u_maskTexture,v_uv);if(color.a<u_maskAlphaCutoff){discard;}gl_FragColor=color;}";// eslint-disable-line
  var spriteMaskVs="#define GLSLIFY 1\nuniform mat4 u_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=u_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";// eslint-disable-line
  var spriteFs="#define GLSLIFY 1\n#ifdef USE_CUSTOM_TEXTURE\nuniform sampler2D u_cusTomTexture;\n#else\nuniform sampler2D u_spriteTexture;\n#endif\nvarying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_CUSTOM_TEXTURE\nvec4 baseColor=texture2D(u_cusTomTexture,v_uv);\n#else\nvec4 baseColor=texture2D(u_spriteTexture,v_uv);\n#endif\ngl_FragColor=baseColor*v_color;}";// eslint-disable-line
  var spriteVs="#define GLSLIFY 1\n#ifdef USE_MODEL_MATRIX\nuniform mat4 u_MVPMat;\n#else\nuniform mat4 u_VPMat;\n#endif\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_MODEL_MATRIX\ngl_Position=u_MVPMat*vec4(POSITION,1.0);\n#else\ngl_Position=u_VPMat*vec4(POSITION,1.0);\n#endif\nv_uv=TEXCOORD_0;v_color=COLOR_0;}";// eslint-disable-line
  var unlitFs="#define GLSLIFY 1\n#include <common>\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;uniform float u_alphaCutoff;\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef BASETEXTURE\nvec4 textureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\ntextureColor=gammaToLinear(textureColor);\n#endif\nbaseColor*=textureColor;\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<u_alphaCutoff){discard;}\n#endif\n#ifndef OASIS_COLORSPACE_GAMMA\nbaseColor=linearToGamma(baseColor);\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}";// eslint-disable-line
  var unlitVs="#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}";// eslint-disable-line
  var backgroundTextureVs="#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";// eslint-disable-line
  var backgroundTextureFs="#define GLSLIFY 1\nuniform sampler2D u_baseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_baseTexture,v_uv);}";// eslint-disable-line
  /**
   * Internal shader pool.
   * @internal
   */var ShaderPool=/*#__PURE__*/function(){function ShaderPool(){}ShaderPool.init=function init(){Shader.create("blinn-phong",blinnPhongVs,blinnPhongFs);Shader.create("pbr",pbrVs,pbrFs);Shader.create("pbr-specular",pbrVs,pbrSpecularFs);Shader.create("unlit",unlitVs,unlitFs);Shader.create("shadow-map",shadowMapVs,shadowMapFs);Shader.create("shadow",shadowMapVs,shadowFs);Shader.create("skybox",skyboxVs,skyboxFs);Shader.create("particle-shader",particleVs,particleFs);Shader.create("SpriteMask",spriteMaskVs,spriteMaskFs);Shader.create("Sprite",spriteVs,spriteFs);Shader.create("background-texture",backgroundTextureVs,backgroundTextureFs);};return ShaderPool;}();/**
   * Shader program pool.
   * @internal
   */var ShaderProgramPool=/*#__PURE__*/function(){function ShaderProgramPool(){this._cacheHierarchy=1;this._cacheMap=Object.create(null);this._lastQueryMap=void 0;this._lastQueryKey=void 0;}var _proto=ShaderProgramPool.prototype;/**
     * Get shader program by macro collection.
     * @param macros - macro collection
     * @returns shader program
     */_proto.get=function get(macros){var cacheMap=this._cacheMap;var maskLength=macros._length;if(maskLength>this._cacheHierarchy){this._resizeCacheMapHierarchy(cacheMap,0,maskLength);}var mask=macros._mask;var endIndex=macros._length-1;var maxEndIndex=this._cacheHierarchy-1;for(var i=0;i<maxEndIndex;i++){var subMask=endIndex<i?0:mask[i];var subCacheShaders=cacheMap[subMask];subCacheShaders||(cacheMap[subMask]=subCacheShaders=Object.create(null));cacheMap=subCacheShaders;}var cacheKey=endIndex<maxEndIndex?0:mask[maxEndIndex];var shader=cacheMap[cacheKey];if(!shader){this._lastQueryKey=cacheKey;this._lastQueryMap=cacheMap;}return shader;}/**
     * Cache the shader program.
     *
     * @remarks
     * The method must return an empty value after calling get() to run normally.
     *
     * @param shaderProgram - shader program
     */;_proto.cache=function cache(shaderProgram){this._lastQueryMap[this._lastQueryKey]=shaderProgram;};_proto._resizeCacheMapHierarchy=function _resizeCacheMapHierarchy(cacheMap,hierarchy,resizeLength){// only expand but not shrink.
  var end=this._cacheHierarchy-1;if(hierarchy==end){for(var k in cacheMap){var shader=cacheMap[k];for(var i=0,n=resizeLength-end;i<n;i++){if(i==n-1){cacheMap[0]=shader;}else {cacheMap=cacheMap[i==0?k:0]=Object.create(null);}}}this._cacheHierarchy=resizeLength;}else {for(var _k in cacheMap){this._resizeCacheMapHierarchy(cacheMap[_k],++hierarchy,resizeLength);}}};return ShaderProgramPool;}();/** TODO: delete */var engineFeatureManager=new FeatureManager();ShaderPool.init();/**
   * Engine.
   */var Engine=/*#__PURE__*/function(_EventDispatcher){_inheritsLoose$2(Engine,_EventDispatcher);/**
     * Create engine.
     * @param canvas - The canvas to use for rendering
     * @param hardwareRenderer - Graphics API renderer
     */function Engine(canvas,hardwareRenderer,settings){var _this;_this=_EventDispatcher.call(this)||this;_this.physicsManager=void 0;_this.inputManager=void 0;_this._componentsManager=new ComponentsManager();_this._hardwareRenderer=void 0;_this._lastRenderState=new RenderState();_this._renderElementPool=new ClassPool(MeshRenderElement);_this._spriteElementPool=new ClassPool(SpriteElement);_this._spriteMaskElementPool=new ClassPool(SpriteMaskElement);_this._textElementPool=new ClassPool(TextRenderElement);_this._spriteDefaultMaterial=void 0;_this._spriteMaskDefaultMaterial=void 0;_this._renderContext=new RenderContext();_this._magentaTexture2D=void 0;_this._magentaTextureCube=void 0;_this._magentaTexture2DArray=void 0;_this._magentaMaterial=void 0;_this._backgroundTextureMaterial=void 0;_this._renderCount=0;_this._shaderProgramPools=[];_this._spriteMaskManager=void 0;_this._canSpriteBatch=true;_this._macroCollection=new ShaderMacroCollection();_this._canvas=void 0;_this._settings={};_this._resourceManager=new ResourceManager(_assertThisInitialized(_this));_this._sceneManager=new SceneManager(_assertThisInitialized(_this));_this._vSyncCount=1;_this._targetFrameRate=60;_this._time=new Time();_this._isPaused=true;_this._requestId=void 0;_this._timeoutId=void 0;_this._vSyncCounter=1;_this._targetFrameInterval=1000/60;_this._destroyed=false;_this._waittingDestroy=false;_this._animate=function(){if(_this._vSyncCount){_this._requestId=requestAnimationFrame(_this._animate);if(_this._vSyncCounter++%_this._vSyncCount===0){_this.update();_this._vSyncCounter=1;}}else {_this._timeoutId=window.setTimeout(_this._animate,_this._targetFrameInterval);_this.update();}};_this.features=[];_this._hardwareRenderer=hardwareRenderer;_this._hardwareRenderer.init(canvas);_this.physicsManager=new PhysicsManager(_assertThisInitialized(_this));_this._canvas=canvas;// @todo delete
  engineFeatureManager.addObject(_assertThisInitialized(_this));_this._sceneManager.activeScene=new Scene(_assertThisInitialized(_this),"DefaultScene");_this._spriteMaskManager=new SpriteMaskManager(_assertThisInitialized(_this));_this._spriteDefaultMaterial=_this._createSpriteMaterial();_this._spriteMaskDefaultMaterial=_this._createSpriteMaskMaterial();_this.inputManager=new InputManager(_assertThisInitialized(_this));var magentaPixel=new Uint8Array([255,0,255,255]);var magentaTexture2D=new Texture2D(_assertThisInitialized(_this),1,1,exports.TextureFormat.R8G8B8A8,false);magentaTexture2D.setPixelBuffer(magentaPixel);magentaTexture2D.isGCIgnored=true;var magentaTextureCube=new TextureCube(_assertThisInitialized(_this),1,exports.TextureFormat.R8G8B8A8,false);magentaTextureCube.setPixelBuffer(exports.TextureCubeFace.PositiveX,magentaPixel);magentaTextureCube.setPixelBuffer(exports.TextureCubeFace.NegativeX,magentaPixel);magentaTextureCube.setPixelBuffer(exports.TextureCubeFace.PositiveY,magentaPixel);magentaTextureCube.setPixelBuffer(exports.TextureCubeFace.NegativeY,magentaPixel);magentaTextureCube.setPixelBuffer(exports.TextureCubeFace.PositiveZ,magentaPixel);magentaTextureCube.setPixelBuffer(exports.TextureCubeFace.NegativeZ,magentaPixel);magentaTextureCube.isGCIgnored=true;_this._magentaTexture2D=magentaTexture2D;_this._magentaTextureCube=magentaTextureCube;if(hardwareRenderer.isWebGL2){var magentaTexture2DArray=new Texture2DArray(_assertThisInitialized(_this),1,1,1,exports.TextureFormat.R8G8B8A8,false);magentaTexture2DArray.setPixelBuffer(0,magentaPixel);magentaTexture2DArray.isGCIgnored=true;_this._magentaTexture2DArray=magentaTexture2DArray;}var magentaMaterial=new Material(_assertThisInitialized(_this),Shader.find("unlit"));magentaMaterial.shaderData.setColor("u_baseColor",new Color(1.0,0.0,1.01,1.0));_this._magentaMaterial=magentaMaterial;var backgroundTextureMaterial=new Material(_assertThisInitialized(_this),Shader.find("background-texture"));backgroundTextureMaterial.isGCIgnored=true;backgroundTextureMaterial.renderState.depthState.compareFunction=exports.CompareFunction.LessEqual;_this._backgroundTextureMaterial=backgroundTextureMaterial;var colorSpace=(settings===null||settings===void 0?void 0:settings.colorSpace)||exports.ColorSpace.Linear;colorSpace===exports.ColorSpace.Gamma&&_this._macroCollection.enable(Engine._gammaMacro);_this._settings.colorSpace=colorSpace;return _this;}/**
     * Create an entity.
     * @param name - The name of the entity
     * @returns Entity
     */var _proto=Engine.prototype;_proto.createEntity=function createEntity(name){return new Entity(this,name);}/**
     * Pause the engine.
     */;_proto.pause=function pause(){this._isPaused=true;cancelAnimationFrame(this._requestId);clearTimeout(this._timeoutId);}/**
     * Resume the engine.
     */;_proto.resume=function resume(){if(!this._isPaused)return;this._isPaused=false;this.time.reset();this._requestId=requestAnimationFrame(this._animate);}/**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */;_proto.update=function update(){var time=this._time;var deltaTime=time.deltaTime;time.tick();this._renderElementPool.resetPool();this._spriteElementPool.resetPool();this._spriteMaskElementPool.resetPool();this._textElementPool.resetPool();engineFeatureManager.callFeatureMethod(this,"preTick",[this,this._sceneManager._activeScene]);var scene=this._sceneManager._activeScene;var componentsManager=this._componentsManager;if(scene){scene._activeCameras.sort(function(camera1,camera2){return camera1.priority-camera2.priority;});componentsManager.callScriptOnStart();this.physicsManager._initialized&&this.physicsManager._update(deltaTime/1000.0);this.inputManager._update();componentsManager.callScriptOnUpdate(deltaTime);componentsManager.callAnimationUpdate(deltaTime);componentsManager.callScriptOnLateUpdate(deltaTime);this._render(scene);}engineFeatureManager.callFeatureMethod(this,"postTick",[this,this._sceneManager._activeScene]);// Engine is complete delayed destruction mechanism
  if(this._waittingDestroy){this._sceneManager._destroyAllScene();}componentsManager.handlingInvalidScripts();if(this._waittingDestroy){this._destroy();}}/**
     * Execution engine loop.
     */;_proto.run=function run(){// @todo: delete
  engineFeatureManager.callFeatureMethod(this,"preLoad",[this]);this.resume();this.trigger(new Event("run",this));}/**
     * Destroy engine.
     * @remarks The timing of engine destruction is at the end of the current frame
     */;_proto.destroy=function destroy(){if(this._destroyed){return;}this._waittingDestroy=true;}/**
     * @internal
     */;_proto._destroy=function _destroy(){this._resourceManager._destroy();this._magentaTexture2D.destroy(true);this._magentaTextureCube.destroy(true);this.inputManager._destroy();this.trigger(new Event("shutdown",this));engineFeatureManager.callFeatureMethod(this,"shutdown",[this]);// -- cancel animation
  this.pause();this._animate=null;this._sceneManager=null;this._resourceManager=null;this._canvas=null;this.features=[];this._time=null;// delete mask manager
  this._spriteMaskManager.destroy();// todo: delete
  engineFeatureManager._objects=[];this.removeAllEventListeners();this._waittingDestroy=false;this._destroyed=true;}/**
     * @internal
     */;_proto._getShaderProgramPool=function _getShaderProgramPool(shader){var index=shader._shaderId;var shaderProgramPools=this._shaderProgramPools;var pool=shaderProgramPools[index];if(!pool){var length=index+1;if(length<shaderProgramPools.length){shaderProgramPools.length=length;}shaderProgramPools[index]=pool=new ShaderProgramPool();}return pool;};_proto._render=function _render(scene){var cameras=scene._activeCameras;var componentsManager=this._componentsManager;var deltaTime=this.time.deltaTime;componentsManager.callRendererOnUpdate(deltaTime);scene._updateShaderData();if(cameras.length>0){for(var i=0,n=cameras.length;i<n;i++){var camera=cameras[i];componentsManager.callCameraOnBeginRender(camera);Scene.sceneFeatureManager.callFeatureMethod(scene,"preRender",[scene,camera]);//TODO: will be removed
  camera.render();Scene.sceneFeatureManager.callFeatureMethod(scene,"postRender",[scene,camera]);//TODO: will be removed
  componentsManager.callCameraOnEndRender(camera);}}else {Logger.debug("NO active camera.");}};_proto._createSpriteMaterial=function _createSpriteMaterial(){var material=new Material(this,Shader.find("Sprite"));var renderState=material.renderState;var target=renderState.blendState.targetBlendState;target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.colorBlendOperation=target.alphaBlendOperation=exports.BlendOperation.Add;renderState.depthState.writeEnabled=false;renderState.rasterState.cullMode=exports.CullMode.Off;material.renderQueueType=exports.RenderQueueType.Transparent;material.isGCIgnored=true;return material;};_proto._createSpriteMaskMaterial=function _createSpriteMaskMaterial(){var material=new Material(this,Shader.find("SpriteMask"));var renderState=material.renderState;renderState.blendState.targetBlendState.colorWriteMask=exports.ColorWriteMask.None;renderState.rasterState.cullMode=exports.CullMode.Off;renderState.stencilState.enabled=true;renderState.depthState.enabled=false;material.isGCIgnored=true;return material;}//-----------------------------------------@deprecated-----------------------------------
  ;_proto.findFeature=function findFeature(Feature){return engineFeatureManager.findFeature(this,Feature);};Engine.registerFeature=function registerFeature(Feature){engineFeatureManager.registerFeature(Feature);};_createClass$3(Engine,[{key:"settings",get:/** @internal */ /** @internal Conversion of space units to pixel units for 2D. */ /** @internal */ /** Physics manager of Engine. */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /** @internal */ /** @internal */ /** @internal @todo: temporary solution */ /**
       * Settings of Engine.
       */function get(){return this._settings;}/**
       * The canvas to use for rendering.
       */},{key:"canvas",get:function get(){return this._canvas;}/**
       * Get the resource manager.
       */},{key:"resourceManager",get:function get(){return this._resourceManager;}/**
       * Get the scene manager.
       */},{key:"sceneManager",get:function get(){return this._sceneManager;}/**
       * Get the Time class.
       */},{key:"time",get:function get(){return this._time;}/**
       * Whether the engine is paused.
       */},{key:"isPaused",get:function get(){return this._isPaused;}/**
       * The number of vertical synchronization means the number of vertical blanking for one frame.
       * @remarks 0 means that the vertical synchronization is turned off.
       */},{key:"vSyncCount",get:function get(){return this._vSyncCount;},set:function set(value){this._vSyncCount=Math.max(0,Math.floor(value));}/**
       * Set the target frame rate you want to achieve.
       * @remarks
       * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
       * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
       */},{key:"targetFrameRate",get:function get(){return this._targetFrameRate;},set:function set(value){value=Math.max(0.000001,value);this._targetFrameRate=value;this._targetFrameInterval=1000/value;}/**
       * Indicates whether the engine is destroyed.
       */},{key:"destroyed",get:function get(){return this._destroyed;}}]);return Engine;}(EventDispatcher);Engine._gammaMacro=Shader.getMacroByName("OASIS_COLORSPACE_GAMMA");Engine._pixelsPerUnit=100;Engine._defaultBoundingBox=new BoundingBox(new Vector3(0,0,0),new Vector3(0,0,0));/**
   * System info.
   */var SystemInfo=/*#__PURE__*/function(){function SystemInfo(){}/**
     * @internal
     */SystemInfo._isIos=function _isIos(){if(!window){return false;}var ua=window.navigator.userAgent.toLocaleLowerCase();return /iphone|ipad|ipod/.test(ua);};_createClass$3(SystemInfo,null,[{key:"devicePixelRatio",get:/**
       * The pixel ratio of the device.
       */function get(){return window.devicePixelRatio;}}]);return SystemInfo;}();/**
   * Engine feature plug-in.
   * @deprecated
   */var EngineFeature=/*#__PURE__*/function(){function EngineFeature(){}var _proto=EngineFeature.prototype;/**
     * Callback before the engine main loop runs,used to load resource.
     * @param engine - Engine
     */_proto.preLoad=function preLoad(engine){}/**
     * Callback before every engine tick.
     * @param engine - Engine
     * @param currentScene - Scene
     */;_proto.preTick=function preTick(engine,currentScene){}/**
     * Callback after every engine tick.
     * @param  engine - Engine
     */;_proto.postTick=function postTick(engine,currentScene){}/**
     * Callback after the engine is destroyed.
     * @param engine - Engine
     */;_proto.shutdown=function shutdown(engine){};return EngineFeature;}();var _class$5$1,_descriptor$4,_descriptor2$4,_descriptor3$4,_descriptor4$4,_descriptor5$4,_descriptor6$4,_descriptor7$4,_descriptor8$4,_descriptor9$4;/**
   * Script class, used for logic writing.
   */var Script=(_class$5$1=/*#__PURE__*/function(_Component){_inheritsLoose$2(Script,_Component);function Script(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Component.call.apply(_Component,[this].concat(args))||this;_initializerDefineProperty(_this,"_started",_descriptor$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onStartIndex",_descriptor2$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onUpdateIndex",_descriptor3$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onLateUpdateIndex",_descriptor4$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onPhysicsUpdateIndex",_descriptor5$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onPreRenderIndex",_descriptor6$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_onPostRenderIndex",_descriptor7$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_entityScriptsIndex",_descriptor8$4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_waitHandlingInValid",_descriptor9$4,_assertThisInitialized(_this));return _this;}var _proto=Script.prototype;/**
     * Called when be enabled first time, only once.
     */_proto.onAwake=function onAwake(){}/**
     * Called when be enabled.
     */;_proto.onEnable=function onEnable(){}/**
     * Called before the frame-level loop start for the first time, only once.
     */;_proto.onStart=function onStart(){}/**
     * The main loop, called frame by frame.
     * @param deltaTime - The deltaTime when the script update.
     */;_proto.onUpdate=function onUpdate(deltaTime){}/**
     * Called after the onUpdate finished, called frame by frame.
     * @param deltaTime - The deltaTime when the script update.
     */;_proto.onLateUpdate=function onLateUpdate(deltaTime){}/**
     * Called before camera rendering, called per camera.
     * @param camera - Current camera.
     */;_proto.onBeginRender=function onBeginRender(camera){}/**
     * Called after camera rendering, called per camera.
     * @param camera - Current camera.
     */;_proto.onEndRender=function onEndRender(camera){}/**
     * Called before physics calculations, the number of times is related to the physical update frequency.
     */;_proto.onPhysicsUpdate=function onPhysicsUpdate(){}/**
     * Called when the collision enter.
     * @param other - ColliderShape
     */;_proto.onTriggerEnter=function onTriggerEnter(other){}/**
     * Called when the collision stay.
     * @remarks onTriggerStay is called every frame while the collision stay.
     * @param other - ColliderShape
     */;_proto.onTriggerExit=function onTriggerExit(other){}/**
     * Called when the collision exit.
     * @param other - ColliderShape
     */;_proto.onTriggerStay=function onTriggerStay(other){}/**
     * Called when the collision enter.
     * @param other - ColliderShape
     */;_proto.onCollisionEnter=function onCollisionEnter(other){}/**
     * Called when the collision stay.
     * @remarks onTriggerStay is called every frame while the collision stay.
     * @param other - ColliderShape
     */;_proto.onCollisionExit=function onCollisionExit(other){}/**
     * Called when the collision exit.
     * @param other - ColliderShape
     */;_proto.onCollisionStay=function onCollisionStay(other){}/**
     * Called when the pointer is down while over the ColliderShape.
     */;_proto.onPointerDown=function onPointerDown(){}/**
     * Called when the pointer is up while over the ColliderShape.
     */;_proto.onPointerUp=function onPointerUp(){}/**
     * Called when the pointer is down and up with the same collider.
     */;_proto.onPointerClick=function onPointerClick(){}/**
     * Called when the pointer is enters the ColliderShape.
     */;_proto.onPointerEnter=function onPointerEnter(){}/**
     * Called when the pointer is no longer over the ColliderShape.
     */;_proto.onPointerExit=function onPointerExit(){}/**
     * Called when the pointer is down while over the ColliderShape and is still holding down.
     * @remarks onPointerDrag is called every frame while the pointer is down.
     */;_proto.onPointerDrag=function onPointerDrag(){}/**
     * Called when be disabled.
     */;_proto.onDisable=function onDisable(){}/**
     * Called at the end of the destroyed frame.
     */;_proto.onDestroy=function onDestroy(){}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onAwake=function _onAwake(){this.onAwake();}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onEnable=function _onEnable(){if(this._waitHandlingInValid){this._waitHandlingInValid=false;}else {var componentsManager=this.engine._componentsManager;var prototype=Script.prototype;if(!this._started){componentsManager.addOnStartScript(this);}if(this.onUpdate!==prototype.onUpdate){componentsManager.addOnUpdateScript(this);}if(this.onLateUpdate!==prototype.onLateUpdate){componentsManager.addOnLateUpdateScript(this);}if(this.onPhysicsUpdate!==prototype.onPhysicsUpdate){componentsManager.addOnPhysicsUpdateScript(this);}this._entity._addScript(this);}this.onEnable();}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onDisable=function _onDisable(){this._waitHandlingInValid=true;this._engine._componentsManager.addDisableScript(this);this.onDisable();}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onDestroy=function _onDestroy(){this._engine._componentsManager.addDestroyScript(this);}/**
     * @internal
     */;_proto._handlingInValid=function _handlingInValid(){var componentsManager=this.engine._componentsManager;var prototype=Script.prototype;if(this.onUpdate!==prototype.onUpdate){componentsManager.removeOnUpdateScript(this);}if(this.onLateUpdate!==prototype.onLateUpdate){componentsManager.removeOnLateUpdateScript(this);}if(this.onPhysicsUpdate!==prototype.onPhysicsUpdate){componentsManager.removeOnPhysicsUpdateScript(this);}this._entity._removeScript(this);this._waitHandlingInValid=false;};return Script;}(Component),(_descriptor$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_started",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor2$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_onStartIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor3$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_onUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor4$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_onLateUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor5$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_onPhysicsUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor6$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_onPreRenderIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor7$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_onPostRenderIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor8$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_entityScriptsIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor9$4=_applyDecoratedDescriptor(_class$5$1.prototype,"_waitHandlingInValid",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}})),_class$5$1);var passNum=0;/**
   * RenderPass.
   */var RenderPass=/*#__PURE__*/function(){/**
     * Create a RenderPass.
     * @param name - Pass name
     * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
     * @param renderTarget - The specified Render Target
     * @param replaceMaterial -  Replaced material
     * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
     */function RenderPass(name,priority,renderTarget,replaceMaterial,mask){if(name===void 0){name="RENDER_PASS"+passNum++;}if(priority===void 0){priority=0;}if(renderTarget===void 0){renderTarget=null;}if(replaceMaterial===void 0){replaceMaterial=null;}if(mask===void 0){mask=null;}this.name=void 0;this.enabled=void 0;this.priority=void 0;this.renderTarget=void 0;this.replaceMaterial=void 0;this.mask=void 0;this.renderOverride=void 0;this.clearFlags=void 0;this.clearColor=void 0;this.name=name;this.enabled=true;this.priority=priority;this.renderTarget=renderTarget;this.replaceMaterial=replaceMaterial;this.mask=mask||exports.Layer.Everything;this.renderOverride=false;// If renderOverride is set to true, you need to implement the render method
  }/**
     * Rendering callback, will be executed if renderOverride is set to true.
     * @param camera - Camera
     * @param opaqueQueue - Opaque queue
     * @param alphaTestQueue - Alpha test queue
     * @param transparentQueue - Transparent queue
     */var _proto=RenderPass.prototype;_proto.render=function render(camera,opaqueQueue,alphaTestQueue,transparentQueue){}/**
     * Post rendering callback.
     * @param camera - Camera
     * @param opaqueQueue - Opaque queue
     * @param alphaTestQueue - Alpha test queue
     * @param transparentQueue - Transparent queue
     */;_proto.preRender=function preRender(camera,opaqueQueue,alphaTestQueue,transparentQueue){}/**
     * Post rendering callback.
     * @param camera - Camera
     * @param opaqueQueue - Opaque queue
     * @param alphaTestQueue - Alpha test queue
     * @param transparentQueue - Transparent queue
     */;_proto.postRender=function postRender(camera,opaqueQueue,alphaTestQueue,transparentQueue){};return RenderPass;}();/**
   * @internal
   */var SpriteBatcher=/*#__PURE__*/function(_Basic2DBatcher){_inheritsLoose$2(SpriteBatcher,_Basic2DBatcher);function SpriteBatcher(){return _Basic2DBatcher.apply(this,arguments)||this;}var _proto=SpriteBatcher.prototype;_proto.createVertexElements=function createVertexElements(vertexElements){vertexElements[0]=new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0);vertexElements[1]=new VertexElement("TEXCOORD_0",12,exports.VertexElementFormat.Vector2,0);vertexElements[2]=new VertexElement("COLOR_0",20,exports.VertexElementFormat.Vector4,0);return 36;};_proto.canBatch=function canBatch(preElement,curElement){if(!this._engine._canSpriteBatch){return false;}var preRenderer=preElement.component;var curRenderer=curElement.component;// Compare mask
  if(!this.checkBatchWithMask(preRenderer,curRenderer)){return false;}// Compare texture
  if(preElement.texture!==curElement.texture){return false;}// Compare material
  return preElement.material===curElement.material;};_proto.checkBatchWithMask=function checkBatchWithMask(left,right){var leftMaskInteraction=left.maskInteraction;if(leftMaskInteraction!==right.maskInteraction){return false;}if(leftMaskInteraction===exports.SpriteMaskInteraction.None){return true;}return left.maskLayer===right.maskLayer;};_proto.updateVertices=function updateVertices(element,vertices,vertexIndex){var _element$renderData=element.renderData,positions=_element$renderData.positions,uvs=_element$renderData.uvs,color=_element$renderData.color,vertexCount=_element$renderData.vertexCount;for(var i=0;i<vertexCount;i++){var curPos=positions[i];var curUV=uvs[i];vertices[vertexIndex++]=curPos.x;vertices[vertexIndex++]=curPos.y;vertices[vertexIndex++]=curPos.z;vertices[vertexIndex++]=curUV.x;vertices[vertexIndex++]=curUV.y;vertices[vertexIndex++]=color.r;vertices[vertexIndex++]=color.g;vertices[vertexIndex++]=color.b;vertices[vertexIndex++]=color.a;}return vertexIndex;};_proto.drawBatches=function drawBatches(camera,replaceMaterial){var engine=this._engine,batchedQueue=this._batchedQueue;var mesh=this._meshes[this._flushId];var subMeshes=mesh.subMeshes;var maskManager=engine._spriteMaskManager;var sceneData=camera.scene.shaderData;var cameraData=camera.shaderData;for(var i=0,len=subMeshes.length;i<len;i++){var subMesh=subMeshes[i];var spriteElement=batchedQueue[i];if(!subMesh||!spriteElement){return;}var renderer=spriteElement.component;var material=spriteElement.material;maskManager.preRender(camera,renderer);var compileMacros=Shader._compileMacros;// union render global macro and material self macro.
  ShaderMacroCollection.unionCollection(renderer._globalShaderMacro,material.shaderData._macroCollection,compileMacros);// @todo: temporary solution
  (replaceMaterial||material)._preRender(spriteElement);var program=(replaceMaterial||material).shader._getShaderProgram(engine,compileMacros);if(!program.isValid){return;}renderer.shaderData.setTexture(SpriteBatcher._textureProperty,spriteElement.texture);program.bind();program.groupingOtherUniformBlock();program.uploadAll(program.sceneUniformBlock,sceneData);program.uploadAll(program.cameraUniformBlock,cameraData);program.uploadAll(program.rendererUniformBlock,renderer.shaderData);program.uploadAll(program.materialUniformBlock,material.shaderData);material.renderState._apply(engine,false);engine._hardwareRenderer.drawPrimitive(mesh,subMesh,program);maskManager.postRender(renderer);}};_proto.destroy=function destroy(){this._batchedQueue=null;var meshes=this._meshes,vertexBuffers=this._vertexBuffers,indiceBuffers=this._indiceBuffers;for(var i=0,n=meshes.length;i<n;++i){meshes[i].destroy();}this._meshes=null;for(var _i=0,_n=vertexBuffers.length;_i<_n;++_i){vertexBuffers[_i].destroy();}this._vertexBuffers=null;for(var _i2=0,_n2=indiceBuffers.length;_i2<_n2;++_i2){indiceBuffers[_i2].destroy();}this._indiceBuffers=null;};return SpriteBatcher;}(Basic2DBatcher);SpriteBatcher._textureProperty=Shader.getPropertyByName("u_spriteTexture");/**
   * Render queue.
   */var RenderQueue=/*#__PURE__*/function(){/**
     * @internal
     */RenderQueue._compareFromNearToFar=function _compareFromNearToFar(a,b){return a.component.priority-b.component.priority||a.component._distanceForSort-b.component._distanceForSort;}/**
     * @internal
     */;RenderQueue._compareFromFarToNear=function _compareFromFarToNear(a,b){return a.component.priority-b.component.priority||b.component._distanceForSort-a.component._distanceForSort;};function RenderQueue(engine){this.items=[];this._spriteBatcher=void 0;this._spriteBatcher=new SpriteBatcher(engine);}/**
     * Push a render element.
     */var _proto=RenderQueue.prototype;_proto.pushPrimitive=function pushPrimitive(element){this.items.push(element);};_proto.render=function render(camera,replaceMaterial,mask){var items=this.items;if(items.length===0){return;}var engine=camera.engine,scene=camera.scene;var renderCount=engine._renderCount;var rhi=engine._hardwareRenderer;var sceneData=scene.shaderData;var cameraData=camera.shaderData;for(var i=0,n=items.length;i<n;i++){var item=items[i];var renderPassFlag=item.component.entity.layer;if(!(renderPassFlag&mask)){continue;}if(!!item.mesh){this._spriteBatcher.flush(camera,replaceMaterial);var compileMacros=Shader._compileMacros;var element=item;var renderer=element.component;var material=element.material.destroyed?engine._magentaMaterial:element.material;var rendererData=renderer.shaderData;var materialData=material.shaderData;// @todo: temporary solution
  (replaceMaterial||material)._preRender(element);// union render global macro and material self macro.
  ShaderMacroCollection.unionCollection(renderer._globalShaderMacro,materialData._macroCollection,compileMacros);var program=(replaceMaterial||material).shader._getShaderProgram(engine,compileMacros);if(!program.isValid){continue;}var switchProgram=program.bind();var switchRenderCount=renderCount!==program._uploadRenderCount;if(switchRenderCount){program.groupingOtherUniformBlock();program.uploadAll(program.sceneUniformBlock,sceneData);program.uploadAll(program.cameraUniformBlock,cameraData);program.uploadAll(program.rendererUniformBlock,rendererData);program.uploadAll(program.materialUniformBlock,materialData);// UnGroup textures should upload default value, texture uint maybe change by logic of texture bind.
  program.uploadUnGroupTextures();program._uploadCamera=camera;program._uploadRenderer=renderer;program._uploadMaterial=material;program._uploadRenderCount=renderCount;}else {if(program._uploadCamera!==camera){program.uploadAll(program.cameraUniformBlock,cameraData);program._uploadCamera=camera;}else if(switchProgram){program.uploadTextures(program.cameraUniformBlock,cameraData);}if(program._uploadRenderer!==renderer){program.uploadAll(program.rendererUniformBlock,rendererData);program._uploadRenderer=renderer;}else if(switchProgram){program.uploadTextures(program.rendererUniformBlock,rendererData);}if(program._uploadMaterial!==material){program.uploadAll(program.materialUniformBlock,materialData);program._uploadMaterial=material;}else if(switchProgram){program.uploadTextures(program.materialUniformBlock,materialData);}// We only consider switchProgram case, because UnGroup texture's value is always default.
  if(switchProgram){program.uploadUnGroupTextures();}}material.renderState._apply(engine,renderer.entity.transform._isFrontFaceInvert());rhi.drawPrimitive(element.mesh,element.subMesh,program);}else {var spriteElement=item;this._spriteBatcher.drawElement(spriteElement,camera,replaceMaterial);}}this._spriteBatcher.flush(camera,replaceMaterial);}/**
     * Clear collection.
     */;_proto.clear=function clear(){this.items.length=0;this._spriteBatcher.clear();}/**
     * Destroy internal resources.
     */;_proto.destroy=function destroy(){this._spriteBatcher.destroy();this._spriteBatcher=null;}/**
     * Sort the elements.
     */;_proto.sort=function sort(compareFunc){this._quickSort(this.items,0,this.items.length,compareFunc);}/**
     * @remarks
     * Modified based on v8.
     * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js
     */;_proto._quickSort=function _quickSort(a,from,to,compareFunc){while(true){// Insertion sort is faster for short arrays.
  if(to-from<=10){this._insertionSort(a,from,to,compareFunc);return;}var third_index=from+to>>1;// Find a pivot as the median of first, last and middle element.
  var v0=a[from];var v1=a[to-1];var v2=a[third_index];var c01=compareFunc(v0,v1);if(c01>0){// v1 < v0, so swap them.
  var tmp=v0;v0=v1;v1=tmp;}// v0 <= v1.
  var c02=compareFunc(v0,v2);if(c02>=0){// v2 <= v0 <= v1.
  var _tmp=v0;v0=v2;v2=v1;v1=_tmp;}else {// v0 <= v1 && v0 < v2
  var c12=compareFunc(v1,v2);if(c12>0){// v0 <= v2 < v1
  var _tmp2=v1;v1=v2;v2=_tmp2;}}// v0 <= v1 <= v2
  a[from]=v0;a[to-1]=v2;var pivot=v1;var low_end=from+1;// Upper bound of elements lower than pivot.
  var high_start=to-1;// Lower bound of elements greater than pivot.
  a[third_index]=a[low_end];a[low_end]=pivot;// From low_end to i are elements equal to pivot.
  // From i to high_start are elements that haven't been compared yet.
  partition:for(var i=low_end+1;i<high_start;i++){var element=a[i];var order=compareFunc(element,pivot);if(order<0){a[i]=a[low_end];a[low_end]=element;low_end++;}else if(order>0){do{high_start--;if(high_start==i)break partition;var top_elem=a[high_start];order=compareFunc(top_elem,pivot);}while(order>0);a[i]=a[high_start];a[high_start]=element;if(order<0){element=a[i];a[i]=a[low_end];a[low_end]=element;low_end++;}}}if(to-high_start<low_end-from){this._quickSort(a,high_start,to,compareFunc);to=low_end;}else {this._quickSort(a,from,low_end,compareFunc);from=high_start;}}};_proto._insertionSort=function _insertionSort(a,from,to,compareFunc){for(var i=from+1;i<to;i++){var j=void 0;var element=a[i];for(j=i-1;j>=from;j--){var tmp=a[j];var order=compareFunc(tmp,element);if(order>0){a[j+1]=tmp;}else {break;}}a[j+1]=element;}};return RenderQueue;}();/**
   * Basic render pipeline.
   */var BasicRenderPipeline=/*#__PURE__*/function(){/** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
     * Create a basic render pipeline.
     * @param camera - Camera
     */function BasicRenderPipeline(camera){this._opaqueQueue=void 0;this._transparentQueue=void 0;this._alphaTestQueue=void 0;this._allSpriteMasks=new DisorderedArray();this._camera=void 0;this._defaultPass=void 0;this._renderPassArray=void 0;this._lastCanvasSize=new Vector2();this._camera=camera;var engine=camera.engine;this._opaqueQueue=new RenderQueue(engine);this._alphaTestQueue=new RenderQueue(engine);this._transparentQueue=new RenderQueue(engine);this._renderPassArray=[];this._defaultPass=new RenderPass("default",0,null,null,0);this.addRenderPass(this._defaultPass);}/**
     * Default render pass.
     */var _proto=BasicRenderPipeline.prototype;/**
     * Add render pass.
     * @param nameOrPass - The name of this Pass or RenderPass object. When it is a name, the following parameters need to be provided
     * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
     * @param renderTarget - The specified Render Target
     * @param replaceMaterial -  Replaced material
     * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
     */_proto.addRenderPass=function addRenderPass(nameOrPass,priority,renderTarget,replaceMaterial,mask){if(priority===void 0){priority=null;}if(renderTarget===void 0){renderTarget=null;}if(replaceMaterial===void 0){replaceMaterial=null;}if(mask===void 0){mask=null;}if(typeof nameOrPass==="string"){var renderPass=new RenderPass(nameOrPass,priority,renderTarget,replaceMaterial,mask);this._renderPassArray.push(renderPass);}else if(nameOrPass instanceof RenderPass){this._renderPassArray.push(nameOrPass);}this._renderPassArray.sort(function(p1,p2){return p1.priority-p2.priority;});}/**
     * Remove render pass by name or render pass object.
     * @param nameOrPass - Render pass name or render pass object
     */;_proto.removeRenderPass=function removeRenderPass(nameOrPass){var pass;if(typeof nameOrPass==="string")pass=this.getRenderPass(nameOrPass);else if(nameOrPass instanceof RenderPass)pass=nameOrPass;if(pass){var idx=this._renderPassArray.indexOf(pass);this._renderPassArray.splice(idx,1);}}/**
     * Get render pass by name.
     * @param  name - Render pass name
     */;_proto.getRenderPass=function getRenderPass(name){for(var i=0,len=this._renderPassArray.length;i<len;i++){var pass=this._renderPassArray[i];if(pass.name===name)return pass;}return null;}/**
     * Destroy internal resources.
     */;_proto.destroy=function destroy(){this._opaqueQueue.destroy();this._alphaTestQueue.destroy();this._transparentQueue.destroy();this._allSpriteMasks=null;this._renderPassArray=null;this._defaultPass=null;this._camera=null;}/**
     * Perform scene rendering.
     * @param context - Render context
     * @param cubeFace - Render surface of cube texture
     * @param mipLevel - Set mip level the data want to write
     */;_proto.render=function render(context,cubeFace,mipLevel){var camera=this._camera;var opaqueQueue=this._opaqueQueue;var alphaTestQueue=this._alphaTestQueue;var transparentQueue=this._transparentQueue;camera.engine._spriteMaskManager.clear();opaqueQueue.clear();alphaTestQueue.clear();transparentQueue.clear();this._allSpriteMasks.length=0;camera.engine._componentsManager.callRender(context);opaqueQueue.sort(RenderQueue._compareFromNearToFar);alphaTestQueue.sort(RenderQueue._compareFromNearToFar);transparentQueue.sort(RenderQueue._compareFromFarToNear);for(var i=0,len=this._renderPassArray.length;i<len;i++){this._drawRenderPass(this._renderPassArray[i],camera,cubeFace,mipLevel);}};_proto._drawRenderPass=function _drawRenderPass(pass,camera,cubeFace,mipLevel){pass.preRender(camera,this._opaqueQueue,this._alphaTestQueue,this._transparentQueue);if(pass.enabled){var _pass$clearFlags,_pass$clearColor;var engine=camera.engine,scene=camera.scene;var background=scene.background;var rhi=engine._hardwareRenderer;var renderTarget=camera.renderTarget||pass.renderTarget;rhi.activeRenderTarget(renderTarget,camera,mipLevel);// change viewport with mip level
  renderTarget===null||renderTarget===void 0?void 0:renderTarget._setRenderTargetInfo(cubeFace,mipLevel);var clearFlags=(_pass$clearFlags=pass.clearFlags)!=null?_pass$clearFlags:camera.clearFlags;var color=(_pass$clearColor=pass.clearColor)!=null?_pass$clearColor:background.solidColor;if(clearFlags!==exports.CameraClearFlags.None){rhi.clearRenderTarget(camera.engine,clearFlags,color);}if(pass.renderOverride){pass.render(camera,this._opaqueQueue,this._alphaTestQueue,this._transparentQueue);}else {this._opaqueQueue.render(camera,pass.replaceMaterial,pass.mask);this._alphaTestQueue.render(camera,pass.replaceMaterial,pass.mask);if(camera.clearFlags&exports.CameraClearFlags.Color){if(background.mode===exports.BackgroundMode.Sky){this._drawSky(engine,camera,background.sky);}else if(background.mode===exports.BackgroundMode.Texture&&background.texture){this._drawBackgroundTexture(engine,background);}}this._transparentQueue.render(camera,pass.replaceMaterial,pass.mask);}renderTarget===null||renderTarget===void 0?void 0:renderTarget._blitRenderTarget();renderTarget===null||renderTarget===void 0?void 0:renderTarget.generateMipmaps();}pass.postRender(camera,this._opaqueQueue,this._alphaTestQueue,this._transparentQueue);}/**
     * Push a render element to the render queue.
     * @param element - Render element
     */;_proto.pushPrimitive=function pushPrimitive(element){switch(element.material.renderQueueType){case exports.RenderQueueType.Transparent:this._transparentQueue.pushPrimitive(element);break;case exports.RenderQueueType.AlphaTest:this._alphaTestQueue.pushPrimitive(element);break;case exports.RenderQueueType.Opaque:this._opaqueQueue.pushPrimitive(element);break;}};_proto._drawBackgroundTexture=function _drawBackgroundTexture(engine,background){var rhi=engine._hardwareRenderer;var _backgroundTextureMaterial=engine._backgroundTextureMaterial,canvas=engine.canvas;var mesh=background._mesh;if((this._lastCanvasSize.x!==canvas.width||this._lastCanvasSize.y!==canvas.height)&&background._textureFillMode!==exports.BackgroundTextureFillMode.Fill){this._lastCanvasSize.set(canvas.width,canvas.height);background._resizeBackgroundTexture();}var program=_backgroundTextureMaterial.shader._getShaderProgram(engine,Shader._compileMacros);program.bind();program.uploadAll(program.materialUniformBlock,_backgroundTextureMaterial.shaderData);program.uploadUnGroupTextures();_backgroundTextureMaterial.renderState._apply(engine,false);rhi.drawPrimitive(mesh,mesh.subMesh,program);};_proto._drawSky=function _drawSky(engine,camera,sky){var material=sky.material,mesh=sky.mesh,_matrix=sky._matrix;if(!material){Logger.warn("The material of sky is not defined.");return;}if(!mesh){Logger.warn("The mesh of sky is not defined.");return;}var rhi=engine._hardwareRenderer;var shaderData=material.shaderData,shader=material.shader,renderState=material.renderState;var compileMacros=Shader._compileMacros;ShaderMacroCollection.unionCollection(camera._globalShaderMacro,shaderData._macroCollection,compileMacros);var viewMatrix=camera.viewMatrix,projectionMatrix=camera.projectionMatrix;_matrix.copyFrom(viewMatrix);var e=_matrix.elements;e[12]=e[13]=e[14]=0;Matrix.multiply(projectionMatrix,_matrix,_matrix);shaderData.setMatrix("u_mvpNoscale",_matrix);var program=shader._getShaderProgram(engine,compileMacros);program.bind();program.groupingOtherUniformBlock();program.uploadAll(program.materialUniformBlock,shaderData);program.uploadUnGroupTextures();renderState._apply(engine,false);rhi.drawPrimitive(mesh,mesh.subMesh,program);};_createClass$3(BasicRenderPipeline,[{key:"defaultRenderPass",get:function get(){return this._defaultPass;}}]);return BasicRenderPipeline;}();var _dec$1$1,_class$4$1,_class2$4,_descriptor$3,_descriptor2$3,_descriptor3$3,_descriptor4$3,_descriptor5$3,_descriptor6$3,_descriptor7$3,_descriptor8$3,_descriptor9$3,_descriptor10$2,_descriptor11$2,_descriptor12$2,_class3;var MathTemp=function MathTemp(){};/**
   * Camera component, as the entrance to the three-dimensional world.
   * @decorator `@dependentComponents(Transform)`
   */MathTemp.tempVec4=new Vector4();MathTemp.tempVec3=new Vector3();MathTemp.tempVec2=new Vector2();var Camera=(_dec$1$1=dependentComponents(Transform),_dec$1$1(_class$4$1=(_class2$4=(_class3=/*#__PURE__*/function(_Component){_inheritsLoose$2(Camera,_Component);/**
     * @internal
     */function Camera(entity){var _this;_this=_Component.call(this,entity)||this;_this.shaderData=new ShaderData(ShaderDataGroup.Camera);_this.priority=0;_this.enableFrustumCulling=true;_this.clearFlags=exports.CameraClearFlags.All;_this.cullingMask=exports.Layer.Everything;_this._globalShaderMacro=new ShaderMacroCollection();_initializerDefineProperty(_this,"_frustum",_descriptor$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_renderPipeline",_descriptor2$3,_assertThisInitialized(_this));_this._isOrthographic=false;_this._isProjMatSetting=false;_this._nearClipPlane=0.1;_this._farClipPlane=100;_this._fieldOfView=45;_this._orthographicSize=10;_this._isProjectionDirty=true;_this._isInvProjMatDirty=true;_this._isFrustumProjectDirty=true;_this._customAspectRatio=undefined;_this._renderTarget=null;_initializerDefineProperty(_this,"_frustumViewChangeFlag",_descriptor3$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_transform",_descriptor4$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_isViewMatrixDirty",_descriptor5$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_isInvViewProjDirty",_descriptor6$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_projectionMatrix",_descriptor7$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_viewMatrix",_descriptor8$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_viewport",_descriptor9$3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_inverseProjectionMatrix",_descriptor10$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_lastAspectSize",_descriptor11$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_invViewProjMat",_descriptor12$2,_assertThisInitialized(_this));var transform=_this.entity.transform;_this._transform=transform;_this._isViewMatrixDirty=transform.registerWorldChangeFlag();_this._isInvViewProjDirty=transform.registerWorldChangeFlag();_this._frustumViewChangeFlag=transform.registerWorldChangeFlag();_this._renderPipeline=new BasicRenderPipeline(_assertThisInitialized(_this));_this.shaderData._addRefCount(1);return _this;}/**
     * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
     */var _proto=Camera.prototype;_proto.resetProjectionMatrix=function resetProjectionMatrix(){this._isProjMatSetting=false;this._projMatChange();}/**
     * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
     */;_proto.resetAspectRatio=function resetAspectRatio(){this._customAspectRatio=undefined;this._projMatChange();}/**
     * Transform a point from world space to viewport space.
     * @param point - Point in world space
     * @param out - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
     * @returns Point in viewport space
     */;_proto.worldToViewportPoint=function worldToViewportPoint(point,out){var cameraPoint=MathTemp.tempVec3;var viewportPoint=MathTemp.tempVec4;Vector3.transformCoordinate(point,this.viewMatrix,cameraPoint);Vector3.transformToVec4(cameraPoint,this.projectionMatrix,viewportPoint);var w=viewportPoint.w;out.set((viewportPoint.x/w+1.0)*0.5,(1.0-viewportPoint.y/w)*0.5,-cameraPoint.z);return out;}/**
     * Transform a point from viewport space to world space.
     * @param point - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
     * @param out - Point in world space
     * @returns Point in world space
     */;_proto.viewportToWorldPoint=function viewportToWorldPoint(point,out){var nearClipPlane=this.nearClipPlane,farClipPlane=this.farClipPlane;var nf=1/(nearClipPlane-farClipPlane);var z;if(this.isOrthographic){z=-point.z*2*nf;z+=(farClipPlane+nearClipPlane)*nf;}else {var pointZ=point.z;z=-pointZ*(nearClipPlane+farClipPlane)*nf;z+=2*nearClipPlane*farClipPlane*nf;z=z/pointZ;}this._innerViewportToWorldPoint(point.x,point.y,(z+1.0)/2.0,this._getInvViewProjMat(),out);return out;}/**
     * Generate a ray by a point in viewport.
     * @param point - Point in viewport space, X and Y are the camera viewport space coordinates
     * @param out - Ray
     * @returns Ray
     */;_proto.viewportPointToRay=function viewportPointToRay(point,out){var invViewProjMat=this._getInvViewProjMat();// Use the intersection of the near clipping plane as the origin point.
  var origin=this._innerViewportToWorldPoint(point.x,point.y,0.0,invViewProjMat,out.origin);// Use the intersection of the far clipping plane as the origin point.
  var direction=this._innerViewportToWorldPoint(point.x,point.y,1.0,invViewProjMat,out.direction);Vector3.subtract(direction,origin,direction);direction.normalize();return out;}/**
     * Transform the X and Y coordinates of a point from screen space to viewport space
     * @param point - Point in screen space
     * @param out - Point in viewport space
     * @returns Point in viewport space
     */;_proto.screenToViewportPoint=function screenToViewportPoint(point,out){var canvas=this.engine.canvas;var viewport=this.viewport;out.x=(point.x/canvas.width-viewport.x)/viewport.z;out.y=(point.y/canvas.height-viewport.y)/viewport.w;point.z!==undefined&&(out.z=point.z);return out;}/**
     * Transform the X and Y coordinates of a point from viewport space to screen space.
     * @param point - Point in viewport space
     * @param out - Point in screen space
     * @returns Point in screen space
     */;_proto.viewportToScreenPoint=function viewportToScreenPoint(point,out){var canvas=this.engine.canvas;var viewport=this.viewport;out.x=(viewport.x+point.x*viewport.z)*canvas.width;out.y=(viewport.y+point.y*viewport.w)*canvas.height;point.z!==undefined&&(out.z=point.z);return out;}/**
     * Transform a point from world space to screen space.
     * @param point - Point in world space
     * @param out - Point of screen space
     * @returns Point of screen space
     */;_proto.worldToScreenPoint=function worldToScreenPoint(point,out){this.worldToViewportPoint(point,out);return this.viewportToScreenPoint(out,out);}/**
     * Transform a point from screen space to world space.
     *
     * @param point - Screen space point, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight), The z position is in world units from the camera
     * @param out - Point in world space
     * @returns Point in world space
     */;_proto.screenToWorldPoint=function screenToWorldPoint(point,out){this.screenToViewportPoint(point,out);return this.viewportToWorldPoint(out,out);}/**
     * Generate a ray by a point in screen.
     * @param point - Point in screen space, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight)
     * @param out - Ray
     * @returns Ray
     */;_proto.screenPointToRay=function screenPointToRay(point,out){var viewportPoint=MathTemp.tempVec2;this.screenToViewportPoint(point,viewportPoint);return this.viewportPointToRay(viewportPoint,out);}/**
     * Manually call the rendering of the camera.
     * @param cubeFace - Cube rendering surface collection
     * @param mipLevel - Set mip level the data want to write, only take effect in webgl2.0
     */;_proto.render=function render(cubeFace,mipLevel){if(mipLevel===void 0){mipLevel=0;}// compute cull frustum.
  var context=this.engine._renderContext;context._setContext(this);if(this.enableFrustumCulling&&(this._frustumViewChangeFlag.flag||this._isFrustumProjectDirty)){this._frustum.calculateFromMatrix(context._viewProjectMatrix);this._frustumViewChangeFlag.flag=false;this._isFrustumProjectDirty=false;}this._updateShaderData(context);// union scene and camera macro.
  ShaderMacroCollection.unionCollection(this.scene._globalShaderMacro,this.shaderData._macroCollection,this._globalShaderMacro);if(mipLevel>0&&!this.engine._hardwareRenderer.isWebGL2){mipLevel=0;Logger.error("mipLevel only take effect in WebGL2.0");}this._renderPipeline.render(context,cubeFace,mipLevel);this._engine._renderCount++;}/**
     * @override
     * @inheritdoc
     */;_proto._onEnable=function _onEnable(){this.entity.scene._attachRenderCamera(this);}/**
     * @override
     * @inheritdoc
     */;_proto._onDisable=function _onDisable(){this.entity.scene._detachRenderCamera(this);}/**
     * @override
     * @inheritdoc
     */;_proto._onDestroy=function _onDestroy(){var _this$_renderPipeline;(_this$_renderPipeline=this._renderPipeline)===null||_this$_renderPipeline===void 0?void 0:_this$_renderPipeline.destroy();this._isInvViewProjDirty.destroy();this._isViewMatrixDirty.destroy();this.shaderData._addRefCount(-1);};_proto._projMatChange=function _projMatChange(){this._isFrustumProjectDirty=true;this._isProjectionDirty=true;this._isInvProjMatDirty=true;this._isInvViewProjDirty.flag=true;};_proto._innerViewportToWorldPoint=function _innerViewportToWorldPoint(x,y,z,invViewProjMat,out){// Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.
  // Transform to clipping space matrix
  var clipPoint=MathTemp.tempVec3;clipPoint.set(x*2-1,1-y*2,z*2-1);Vector3.transformCoordinate(clipPoint,invViewProjMat,out);return out;};_proto._updateShaderData=function _updateShaderData(context){var shaderData=this.shaderData;shaderData.setMatrix(Camera._viewMatrixProperty,this.viewMatrix);shaderData.setMatrix(Camera._projectionMatrixProperty,this.projectionMatrix);shaderData.setMatrix(Camera._vpMatrixProperty,context._viewProjectMatrix);shaderData.setMatrix(Camera._inverseViewMatrixProperty,this._transform.worldMatrix);shaderData.setMatrix(Camera._inverseProjectionMatrixProperty,this._getInverseProjectionMatrix());shaderData.setVector3(Camera._cameraPositionProperty,this._transform.worldPosition);}/**
     * The inverse matrix of view projection matrix.
     */;_proto._getInvViewProjMat=function _getInvViewProjMat(){if(this._isInvViewProjDirty.flag){this._isInvViewProjDirty.flag=false;Matrix.multiply(this._transform.worldMatrix,this._getInverseProjectionMatrix(),this._invViewProjMat);}return this._invViewProjMat;}/**
     * The inverse of the projection matrix.
     */;_proto._getInverseProjectionMatrix=function _getInverseProjectionMatrix(){if(this._isInvProjMatDirty){this._isInvProjMatDirty=false;Matrix.invert(this.projectionMatrix,this._inverseProjectionMatrix);}return this._inverseProjectionMatrix;};_createClass$3(Camera,[{key:"nearClipPlane",get:/** Shader data. */ /** Rendering priority - A Camera with higher priority will be rendered on top of a camera with lower priority. */ /** Whether to enable frustum culling, it is enabled by default. */ /**
       * Determining what to clear when rendering by a Camera.
       * @defaultValue `CameraClearFlags.All`
       */ /**
       * Culling mask - which layers the camera renders.
       * @remarks Support bit manipulation, corresponding to Entity's layer.
       */ /** @internal */ /** @internal */ /** @internal */ /**
       * Near clip plane - the closest point to the camera when rendering occurs.
       */function get(){return this._nearClipPlane;},set:function set(value){this._nearClipPlane=value;this._projMatChange();}/**
       * Far clip plane - the furthest point to the camera when rendering occurs.
       */},{key:"farClipPlane",get:function get(){return this._farClipPlane;},set:function set(value){this._farClipPlane=value;this._projMatChange();}/**
       * The camera's view angle. activating when camera use perspective projection.
       */},{key:"fieldOfView",get:function get(){return this._fieldOfView;},set:function set(value){this._fieldOfView=value;this._projMatChange();}/**
       * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
       * the manual value will be kept. Call resetAspectRatio() to restore it.
       */},{key:"aspectRatio",get:function get(){var _this$_customAspectRa;var canvas=this._entity.engine.canvas;return (_this$_customAspectRa=this._customAspectRatio)!=null?_this$_customAspectRa:canvas.width*this._viewport.z/(canvas.height*this._viewport.w);},set:function set(value){this._customAspectRatio=value;this._projMatChange();}/**
       * Viewport, normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
       * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
       */},{key:"viewport",get:function get(){return this._viewport;},set:function set(value){if(value!==this._viewport){this._viewport.copyFrom(value);}this._projMatChange();}/**
       * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
       */},{key:"isOrthographic",get:function get(){return this._isOrthographic;},set:function set(value){this._isOrthographic=value;this._projMatChange();}/**
       * Half the size of the camera in orthographic mode.
       */},{key:"orthographicSize",get:function get(){return this._orthographicSize;},set:function set(value){this._orthographicSize=value;this._projMatChange();}/**
       * View matrix.
       */},{key:"viewMatrix",get:function get(){if(this._isViewMatrixDirty.flag){this._isViewMatrixDirty.flag=false;// Ignore scale.
  Matrix.rotationTranslation(this._transform.worldRotationQuaternion,this._transform.worldPosition,this._viewMatrix);this._viewMatrix.invert();}return this._viewMatrix;}/**
       * The projection matrix is â€‹â€‹calculated by the relevant parameters of the camera by default.
       * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
       */},{key:"projectionMatrix",get:function get(){var canvas=this._entity.engine.canvas;if((!this._isProjectionDirty||this._isProjMatSetting)&&this._lastAspectSize.x===canvas.width&&this._lastAspectSize.y===canvas.height){return this._projectionMatrix;}this._isProjectionDirty=false;this._lastAspectSize.x=canvas.width;this._lastAspectSize.y=canvas.height;var aspectRatio=this.aspectRatio;if(!this._isOrthographic){Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView),aspectRatio,this._nearClipPlane,this._farClipPlane,this._projectionMatrix);}else {var width=this._orthographicSize*aspectRatio;var height=this._orthographicSize;Matrix.ortho(-width,width,-height,height,this._nearClipPlane,this._farClipPlane,this._projectionMatrix);}return this._projectionMatrix;}/**
       * Whether to enable HDR.
       * @todo When render pipeline modification
       */,set:function set(value){this._projectionMatrix=value;this._isProjMatSetting=true;this._projMatChange();}},{key:"enableHDR",get:function get(){console.log("not implementation");return false;},set:function set(value){console.log("not implementation");}/**
       * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
       */},{key:"renderTarget",get:function get(){return this._renderTarget;},set:function set(value){this._renderTarget=value;}}]);return Camera;}(Component),_class3._viewMatrixProperty=Shader.getPropertyByName("u_viewMat"),_class3._projectionMatrixProperty=Shader.getPropertyByName("u_projMat"),_class3._vpMatrixProperty=Shader.getPropertyByName("u_VPMat"),_class3._inverseViewMatrixProperty=Shader.getPropertyByName("u_viewInvMat"),_class3._inverseProjectionMatrixProperty=Shader.getPropertyByName("u_projInvMat"),_class3._cameraPositionProperty=Shader.getPropertyByName("u_cameraPos"),_class3),(_descriptor$3=_applyDecoratedDescriptor(_class2$4.prototype,"_frustum",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new BoundingFrustum();}}),_descriptor2$3=_applyDecoratedDescriptor(_class2$4.prototype,"_renderPipeline",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3$3=_applyDecoratedDescriptor(_class2$4.prototype,"_frustumViewChangeFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$3=_applyDecoratedDescriptor(_class2$4.prototype,"_transform",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor5$3=_applyDecoratedDescriptor(_class2$4.prototype,"_isViewMatrixDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor6$3=_applyDecoratedDescriptor(_class2$4.prototype,"_isInvViewProjDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor7$3=_applyDecoratedDescriptor(_class2$4.prototype,"_projectionMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor8$3=_applyDecoratedDescriptor(_class2$4.prototype,"_viewMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor9$3=_applyDecoratedDescriptor(_class2$4.prototype,"_viewport",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector4(0,0,1,1);}}),_descriptor10$2=_applyDecoratedDescriptor(_class2$4.prototype,"_inverseProjectionMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor11$2=_applyDecoratedDescriptor(_class2$4.prototype,"_lastAspectSize",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector2(0,0);}}),_descriptor12$2=_applyDecoratedDescriptor(_class2$4.prototype,"_invViewProjMat",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}})),_class2$4))||_class$4$1);var mimeType={json:"json",gltf:"json",mtl:"json",prefab:"json",txt:"text",bin:"arraybuffer",png:"image",webp:"image",jpg:"image"};var defaultRetryCount=1;var defaultTimeout=Infinity;var defaultInterval=500;/**
   * Web request.
   * @param url - The link
   * @param config - Load configuration
   */function request(url,config){if(config===void 0){config={};}return new AssetPromise(function(resolve,reject,setProgress){var _config$retryCount,_config$retryInterval,_config$timeout,_config$type;var retryCount=(_config$retryCount=config.retryCount)!=null?_config$retryCount:defaultRetryCount;var retryInterval=(_config$retryInterval=config.retryInterval)!=null?_config$retryInterval:defaultInterval;config.timeout=(_config$timeout=config.timeout)!=null?_config$timeout:defaultTimeout;config.type=(_config$type=config.type)!=null?_config$type:getMimeTypeFromUrl(url);var realRequest=config.type==="image"?requestImage:requestRes;var lastError;var executor=new MultiExecutor(function(){return realRequest(url,config).onProgress(setProgress).then(function(res){resolve(res);executor.stop();}).catch(function(err){return lastError=err;});},retryCount,retryInterval);executor.start(function(){reject(lastError);});});}function requestImage(url,config){return new AssetPromise(function(resolve,reject){var timeout=config.timeout;var img=new Image();var onerror=function onerror(){reject(new Error("request "+url+" fail"));};img.onerror=onerror;img.onabort=onerror;var timeoutId=-1;if(timeout!=Infinity){timeoutId=window.setTimeout(function(){reject(new Error("request "+url+" timeout"));},timeout);}img.onload=function(timeoutId){return function(){// Call requestAnimationFrame to avoid iOS's bug.
  requestAnimationFrame(function(){//@ts-ignore
  resolve(img);img.onload=null;img.onerror=null;img.onabort=null;});clearTimeout(timeoutId);};}(timeoutId);img.crossOrigin="anonymous";img.src=url;});}function requestRes(url,config){return new AssetPromise(function(resolve,reject,setProgress){var _config$method;var xhr=new XMLHttpRequest();xhr.timeout=config.timeout;config.method=(_config$method=config.method)!=null?_config$method:"get";xhr.onload=function(){var _xhr$response;if(xhr.status<200||xhr.status>=300){reject(new Error("request failed from: "+url));return;}var result=(_xhr$response=xhr.response)!=null?_xhr$response:xhr.responseText;resolve(result);};xhr.onerror=function(){reject(new Error("request failed from: "+url));};xhr.ontimeout=function(){reject(new Error("request timeout from: "+url));};xhr.onprogress=function(e){setProgress(e.loaded/e.total);};xhr.open(config.method,url,true);xhr.withCredentials=config.credentials==="include";//@ts-ignore
  xhr.responseType=config.type;var headers=config.headers;if(headers){Object.keys(headers).forEach(function(name){xhr.setRequestHeader(name,headers[name]);});}// @ts-ignore
  xhr.send(config.body);});}function getMimeTypeFromUrl(url){var extname=url.substring(url.lastIndexOf(".")+1);return mimeType[extname];}var MultiExecutor=/*#__PURE__*/function(){function MultiExecutor(execFunc,totalCount,interval){this.execFunc=execFunc;this.totalCount=totalCount;this.interval=interval;this._timeoutId=-100;this._currentCount=0;this.done=void 0;this.exec=this.exec.bind(this);}var _proto=MultiExecutor.prototype;_proto.start=function start(done){this.done=done;this.exec();};_proto.stop=function stop(){clearTimeout(this._timeoutId);};_proto.exec=function exec(){var _this=this;if(this._currentCount>=this.totalCount){this.done&&this.done();return;}this._currentCount++;this.execFunc(this._currentCount).then(function(){//@ts-ignore
  _this._timeoutId=setTimeout(_this.exec,_this.interval);});};return MultiExecutor;}();/**
   * Loader abstract class.
   */var Loader=/*#__PURE__*/function(){/**
     * Register a class with a string name for serialization and deserialization.
     * @param key - class name
     * @param obj - class object
     */Loader.registerClass=function registerClass(className,classDefine){this._engineObjects[className]=classDefine;}/**
     * Get the class object by class name.
     * @param key - class name
     * @returns class object
     */;Loader.getClass=function getClass(className){return this._engineObjects[className];};function Loader(useCache){this.useCache=useCache;this.request=request;}return Loader;}();Loader._engineObjects={};/**
   * Asset Type.
   */exports.AssetType = void 0;(function(AssetType){AssetType["Text"]="text";AssetType["JSON"]="json";AssetType["Buffer"]="buffer";AssetType["Texture2D"]="texture2d";AssetType["TextureCube"]="texture-cube";AssetType["Material"]="material";AssetType["Mesh"]="mesh";AssetType["AnimationClip"]="AnimationClip";AssetType["AnimatorController"]="AnimatorController";AssetType["Prefab"]="prefab";AssetType["KTX"]="ktx";AssetType["KTXCube"]="ktx-cube";AssetType["Sprite"]="sprite";AssetType["SpriteAtlas"]="sprite-atlas";AssetType["Env"]="environment";AssetType["Scene"]="scene";AssetType["HDR"]="HDR";})(exports.AssetType||(exports.AssetType={}));/**
   * Set which face for render.
   */exports.RenderFace = void 0;(function(RenderFace){RenderFace[RenderFace["Front"]=0]="Front";RenderFace[RenderFace["Back"]=1]="Back";RenderFace[RenderFace["Double"]=2]="Double";})(exports.RenderFace||(exports.RenderFace={}));/**
   * Alpha blend mode.
   */exports.BlendMode = void 0;(function(BlendMode){BlendMode[BlendMode["Normal"]=0]="Normal";BlendMode[BlendMode["Additive"]=1]="Additive";})(exports.BlendMode||(exports.BlendMode={}));/**
   * Texture UV coordinate.
   */exports.TextureCoordinate = void 0;(function(TextureCoordinate){TextureCoordinate[TextureCoordinate["UV0"]=0]="UV0";TextureCoordinate[TextureCoordinate["UV1"]=1]="UV1";TextureCoordinate[TextureCoordinate["UV2"]=2]="UV2";TextureCoordinate[TextureCoordinate["UV3"]=3]="UV3";TextureCoordinate[TextureCoordinate["UV4"]=4]="UV4";TextureCoordinate[TextureCoordinate["UV5"]=5]="UV5";TextureCoordinate[TextureCoordinate["UV6"]=6]="UV6";TextureCoordinate[TextureCoordinate["UV7"]=7]="UV7";})(exports.TextureCoordinate||(exports.TextureCoordinate={}));var BaseMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(BaseMaterial,_Material);/**
     * Create a BaseMaterial instance.
     * @param engine - Engine to which the material belongs
     * @param shader - Shader used by the material
     */function BaseMaterial(engine,shader){var _this;_this=_Material.call(this,engine,shader)||this;_this._renderFace=exports.RenderFace.Front;_this._isTransparent=false;_this._blendMode=void 0;_this.blendMode=exports.BlendMode.Normal;_this.shaderData.setFloat(BaseMaterial._alphaCutoffProp,0);return _this;}/**
     * @override
     * Clone and return the instance.
     */var _proto=BaseMaterial.prototype;_proto.clone=function clone(){var dest=new BaseMaterial(this._engine,this.shader);this.cloneTo(dest);return dest;}/**
     * @override
     * Clone to the target material.
     * @param target - target material
     */;_proto.cloneTo=function cloneTo(target){_Material.prototype.cloneTo.call(this,target);target._renderFace=this._renderFace;target._isTransparent=this._isTransparent;target._blendMode=this._blendMode;};_createClass$3(BaseMaterial,[{key:"isTransparent",get:/**
       * Is this material transparent.
       * @remarks
       * If material is transparent, transparent blend mode will be affected by `blendMode`, default is `BlendMode.Normal`.
       */function get(){return this._isTransparent;},set:function set(value){if(value===this._isTransparent)return;this._isTransparent=value;var _this$renderState=this.renderState,depthState=_this$renderState.depthState,targetBlendState=_this$renderState.blendState.targetBlendState;if(value){targetBlendState.enabled=true;depthState.writeEnabled=false;this.renderQueueType=exports.RenderQueueType.Transparent;}else {targetBlendState.enabled=false;depthState.writeEnabled=true;this.renderQueueType=this.shaderData.getFloat(BaseMaterial._alphaCutoffProp)?exports.RenderQueueType.AlphaTest:exports.RenderQueueType.Opaque;}}/**
       * Alpha cutoff value.
       * @remarks
       * Fragments with alpha channel lower than cutoff value will be discarded.
       * `0` means no fragment will be discarded.
       */},{key:"alphaCutoff",get:function get(){return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);},set:function set(value){this.shaderData.setFloat(BaseMaterial._alphaCutoffProp,value);if(value>0){this.shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);this.renderQueueType=this._isTransparent?exports.RenderQueueType.Transparent:exports.RenderQueueType.AlphaTest;}else {this.shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);this.renderQueueType=this._isTransparent?exports.RenderQueueType.Transparent:exports.RenderQueueType.Opaque;}}/**
       * Set which face for render.
       */},{key:"renderFace",get:function get(){return this._renderFace;},set:function set(value){if(value===this._renderFace)return;this._renderFace=value;switch(value){case exports.RenderFace.Front:this.renderState.rasterState.cullMode=exports.CullMode.Back;break;case exports.RenderFace.Back:this.renderState.rasterState.cullMode=exports.CullMode.Front;break;case exports.RenderFace.Double:this.renderState.rasterState.cullMode=exports.CullMode.Off;break;}}/**
       * Alpha blend mode.
       * @remarks
       * Only take effect when `isTransparent` is `true`.
       */},{key:"blendMode",get:function get(){return this._blendMode;},set:function set(value){if(value===this._blendMode)return;this._blendMode=value;var target=this.renderState.blendState.targetBlendState;switch(value){case exports.BlendMode.Normal:target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.colorBlendOperation=target.alphaBlendOperation=exports.BlendOperation.Add;break;case exports.BlendMode.Additive:target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.One;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.colorBlendOperation=target.alphaBlendOperation=exports.BlendOperation.Add;break;}}}]);return BaseMaterial;}(Material);BaseMaterial._baseColorProp=Shader.getPropertyByName("u_baseColor");BaseMaterial._baseTextureProp=Shader.getPropertyByName("u_baseTexture");BaseMaterial._baseTextureMacro=Shader.getMacroByName("BASETEXTURE");BaseMaterial._tilingOffsetProp=Shader.getPropertyByName("u_tilingOffset");BaseMaterial._normalTextureProp=Shader.getPropertyByName("u_normalTexture");BaseMaterial._normalIntensityProp=Shader.getPropertyByName("u_normalIntensity");BaseMaterial._normalTextureMacro=Shader.getMacroByName("NORMALTEXTURE");BaseMaterial._emissiveColorProp=Shader.getPropertyByName("u_emissiveColor");BaseMaterial._emissiveTextureProp=Shader.getPropertyByName("u_emissiveTexture");BaseMaterial._emissiveTextureMacro=Shader.getMacroByName("EMISSIVETEXTURE");BaseMaterial._alphaCutoffProp=Shader.getPropertyByName("u_alphaCutoff");BaseMaterial._alphaCutoffMacro=Shader.getMacroByName("ALPHA_CUTOFF");/**
   * Blinn-phong Material.
   */var BlinnPhongMaterial=/*#__PURE__*/function(_BaseMaterial){_inheritsLoose$2(BlinnPhongMaterial,_BaseMaterial);function BlinnPhongMaterial(engine){var _this;_this=_BaseMaterial.call(this,engine,Shader.find("blinn-phong"))||this;var shaderData=_this.shaderData;shaderData.enableMacro("O3_NEED_WORLDPOS");shaderData.enableMacro("O3_NEED_TILINGOFFSET");shaderData.setColor(BlinnPhongMaterial._baseColorProp,new Color(1,1,1,1));shaderData.setColor(BlinnPhongMaterial._specularColorProp,new Color(1,1,1,1));shaderData.setColor(BlinnPhongMaterial._emissiveColorProp,new Color(0,0,0,1));shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp,new Vector4(1,1,0,0));shaderData.setFloat(BlinnPhongMaterial._shininessProp,16);shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp,1);return _this;}/**
     * @override
     */var _proto=BlinnPhongMaterial.prototype;_proto.clone=function clone(){var dest=new BlinnPhongMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(BlinnPhongMaterial,[{key:"baseColor",get:/**
       * Base color.
       */function get(){return this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);},set:function set(value){var baseColor=this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);if(value!==baseColor){baseColor.copyFrom(value);}}/**
       * Base texture.
       */},{key:"baseTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp,value);if(value){this.shaderData.enableMacro(BlinnPhongMaterial._baseTextureMacro);}else {this.shaderData.disableMacro(BlinnPhongMaterial._baseTextureMacro);}}/**
       * Specular color.
       */},{key:"specularColor",get:function get(){return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);},set:function set(value){var specularColor=this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);if(value!==specularColor){specularColor.copyFrom(value);}}/**
       * Specular texture.
       */},{key:"specularTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp,value);if(value){this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");}else {this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");}}/**
       * Emissive color.
       */},{key:"emissiveColor",get:function get(){return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);},set:function set(value){var emissiveColor=this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);if(value!==emissiveColor){emissiveColor.copyFrom(value);}}/**
       * Emissive texture.
       */},{key:"emissiveTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp,value);if(value){this.shaderData.enableMacro(BlinnPhongMaterial._emissiveTextureMacro);}else {this.shaderData.disableMacro(BlinnPhongMaterial._emissiveTextureMacro);}}/**
       * Normal texture.
       */},{key:"normalTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp,value);if(value){this.shaderData.enableMacro(BlinnPhongMaterial._normalTextureMacro);}else {this.shaderData.disableMacro(BlinnPhongMaterial._normalTextureMacro);}}/**
       * Normal texture intensity.
       */},{key:"normalIntensity",get:function get(){return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);},set:function set(value){this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp,value);}/**
       * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.
       */},{key:"shininess",get:function get(){return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);},set:function set(value){this.shaderData.setFloat(BlinnPhongMaterial._shininessProp,Math.max(value,1e-4));}/**
       * Tiling and offset of main textures.
       */},{key:"tilingOffset",get:function get(){return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);},set:function set(value){var tilingOffset=this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);if(value!==tilingOffset){tilingOffset.copyFrom(value);}}}]);return BlinnPhongMaterial;}(BaseMaterial);BlinnPhongMaterial._specularColorProp=Shader.getPropertyByName("u_specularColor");BlinnPhongMaterial._shininessProp=Shader.getPropertyByName("u_shininess");BlinnPhongMaterial._specularTextureProp=Shader.getPropertyByName("u_specularTexture");/**
   * PBR (Physically-Based Rendering) Material.
   */var PBRBaseMaterial=/*#__PURE__*/function(_BaseMaterial){_inheritsLoose$2(PBRBaseMaterial,_BaseMaterial);/**
     * Create a pbr base material instance.
     * @param engine - Engine to which the material belongs
     * @param shader - Shader used by the material
     */function PBRBaseMaterial(engine,shader){var _this;_this=_BaseMaterial.call(this,engine,shader)||this;var shaderData=_this.shaderData;shaderData.enableMacro("O3_NEED_WORLDPOS");shaderData.enableMacro("O3_NEED_TILINGOFFSET");shaderData.setColor(PBRBaseMaterial._baseColorProp,new Color(1,1,1,1));shaderData.setColor(PBRBaseMaterial._emissiveColorProp,new Color(0,0,0,1));shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp,new Vector4(1,1,0,0));shaderData.setFloat(PBRBaseMaterial._normalIntensityProp,1);shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp,1);shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp,exports.TextureCoordinate.UV0);shaderData.setFloat(PBRBaseMaterial._clearCoatProp,0);shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp,0);return _this;}_createClass$3(PBRBaseMaterial,[{key:"baseColor",get:/**
       * Base color.
       */function get(){return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);},set:function set(value){var baseColor=this.shaderData.getColor(PBRBaseMaterial._baseColorProp);if(value!==baseColor){baseColor.copyFrom(value);}}/**
       * Base texture.
       */},{key:"baseTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp,value);if(value){this.shaderData.enableMacro(PBRBaseMaterial._baseTextureMacro);}else {this.shaderData.disableMacro(PBRBaseMaterial._baseTextureMacro);}}/**
       * Normal texture.
       */},{key:"normalTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp,value);if(value){this.shaderData.enableMacro(PBRBaseMaterial._normalTextureMacro);}else {this.shaderData.disableMacro(PBRBaseMaterial._normalTextureMacro);}}/**
       * Normal texture intensity.
       */},{key:"normalTextureIntensity",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._normalIntensityProp);},set:function set(value){this.shaderData.setFloat(PBRBaseMaterial._normalIntensityProp,value);}/**
       * Emissive color.
       */},{key:"emissiveColor",get:function get(){return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);},set:function set(value){var emissiveColor=this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);if(value!==emissiveColor){emissiveColor.copyFrom(value);}}/**
       * Emissive texture.
       */},{key:"emissiveTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp,value);if(value){this.shaderData.enableMacro(PBRBaseMaterial._emissiveTextureMacro);}else {this.shaderData.disableMacro(PBRBaseMaterial._emissiveTextureMacro);}}/**
       * Occlusion texture.
       */},{key:"occlusionTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp,value);if(value){this.shaderData.enableMacro("OCCLUSIONTEXTURE");}else {this.shaderData.disableMacro("OCCLUSIONTEXTURE");}}/**
       * Occlusion texture intensity.
       */},{key:"occlusionTextureIntensity",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);},set:function set(value){this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp,value);}/**
       * Occlusion texture uv coordinate.
       * @remarks Must be UV0 or UV1.
       */},{key:"occlusionTextureCoord",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureCoordProp);},set:function set(value){if(value>exports.TextureCoordinate.UV1){Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");}this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp,value);}/**
       * Tiling and offset of main textures.
       */},{key:"tilingOffset",get:function get(){return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);},set:function set(value){var tilingOffset=this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);if(value!==tilingOffset){tilingOffset.copyFrom(value);}}/**
       * The clearCoat layer intensity, default 0.
       */},{key:"clearCoat",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp);},set:function set(value){if(!!this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp)!==!!value){if(value===0){this.shaderData.disableMacro("CLEARCOAT");}else {this.shaderData.enableMacro("CLEARCOAT");}}this.shaderData.setFloat(PBRBaseMaterial._clearCoatProp,value);}/**
       * The clearCoat layer intensity texture.
       */},{key:"clearCoatTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._clearCoatTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._clearCoatTextureProp,value);if(value){this.shaderData.enableMacro("HAS_CLEARCOATTEXTURE");}else {this.shaderData.disableMacro("HAS_CLEARCOATTEXTURE");}}/**
       * The clearCoat layer roughness, default 0.
       */},{key:"clearCoatRoughness",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._clearCoatRoughnessProp);},set:function set(value){this.shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp,value);}/**
       * The clearCoat layer roughness texture.
       */},{key:"clearCoatRoughnessTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp,value);if(value){this.shaderData.enableMacro("HAS_CLEARCOATROUGHNESSTEXTURE");}else {this.shaderData.disableMacro("HAS_CLEARCOATROUGHNESSTEXTURE");}}/**
       * The clearCoat normal map texture.
       */},{key:"clearCoatNormalTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._clearCoatNormalTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._clearCoatNormalTextureProp,value);if(value){this.shaderData.enableMacro("HAS_CLEARCOATNORMALTEXTURE");}else {this.shaderData.disableMacro("HAS_CLEARCOATNORMALTEXTURE");}}}]);return PBRBaseMaterial;}(BaseMaterial);PBRBaseMaterial._occlusionTextureIntensityProp=Shader.getPropertyByName("u_occlusionIntensity");PBRBaseMaterial._occlusionTextureCoordProp=Shader.getPropertyByName("u_occlusionTextureCoord");PBRBaseMaterial._occlusionTextureProp=Shader.getPropertyByName("u_occlusionTexture");PBRBaseMaterial._clearCoatProp=Shader.getPropertyByName("u_clearCoat");PBRBaseMaterial._clearCoatTextureProp=Shader.getPropertyByName("u_clearCoatTexture");PBRBaseMaterial._clearCoatRoughnessProp=Shader.getPropertyByName("u_clearCoatRoughness");PBRBaseMaterial._clearCoatRoughnessTextureProp=Shader.getPropertyByName("u_clearCoatRoughnessTexture");PBRBaseMaterial._clearCoatNormalTextureProp=Shader.getPropertyByName("u_clearCoatNormalTexture");/**
   * PBR (Metallic-Roughness Workflow) Material.
   */var PBRMaterial=/*#__PURE__*/function(_PBRBaseMaterial){_inheritsLoose$2(PBRMaterial,_PBRBaseMaterial);/**
     * Create a pbr metallic-roughness workflow material instance.
     * @param engine - Engine to which the material belongs
     */function PBRMaterial(engine){var _this;_this=_PBRBaseMaterial.call(this,engine,Shader.find("pbr"))||this;_this.shaderData.setFloat(PBRMaterial._metallicProp,1);_this.shaderData.setFloat(PBRMaterial._roughnessProp,1);return _this;}/**
     * @override
     */var _proto=PBRMaterial.prototype;_proto.clone=function clone(){var dest=new PBRMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(PBRMaterial,[{key:"metallic",get:/**
       * Metallic, default 1.0.
       */function get(){return this.shaderData.getFloat(PBRMaterial._metallicProp);},set:function set(value){this.shaderData.setFloat(PBRMaterial._metallicProp,value);}/**
       * Roughness, default 1.0.
       */},{key:"roughness",get:function get(){return this.shaderData.getFloat(PBRMaterial._roughnessProp);},set:function set(value){this.shaderData.setFloat(PBRMaterial._roughnessProp,value);}/**
       * Roughness metallic texture.
       * @remarks G channel is roughness, B channel is metallic
       */},{key:"roughnessMetallicTexture",get:function get(){return this.shaderData.getTexture(PBRMaterial._roughnessMetallicTextureProp);},set:function set(value){this.shaderData.setTexture(PBRMaterial._roughnessMetallicTextureProp,value);if(value){this.shaderData.enableMacro("ROUGHNESSMETALLICTEXTURE");}else {this.shaderData.disableMacro("ROUGHNESSMETALLICTEXTURE");}}}]);return PBRMaterial;}(PBRBaseMaterial);PBRMaterial._metallicProp=Shader.getPropertyByName("u_metal");PBRMaterial._roughnessProp=Shader.getPropertyByName("u_roughness");PBRMaterial._roughnessMetallicTextureProp=Shader.getPropertyByName("u_roughnessMetallicTexture");/**
   * PBR (Specular-Glossiness Workflow) Material.
   */var PBRSpecularMaterial=/*#__PURE__*/function(_PBRBaseMaterial){_inheritsLoose$2(PBRSpecularMaterial,_PBRBaseMaterial);/**
     * Create a pbr specular-glossiness workflow material instance.
     * @param engine - Engine to which the material belongs
     */function PBRSpecularMaterial(engine){var _this;_this=_PBRBaseMaterial.call(this,engine,Shader.find("pbr-specular"))||this;_this.shaderData.setColor(PBRSpecularMaterial._specularColorProp,new Color(1,1,1,1));_this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp,1.0);return _this;}/**
     * @override
     */var _proto=PBRSpecularMaterial.prototype;_proto.clone=function clone(){var dest=new PBRSpecularMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(PBRSpecularMaterial,[{key:"specularColor",get:/**
       * Specular color.
       */function get(){return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);},set:function set(value){var specularColor=this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);if(value!==specularColor){specularColor.copyFrom(value);}}/**
       * Glossiness.
       */},{key:"glossiness",get:function get(){return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);},set:function set(value){this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp,value);}/**
       * Specular glossiness texture.
       * @remarks RGB is specular, A is glossiness
       */},{key:"specularGlossinessTexture",get:function get(){return this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);},set:function set(value){this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp,value);if(value){this.shaderData.enableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);}else {this.shaderData.disableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);}}}]);return PBRSpecularMaterial;}(PBRBaseMaterial);PBRSpecularMaterial._specularColorProp=Shader.getPropertyByName("u_PBRSpecularColor");PBRSpecularMaterial._glossinessProp=Shader.getPropertyByName("u_glossiness");PBRSpecularMaterial._specularGlossinessTextureProp=Shader.getPropertyByName("u_specularGlossinessTexture");PBRSpecularMaterial._specularGlossinessTextureMacro=Shader.getMacroByName("SPECULARGLOSSINESSTEXTURE");/**
   * Unlit Material.
   */var UnlitMaterial=/*#__PURE__*/function(_BaseMaterial){_inheritsLoose$2(UnlitMaterial,_BaseMaterial);/**
     * Create a unlit material instance.
     * @param engine - Engine to which the material belongs
     */function UnlitMaterial(engine){var _this;_this=_BaseMaterial.call(this,engine,Shader.find("unlit"))||this;var shaderData=_this.shaderData;shaderData.enableMacro("OMIT_NORMAL");shaderData.enableMacro("O3_NEED_TILINGOFFSET");shaderData.setColor(UnlitMaterial._baseColorProp,new Color(1,1,1,1));shaderData.setVector4(UnlitMaterial._tilingOffsetProp,new Vector4(1,1,0,0));return _this;}/**
     * @override
     */var _proto=UnlitMaterial.prototype;_proto.clone=function clone(){var dest=new UnlitMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(UnlitMaterial,[{key:"baseColor",get:/**
       * Base color.
       */function get(){return this.shaderData.getColor(UnlitMaterial._baseColorProp);},set:function set(value){var baseColor=this.shaderData.getColor(UnlitMaterial._baseColorProp);if(value!==baseColor){baseColor.copyFrom(value);}}/**
       * Base texture.
       */},{key:"baseTexture",get:function get(){return this.shaderData.getTexture(UnlitMaterial._baseTextureProp);},set:function set(value){this.shaderData.setTexture(UnlitMaterial._baseTextureProp,value);if(value){this.shaderData.enableMacro(UnlitMaterial._baseTextureMacro);}else {this.shaderData.disableMacro(UnlitMaterial._baseTextureMacro);}}/**
       * Tiling and offset of main textures.
       */},{key:"tilingOffset",get:function get(){return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);},set:function set(value){var tilingOffset=this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);if(value!==tilingOffset){tilingOffset.copyFrom(value);}}}]);return UnlitMaterial;}(BaseMaterial);/**
   * The horizontal alignment of the text.
   */exports.TextHorizontalAlignment = void 0;/**
   * The vertical alignment of the text.
   */(function(TextHorizontalAlignment){TextHorizontalAlignment[TextHorizontalAlignment["Left"]=0]="Left";TextHorizontalAlignment[TextHorizontalAlignment["Center"]=1]="Center";TextHorizontalAlignment[TextHorizontalAlignment["Right"]=2]="Right";})(exports.TextHorizontalAlignment||(exports.TextHorizontalAlignment={}));exports.TextVerticalAlignment = void 0;(function(TextVerticalAlignment){TextVerticalAlignment[TextVerticalAlignment["Top"]=0]="Top";TextVerticalAlignment[TextVerticalAlignment["Center"]=1]="Center";TextVerticalAlignment[TextVerticalAlignment["Bottom"]=2]="Bottom";})(exports.TextVerticalAlignment||(exports.TextVerticalAlignment={}));/**
   * The way to handle the situation where wrapped text is too tall to fit in the height.
   */exports.OverflowMode = void 0;(function(OverflowMode){OverflowMode[OverflowMode["Overflow"]=0]="Overflow";OverflowMode[OverflowMode["Truncate"]=1]="Truncate";})(exports.OverflowMode||(exports.OverflowMode={}));/**
   * The style of the font.
   */exports.FontStyle = void 0;(function(FontStyle){FontStyle[FontStyle["None"]=0]="None";FontStyle[FontStyle["Bold"]=1]="Bold";FontStyle[FontStyle["Italic"]=2]="Italic";})(exports.FontStyle||(exports.FontStyle={}));/**
   * Sprite Atlas.
   */var SpriteAtlas=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(SpriteAtlas,_RefObject);var _proto=SpriteAtlas.prototype;/**
     * Get the last sprite named 'name' from the atlas.
     * @param name - The name of the sprite you want to find
     * @returns The sprite you want to find
     */_proto.getSprite=function getSprite(name){var sprite=this._sprites[this._spriteNamesToIndex[name]];if(!sprite){console.warn("There is no sprite named "+name+" in the atlas.");}return sprite;}/**
     * Get all the sprite named 'name' from the atlas.
     * @param name - The name of the sprites you want to find
     * @param outSprites - This array holds the sprites found
     * @returns The sprites you want to find
     */;_proto.getSprites=function getSprites(name,outSprites){outSprites.length=0;var i=this._spriteNamesToIndex[name];if(i!==undefined){var _sprites=this._sprites;for(;i>=0;i--){var sprite=_sprites[i];sprite.name===name&&outSprites.push(sprite);}}else {console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");}return outSprites;}/**
     * Constructor a SpriteAtlas.
     * @param engine - Engine to which the SpriteAtlas belongs
     */;function SpriteAtlas(engine){var _this;_this=_RefObject.call(this,engine)||this;_this._sprites=new Array();_this._spriteNamesToIndex={};return _this;}/**
     * @internal
     */_proto._addSprite=function _addSprite(sprite){this._spriteNamesToIndex[sprite.name]=this._sprites.push(sprite)-1;}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){this._sprites=null;this._spriteNamesToIndex=null;};_createClass$3(SpriteAtlas,[{key:"sprites",get:/**
       * All the sprites in the atlas.
       */function get(){return this._sprites;}}]);return SpriteAtlas;}(RefObject);/**
   * Sprite's drawing mode enumeration.
   */exports.SpriteDrawMode = void 0;(function(SpriteDrawMode){SpriteDrawMode[SpriteDrawMode["Simple"]=0]="Simple";SpriteDrawMode[SpriteDrawMode["Sliced"]=1]="Sliced";})(exports.SpriteDrawMode||(exports.SpriteDrawMode={}));/**
   * 2D sprite.
   */var Sprite=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Sprite,_RefObject);/**
     * Constructor a Sprite.
     * @param engine - Engine to which the sprite belongs
     * @param texture - Texture from which to obtain the Sprite
     * @param region - Rectangle region of the texture to use for the Sprite, specified in normalized
     * @param pivot - Sprite's pivot point relative to its graphic rectangle, specified in normalized
     * @param border - Boundaries when using Slice DrawMode, specified in normalized
     * @param name - The name of Sprite
     */function Sprite(engine,texture,region,pivot,border,name){var _this;if(texture===void 0){texture=null;}if(region===void 0){region=null;}if(pivot===void 0){pivot=null;}if(border===void 0){border=null;}if(name===void 0){name=null;}_this=_RefObject.call(this,engine)||this;_this.name=void 0;_this._assetID=void 0;_this._width=undefined;_this._height=undefined;_this._positions=[new Vector2(),new Vector2(),new Vector2(),new Vector2()];_this._uvs=[new Vector2(),new Vector2(),new Vector2(),new Vector2()];_this._bounds=new BoundingBox();_this._texture=null;_this._atlasRotated=false;_this._atlasRegion=new Rect(0,0,1,1);_this._atlasRegionOffset=new Vector4(0,0,0,0);_this._region=new Rect(0,0,1,1);_this._pivot=new Vector2(0.5,0.5);_this._border=new Vector4(0,0,0,0);_this._dirtyFlag=DirtyFlag$2.all;_this._updateFlagManager=new UpdateFlagManager();_this._texture=texture;region&&_this._region.copyFrom(region);pivot&&_this._pivot.copyFrom(pivot);border&&_this._border.copyFrom(border);_this.name=name;return _this;}/**
     * Clone.
     * @returns Cloned sprite
     */var _proto=Sprite.prototype;_proto.clone=function clone(){var cloneSprite=new Sprite(this._engine,this._texture,this._region,this._pivot,this._border,this.name);cloneSprite._assetID=this._assetID;cloneSprite._atlasRotated=this._atlasRotated;cloneSprite._atlasRegion.copyFrom(this._atlasRegion);cloneSprite._atlasRegionOffset.copyFrom(this._atlasRegionOffset);return cloneSprite;}/**
     * @internal
     */;_proto._registerUpdateFlag=function _registerUpdateFlag(){return this._updateFlagManager.createFlag(ListenerUpdateFlag);}/**
     * @internal
     */;_proto._getPositions=function _getPositions(){this._dirtyFlag&DirtyFlag$2.positions&&this._updatePositions();return this._positions;}/**
     * @internal
     */;_proto._getUVs=function _getUVs(){this._dirtyFlag&DirtyFlag$2.uvs&&this._updateUVs();return this._uvs;}/**
     * @internal
     */;_proto._getBounds=function _getBounds(){this._dirtyFlag&DirtyFlag$2.positions&&this._updatePositions();return this._bounds;}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){if(this._texture){this._texture=null;}};_proto._calDefaultSize=function _calDefaultSize(){if(this._texture){var _texture=this._texture,_atlasRegion=this._atlasRegion,_atlasRegionOffset=this._atlasRegionOffset,_region=this._region;var pixelsPerUnitReciprocal=1.0/Engine._pixelsPerUnit;this.width=_texture.width*_atlasRegion.width/(1-_atlasRegionOffset.x-_atlasRegionOffset.z)*_region.width*pixelsPerUnitReciprocal;this.height=_texture.height*_atlasRegion.height/(1-_atlasRegionOffset.y-_atlasRegionOffset.w)*_region.height*pixelsPerUnitReciprocal;}};_proto._updatePositions=function _updatePositions(){var blank=this._atlasRegionOffset;var _this$_region=this._region,regionX=_this$_region.x,regionY=_this$_region.y,regionW=_this$_region.width,regionH=_this$_region.height;var regionRight=1-regionX-regionW;var regionBottom=1-regionY-regionH;var left=Math.max(blank.x-regionX,0)/regionW;var bottom=Math.max(blank.w-regionY,0)/regionH;var right=1-Math.max(blank.z-regionRight,0)/regionW;var top=1-Math.max(blank.y-regionBottom,0)/regionH;// Update positions.
  // ---------------
  //  2 - 3
  //  |   |
  //  0 - 1
  // ---------------
  var positions=this._positions;positions[0].set(left,bottom);positions[1].set(right,bottom);positions[2].set(left,top);positions[3].set(right,top);var _this$_bounds=this._bounds,min=_this$_bounds.min,max=_this$_bounds.max;min.set(left,bottom,0);max.set(right,top,0);this._dirtyFlag&=~DirtyFlag$2.positions;};_proto._updateUVs=function _updateUVs(){var uv=this._uvs,atlasRegionOffset=this._atlasRegionOffset;var _this$_region2=this._region,regionX=_this$_region2.x,regionY=_this$_region2.y,regionW=_this$_region2.width,regionH=_this$_region2.height;var regionRight=1-regionX-regionW;var regionBottom=1-regionY-regionH;var _this$_atlasRegion=this._atlasRegion,atlasRegionX=_this$_atlasRegion.x,atlasRegionY=_this$_atlasRegion.y,atlasRegionW=_this$_atlasRegion.width,atlasRegionH=_this$_atlasRegion.height;var offsetLeft=atlasRegionOffset.x,offsetTop=atlasRegionOffset.y,offsetRight=atlasRegionOffset.z,offsetBottom=atlasRegionOffset.w;var realWidth=atlasRegionW/(1-offsetLeft-offsetRight);var realHeight=atlasRegionH/(1-offsetTop-offsetBottom);// Coordinates of the four boundaries.
  var left=Math.max(regionX-offsetLeft,0)*realWidth+atlasRegionX;var top=Math.max(regionBottom-offsetTop,0)*realHeight+atlasRegionY;var right=atlasRegionW+atlasRegionX-Math.max(regionRight-offsetRight,0)*realWidth;var bottom=atlasRegionH+atlasRegionY-Math.max(regionY-offsetBottom,0)*realHeight;var _this$_border=this._border,borderLeft=_this$_border.x,borderBottom=_this$_border.y,borderRight=_this$_border.z,borderTop=_this$_border.w;// Left-Bottom
  uv[0].set(left,bottom);// Border ( Left-Bottom )
  uv[1].set((regionX-offsetLeft+borderLeft*regionW)*realWidth+atlasRegionX,atlasRegionH+atlasRegionY-(regionY-offsetBottom+borderBottom*regionH)*realHeight);// Border ( Right-Top )
  uv[2].set(atlasRegionW+atlasRegionX-(regionRight-offsetRight+borderRight*regionW)*realWidth,(regionBottom-offsetTop+borderTop*regionH)*realHeight+atlasRegionY);// Right-Top
  uv[3].set(right,top);this._dirtyFlag&=~DirtyFlag$2.uvs;};_proto._dispatchSpriteChange=function _dispatchSpriteChange(type){switch(type){case SpritePropertyDirtyFlag.atlasRegionOffset:case SpritePropertyDirtyFlag.region:this._dirtyFlag|=DirtyFlag$2.all;break;case SpritePropertyDirtyFlag.atlasRegion:case SpritePropertyDirtyFlag.border:this._dirtyFlag|=DirtyFlag$2.uvs;break;}this._updateFlagManager.dispatch(type);};_createClass$3(Sprite,[{key:"texture",get:/** The name of sprite. */ /** @internal temp solution. */ /**
       * The reference to the used texture.
       */function get(){return this._texture;},set:function set(value){if(this._texture!==value){this._texture=value;this._dispatchSpriteChange(SpritePropertyDirtyFlag.texture);}}/**
       * The width of the sprite (in world coordinates).
       */},{key:"width",get:function get(){this._width===undefined&&this._calDefaultSize();return this._width;},set:function set(value){if(this._width!==value){this._width=value;this._dispatchSpriteChange(SpritePropertyDirtyFlag.size);}}/**
       * The height of the sprite (in world coordinates).
       */},{key:"height",get:function get(){this._height===undefined&&this._calDefaultSize();return this._height;},set:function set(value){if(this._height!==value){this._height=value;this._dispatchSpriteChange(SpritePropertyDirtyFlag.size);}}/**
       * Is it rotated 90 degrees clockwise when packing.
       */},{key:"atlasRotated",get:function get(){return this._atlasRotated;},set:function set(value){if(this._atlasRotated!=value){this._atlasRotated=value;}}/**
       * The rectangle region of the original texture on its atlas texture, specified in normalized.
       */},{key:"atlasRegion",get:function get(){return this._atlasRegion;},set:function set(value){var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);this._atlasRegion.set(x,y,MathUtil.clamp(value.width,0,1-x),MathUtil.clamp(value.height,0,1-y));this._dispatchSpriteChange(SpritePropertyDirtyFlag.atlasRegion);}/**
       * The rectangle region offset of the original texture on its atlas texture, specified in normalized.
       */},{key:"atlasRegionOffset",get:function get(){return this._atlasRegionOffset;},set:function set(value){var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);this._atlasRegionOffset.set(x,y,MathUtil.clamp(value.z,0,1-x),MathUtil.clamp(value.w,0,1-y));this._dispatchSpriteChange(SpritePropertyDirtyFlag.atlasRegionOffset);}/**
       * The rectangle region of the sprite, specified in normalized.
       */},{key:"region",get:function get(){return this._region;},set:function set(value){var region=this._region;var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);region.set(x,y,MathUtil.clamp(value.width,0,1-x),MathUtil.clamp(value.height,0,1-y));this._dispatchSpriteChange(SpritePropertyDirtyFlag.region);}/**
       * Location of the sprite's center point in the rectangle region, specified in normalized.
       * The origin is at the bottom left and the default value is (0.5, 0.5).
       */},{key:"pivot",get:function get(){return this._pivot;},set:function set(value){var pivot=this._pivot;if(pivot===value){this._dispatchSpriteChange(SpritePropertyDirtyFlag.pivot);}else {var x=value.x,y=value.y;if(pivot.x!==x||pivot.y!==y){pivot.set(x,y);this._dispatchSpriteChange(SpritePropertyDirtyFlag.pivot);}}}/**
       * Get the border of the sprite.
       *  x      y       z     w
       *  |      |       |     |
       * Left, bottom, right, top.
       * @remarks only use in sliced mode.
       */},{key:"border",get:function get(){return this._border;},set:function set(value){var border=this._border;var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);border.set(x,y,MathUtil.clamp(value.z,0,1-x),MathUtil.clamp(value.w,0,1-y));this._dispatchSpriteChange(SpritePropertyDirtyFlag.border);}}]);return Sprite;}(RefObject);var DirtyFlag$2;(function(DirtyFlag){DirtyFlag[DirtyFlag["positions"]=1]="positions";DirtyFlag[DirtyFlag["uvs"]=2]="uvs";DirtyFlag[DirtyFlag["all"]=3]="all";})(DirtyFlag$2||(DirtyFlag$2={}));var _dec$s,_class$3$1,_class2$3;/**
   * @internal
   */var SlicedSpriteAssembler=(_dec$s=StaticInterfaceImplement(),_dec$s(_class$3$1=(_class2$3=/*#__PURE__*/function(){function SlicedSpriteAssembler(){}SlicedSpriteAssembler.resetData=function resetData(renderer){var renderData=renderer._renderData;var positions=renderData.positions,uvs=renderData.uvs;if(positions.length<16){for(var i=positions.length;i<16;i++){positions.push(new Vector3());uvs.push(new Vector2());}}renderData.triangles=[];};SlicedSpriteAssembler.updatePositions=function updatePositions(renderer){var width=renderer.width,height=renderer.height,sprite=renderer.sprite;var _renderer$_renderData=renderer._renderData,positions=_renderer$_renderData.positions,uvs=_renderer$_renderData.uvs,triangles=_renderer$_renderData.triangles;var border=sprite.border;var spriteUVs=sprite._getUVs();// Update local positions.
  var spritePositions=sprite._getPositions();var _spritePositions$=spritePositions[0],left=_spritePositions$.x,bottom=_spritePositions$.y;var _spritePositions$2=spritePositions[3],right=_spritePositions$2.x,top=_spritePositions$2.y;var expectWidth=sprite.width,expectHeight=sprite.height;var fixedLeft=expectWidth*border.x;var fixedBottom=expectHeight*border.y;var fixedRight=expectHeight*border.z;var fixedTop=expectWidth*border.w;// ------------------------
  //     [3]
  //      |
  //     [2]
  //      |
  //     [1]
  //      |
  // row [0] - [1] - [2] - [3]
  //    column
  // ------------------------
  // Calculate row and column.
  var row,column;if(fixedLeft+fixedRight>width){var widthScale=width/(fixedLeft+fixedRight);row=[expectWidth*left*widthScale,fixedLeft*widthScale,fixedLeft*widthScale,width-expectWidth*(1-right)*widthScale];}else {row=[expectWidth*left,fixedLeft,width-fixedRight,width-expectWidth*(1-right)];}if(fixedTop+fixedBottom>height){var heightScale=height/(fixedTop+fixedBottom);column=[expectHeight*bottom*heightScale,fixedBottom*heightScale,fixedBottom*heightScale,height-expectHeight*(1-top)*heightScale];}else {column=[expectHeight*bottom,fixedBottom,height-fixedTop,height-expectHeight*(1-top)];}// Update renderer's worldMatrix.
  var _renderer$sprite$pivo=renderer.sprite.pivot,pivotX=_renderer$sprite$pivo.x,pivotY=_renderer$sprite$pivo.y;var localTransX=renderer.width*pivotX;var localTransY=renderer.height*pivotY;// Renderer's worldMatrix.
  var worldMatrix=SlicedSpriteAssembler._worldMatrix;var wE=worldMatrix.elements;// Parent's worldMatrix.
  var pWE=renderer.entity.transform.worldMatrix.elements;var sx=renderer.flipX?-1:1;var sy=renderer.flipY?-1:1;wE[0]=pWE[0]*sx,wE[1]=pWE[1]*sx,wE[2]=pWE[2]*sx;wE[4]=pWE[4]*sy,wE[5]=pWE[5]*sy,wE[6]=pWE[6]*sy;wE[8]=pWE[8],wE[9]=pWE[9],wE[10]=pWE[10];wE[12]=pWE[12]-localTransX*wE[0]-localTransY*wE[4];wE[13]=pWE[13]-localTransX*wE[1]-localTransY*wE[5];wE[14]=pWE[14]-localTransX*wE[2]-localTransY*wE[6];// ------------------------
  //  3 - 7 - 11 - 15
  //  |   |   |    |
  //  2 - 6 - 10 - 14
  //  |   |   |    |
  //  1 - 5 - 9  - 13
  //  |   |   |    |
  //  0 - 4 - 8  - 12
  // ------------------------
  // Assemble position and uv.
  var vertexCount=0;var realICount=0;for(var i=0;i<4;i++){var rowValue=row[i];var rowU=spriteUVs[i].x;for(var j=0;j<4;j++){var columnValue=column[j];positions[vertexCount].set(wE[0]*rowValue+wE[4]*columnValue+wE[12],wE[1]*rowValue+wE[5]*columnValue+wE[13],wE[2]*rowValue+wE[6]*columnValue+wE[14]);uvs[vertexCount].set(rowU,spriteUVs[j].y);++vertexCount;}++realICount;}var realJCount=vertexCount/realICount;var indexOffset=0;for(var _i=0;_i<realICount-1;++_i){for(var _j=0;_j<realJCount-1;++_j){var start=_i*realJCount+_j;triangles[indexOffset++]=start;triangles[indexOffset++]=start+1;triangles[indexOffset++]=start+realJCount;triangles[indexOffset++]=start+1;triangles[indexOffset++]=start+realJCount+1;triangles[indexOffset++]=start+realJCount;}}renderer._renderData.vertexCount=realICount*realJCount;triangles.length=(realICount-1)*(realJCount-1)*6;var _renderer$_bounds=renderer._bounds,min=_renderer$_bounds.min,max=_renderer$_bounds.max;min.set(row[0],column[0],0);max.set(row[3],column[3],0);renderer._bounds.transform(worldMatrix);};SlicedSpriteAssembler.updateUVs=function updateUVs(renderer){};return SlicedSpriteAssembler;}(),_class2$3._worldMatrix=new Matrix(),_class2$3))||_class$3$1);var _class$2$1,_descriptor$2,_descriptor2$2,_descriptor3$2,_descriptor4$2,_descriptor5$2,_descriptor6$2,_descriptor7$2,_descriptor8$2,_descriptor9$2,_descriptor10$1,_descriptor11$1,_descriptor12$1,_descriptor13$1,_class2$2;/**
   * Renders a Sprite for 2D graphics.
   */var SpriteRenderer=(_class$2$1=(_class2$2=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(SpriteRenderer,_Renderer);/**
     * @internal
     */function SpriteRenderer(entity){var _this;_this=_Renderer.call(this,entity)||this;_initializerDefineProperty(_this,"_renderData",_descriptor$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_drawMode",_descriptor2$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_assembler",_descriptor3$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_color",_descriptor4$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_sprite",_descriptor5$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_width",_descriptor6$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_height",_descriptor7$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_flipX",_descriptor8$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_flipY",_descriptor9$2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_maskLayer",_descriptor10$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_maskInteraction",_descriptor11$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_dirtyFlag",_descriptor12$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_spriteChangeFlag",_descriptor13$1,_assertThisInitialized(_this));_this._renderData=new RenderData2D(4,[],[],null,_this._color);_this.drawMode=exports.SpriteDrawMode.Simple;_this.setMaterial(_this._engine._spriteDefaultMaterial);_this._onSpriteChange=_this._onSpriteChange.bind(_assertThisInitialized(_this));return _this;}/**
     * @internal
     */var _proto=SpriteRenderer.prototype;_proto._render=function _render(camera){var _this$sprite;if(!((_this$sprite=this.sprite)!==null&&_this$sprite!==void 0&&_this$sprite.texture)||!this.width||!this.height){return;}// Update position.
  if(this._transformChangeFlag.flag||this._dirtyFlag&DirtyFlag$1.Position){this._assembler.updatePositions(this);this._dirtyFlag&=~DirtyFlag$1.Position;this._transformChangeFlag.flag=false;}// Update uv.
  if(this._dirtyFlag&DirtyFlag$1.UV){this._assembler.updateUVs(this);this._dirtyFlag&=~DirtyFlag$1.UV;}// Push primitive.
  var spriteElement=this._engine._spriteElementPool.getFromPool();spriteElement.setValue(this,this._renderData,this.getMaterial(),this.sprite.texture);camera._renderPipeline.pushPrimitive(spriteElement);}/**
     * @internal
     */;_proto._cloneTo=function _cloneTo(target){target.sprite=this._sprite;}/**
     * @internal
     */;_proto._onDestroy=function _onDestroy(){this._color=null;this._sprite=null;this._assembler=null;this._renderData=null;if(this._spriteChangeFlag){this._spriteChangeFlag.destroy();this._spriteChangeFlag=null;}_Renderer.prototype._onDestroy.call(this);};_proto._updateStencilState=function _updateStencilState(){// Update stencil.
  var material=this.getInstanceMaterial();var stencilState=material.renderState.stencilState;var maskInteraction=this._maskInteraction;if(maskInteraction===exports.SpriteMaskInteraction.None){stencilState.enabled=false;stencilState.writeMask=0xff;stencilState.referenceValue=0;stencilState.compareFunctionFront=stencilState.compareFunctionBack=exports.CompareFunction.Always;}else {stencilState.enabled=true;stencilState.writeMask=0x00;stencilState.referenceValue=1;var compare=maskInteraction===exports.SpriteMaskInteraction.VisibleInsideMask?exports.CompareFunction.LessEqual:exports.CompareFunction.Greater;stencilState.compareFunctionFront=compare;stencilState.compareFunctionBack=compare;}};_proto._onSpriteChange=function _onSpriteChange(dirtyFlag){switch(dirtyFlag){case SpritePropertyDirtyFlag.texture:this.shaderData.setTexture(SpriteRenderer._textureProperty,this.sprite.texture);break;case SpritePropertyDirtyFlag.size:this._drawMode===exports.SpriteDrawMode.Sliced&&(this._dirtyFlag|=DirtyFlag$1.Position);break;case SpritePropertyDirtyFlag.border:this._drawMode===exports.SpriteDrawMode.Sliced&&(this._dirtyFlag|=DirtyFlag$1.All);break;case SpritePropertyDirtyFlag.region:case SpritePropertyDirtyFlag.atlasRegionOffset:this._dirtyFlag|=DirtyFlag$1.All;break;case SpritePropertyDirtyFlag.atlasRegion:this._dirtyFlag|=DirtyFlag$1.UV;break;case SpritePropertyDirtyFlag.pivot:this._dirtyFlag|=DirtyFlag$1.Position;break;}};_createClass$3(SpriteRenderer,[{key:"drawMode",get:/** @internal */ /** @internal */ /**
       * The draw mode of the sprite renderer.
       */function get(){return this._drawMode;},set:function set(drawMode){if(this._drawMode!==drawMode){this._drawMode=drawMode;switch(drawMode){case exports.SpriteDrawMode.Simple:this._assembler=SimpleSpriteAssembler;break;case exports.SpriteDrawMode.Sliced:this._assembler=SlicedSpriteAssembler;break;}this._assembler.resetData(this);this._dirtyFlag|=DirtyFlag$1.All;}}/**
       * The Sprite to render.
       */},{key:"sprite",get:function get(){return this._sprite;},set:function set(value){if(this._sprite!==value){this._sprite=value;this._spriteChangeFlag&&this._spriteChangeFlag.destroy();if(value){this._spriteChangeFlag=value._registerUpdateFlag();this._spriteChangeFlag.listener=this._onSpriteChange;this._dirtyFlag|=DirtyFlag$1.All;this.shaderData.setTexture(SpriteRenderer._textureProperty,value.texture);}else {this._spriteChangeFlag=null;this.shaderData.setTexture(SpriteRenderer._textureProperty,null);}}}/**
       * Rendering color for the Sprite graphic.
       */},{key:"color",get:function get(){return this._color;},set:function set(value){if(this._color!==value){this._color.copyFrom(value);}}/**
       * Render width.
       */},{key:"width",get:function get(){if(this._width===undefined&&this._sprite){this.width=this._sprite.width;}return this._width;},set:function set(value){if(this._width!==value){this._width=value;this._dirtyFlag|=DirtyFlag$1.Position;}}/**
       * Render height.
       */},{key:"height",get:function get(){if(this._height===undefined&&this._sprite){this.height=this._sprite.height;}return this._height;},set:function set(value){if(this._height!==value){this._height=value;this._dirtyFlag|=DirtyFlag$1.Position;}}/**
       * Flips the sprite on the X axis.
       */},{key:"flipX",get:function get(){return this._flipX;},set:function set(value){if(this._flipX!==value){this._flipX=value;this._dirtyFlag|=DirtyFlag$1.Position;}}/**
       * Flips the sprite on the Y axis.
       */},{key:"flipY",get:function get(){return this._flipY;},set:function set(value){if(this._flipY!==value){this._flipY=value;this._dirtyFlag|=DirtyFlag$1.Position;}}/**
       * The bounding volume of the spriteRenderer.
       */},{key:"bounds",get:function get(){var _this$sprite2;if(!((_this$sprite2=this.sprite)!==null&&_this$sprite2!==void 0&&_this$sprite2.texture)||!this.width||!this.height){return Engine._defaultBoundingBox;}else if(this._transformChangeFlag.flag||this._dirtyFlag&DirtyFlag$1.Position){this._assembler.updatePositions(this);this._dirtyFlag&=~DirtyFlag$1.Position;this._transformChangeFlag.flag=false;}return this._bounds;}/**
       * The mask layer the sprite renderer belongs to.
       */},{key:"maskLayer",get:function get(){return this._maskLayer;},set:function set(value){this._maskLayer=value;}/**
       * Interacts with the masks.
       */},{key:"maskInteraction",get:function get(){return this._maskInteraction;},set:function set(value){if(this._maskInteraction!==value){this._maskInteraction=value;this._updateStencilState();}}}]);return SpriteRenderer;}(Renderer),_class2$2._textureProperty=Shader.getPropertyByName("u_spriteTexture"),_class2$2),(_descriptor$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_renderData",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_drawMode",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_assembler",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_color",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Color(1,1,1,1);}}),_descriptor5$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_sprite",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor6$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_width",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return undefined;}}),_descriptor7$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_height",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return undefined;}}),_descriptor8$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_flipX",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor9$2=_applyDecoratedDescriptor(_class$2$1.prototype,"_flipY",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor10$1=_applyDecoratedDescriptor(_class$2$1.prototype,"_maskLayer",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskLayer.Layer0;}}),_descriptor11$1=_applyDecoratedDescriptor(_class$2$1.prototype,"_maskInteraction",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskInteraction.None;}}),_descriptor12$1=_applyDecoratedDescriptor(_class$2$1.prototype,"_dirtyFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}}),_descriptor13$1=_applyDecoratedDescriptor(_class$2$1.prototype,"_spriteChangeFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}})),_class$2$1);var DirtyFlag$1;(function(DirtyFlag){DirtyFlag[DirtyFlag["Position"]=1]="Position";DirtyFlag[DirtyFlag["UV"]=2]="UV";DirtyFlag[DirtyFlag["All"]=3]="All";})(DirtyFlag$1||(DirtyFlag$1={}));/**
   * @internal
   * Font Atlas.
   */var FontAtlas=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(FontAtlas,_RefObject);/**
     * Constructor a FontAtlas.
     * @param engine - Engine to which the FontAtlas belongs
     */function FontAtlas(engine){var _this;_this=_RefObject.call(this,engine)||this;_this._charInfoMap={};_this._texture=void 0;_this._space=1;_this._curX=1;_this._curY=1;_this._nextY=1;return _this;}/**
     * @override
     */var _proto=FontAtlas.prototype;_proto._onDestroy=function _onDestroy(){this._texture.destroy();this._texture=null;this._charInfoMap={};};_proto.uploadCharTexture=function uploadCharTexture(charInfo){var width=charInfo.w,height=charInfo.h,data=charInfo.data;var space=this._space,texture=this.texture;var textureSize=texture.width;var offsetWidth=width+space;var offsetHeight=height+space;if(1+offsetWidth>=textureSize||1+offsetHeight>=textureSize){throw Error("The char fontSize is too large.");}var endX=this._curX+offsetWidth;if(endX>=textureSize){this._curX=space;this._curY=this._nextY+space;}var endY=this._curY+offsetHeight;if(endY>this._nextY){this._nextY=endY;}if(endY>=textureSize){return false;}if(width>0&&height>0&&data){texture.setPixelBuffer(data,0,this._curX,this._curY,width,height);texture.generateMipmaps();}var textureSizeReciprocal=1.0/textureSize;var x=this._curX;var y=this._curY;var w=width;var h=height;var u0=x*textureSizeReciprocal;var u1=(x+w)*textureSizeReciprocal;var v0=y*textureSizeReciprocal;var v1=(y+h)*textureSizeReciprocal;charInfo.x=x;charInfo.y=y;var uvs=charInfo.uvs;uvs[0].set(u0,v0);uvs[1].set(u1,v0);uvs[2].set(u1,v1);uvs[3].set(u0,v1);this._curX+=offsetWidth+space;return true;};_proto.addCharInfo=function addCharInfo(char,charInfo){this._charInfoMap[char.charCodeAt(0)]=charInfo;};_proto.getCharInfo=function getCharInfo(char){return this._charInfoMap[char.charCodeAt(0)];};_createClass$3(FontAtlas,[{key:"texture",get:function get(){return this._texture;},set:function set(value){this._texture=value;}}]);return FontAtlas;}(RefObject);/**
   * Font.
   */var Font=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Font,_RefObject);/**
     * Create a font from OS.
     * @param engine - Engine to which the font belongs
     * @param name - The name of font
     * @returns The font object has been create
     */Font.createFromOS=function createFromOS(engine,name){if(name===void 0){name="";}var fontMap=Font._fontMap;var font=fontMap[name];if(font){return font;}font=new Font(engine,name);fontMap[name]=font;return font;};function Font(engine,name){var _this;if(name===void 0){name="";}_this=_RefObject.call(this,engine)||this;_this._name="";_this._fontAtlases=[];_this._lastIndex=-1;_this._name=name;return _this;}/**
     * @internal
     */var _proto=Font.prototype;_proto._uploadCharTexture=function _uploadCharTexture(charInfo){var fontAtlases=this._fontAtlases;var lastIndex=this._lastIndex;if(lastIndex===-1){this._createFontAtlas();lastIndex++;}var fontAtlas=fontAtlases[lastIndex];if(!fontAtlas.uploadCharTexture(charInfo)){fontAtlas=this._createFontAtlas();fontAtlas.uploadCharTexture(charInfo);lastIndex++;}this._lastIndex=lastIndex;charInfo.data=null;}/**
     * @internal
     */;_proto._addCharInfo=function _addCharInfo(char,charInfo){var lastIndex=this._lastIndex;charInfo.index=lastIndex;this._fontAtlases[lastIndex].addCharInfo(char,charInfo);}/**
     * @internal
     */;_proto._getCharInfo=function _getCharInfo(char){var fontAtlases=this._fontAtlases;for(var i=0,n=fontAtlases.length;i<n;++i){var fontAtlas=fontAtlases[i];var charInfo=fontAtlas.getCharInfo(char);if(charInfo){return charInfo;}}return null;}/**
     * @internal
     */;_proto._getTextureByIndex=function _getTextureByIndex(index){var fontAtlas=this._fontAtlases[index];if(fontAtlas){return fontAtlas.texture;}return null;}/**
     * @internal
     */;_proto._getLastIndex=function _getLastIndex(){return this._lastIndex;}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){var fontAtlases=this._fontAtlases;for(var i=0,n=fontAtlases.length;i<n;++i){fontAtlases[i].destroy(true);}fontAtlases.length=0;delete Font._fontMap[this._name];};_proto._createFontAtlas=function _createFontAtlas(){var engine=this.engine;var fontAtlas=new FontAtlas(engine);var texture=new Texture2D(engine,256,256);fontAtlas.texture=texture;this._fontAtlases.push(fontAtlas);return fontAtlas;};_createClass$3(Font,[{key:"name",get:/**
       * The name of the font object.
       */function get(){return this._name;}}]);return Font;}(RefObject);Font._fontMap={};/**
   * @internal
   */var CharRenderData=/** x:Top y:Left z:Bottom w:Right */function CharRenderData(){this.texture=void 0;this.localPositions=new Vector4();this.renderData=void 0;var positions=[new Vector3(),new Vector3(),new Vector3(),new Vector3()];this.renderData=new RenderData2D(4,positions,null,CharRenderData.triangles,null);};CharRenderData.triangles=[0,2,1,2,0,3];/**
   * @internal
   */var CharRenderDataPool=/*#__PURE__*/function(){function CharRenderDataPool(type,length){this._elements=[];this._type=void 0;this._type=type;var elements=this._elements;for(var i=0;i<length;++i){elements[i]=new type();}}var _proto=CharRenderDataPool.prototype;_proto.get=function get(){if(this._elements.length>0){return this._elements.pop();}return new this._type();};_proto.put=function put(data){this._elements.push(data);};return CharRenderDataPool;}();/**
   * @internal
   * TextUtils includes some helper function for text.
   */var TextUtils=/*#__PURE__*/function(){function TextUtils(){}/** @internal */ /** These characters are all tall to help calculate the height required for text. */ /**
     * The instance function to get an object includes 2d context and canvas.
     * @returns the TextContext object
     */TextUtils.textContext=function textContext(){var textContext=TextUtils._textContext;if(!textContext){var canvas;try{canvas=new OffscreenCanvas(0,0);}catch(_unused){canvas=document.createElement("canvas");}var context=canvas.getContext("2d");textContext={canvas:canvas,context:context};TextUtils._textContext=textContext;}return textContext;}/**
     * Measure the font.
     * @param fontString - the string of the font
     * @returns the font size info
     */;TextUtils.measureFont=function measureFont(fontString){var fontSizeInfoCache=TextUtils._fontSizeInfoCache;var info=fontSizeInfoCache[fontString];if(info){return info;}info=TextUtils._measureFontOrChar(fontString);fontSizeInfoCache[fontString]=info;return info;}/**
     * Get native font string.
     * @param fontName - The font name
     * @param fontSize - The font size
     * @param style - The font style
     * @returns The native font string
     */;TextUtils.getNativeFontString=function getNativeFontString(fontName,fontSize,style){var str=style&exports.FontStyle.Bold?"bold ":"";style&exports.FontStyle.Italic&&(str+="italic ");// Check if font already contains strings
  if(!/([\"\'])[^\'\"]+\1/.test(fontName)&&TextUtils._genericFontFamilies.indexOf(fontName)==-1){fontName="\""+fontName+"\"";}str+=fontSize+"px "+fontName;return str;};TextUtils.measureChar=function measureChar(char,fontString){return TextUtils._measureFontOrChar(fontString,char);};TextUtils.measureTextWithWrap=function measureTextWithWrap(renderer){var fontSize=renderer.fontSize,fontStyle=renderer.fontStyle;var name=renderer.font.name;var fontString=TextUtils.getNativeFontString(name,fontSize,fontStyle);var charFont=renderer._styleFont;var fontSizeInfo=TextUtils.measureFont(fontString);var subTexts=renderer.text.split(/(?:\r\n|\r|\n)/);var lines=new Array();var lineWidths=new Array();var lineMaxSizes=new Array();var _pixelsPerUnit=Engine._pixelsPerUnit;var lineHeight=fontSizeInfo.size+renderer.lineSpacing*_pixelsPerUnit;var wrapWidth=renderer.width*_pixelsPerUnit;var width=0;for(var i=0,n=subTexts.length;i<n;++i){var subText=subTexts[i];var chars="";var charsWidth=0;var maxAscent=-1;var maxDescent=-1;for(var j=0,m=subText.length;j<m;++j){var char=subText[j];var charInfo=TextUtils._getCharInfo(char,fontString,charFont);var w=charInfo.w,offsetY=charInfo.offsetY;var halfH=charInfo.h*0.5;var ascent=halfH+offsetY;var descent=halfH-offsetY;if(charsWidth+w>wrapWidth){if(charsWidth===0){lines.push(char);lineWidths.push(w);lineMaxSizes.push({ascent:ascent,descent:descent,size:ascent+descent});}else {lines.push(chars);lineWidths.push(charsWidth);lineMaxSizes.push({ascent:maxAscent,descent:maxDescent,size:maxAscent+maxDescent});chars=char;charsWidth=charInfo.xAdvance;maxAscent=ascent;maxDescent=descent;}}else {chars+=char;charsWidth+=charInfo.xAdvance;maxAscent<ascent&&(maxAscent=ascent);maxDescent<descent&&(maxDescent=descent);}}if(charsWidth>0){lines.push(chars);lineWidths.push(charsWidth);lineMaxSizes.push({ascent:maxAscent,descent:maxDescent,size:maxAscent+maxDescent});}}var height=renderer.height*_pixelsPerUnit;if(renderer.overflowMode===exports.OverflowMode.Overflow){height=lineHeight*lines.length;}return {width:width,height:height,lines:lines,lineWidths:lineWidths,lineHeight:lineHeight,lineMaxSizes:lineMaxSizes};};TextUtils.measureTextWithoutWrap=function measureTextWithoutWrap(renderer){var fontSize=renderer.fontSize,fontStyle=renderer.fontStyle;var name=renderer.font.name;var fontString=TextUtils.getNativeFontString(name,fontSize,fontStyle);var charFont=renderer._styleFont;var fontSizeInfo=TextUtils.measureFont(fontString);var lines=renderer.text.split(/(?:\r\n|\r|\n)/);var lineCount=lines.length;var lineWidths=new Array();var lineMaxSizes=new Array();var _pixelsPerUnit=Engine._pixelsPerUnit;var lineHeight=fontSizeInfo.size+renderer.lineSpacing*_pixelsPerUnit;var width=0;var height=renderer.height*_pixelsPerUnit;if(renderer.overflowMode===exports.OverflowMode.Overflow){height=lineHeight*lineCount;}for(var i=0;i<lineCount;++i){var line=lines[i];var curWidth=0;var maxAscent=-1;var maxDescent=-1;for(var j=0,m=line.length;j<m;++j){var charInfo=TextUtils._getCharInfo(line[j],fontString,charFont);curWidth+=charInfo.xAdvance;var offsetY=charInfo.offsetY;var halfH=charInfo.h*0.5;var ascent=halfH+offsetY;var descent=halfH-offsetY;maxAscent<ascent&&(maxAscent=ascent);maxDescent<descent&&(maxDescent=descent);}lineWidths[i]=curWidth;lineMaxSizes[i]={ascent:maxAscent,descent:maxDescent,size:maxAscent+maxDescent};if(curWidth>width){width=curWidth;}}return {width:width,height:height,lines:lines,lineWidths:lineWidths,lineHeight:lineHeight,lineMaxSizes:lineMaxSizes};}/**
     * Get native font hash.
     * @param fontName - The font name
     * @param fontSize - The font size
     * @param style - The font style
     * @returns The native font hash
     */;TextUtils.getNativeFontHash=function getNativeFontHash(fontName,fontSize,style){var str=style&exports.FontStyle.Bold?"bold":"";style&exports.FontStyle.Italic&&(str+="italic");// Check if font already contains strings
  if(!/([\"\'])[^\'\"]+\1/.test(fontName)&&TextUtils._genericFontFamilies.indexOf(fontName)==-1){fontName=""+fontName;}str+=fontSize+"px"+fontName;return str;};TextUtils._measureFontOrChar=function _measureFontOrChar(fontString,char){if(char===void 0){char="";}var _TextUtils$textContex=TextUtils.textContext(),canvas=_TextUtils$textContex.canvas,context=_TextUtils$textContex.context;context.font=fontString;var measureString=char||TextUtils._measureString;// Safari gets data confusion through getImageData when the canvas width is not an integer.
  // @todo: Text layout may vary from standard.
  var width=Math.round(context.measureText(measureString).width);var baseline=Math.ceil(context.measureText(TextUtils._measureBaseline).width);var height=baseline*TextUtils._heightMultiplier;baseline=TextUtils._baselineMultiplier*baseline|0;canvas.width=width;canvas.height=height;context.font=fontString;context.fillStyle="#000";context.clearRect(0,0,width,height);context.textBaseline="middle";context.fillStyle="#fff";context.fillText(measureString,0,baseline);var colorData=context.getImageData(0,0,width,height).data;var len=colorData.length;var top=-1;var bottom=-1;var y;var ascent=0;var descent=0;var size=0;var integerW=canvas.width;var integerWReciprocal=1.0/integerW;for(var i=0;i<len;i+=4){if(colorData[i+3]!==0){var idx=i*0.25;y=~~(idx*integerWReciprocal);if(top===-1){top=y;}if(y>bottom){bottom=y;}}}if(top!==-1&&bottom!==-1){ascent=baseline-top;descent=bottom-baseline+1;size=ascent+descent;}var sizeInfo={ascent:ascent,descent:descent,size:size};if(char){var data=null;if(size>0){var lineIntegerW=integerW*4;// gl.texSubImage2D uploading data of type Uint8ClampedArray is not supported in some devices(eg: IphoneX IOS 13.6.1).
  data=new Uint8Array(colorData.buffer,top*lineIntegerW,size*lineIntegerW);}return {x:0,y:0,w:width,h:size,offsetX:0,offsetY:(ascent-descent)*0.5,xAdvance:width,uvs:[new Vector2(),new Vector2(),new Vector2(),new Vector2()],ascent:ascent,descent:descent,index:0,data:data};}else {return sizeInfo;}};TextUtils._getCharInfo=function _getCharInfo(char,fontString,font){var charInfo=font._getCharInfo(char);if(!charInfo){charInfo=TextUtils.measureChar(char,fontString);font._uploadCharTexture(charInfo);font._addCharInfo(char,charInfo);}return charInfo;};return TextUtils;}();/**
   * @internal
   * TextContext.
   */TextUtils._genericFontFamilies=["serif","sans-serif","monospace","cursive","fantasy","system-ui","math","emoji","fangsong"];TextUtils._measureString="|Ã‰qÃ…";TextUtils._measureBaseline="M";TextUtils._heightMultiplier=2;TextUtils._baselineMultiplier=1.4;TextUtils._fontSizeInfoCache={};TextUtils._textContext=null;var _class$1$1,_descriptor$1,_descriptor2$1,_descriptor3$1,_descriptor4$1,_descriptor5$1,_descriptor6$1,_descriptor7$1,_descriptor8$1,_descriptor9$1,_descriptor10,_descriptor11,_descriptor12,_descriptor13,_descriptor14,_descriptor15,_descriptor16,_descriptor17,_descriptor18,_descriptor19,_class2$1$1;/**
   * Renders a text for 2D graphics.
   */var TextRenderer=(_class$1$1=(_class2$1$1=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(TextRenderer,_Renderer);function TextRenderer(entity){var _this;_this=_Renderer.call(this,entity)||this;_initializerDefineProperty(_this,"_styleFont",_descriptor$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_charRenderDatas",_descriptor2$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_dirtyFlag",_descriptor3$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_isWorldMatrixDirty",_descriptor4$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_color",_descriptor5$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_text",_descriptor6$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_width",_descriptor7$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_height",_descriptor8$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_localBounds",_descriptor9$1,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_font",_descriptor10,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_fontSize",_descriptor11,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_fontStyle",_descriptor12,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_lineSpacing",_descriptor13,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_horizontalAlignment",_descriptor14,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_verticalAlignment",_descriptor15,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_enableWrapping",_descriptor16,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_overflowMode",_descriptor17,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_maskInteraction",_descriptor18,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_maskLayer",_descriptor19,_assertThisInitialized(_this));var _assertThisInitialize=_assertThisInitialized(_this),engine=_assertThisInitialize.engine;_this._isWorldMatrixDirty=entity.transform._registerWorldChangeListener();_this._isWorldMatrixDirty.listener=function(){_this._setDirtyFlagTrue(DirtyFlag.WorldPosition|DirtyFlag.WorldBounds);};_this.font=Font.createFromOS(engine);_this.setMaterial(engine._spriteDefaultMaterial);return _this;}/**
     * @internal
     */var _proto=TextRenderer.prototype;_proto._render=function _render(camera){if(this._text===""||this.enableWrapping&&this.width<=0||this.overflowMode===exports.OverflowMode.Truncate&&this.height<=0){return;}if(this._isContainDirtyFlag(DirtyFlag.MaskInteraction)){this._updateStencilState();this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);}if(this._isContainDirtyFlag(DirtyFlag.StyleFont)){this._resetStyleFont();this._setDirtyFlagFalse(DirtyFlag.StyleFont);}if(this._isContainDirtyFlag(DirtyFlag.LocalPositionBounds)){this._updateLocalData();this._setDirtyFlagFalse(DirtyFlag.LocalPositionBounds);}if(this._isContainDirtyFlag(DirtyFlag.WorldPosition)){this._updatePosition();this._setDirtyFlagFalse(DirtyFlag.WorldPosition);}var spriteElementPool=this._engine._spriteElementPool;var textElement=this._engine._textElementPool.getFromPool();var charElements=textElement.charElements;var material=this.getMaterial();var charRenderDatas=this._charRenderDatas;var charCount=charRenderDatas.length;textElement.component=this;textElement.material=material;charElements.length=charCount;for(var i=0;i<charCount;++i){var charRenderData=charRenderDatas[i];var spriteElement=spriteElementPool.getFromPool();spriteElement.setValue(this,charRenderData.renderData,material,charRenderData.texture);charElements[i]=spriteElement;}camera._renderPipeline.pushPrimitive(textElement);}/**
     * @internal
     */;_proto._onDestroy=function _onDestroy(){// Clear render data.
  var charRenderDatas=this._charRenderDatas;for(var i=0,n=charRenderDatas.length;i<n;++i){TextRenderer._charRenderDataPool.put(charRenderDatas[i]);}charRenderDatas.length=0;this._isWorldMatrixDirty.destroy();_Renderer.prototype._onDestroy.call(this);}/**
     * @internal
     */;_proto._cloneTo=function _cloneTo(target){target.font=this._font;}/**
     * @internal
     */;_proto._isContainDirtyFlag=function _isContainDirtyFlag(type){return (this._dirtyFlag&type)!=0;}/**
     * @internal
     */;_proto._setDirtyFlagTrue=function _setDirtyFlagTrue(type){this._dirtyFlag|=type;}/**
     * @internal
     */;_proto._setDirtyFlagFalse=function _setDirtyFlagFalse(type){this._dirtyFlag&=~type;}/**
     * @override
     */;_proto._updateBounds=function _updateBounds(worldBounds){BoundingBox.transform(this._localBounds,this._entity.transform.worldMatrix,worldBounds);};_proto._updateStencilState=function _updateStencilState(){// Update stencil.
  var material=this.getInstanceMaterial();var stencilState=material.renderState.stencilState;var maskInteraction=this._maskInteraction;if(maskInteraction===exports.SpriteMaskInteraction.None){stencilState.enabled=false;stencilState.writeMask=0xff;stencilState.referenceValue=0;stencilState.compareFunctionFront=stencilState.compareFunctionBack=exports.CompareFunction.Always;}else {stencilState.enabled=true;stencilState.writeMask=0x00;stencilState.referenceValue=1;var compare=maskInteraction===exports.SpriteMaskInteraction.VisibleInsideMask?exports.CompareFunction.LessEqual:exports.CompareFunction.Greater;stencilState.compareFunctionFront=compare;stencilState.compareFunctionBack=compare;}};_proto._resetStyleFont=function _resetStyleFont(){var lastStyleFont=this._styleFont;if(lastStyleFont){lastStyleFont._addRefCount(-1);lastStyleFont.destroy();}this._styleFont=Font.createFromOS(this.engine,TextUtils.getNativeFontHash(this.font.name,this.fontSize,this.fontStyle));this._styleFont._addRefCount(1);};_proto._updatePosition=function _updatePosition(){var transform=this.entity.transform;var e=transform.worldMatrix.elements;var charRenderDatas=this._charRenderDatas;// prettier-ignore
  var e0=e[0],e1=e[1],e2=e[2];// prettier-ignore
  var e4=e[4],e5=e[5],e6=e[6];// prettier-ignore
  var e12=e[12],e13=e[13],e14=e[14];var up=TextRenderer._tempVec31.set(e4,e5,e6);var right=TextRenderer._tempVec30.set(e0,e1,e2);for(var i=0,n=charRenderDatas.length;i<n;++i){var charRenderData=charRenderDatas[i];var localPositions=charRenderData.localPositions;var positions=charRenderData.renderData.positions;var topLeftX=localPositions.x,topLeftY=localPositions.y;// Top-Left
  var worldPosition0=positions[0];worldPosition0.x=topLeftX*e0+topLeftY*e4+e12;worldPosition0.y=topLeftX*e1+topLeftY*e5+e13;worldPosition0.z=topLeftX*e2+topLeftY*e6+e14;// Right offset
  var worldPosition1=positions[1];Vector3.scale(right,localPositions.z-topLeftX,worldPosition1);// Top-Right
  Vector3.add(worldPosition0,worldPosition1,worldPosition1);// Up offset
  var worldPosition2=positions[2];Vector3.scale(up,localPositions.w-topLeftY,worldPosition2);// Bottom-Left
  Vector3.add(worldPosition0,worldPosition2,positions[3]);// Bottom-Right
  Vector3.add(worldPosition1,worldPosition2,worldPosition2);}};_proto._updateLocalData=function _updateLocalData(){var color=this.color,horizontalAlignment=this.horizontalAlignment,verticalAlignment=this.verticalAlignment,charRenderDatas=this._charRenderDatas;var _this$_localBounds=this._localBounds,min=_this$_localBounds.min,max=_this$_localBounds.max;min.set(0,0,0);max.set(0,0,0);var _pixelsPerUnit=Engine._pixelsPerUnit;var pixelsPerUnitReciprocal=1.0/_pixelsPerUnit;var charFont=this._styleFont;var rendererWidth=this.width*_pixelsPerUnit;var halfRendererWidth=rendererWidth*0.5;var rendererHeight=this.height*_pixelsPerUnit;var textMetrics=this.enableWrapping?TextUtils.measureTextWithWrap(this):TextUtils.measureTextWithoutWrap(this);var height=textMetrics.height,lines=textMetrics.lines,lineWidths=textMetrics.lineWidths,lineHeight=textMetrics.lineHeight,lineMaxSizes=textMetrics.lineMaxSizes;var charRenderDataPool=TextRenderer._charRenderDataPool;var halfLineHeight=lineHeight*0.5;var linesLen=lines.length;var startY=0;var topDiff=lineHeight*0.5-lineMaxSizes[0].ascent;var bottomDiff=lineHeight*0.5-lineMaxSizes[linesLen-1].descent-1;switch(verticalAlignment){case exports.TextVerticalAlignment.Top:startY=rendererHeight*0.5-halfLineHeight+topDiff;break;case exports.TextVerticalAlignment.Center:startY=height*0.5-halfLineHeight-(bottomDiff-topDiff)*0.5;break;case exports.TextVerticalAlignment.Bottom:startY=height-rendererHeight*0.5-halfLineHeight-bottomDiff;break;}var renderDataCount=0;var minX=Number.MAX_SAFE_INTEGER;var minY=Number.MAX_SAFE_INTEGER;var maxX=Number.MIN_SAFE_INTEGER;var maxY=Number.MIN_SAFE_INTEGER;var lastLineIndex=linesLen-1;for(var i=0;i<linesLen;++i){var line=lines[i];var lineWidth=lineWidths[i];var startX=0;switch(horizontalAlignment){case exports.TextHorizontalAlignment.Left:startX=-halfRendererWidth;break;case exports.TextHorizontalAlignment.Center:startX=-lineWidth*0.5;break;case exports.TextHorizontalAlignment.Right:startX=halfRendererWidth-lineWidth;break;}for(var j=0,m=line.length-1;j<=m;++j){var char=line[j];var charInfo=charFont._getCharInfo(char);if(charInfo.h>0){var charRenderData=charRenderDatas[renderDataCount]||charRenderDataPool.get();var renderData=charRenderData.renderData,localPositions=charRenderData.localPositions;charRenderData.texture=charFont._getTextureByIndex(charInfo.index);renderData.color=color;renderData.uvs=charInfo.uvs;var w=charInfo.w,ascent=charInfo.ascent,descent=charInfo.descent;var left=startX*pixelsPerUnitReciprocal;var right=(startX+w)*pixelsPerUnitReciprocal;var top=(startY+ascent)*pixelsPerUnitReciprocal;var bottom=(startY-descent+1)*pixelsPerUnitReciprocal;localPositions.set(left,top,right,bottom);charRenderDatas[renderDataCount]=charRenderData;renderDataCount++;i===0&&(maxY=Math.max(maxY,top));i===lastLineIndex&&(minY=Math.min(minY,bottom));j===0&&(minX=Math.min(minX,left));j===m&&(maxX=Math.max(maxX,right));}startX+=charInfo.xAdvance;}startY-=lineHeight;}min.set(minX,minY,0);max.set(maxX,maxY,0);// Revert excess render data to pool.
  var lastRenderDataCount=charRenderDatas.length;if(lastRenderDataCount>renderDataCount){for(var _i=renderDataCount;_i<lastRenderDataCount;++_i){charRenderDataPool.put(charRenderDatas[_i]);}charRenderDatas.length=renderDataCount;}charFont._getLastIndex()>0&&charRenderDatas.sort(function(a,b){return a.texture.instanceId-b.texture.instanceId;});};_createClass$3(TextRenderer,[{key:"color",get:/** @internal */ /** @internal */ /** @internal */ /**
       * Rendering color for the Text.
       */function get(){return this._color;},set:function set(value){if(this._color!==value){this._color.copyFrom(value);}}/**
       * Rendering string for the Text.
       */},{key:"text",get:function get(){return this._text;},set:function set(value){value=value||"";if(this._text!==value){this._text=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * The width of the TextRenderer (in 3D world coordinates).
       */},{key:"width",get:function get(){return this._width;},set:function set(value){if(this._width!==value){this._width=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * The height of the TextRenderer (in 3D world coordinates).
       */},{key:"height",get:function get(){return this._height;},set:function set(value){if(this._height!==value){this._height=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * The font of the Text.
       */},{key:"font",get:function get(){return this._font;},set:function set(value){if(this._font!==value){this._font=value;this._setDirtyFlagTrue(DirtyFlag.Font);}}/**
       * The font size of the Text.
       */},{key:"fontSize",get:function get(){return this._fontSize;},set:function set(value){if(this._fontSize!==value){this._fontSize=value;this._setDirtyFlagTrue(DirtyFlag.Font);}}/**
       * The style of the font.
       */},{key:"fontStyle",get:function get(){return this._fontStyle;},set:function set(value){if(this.fontStyle!==value){this._fontStyle=value;this._setDirtyFlagTrue(DirtyFlag.Font);}}/**
       * The space between two lines (in pixels).
       */},{key:"lineSpacing",get:function get(){return this._lineSpacing;},set:function set(value){if(this._lineSpacing!==value){this._lineSpacing=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * The horizontal alignment.
       */},{key:"horizontalAlignment",get:function get(){return this._horizontalAlignment;},set:function set(value){if(this._horizontalAlignment!==value){this._horizontalAlignment=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * The vertical alignment.
       */},{key:"verticalAlignment",get:function get(){return this._verticalAlignment;},set:function set(value){if(this._verticalAlignment!==value){this._verticalAlignment=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * Whether wrap text to next line when exceeds the width of the container.
       */},{key:"enableWrapping",get:function get(){return this._enableWrapping;},set:function set(value){if(this._enableWrapping!==value){this._enableWrapping=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * The overflow mode.
       */},{key:"overflowMode",get:function get(){return this._overflowMode;},set:function set(value){if(this._overflowMode!==value){this._overflowMode=value;this._setDirtyFlagTrue(DirtyFlag.Position);}}/**
       * Interacts with the masks.
       */},{key:"maskInteraction",get:function get(){return this._maskInteraction;},set:function set(value){if(this._maskInteraction!==value){this._maskInteraction=value;this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);}}/**
       * The mask layer the sprite renderer belongs to.
       */},{key:"maskLayer",get:function get(){return this._maskLayer;},set:function set(value){this._maskLayer=value;}/**
       * The bounding volume of the TextRenderer.
       */},{key:"bounds",get:function get(){this._isContainDirtyFlag(DirtyFlag.StyleFont)&&this._resetStyleFont();this._isContainDirtyFlag(DirtyFlag.LocalPositionBounds)&&this._updateLocalData();this._isContainDirtyFlag(DirtyFlag.WorldPosition)&&this._updatePosition();this._isContainDirtyFlag(DirtyFlag.WorldBounds)&&this._updateBounds(this._bounds);this._setDirtyFlagFalse(DirtyFlag.Font);return this._bounds;}}]);return TextRenderer;}(Renderer),_class2$1$1._charRenderDataPool=new CharRenderDataPool(CharRenderData,50),_class2$1$1._tempVec30=new Vector3(),_class2$1$1._tempVec31=new Vector3(),_class2$1$1),(_descriptor$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_styleFont",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor2$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_charRenderDatas",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor3$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_dirtyFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return DirtyFlag.Font;}}),_descriptor4$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_isWorldMatrixDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor5$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_color",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Color(1,1,1,1);}}),_descriptor6$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_text",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return "";}}),_descriptor7$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_width",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}}),_descriptor8$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_height",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}}),_descriptor9$1=_applyDecoratedDescriptor(_class$1$1.prototype,"_localBounds",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new BoundingBox();}}),_descriptor10=_applyDecoratedDescriptor(_class$1$1.prototype,"_font",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor11=_applyDecoratedDescriptor(_class$1$1.prototype,"_fontSize",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 24;}}),_descriptor12=_applyDecoratedDescriptor(_class$1$1.prototype,"_fontStyle",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.FontStyle.None;}}),_descriptor13=_applyDecoratedDescriptor(_class$1$1.prototype,"_lineSpacing",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}}),_descriptor14=_applyDecoratedDescriptor(_class$1$1.prototype,"_horizontalAlignment",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.TextHorizontalAlignment.Center;}}),_descriptor15=_applyDecoratedDescriptor(_class$1$1.prototype,"_verticalAlignment",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.TextVerticalAlignment.Center;}}),_descriptor16=_applyDecoratedDescriptor(_class$1$1.prototype,"_enableWrapping",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor17=_applyDecoratedDescriptor(_class$1$1.prototype,"_overflowMode",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.OverflowMode.Overflow;}}),_descriptor18=_applyDecoratedDescriptor(_class$1$1.prototype,"_maskInteraction",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskInteraction.None;}}),_descriptor19=_applyDecoratedDescriptor(_class$1$1.prototype,"_maskLayer",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskLayer.Layer0;}})),_class$1$1);var DirtyFlag;(function(DirtyFlag){DirtyFlag[DirtyFlag["StyleFont"]=1]="StyleFont";DirtyFlag[DirtyFlag["LocalPositionBounds"]=2]="LocalPositionBounds";DirtyFlag[DirtyFlag["WorldPosition"]=4]="WorldPosition";DirtyFlag[DirtyFlag["WorldBounds"]=8]="WorldBounds";DirtyFlag[DirtyFlag["MaskInteraction"]=16]="MaskInteraction";DirtyFlag[DirtyFlag["Position"]=14]="Position";DirtyFlag[DirtyFlag["Font"]=15]="Font";})(DirtyFlag||(DirtyFlag={}));/**
   * Associate AnimationCurve and the Entity
   */var AnimationClipCurveBinding=function AnimationClipCurveBinding(){this.relativePath=void 0;this.type=void 0;this.property=void 0;this.curve=void 0;};/**
   * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
   */var AnimationEvent=function AnimationEvent(){this.time=void 0;this.functionName=void 0;this.parameter=void 0;};exports.AnimationProperty = void 0;(function(AnimationProperty){AnimationProperty[AnimationProperty["Position"]=0]="Position";AnimationProperty[AnimationProperty["Rotation"]=1]="Rotation";AnimationProperty[AnimationProperty["Scale"]=2]="Scale";AnimationProperty[AnimationProperty["BlendShapeWeights"]=3]="BlendShapeWeights";})(exports.AnimationProperty||(exports.AnimationProperty={}));/**
   * Base class for AnimationClips and BlendTrees.
   */var Motion=function Motion(){};/**
   * Stores keyframe based animations.
   */var AnimationClip=/*#__PURE__*/function(_Motion){_inheritsLoose$2(AnimationClip,_Motion);/**
     * @param name - The AnimationClip's name
     */function AnimationClip(name){var _this;_this=_Motion.call(this)||this;_this.name=name;_this._curveBindings=[];_this._length=0;_this._events=[];return _this;}/**
     * Adds an animation event to the clip.
     * @param functionName - The name of the method called in the script
     * @param time - The time when the event be triggered
     * @param parameter - The parameter that is stored in the event and will be sent to the function
     */var _proto=AnimationClip.prototype;_proto.addEvent=function addEvent(param,time,parameter){if(typeof param==="string"){var _event=new AnimationEvent();_event.functionName=param;_event.time=time;_event.parameter=parameter;this._events.push(_event);}else {this._events.push(param);}this._events.sort(function(a,b){return a.time-b.time;});}/**
     * Clears all events from the clip.
     */;_proto.clearEvents=function clearEvents(){this._events.length=0;}/**
     * Add curve binding for the clip.
     * @param relativePath - Path to the game object this curve applies to. The relativePath is formatted similar to a pathname, e.g. "/root/spine/leftArm"
     * @param type- The class type of the component that is animated
     * @param propertyName - The name to the property being animated
     * @param curve - The animation curve
     */;_proto.addCurveBinding=function addCurveBinding(relativePath,type,propertyName,curve){var property;switch(propertyName){case"position":property=exports.AnimationProperty.Position;break;case"rotation":property=exports.AnimationProperty.Rotation;break;case"scale":property=exports.AnimationProperty.Scale;break;case"blendShapeWeights":property=exports.AnimationProperty.BlendShapeWeights;break;}var curveBinding=new AnimationClipCurveBinding();curveBinding.relativePath=relativePath;curveBinding.type=type;curveBinding.property=property;curveBinding.curve=curve;if(curve.length>this._length){this._length=curve.length;}this._curveBindings.push(curveBinding);}/**
     * Clears all curve bindings from the clip.
     */;_proto.clearCurveBindings=function clearCurveBindings(){this._curveBindings.length=0;this._length=0;}/**
     * @internal
     * Samples an animation at a given time.
     * @param entity - The animated entity
     * @param time - The time to sample an animation
     */;_proto._sampleAnimation=function _sampleAnimation(entity,time){var length=this._curveBindings.length;for(var i=length-1;i>=0;i--){var curveData=this._curveBindings[i];var curve=curveData.curve,property=curveData.property,relativePath=curveData.relativePath,type=curveData.type;var val=curve.evaluate(time);var target=entity.findByName(relativePath);var transform=target.transform;if(type===Transform){switch(property){case exports.AnimationProperty.Position:transform.position=val;break;case exports.AnimationProperty.Rotation:transform.rotationQuaternion=val;break;case exports.AnimationProperty.Scale:transform.scale=val;break;}}}};_createClass$3(AnimationClip,[{key:"events",get:/** @internal */ /**
       * Animation events for this animation clip.
       */function get(){return this._events;}/**
       * Animation curve bindings for this animation clip.
       */},{key:"curveBindings",get:function get(){return this._curveBindings;}/**
       * Animation length in seconds.
       */},{key:"length",get:function get(){return this._length;}}]);return AnimationClip;}(Motion);exports.InterpolableValueType = void 0;(function(InterpolableValueType){InterpolableValueType[InterpolableValueType["Float"]=0]="Float";InterpolableValueType[InterpolableValueType["FloatArray"]=1]="FloatArray";InterpolableValueType[InterpolableValueType["Vector2"]=2]="Vector2";InterpolableValueType[InterpolableValueType["Vector3"]=3]="Vector3";InterpolableValueType[InterpolableValueType["Vector4"]=4]="Vector4";InterpolableValueType[InterpolableValueType["Quaternion"]=5]="Quaternion";})(exports.InterpolableValueType||(exports.InterpolableValueType={}));/**
   * @internal
   */var AnimatorUtils=/*#__PURE__*/function(){function AnimatorUtils(){}AnimatorUtils.scaleWeight=function scaleWeight(s,w,out){var sX=s.x;var sY=s.y;var sZ=s.z;out.x=sX>0?Math.pow(Math.abs(sX),w):-Math.pow(Math.abs(sX),w);out.y=sY>0?Math.pow(Math.abs(sY),w):-Math.pow(Math.abs(sY),w);out.z=sZ>0?Math.pow(Math.abs(sZ),w):-Math.pow(Math.abs(sZ),w);};AnimatorUtils.scaleBlend=function scaleBlend(sa,sb,w,out){var saw=AnimatorUtils._tempVector30;var sbw=AnimatorUtils._tempVector31;AnimatorUtils.scaleWeight(sa,1.0-w,saw);AnimatorUtils.scaleWeight(sb,w,sbw);var sng=w>0.5?sb:sa;out.x=sng.x>0?Math.abs(saw.x*sbw.x):-Math.abs(saw.x*sbw.x);out.y=sng.y>0?Math.abs(saw.y*sbw.y):-Math.abs(saw.y*sbw.y);out.z=sng.z>0?Math.abs(saw.z*sbw.z):-Math.abs(saw.z*sbw.z);};AnimatorUtils.quaternionWeight=function quaternionWeight(s,w,out){out.x=s.x*w;out.y=s.y*w;out.z=s.z*w;out.w=s.w;};return AnimatorUtils;}();AnimatorUtils._tempVector30=new Vector3();AnimatorUtils._tempVector31=new Vector3();exports.AnimatorLayerBlendingMode = void 0;(function(AnimatorLayerBlendingMode){AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"]=0]="Override";AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"]=1]="Additive";})(exports.AnimatorLayerBlendingMode||(exports.AnimatorLayerBlendingMode={}));/**
   * @internal
   */var AnimatorStatePlayState;(function(AnimatorStatePlayState){AnimatorStatePlayState[AnimatorStatePlayState["UnStarted"]=0]="UnStarted";AnimatorStatePlayState[AnimatorStatePlayState["Playing"]=1]="Playing";AnimatorStatePlayState[AnimatorStatePlayState["Finished"]=2]="Finished";})(AnimatorStatePlayState||(AnimatorStatePlayState={}));/**
   * Layer state.
   */var LayerState;(function(LayerState){LayerState[LayerState["Standby"]=0]="Standby";LayerState[LayerState["Playing"]=1]="Playing";LayerState[LayerState["CrossFading"]=2]="CrossFading";LayerState[LayerState["FixedCrossFading"]=3]="FixedCrossFading";})(LayerState||(LayerState={}));/**
   * @internal
   */var AnimationCurveOwner=/*#__PURE__*/function(){/** @internal */function AnimationCurveOwner(target,type,property){this.crossCurveMark=0;this.crossCurveIndex=void 0;this.target=void 0;this.type=void 0;this.property=void 0;this.component=void 0;this.defaultValue=void 0;this.fixedPoseValue=void 0;this._hasSavedDefaultValue=false;this.target=target;this.type=type;this.property=property;switch(property){case exports.AnimationProperty.Position:this.defaultValue=new Vector3();this.fixedPoseValue=new Vector3();this.component=target.transform;break;case exports.AnimationProperty.Rotation:this.defaultValue=new Quaternion();this.fixedPoseValue=new Quaternion();this.component=target.transform;break;case exports.AnimationProperty.Scale:this.defaultValue=new Vector3();this.fixedPoseValue=new Vector3();this.component=target.transform;break;case exports.AnimationProperty.BlendShapeWeights:this.component=target.getComponent(SkinnedMeshRenderer);var weightLength=this.component.blendShapeWeights.length;this.defaultValue=new Float32Array(weightLength);this.fixedPoseValue=new Float32Array(weightLength);break;}}var _proto=AnimationCurveOwner.prototype;_proto.saveDefaultValue=function saveDefaultValue(){switch(this.property){case exports.AnimationProperty.Position:this.defaultValue.copyFrom(this.target.transform.position);break;case exports.AnimationProperty.Rotation:this.defaultValue.copyFrom(this.target.transform.rotationQuaternion);break;case exports.AnimationProperty.Scale:this.defaultValue.copyFrom(this.target.transform.scale);break;case exports.AnimationProperty.BlendShapeWeights:var _ref=this.component,blendShapeWeights=_ref.blendShapeWeights;for(var i=0,length=blendShapeWeights.length;i<length;++i){this.defaultValue[i]=blendShapeWeights[i];}break;}this._hasSavedDefaultValue=true;};_proto.saveFixedPoseValue=function saveFixedPoseValue(){switch(this.property){case exports.AnimationProperty.Position:this.fixedPoseValue.copyFrom(this.target.transform.position);break;case exports.AnimationProperty.Rotation:this.fixedPoseValue.copyFrom(this.target.transform.rotationQuaternion);break;case exports.AnimationProperty.Scale:this.fixedPoseValue.copyFrom(this.target.transform.scale);break;case exports.AnimationProperty.BlendShapeWeights:var _ref2=this.component,blendShapeWeights=_ref2.blendShapeWeights;for(var i=0,length=blendShapeWeights.length;i<length;++i){this.fixedPoseValue[i]=this.component.blendShapeWeights[i];}break;}};return AnimationCurveOwner;}();/**
   * @internal
   */var AnimationEventHandler=function AnimationEventHandler(){this.event=void 0;this.handlers=[];};/**
   * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.
   */var AnimatorStateTransition=function AnimatorStateTransition(){this.duration=0;this.offset=0;this.exitTime=1;this.destinationState=void 0;};/**
   * Animation wrap mode.
   */exports.WrapMode = void 0;(function(WrapMode){WrapMode[WrapMode["Once"]=0]="Once";WrapMode[WrapMode["Loop"]=1]="Loop";})(exports.WrapMode||(exports.WrapMode={}));/**
   * @internal
   */var AnimatorStatePlayData=/*#__PURE__*/function(){function AnimatorStatePlayData(){this.state=void 0;this.stateData=void 0;this.frameTime=void 0;this.playState=void 0;this.clipTime=void 0;this.currentEventIndex=void 0;}var _proto=AnimatorStatePlayData.prototype;_proto.reset=function reset(state,stateData,offsetFrameTime){this.state=state;this.frameTime=offsetFrameTime;this.stateData=stateData;this.playState=AnimatorStatePlayState.UnStarted;this.clipTime=state.clipStartTime*state.clip.length;this.currentEventIndex=0;};_proto.update=function update(isBackwards){var state=this.state;var time=this.frameTime;var duration=state._getDuration();this.playState=AnimatorStatePlayState.Playing;if(state.wrapMode===exports.WrapMode.Loop){time=duration?time%duration:0;}else {if(Math.abs(time)>duration){time=time<0?-duration:duration;this.playState=AnimatorStatePlayState.Finished;}}if(isBackwards&&time===0){this.clipTime=state.clipEndTime*state.clip.length;}else {time<0&&(time+=duration);this.clipTime=time+state.clipStartTime*state.clip.length;}};return AnimatorStatePlayData;}();/**
   * @internal
   */var AnimatorLayerData=/*#__PURE__*/function(){function AnimatorLayerData(){this.animatorStateDataMap={};this.srcPlayData=new AnimatorStatePlayData();this.destPlayData=new AnimatorStatePlayData();this.layerState=LayerState.Standby;this.crossCurveMark=0;this.manuallyTransition=new AnimatorStateTransition();this.crossFadeTransition=void 0;}var _proto=AnimatorLayerData.prototype;_proto.switchPlayData=function switchPlayData(){var srcPlayData=this.destPlayData;var switchTemp=this.srcPlayData;this.srcPlayData=srcPlayData;this.destPlayData=switchTemp;};return AnimatorLayerData;}();/**
   * @internal
   */var AnimatorStateData=function AnimatorStateData(){this.curveOwners=[];this.eventHandlers=[];};/**
   * @internal
   */var AnimatorStateInfo=function AnimatorStateInfo(){this.layerIndex=void 0;this.state=void 0;};/**
   * @internal
   */var CrossCurveData=function CrossCurveData(){this.curveOwner=void 0;this.srcCurveIndex=void 0;this.destCurveIndex=void 0;};/**
   * @internal
   */var AnimatorTempValue=/*#__PURE__*/function(){function AnimatorTempValue(){this.vector2=new Vector2();this.vector3=new Vector3();this.vector4=new Vector4();this.quaternion=new Quaternion();this._floatArrayPool=[];}var _proto=AnimatorTempValue.prototype;_proto.getFloatArray=function getFloatArray(length){var floatArray=this._floatArrayPool[length];if(!floatArray){this._floatArrayPool[length]=floatArray=new Float32Array(length);}return floatArray;};return AnimatorTempValue;}();var _class$s,_descriptor,_descriptor2,_descriptor3,_descriptor4,_descriptor5,_descriptor6,_descriptor7,_descriptor8,_descriptor9,_class2$d;/**
   * The controller of the animation system.
   */var Animator=(_class$s=(_class2$d=/*#__PURE__*/function(_Component){_inheritsLoose$2(Animator,_Component);/**
     * @internal
     */function Animator(entity){var _this;_this=_Component.call(this,entity)||this;_this._animatorController=void 0;_initializerDefineProperty(_this,"_speed",_descriptor,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_controllerUpdateFlag",_descriptor2,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_animatorLayersData",_descriptor3,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_crossCurveDataCollection",_descriptor4,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_animationCurveOwners",_descriptor5,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_crossCurveDataPool",_descriptor6,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_animationEventHandlerPool",_descriptor7,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_baseTempValue",_descriptor8,_assertThisInitialized(_this));_initializerDefineProperty(_this,"_crossTempValue",_descriptor9,_assertThisInitialized(_this));return _this;}/**
     * Play a state by name.
     * @param stateName - The state name
     * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
     * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
     */var _proto=Animator.prototype;_proto.play=function play(stateName,layerIndex,normalizedTimeOffset){var _this$_controllerUpda;if(layerIndex===void 0){layerIndex=-1;}if(normalizedTimeOffset===void 0){normalizedTimeOffset=0;}if((_this$_controllerUpda=this._controllerUpdateFlag)!==null&&_this$_controllerUpda!==void 0&&_this$_controllerUpda.flag){this._clearPlayData();}var animatorInfo=this._getAnimatorStateInfo(stateName,layerIndex,Animator._animatorInfo);var state=animatorInfo.state;if(!state){return;}if(!state.clip){console.warn("The state named "+stateName+" has no AnimationClip data.");return;}var animatorLayerData=this._getAnimatorLayerData(animatorInfo.layerIndex);var srcPlayData=animatorLayerData.srcPlayData;var curState=srcPlayData.state;if(curState&&curState!==state){this._revertDefaultValue(srcPlayData.state,srcPlayData.stateData);}//CM: Not consider same stateName, but different animation
  var animatorStateData=this._getAnimatorStateData(stateName,state,animatorLayerData);animatorLayerData.layerState=LayerState.Playing;srcPlayData.reset(state,animatorStateData,state._getDuration()*normalizedTimeOffset);this._saveDefaultValues(animatorStateData);}/**
     * @internal
     */;_proto._reset=function _reset(){var animatorController=this._animatorController;if(animatorController){var layers=animatorController.layers;for(var i=0,n=layers.length;i<n;++i){var states=layers[i].stateMachine.states;var animatorLayerData=this._getAnimatorLayerData(i);for(var j=0,m=states.length;j<m;++j){var state=states[j];var animatorStateData=this._getAnimatorStateData(state.name,state,animatorLayerData);this._revertDefaultValue(state,animatorStateData);}}}this._clearPlayData();}/**
     * Create a cross fade from the current state to another state.
     * @param stateName - The state name
     * @param normalizedTransitionDuration - The duration of the transition (normalized)
     * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
     * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
     */;_proto.crossFade=function crossFade(stateName,normalizedTransitionDuration,layerIndex,normalizedTimeOffset){var _this$_controllerUpda2;if(layerIndex===void 0){layerIndex=-1;}if(normalizedTimeOffset===void 0){normalizedTimeOffset=0;}if((_this$_controllerUpda2=this._controllerUpdateFlag)!==null&&_this$_controllerUpda2!==void 0&&_this$_controllerUpda2.flag){this._clearPlayData();}var _this$_getAnimatorSta=this._getAnimatorStateInfo(stateName,layerIndex,Animator._animatorInfo),state=_this$_getAnimatorSta.state;var _this$_getAnimatorLay=this._getAnimatorLayerData(layerIndex),manuallyTransition=_this$_getAnimatorLay.manuallyTransition;manuallyTransition.duration=normalizedTransitionDuration;manuallyTransition.offset=normalizedTimeOffset;manuallyTransition.destinationState=state;this._crossFadeByTransition(manuallyTransition,layerIndex);}/**
     * Evaluates the animator component based on deltaTime.
     * @param deltaTime - The deltaTime when the animation update
     */;_proto.update=function update(deltaTime){var _this$_controllerUpda3;if(this.speed===0){return;}var animatorController=this._animatorController;if(!animatorController){return;}if((_this$_controllerUpda3=this._controllerUpdateFlag)!==null&&_this$_controllerUpda3!==void 0&&_this$_controllerUpda3.flag){return;}deltaTime*=this.speed;for(var i=0,n=animatorController.layers.length;i<n;i++){var animatorLayerData=this._getAnimatorLayerData(i);if(animatorLayerData.layerState===LayerState.Standby){continue;}this._updateLayer(i,i===0,deltaTime/1000);}}/**
     * Get the playing state from the target layerIndex.
     * @param layerIndex - The layer index
     */;_proto.getCurrentAnimatorState=function getCurrentAnimatorState(layerIndex){var _this$_animatorLayers,_this$_animatorLayers2;return (_this$_animatorLayers=this._animatorLayersData[layerIndex])===null||_this$_animatorLayers===void 0?void 0:(_this$_animatorLayers2=_this$_animatorLayers.srcPlayData)===null||_this$_animatorLayers2===void 0?void 0:_this$_animatorLayers2.state;}/**
     * @override
     * @internal
     */;_proto._onEnable=function _onEnable(){this.engine._componentsManager.addOnUpdateAnimations(this);}/**
     * @override
     * @internal
     */;_proto._onDisable=function _onDisable(){this.engine._componentsManager.removeOnUpdateAnimations(this);};_proto._getAnimatorStateInfo=function _getAnimatorStateInfo(stateName,layerIndex,out){var state=null;var animatorController=this._animatorController;if(animatorController){var layers=animatorController.layers;if(layerIndex===-1){for(var i=0,n=layers.length;i<n;i++){state=layers[i].stateMachine.findStateByName(stateName);if(state){layerIndex=i;break;}}}else {state=layers[layerIndex].stateMachine.findStateByName(stateName);}}out.layerIndex=layerIndex;out.state=state;return out;};_proto._saveDefaultValues=function _saveDefaultValues(stateData){var curveOwners=stateData.curveOwners;for(var i=curveOwners.length-1;i>=0;i--){curveOwners[i].saveDefaultValue();}};_proto._getAnimatorStateData=function _getAnimatorStateData(stateName,animatorState,animatorLayerData){var animatorStateDataCollection=animatorLayerData.animatorStateDataMap;var animatorStateData=animatorStateDataCollection[stateName];if(!animatorStateData){animatorStateData=new AnimatorStateData();animatorStateDataCollection[stateName]=animatorStateData;this._saveAnimatorStateData(animatorState,animatorStateData);this._saveAnimatorEventHandlers(animatorState,animatorStateData);}return animatorStateData;};_proto._saveAnimatorStateData=function _saveAnimatorStateData(animatorState,animatorStateData){var entity=this.entity,animationCureOwners=this._animationCurveOwners;var curveOwners=animatorStateData.curveOwners;var curves=animatorState.clip._curveBindings;for(var i=curves.length-1;i>=0;i--){var curve=curves[i];var targetEntity=curve.relativePath===""?entity:entity.findByPath(curve.relativePath);var property=curve.property;var _targetEntity=targetEntity,instanceId=_targetEntity.instanceId;var propertyOwners=animationCureOwners[instanceId]||(animationCureOwners[instanceId]=[]);curveOwners[i]=propertyOwners[property]||(propertyOwners[property]=new AnimationCurveOwner(targetEntity,curve.type,property));}};_proto._saveAnimatorEventHandlers=function _saveAnimatorEventHandlers(state,animatorStateData){var eventHandlerPool=this._animationEventHandlerPool;var scripts=this._entity._scripts;var scriptCount=scripts.length;var eventHandlers=animatorStateData.eventHandlers;var events=state.clip.events;eventHandlers.length=0;for(var i=0,n=events.length;i<n;i++){var event=events[i];var eventHandler=eventHandlerPool.getFromPool();var funcName=event.functionName;var handlers=eventHandler.handlers;eventHandler.event=event;handlers.length=0;for(var j=scriptCount-1;j>=0;j--){var handler=scripts.get(j)[funcName];handler&&handlers.push(handler);}eventHandlers.push(eventHandler);}};_proto._clearCrossData=function _clearCrossData(animatorLayerData){animatorLayerData.crossCurveMark++;this._crossCurveDataCollection.length=0;this._crossCurveDataPool.resetPool();};_proto._addCrossCurveData=function _addCrossCurveData(crossCurveData,owner,curCurveIndex,nextCurveIndex){var dataItem=this._crossCurveDataPool.getFromPool();dataItem.curveOwner=owner;dataItem.srcCurveIndex=curCurveIndex;dataItem.destCurveIndex=nextCurveIndex;crossCurveData.push(dataItem);};_proto._prepareCrossFading=function _prepareCrossFading(animatorLayerData){var crossCurveData=this._crossCurveDataCollection;var crossCurveMark=animatorLayerData.crossCurveMark;// Add src cross curve data.
  this._prepareSrcCrossData(crossCurveData,animatorLayerData.srcPlayData,crossCurveMark,false);// Add dest cross curve data.
  this._prepareDestCrossData(crossCurveData,animatorLayerData.destPlayData,crossCurveMark,false);};_proto._prepareStandbyCrossFading=function _prepareStandbyCrossFading(animatorLayerData){var crossCurveData=this._crossCurveDataCollection;var srcPlayData=animatorLayerData.srcPlayData,crossCurveMark=animatorLayerData.crossCurveMark;// Standby have two sub state, one is never play, one is finished, never play srcPlayData.state is null.
  srcPlayData.state&&this._prepareSrcCrossData(crossCurveData,srcPlayData,crossCurveMark,true);// Add dest cross curve data.
  this._prepareDestCrossData(crossCurveData,animatorLayerData.destPlayData,crossCurveMark,true);};_proto._prepareFixedPoseCrossFading=function _prepareFixedPoseCrossFading(animatorLayerData){var crossCurveData=this._crossCurveDataCollection;// Save current cross curve data owner fixed pose.
  for(var i=crossCurveData.length-1;i>=0;i--){var item=crossCurveData[i];item.curveOwner.saveFixedPoseValue();// Reset destCurveIndex When fixed pose crossFading again.
  item.destCurveIndex=-1;}// prepare dest AnimatorState cross data.
  this._prepareDestCrossData(crossCurveData,animatorLayerData.destPlayData,animatorLayerData.crossCurveMark,true);};_proto._prepareSrcCrossData=function _prepareSrcCrossData(crossCurveData,srcPlayData,crossCurveMark,saveFixed){var curveOwners=srcPlayData.stateData.curveOwners;for(var i=curveOwners.length-1;i>=0;i--){var owner=curveOwners[i];owner.crossCurveMark=crossCurveMark;owner.crossCurveIndex=crossCurveData.length;saveFixed&&owner.saveFixedPoseValue();this._addCrossCurveData(crossCurveData,owner,i,-1);}};_proto._prepareDestCrossData=function _prepareDestCrossData(crossCurveData,destPlayData,crossCurveMark,saveFixed){var curveOwners=destPlayData.stateData.curveOwners;for(var i=curveOwners.length-1;i>=0;i--){var owner=curveOwners[i];// Not include in previous AnimatorState.
  if(owner.crossCurveMark===crossCurveMark){crossCurveData[owner.crossCurveIndex].destCurveIndex=i;}else {owner.saveDefaultValue();saveFixed&&owner.saveFixedPoseValue();owner.crossCurveMark=crossCurveMark;owner.crossCurveIndex=crossCurveData.length;this._addCrossCurveData(crossCurveData,owner,-1,i);}}};_proto._evaluateCurve=function _evaluateCurve(property,curve,time,additive,tempValue){var baseValue;if(additive){baseValue=curve.keys[0].value;}switch(curve._valueType){case exports.InterpolableValueType.Float:{var value=curve.evaluate(time);if(additive){return value-baseValue;}return value;}case exports.InterpolableValueType.FloatArray:{var _value=tempValue.getFloatArray(curve._valueSize);curve._evaluate(time,_value);if(additive){for(var i=0,n=_value.length;i<n;i++){_value[i]=_value[i]-baseValue[i];}}return _value;}case exports.InterpolableValueType.Vector2:{var _value2=tempValue.vector2;curve._evaluate(time,_value2);if(additive){if(property===exports.AnimationProperty.Scale){Vector2.divide(_value2,baseValue,_value2);}else {Vector2.subtract(_value2,baseValue,_value2);}}return _value2;}case exports.InterpolableValueType.Vector3:{var _value3=tempValue.vector3;curve._evaluate(time,_value3);if(additive){if(property===exports.AnimationProperty.Scale){Vector3.divide(_value3,baseValue,_value3);}else {Vector3.subtract(_value3,baseValue,_value3);}}return _value3;}case exports.InterpolableValueType.Vector4:{var _value4=tempValue.vector4;curve._evaluate(time,_value4);if(additive){Vector4.subtract(_value4,baseValue,_value4);}return _value4;}case exports.InterpolableValueType.Quaternion:{var _value5=tempValue.quaternion;curve._evaluate(time,_value5);if(additive){var tempQuat=Animator._tempQuat;Quaternion.conjugate(baseValue,tempQuat);Quaternion.multiply(tempQuat,_value5,_value5);}return _value5;}}};_proto._getAnimatorLayerData=function _getAnimatorLayerData(layerIndex){var animatorLayerData=this._animatorLayersData[layerIndex];animatorLayerData||(this._animatorLayersData[layerIndex]=animatorLayerData=new AnimatorLayerData());return animatorLayerData;};_proto._updateLayer=function _updateLayer(layerIndex,firstLayer,deltaTime){var _this$_animatorContro=this._animatorController.layers[layerIndex],blendingMode=_this$_animatorContro.blendingMode,weight=_this$_animatorContro.weight;var animLayerData=this._animatorLayersData[layerIndex];var srcPlayData=animLayerData.srcPlayData,destPlayData=animLayerData.destPlayData,crossFadeTransitionInfo=animLayerData.crossFadeTransition;var layerAdditive=blendingMode===exports.AnimatorLayerBlendingMode.Additive;var layerWeight=firstLayer?1.0:weight;//TODO: ä»»æ„æƒ…å†µéƒ½åº”è¯¥æ£€æŸ¥ï¼ŒåŽé¢è¦ä¼˜åŒ–
  animLayerData.layerState!==LayerState.FixedCrossFading&&this._checkTransition(srcPlayData,crossFadeTransitionInfo,layerIndex);switch(animLayerData.layerState){case LayerState.Playing:this._updatePlayingState(srcPlayData,animLayerData,layerIndex,layerWeight,deltaTime,layerAdditive);break;case LayerState.FixedCrossFading:this._updateCrossFadeFromPose(destPlayData,animLayerData,layerIndex,layerWeight,deltaTime,layerAdditive);break;case LayerState.CrossFading:this._updateCrossFade(srcPlayData,destPlayData,animLayerData,layerIndex,layerWeight,deltaTime,layerAdditive);break;}};_proto._updatePlayingState=function _updatePlayingState(playData,layerData,layerIndex,weight,delta,additive){var _playData$stateData=playData.stateData,curveOwners=_playData$stateData.curveOwners,eventHandlers=_playData$stateData.eventHandlers;var state=playData.state,lastPlayState=playData.playState,lastClipTime=playData.clipTime;var curves=state.clip._curveBindings;playData.update(this.speed<0);var clipTime=playData.clipTime,playState=playData.playState;eventHandlers.length&&this._fireAnimationEvents(playData,eventHandlers,lastClipTime,clipTime);for(var i=curves.length-1;i>=0;i--){var owner=curveOwners[i];var value=this._evaluateCurve(owner.property,curves[i].curve,clipTime,additive,this._baseTempValue);if(additive){this._applyClipValueAdditive(owner,value,weight);}else {this._applyClipValue(owner,value,weight);}}playData.frameTime+=state.speed*delta;if(playState===AnimatorStatePlayState.Finished){layerData.layerState=LayerState.Standby;}if(lastPlayState===AnimatorStatePlayState.UnStarted){this._callAnimatorScriptOnEnter(state,layerIndex);}if(playState===AnimatorStatePlayState.Finished){this._callAnimatorScriptOnExit(state,layerIndex);}else {this._callAnimatorScriptOnUpdate(state,layerIndex);}};_proto._updateCrossFade=function _updateCrossFade(srcPlayData,destPlayData,layerData,layerIndex,weight,delta,additive){var crossCurveDataCollection=this._crossCurveDataCollection;var srcCurves=srcPlayData.state.clip._curveBindings;var srcState=srcPlayData.state,srcStateData=srcPlayData.stateData,lastSrcPlayState=srcPlayData.playState;var srcEventHandler=srcStateData.eventHandlers;var destState=destPlayData.state,destStateData=destPlayData.stateData,lastDstPlayState=destPlayData.playState;var destEventHandler=destStateData.eventHandlers;var destCurves=destState.clip._curveBindings;var lastSrcClipTime=srcPlayData.clipTime;var lastDestClipTime=destPlayData.clipTime;var crossWeight=Math.abs(destPlayData.frameTime)/(destState._getDuration()*layerData.crossFadeTransition.duration);crossWeight>=1.0&&(crossWeight=1.0);srcPlayData.update(this.speed<0);destPlayData.update(this.speed<0);var srcPlayState=srcPlayData.playState;var destPlayState=destPlayData.playState;this._updateCrossFadeData(layerData,crossWeight,delta,false);var srcClipTime=srcPlayData.clipTime;var destClipTime=destPlayData.clipTime;srcEventHandler.length&&this._fireAnimationEvents(srcPlayData,srcEventHandler,lastSrcClipTime,srcClipTime);destEventHandler.length&&this._fireAnimationEvents(destPlayData,destEventHandler,lastDestClipTime,destClipTime);if(lastSrcPlayState===AnimatorStatePlayState.UnStarted){this._callAnimatorScriptOnEnter(srcState,layerIndex);}if(crossWeight===1||srcPlayState===AnimatorStatePlayState.Finished){this._callAnimatorScriptOnExit(srcState,layerIndex);}else {this._callAnimatorScriptOnUpdate(srcState,layerIndex);}if(lastDstPlayState===AnimatorStatePlayState.UnStarted){this._callAnimatorScriptOnEnter(destState,layerIndex);}if(destPlayState===AnimatorStatePlayState.Finished){this._callAnimatorScriptOnExit(destState,layerIndex);}else {this._callAnimatorScriptOnUpdate(destState,layerIndex);}for(var i=crossCurveDataCollection.length-1;i>=0;i--){var _crossCurveDataCollec=crossCurveDataCollection[i],curveOwner=_crossCurveDataCollec.curveOwner,srcCurveIndex=_crossCurveDataCollec.srcCurveIndex,destCurveIndex=_crossCurveDataCollec.destCurveIndex;var property=curveOwner.property,defaultValue=curveOwner.defaultValue;var srcValue=srcCurveIndex>=0?this._evaluateCurve(property,srcCurves[srcCurveIndex].curve,srcClipTime,additive,this._baseTempValue):defaultValue;var destValue=destCurveIndex>=0?this._evaluateCurve(property,destCurves[destCurveIndex].curve,destClipTime,additive,this._crossTempValue):defaultValue;this._applyCrossClipValue(curveOwner,srcValue,destValue,crossWeight,weight,additive);}};_proto._updateCrossFadeFromPose=function _updateCrossFadeFromPose(destPlayData,layerData,layerIndex,weight,delta,additive){var crossCurveDataCollection=this._crossCurveDataCollection;var state=destPlayData.state,stateData=destPlayData.stateData,lastPlayState=destPlayData.playState;var eventHandlers=stateData.eventHandlers;var curves=state.clip._curveBindings;var lastDestClipTime=destPlayData.clipTime;var crossWeight=Math.abs(destPlayData.frameTime)/(state._getDuration()*layerData.crossFadeTransition.duration);crossWeight>=1.0&&(crossWeight=1.0);destPlayData.update(this.speed<0);var playState=destPlayData.playState;this._updateCrossFadeData(layerData,crossWeight,delta,true);var destClipTime=destPlayData.clipTime;//TODO: srcState å°‘äº†æœ€æ–°ä¸€æ®µæ—¶é—´çš„åˆ¤æ–­
  eventHandlers.length&&this._fireAnimationEvents(destPlayData,eventHandlers,lastDestClipTime,destClipTime);if(lastPlayState===AnimatorStatePlayState.UnStarted){this._callAnimatorScriptOnEnter(state,layerIndex);}if(playState===AnimatorStatePlayState.Finished){this._callAnimatorScriptOnExit(state,layerIndex);}else {this._callAnimatorScriptOnUpdate(state,layerIndex);}for(var i=crossCurveDataCollection.length-1;i>=0;i--){var _crossCurveDataCollec2=crossCurveDataCollection[i],curveOwner=_crossCurveDataCollec2.curveOwner,destCurveIndex=_crossCurveDataCollec2.destCurveIndex;var destValue=destCurveIndex>=0?this._evaluateCurve(curveOwner.property,curves[destCurveIndex].curve,destClipTime,additive,this._crossTempValue):curveOwner.defaultValue;this._applyCrossClipValue(curveOwner,curveOwner.fixedPoseValue,destValue,crossWeight,weight,additive);}};_proto._updateCrossFadeData=function _updateCrossFadeData(layerData,crossWeight,delta,fixed){var destPlayData=layerData.destPlayData;destPlayData.frameTime+=destPlayData.state.speed*delta;if(crossWeight===1.0){if(destPlayData.playState===AnimatorStatePlayState.Finished){layerData.layerState=LayerState.Standby;}else {layerData.layerState=LayerState.Playing;}layerData.switchPlayData();}else {fixed||(layerData.srcPlayData.frameTime+=layerData.srcPlayData.state.speed*delta);}};_proto._applyCrossClipValue=function _applyCrossClipValue(owner,srcValue,destValue,crossWeight,layerWeight,additive){var value;if(owner.type===Transform){switch(owner.property){case exports.AnimationProperty.Position:value=this._baseTempValue.vector3;Vector3.lerp(srcValue,destValue,crossWeight,value);break;case exports.AnimationProperty.Rotation:value=this._baseTempValue.quaternion;Quaternion.slerp(srcValue,destValue,crossWeight,value);break;case exports.AnimationProperty.Scale:{value=this._baseTempValue.vector3;Vector3.lerp(srcValue,destValue,crossWeight,value);break;}}}else if(owner.type===SkinnedMeshRenderer){switch(owner.property){case exports.AnimationProperty.BlendShapeWeights:value=this._baseTempValue.getFloatArray(srcValue.length);for(var i=0,length=value.length;i<length;++i){value[i]=srcValue[i]+(destValue[i]-srcValue[i])*crossWeight;}break;}}if(additive){this._applyClipValueAdditive(owner,value,layerWeight);}else {this._applyClipValue(owner,value,layerWeight);}};_proto._applyClipValue=function _applyClipValue(owner,value,weight){if(owner.type===Transform){var transform=owner.target.transform;switch(owner.property){case exports.AnimationProperty.Position:if(weight===1.0){transform.position=value;}else {var position=transform.position;Vector3.lerp(position,value,weight,position);}break;case exports.AnimationProperty.Rotation:if(weight===1.0){transform.rotationQuaternion=value;}else {var rotationQuaternion=transform.rotationQuaternion;Quaternion.slerp(rotationQuaternion,value,weight,rotationQuaternion);}break;case exports.AnimationProperty.Scale:if(weight===1.0){transform.scale=value;}else {var scale=transform.scale;Vector3.lerp(scale,value,weight,scale);}break;}}else if(owner.type===SkinnedMeshRenderer){switch(owner.property){case exports.AnimationProperty.BlendShapeWeights:if(weight===1.0){owner.component.blendShapeWeights=value;}else {var _ref=owner.component,blendShapeWeights=_ref.blendShapeWeights;for(var i=0,length=blendShapeWeights.length;i<length;++i){blendShapeWeights[i]+=(value[i]-blendShapeWeights[i])*weight;}}break;}}};_proto._applyClipValueAdditive=function _applyClipValueAdditive(owner,additiveValue,weight){if(owner.type===Transform){var transform=owner.target.transform;switch(owner.property){case exports.AnimationProperty.Position:var position=transform.position;position.x+=additiveValue.x*weight;position.y+=additiveValue.y*weight;position.z+=additiveValue.z*weight;transform.position=position;break;case exports.AnimationProperty.Rotation:var rotationQuaternion=transform.rotationQuaternion;AnimatorUtils.quaternionWeight(additiveValue,weight,additiveValue);additiveValue.normalize();rotationQuaternion.multiply(additiveValue);transform.rotationQuaternion=rotationQuaternion;break;case exports.AnimationProperty.Scale:var scale=transform.scale;AnimatorUtils.scaleWeight(scale,weight,scale);Vector3.multiply(scale,additiveValue,scale);transform.scale=scale;break;case exports.AnimationProperty.BlendShapeWeights:var _ref2=owner.component,blendShapeWeights=_ref2.blendShapeWeights;for(var i=0,length=blendShapeWeights.length;i<length;++i){owner.component.blendShapeWeights[i]+=additiveValue[i]*weight;}break;}}};_proto._revertDefaultValue=function _revertDefaultValue(state,stateData){var clip=state.clip;if(clip){var curves=clip._curveBindings;var curveOwners=stateData.curveOwners;for(var i=curves.length-1;i>=0;i--){var owner=curveOwners[i];var transform=owner.target.transform;if(!owner._hasSavedDefaultValue)continue;switch(owner.property){case exports.AnimationProperty.Position:transform.position=owner.defaultValue;break;case exports.AnimationProperty.Rotation:transform.rotationQuaternion=owner.defaultValue;break;case exports.AnimationProperty.Scale:transform.scale=owner.defaultValue;break;case exports.AnimationProperty.BlendShapeWeights:var _ref3=owner.component,blendShapeWeights=_ref3.blendShapeWeights;for(var j=0,length=blendShapeWeights.length;j<length;++j){owner.component.blendShapeWeights[j]=owner.defaultValue[j];}break;}}}};_proto._checkTransition=function _checkTransition(stateData,crossFadeTransition,layerIndex){var state=stateData.state,clipTime=stateData.clipTime;var duration=state._getDuration();var transitions=state.transitions;for(var i=0,n=transitions.length;i<n;++i){var transition=transitions[i];if(duration*transition.exitTime<=clipTime){crossFadeTransition!==transition&&this._crossFadeByTransition(transition,layerIndex);}}};_proto._crossFadeByTransition=function _crossFadeByTransition(transition,layerIndex){var name=transition.destinationState.name;var animatorStateInfo=this._getAnimatorStateInfo(name,layerIndex,Animator._animatorInfo);var crossState=animatorStateInfo.state;if(!crossState){return;}if(!crossState.clip){console.warn("The state named "+name+" has no AnimationClip data.");return;}var animatorLayerData=this._getAnimatorLayerData(animatorStateInfo.layerIndex);var layerState=animatorLayerData.layerState;var destPlayData=animatorLayerData.destPlayData;var animatorStateData=this._getAnimatorStateData(name,crossState,animatorLayerData);var duration=crossState._getDuration();var offset=duration*transition.offset;destPlayData.reset(crossState,animatorStateData,offset);switch(layerState){// Maybe not play, maybe end.
  case LayerState.Standby:animatorLayerData.layerState=LayerState.FixedCrossFading;this._clearCrossData(animatorLayerData);this._prepareStandbyCrossFading(animatorLayerData);break;case LayerState.Playing:animatorLayerData.layerState=LayerState.CrossFading;this._clearCrossData(animatorLayerData);this._prepareCrossFading(animatorLayerData);break;case LayerState.CrossFading:animatorLayerData.layerState=LayerState.FixedCrossFading;this._prepareFixedPoseCrossFading(animatorLayerData);break;case LayerState.FixedCrossFading:this._prepareFixedPoseCrossFading(animatorLayerData);break;}animatorLayerData.crossFadeTransition=transition;};_proto._fireAnimationEvents=function _fireAnimationEvents(playState,eventHandlers,lastClipTime,clipTime){var state=playState.state;var clipDuration=state.clip.length;if(this.speed>=0){if(clipTime<lastClipTime){this._fireSubAnimationEvents(playState,eventHandlers,lastClipTime,state.clipEndTime*clipDuration);playState.currentEventIndex=0;this._fireSubAnimationEvents(playState,eventHandlers,state.clipStartTime*clipDuration,clipTime);}else {this._fireSubAnimationEvents(playState,eventHandlers,lastClipTime,clipTime);}}else {if(clipTime>lastClipTime){this._fireBackwardSubAnimationEvents(playState,eventHandlers,lastClipTime,state.clipStartTime*clipDuration);playState.currentEventIndex=eventHandlers.length-1;this._fireBackwardSubAnimationEvents(playState,eventHandlers,state.clipEndTime*clipDuration,clipTime);}else {this._fireBackwardSubAnimationEvents(playState,eventHandlers,lastClipTime,clipTime);}}};_proto._fireSubAnimationEvents=function _fireSubAnimationEvents(playState,eventHandlers,lastClipTime,curClipTime){var eventIndex=playState.currentEventIndex;for(var n=eventHandlers.length;eventIndex<n;eventIndex++){var eventHandler=eventHandlers[eventIndex];var _eventHandler$event=eventHandler.event,time=_eventHandler$event.time,parameter=_eventHandler$event.parameter;if(time>curClipTime){break;}var _eventHandler=eventHandler,handlers=_eventHandler.handlers;if(time>=lastClipTime){for(var j=handlers.length-1;j>=0;j--){handlers[j](parameter);}playState.currentEventIndex=Math.min(eventIndex+1,n-1);}}};_proto._fireBackwardSubAnimationEvents=function _fireBackwardSubAnimationEvents(playState,eventHandlers,lastClipTime,curClipTime){var eventIndex=playState.currentEventIndex;for(;eventIndex>=0;eventIndex--){var eventHandler=eventHandlers[eventIndex];var _eventHandler$event2=eventHandler.event,time=_eventHandler$event2.time,parameter=_eventHandler$event2.parameter;if(time<curClipTime){break;}var _eventHandler2=eventHandler,handlers=_eventHandler2.handlers;if(time<=lastClipTime){for(var j=handlers.length-1;j>=0;j--){handlers[j](parameter);}playState.currentEventIndex=Math.max(eventIndex-1,0);}}};_proto._callAnimatorScriptOnEnter=function _callAnimatorScriptOnEnter(state,layerIndex){var scripts=state._onStateEnterScripts;for(var i=0,n=scripts.length;i<n;i++){scripts[i].onStateEnter(this,state,layerIndex);}};_proto._callAnimatorScriptOnUpdate=function _callAnimatorScriptOnUpdate(state,layerIndex){var scripts=state._onStateUpdateScripts;for(var i=0,n=scripts.length;i<n;i++){scripts[i].onStateUpdate(this,state,layerIndex);}};_proto._callAnimatorScriptOnExit=function _callAnimatorScriptOnExit(state,layerIndex){var scripts=state._onStateExitScripts;for(var i=0,n=scripts.length;i<n;i++){scripts[i].onStateExit(this,state,layerIndex);}};_proto._clearPlayData=function _clearPlayData(){this._animatorLayersData.length=0;this._crossCurveDataCollection.length=0;this._animationCurveOwners.length=0;this._animationEventHandlerPool.resetPool();if(this._controllerUpdateFlag){this._controllerUpdateFlag.flag=false;}};_createClass$3(Animator,[{key:"speed",get:/**
       * The playback speed of the Animator, 1.0 is normal playback speed.
       */function get(){return this._speed;},set:function set(value){this._speed=value;}/**
       * All layers from the AnimatorController which belongs this Animator.
       */},{key:"animatorController",get:function get(){return this._animatorController;},set:function set(animatorController){if(animatorController!==this._animatorController){this._controllerUpdateFlag&&this._controllerUpdateFlag.destroy();this._controllerUpdateFlag=animatorController&&animatorController._registerChangeFlag();this._animatorController=animatorController;}}}]);return Animator;}(Component),_class2$d._tempQuat=new Quaternion(),_class2$d._animatorInfo=new AnimatorStateInfo(),_class2$d),(_descriptor=_applyDecoratedDescriptor(_class$s.prototype,"_speed",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 1.0;}}),_descriptor2=_applyDecoratedDescriptor(_class$s.prototype,"_controllerUpdateFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3=_applyDecoratedDescriptor(_class$s.prototype,"_animatorLayersData",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor4=_applyDecoratedDescriptor(_class$s.prototype,"_crossCurveDataCollection",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor5=_applyDecoratedDescriptor(_class$s.prototype,"_animationCurveOwners",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor6=_applyDecoratedDescriptor(_class$s.prototype,"_crossCurveDataPool",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ClassPool(CrossCurveData);}}),_descriptor7=_applyDecoratedDescriptor(_class$s.prototype,"_animationEventHandlerPool",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ClassPool(AnimationEventHandler);}}),_descriptor8=_applyDecoratedDescriptor(_class$s.prototype,"_baseTempValue",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new AnimatorTempValue();}}),_descriptor9=_applyDecoratedDescriptor(_class$s.prototype,"_crossTempValue",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new AnimatorTempValue();}})),_class$s);/**
   * Store the data for Animator playback.
   */var AnimatorController=/*#__PURE__*/function(){function AnimatorController(){this._updateFlagManager=new UpdateFlagManager();this._layers=[];this._layersMap={};}var _proto=AnimatorController.prototype;/**
     * Get the layer by name.
     * @param name - The layer's name.
     */_proto.findLayerByName=function findLayerByName(name){return this._layersMap[name];}/**
     * Add a layer to the controller.
     * @param layer - The layer to add
     */;_proto.addLayer=function addLayer(layer){this._layers.push(layer);this._layersMap[layer.name]=layer;this._distributeUpdateFlag();}/**
     * Remove a layer from the controller.
     * @param layerIndex - The index of the AnimatorLayer
     */;_proto.removeLayer=function removeLayer(layerIndex){var theLayer=this.layers[layerIndex];this._layers.splice(layerIndex,1);delete this._layersMap[theLayer.name];this._distributeUpdateFlag();}/**
     * Clear layers.
     */;_proto.clearLayers=function clearLayers(){this._layers.length=0;for(var name in this._layersMap){delete this._layersMap[name];}this._distributeUpdateFlag();}/**
     * @internal
     */;_proto._registerChangeFlag=function _registerChangeFlag(){return this._updateFlagManager.createFlag(BoolUpdateFlag);};_proto._distributeUpdateFlag=function _distributeUpdateFlag(){this._updateFlagManager.dispatch();};_createClass$3(AnimatorController,[{key:"layers",get:/**
       * The layers in the controller.
       */function get(){return this._layers;}}]);return AnimatorController;}();/**
   * The Animation Layer contains a state machine that controls animations of a model or part of it.
   */var AnimatorControllerLayer=/** The blending weight that the layers has. It is not taken into account for the first layer. */ /** The blending mode used by the layer. It is not taken into account for the first layer. */ /** The state machine for the layer. */ /**
   * @param name - The layer's name
   */function AnimatorControllerLayer(name){this.name=name;this.weight=1.0;this.blendingMode=exports.AnimatorLayerBlendingMode.Override;this.stateMachine=void 0;};/**
   * StateMachineScript is a component that can be added to a animator state. It's the base class every script on a state derives from.
   */var StateMachineScript=/*#__PURE__*/function(){function StateMachineScript(){this._destroyed=false;this._state=void 0;}var _proto=StateMachineScript.prototype;/**
     * onStateEnter is called when a transition starts and the state machine starts to evaluate this state.
     * @param animator - The animator
     * @param animatorState - The state be evaluated
     * @param layerIndex - The index of the layer where the state is located
     */_proto.onStateEnter=function onStateEnter(animator,animatorState,layerIndex){}/**
     * onStateUpdate is called on each Update frame between onStateEnter and onStateExit callbacks.
     * @param animator - The animator
     * @param animatorState - The state be evaluated
     * @param layerIndex - The index of the layer where the state is located
     */;_proto.onStateUpdate=function onStateUpdate(animator,animatorState,layerIndex){}/**
     * onStateExit is called when a transition ends and the state machine finishes evaluating this state.
     * @param animator - The animator
     * @param animatorState - The state be evaluated
     * @param layerIndex - The index of the layer where the state is located
     */;_proto.onStateExit=function onStateExit(animator,animatorState,layerIndex){}/**
     * Destroy this instance.
     */;_proto.destroy=function destroy(){if(this._destroyed){return;}this._state._removeStateMachineScript(this);this._destroyed=true;};return StateMachineScript;}();/**
   * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.
   */var AnimatorState=/*#__PURE__*/function(){/**
     * @param name - The state's name
     */function AnimatorState(name){this.name=name;this.speed=1.0;this.wrapMode=exports.WrapMode.Loop;this._onStateEnterScripts=[];this._onStateUpdateScripts=[];this._onStateExitScripts=[];this._clipStartTime=0;this._clipEndTime=1;this._clip=void 0;this._transitions=[];}/**
     * Add an outgoing transition to the destination state.
     * @param transition - The transition
     */var _proto=AnimatorState.prototype;_proto.addTransition=function addTransition(transition){this._transitions.push(transition);}/**
     * Remove a transition from the state.
     * @param transition - The transition
     */;_proto.removeTransition=function removeTransition(transition){var index=this._transitions.indexOf(transition);index!==-1&&this._transitions.splice(index,1);}/**
     * Adds a state machine script class of type T to the AnimatorState.
     * @param scriptType - The state machine script class of type T
     */;_proto.addStateMachineScript=function addStateMachineScript(scriptType){var script=new scriptType();script._state=this;var prototype=StateMachineScript.prototype;if(script.onStateEnter!==prototype.onStateEnter){this._onStateEnterScripts.push(script);}if(script.onStateUpdate!==prototype.onStateUpdate){this._onStateUpdateScripts.push(script);}if(script.onStateExit!==prototype.onStateExit){this._onStateExitScripts.push(script);}return script;}/**
     * Clears all transitions from the state.
     */;_proto.clearTransitions=function clearTransitions(){this._transitions.length=0;}/**
     * @internal
     */;_proto._getDuration=function _getDuration(){if(this.clip){return (this._clipEndTime-this._clipStartTime)*this.clip.length;}return null;}/**
     * @internal
     */;_proto._removeStateMachineScript=function _removeStateMachineScript(script){var prototype=StateMachineScript.prototype;if(script.onStateEnter!==prototype.onStateEnter){var index=this._onStateEnterScripts.indexOf(script);index!==-1&&this._onStateEnterScripts.splice(index,1);}if(script.onStateUpdate!==prototype.onStateUpdate){var _index=this._onStateUpdateScripts.indexOf(script);_index!==-1&&this._onStateUpdateScripts.splice(_index,1);}if(script.onStateExit!==prototype.onStateExit){var _index2=this._onStateExitScripts.indexOf(script);_index2!==-1&&this._onStateExitScripts.splice(_index2,1);}};_createClass$3(AnimatorState,[{key:"transitions",get:/** The speed of the clip. 1 is normal speed, default 1. */ /** The wrap mode used in the state. */ /** @internal */ /** @internal */ /** @internal */ /**
       * The transitions that are going out of the state.
       */function get(){return this._transitions;}/**
       * The clip that is being played by this animator state.
       */},{key:"clip",get:function get(){return this._clip;},set:function set(clip){this._clip=clip;this._clipEndTime=Math.min(this._clipEndTime,1);}/**
       * The start time of the clip, the range is 0 to 1, default is 0.
       */},{key:"clipStartTime",get:function get(){return this._clipStartTime;},set:function set(time){this._clipStartTime=Math.max(time,0);}/**
       * The end time of the clip, the range is 0 to 1, default is 1.
       */},{key:"clipEndTime",get:function get(){return this._clipEndTime;},set:function set(time){this._clipEndTime=Math.min(time,1);}}]);return AnimatorState;}();/**
   * A graph controlling the interaction of states. Each state references a motion.
   */var AnimatorStateMachine=/*#__PURE__*/function(){function AnimatorStateMachine(){this.states=[];this._statesMap={};}var _proto=AnimatorStateMachine.prototype;/**
     * Add a state to the state machine.
     * @param name - The name of the new state
     */_proto.addState=function addState(name){var state=this.findStateByName(name);if(!state){state=new AnimatorState(name);this.states.push(state);this._statesMap[name]=state;}else {console.warn("The state named "+name+" has existed.");}return state;}/**
     * Remove a state from the state machine.
     * @param state - The state
     */;_proto.removeState=function removeState(state){var name=state.name;var index=this.states.indexOf(state);if(index>-1){this.states.splice(index,1);}delete this._statesMap[name];}/**
     * Get the state by name.
     * @param name - The layer's name
     */;_proto.findStateByName=function findStateByName(name){return this._statesMap[name];}/**
     * Makes a unique state name in the state machine.
     * @param name - Desired name for the state.
     * @returns Unique name.
     */;_proto.makeUniqueStateName=function makeUniqueStateName(name){var _statesMap=this._statesMap;var originName=name;var index=0;while(_statesMap[name]){name=originName+" "+index;index++;}return name;};return AnimatorStateMachine;}();/**
   * Animation interpolation method.
   */exports.InterpolationType = void 0;(function(InterpolationType){InterpolationType[InterpolationType["Linear"]=0]="Linear";InterpolationType[InterpolationType["CubicSpine"]=1]="CubicSpine";InterpolationType[InterpolationType["Step"]=2]="Step";InterpolationType[InterpolationType["Hermite"]=3]="Hermite";})(exports.InterpolationType||(exports.InterpolationType={}));/**
   * Store a collection of Keyframes that can be evaluated over time.
   */var AnimationCurve=/*#__PURE__*/function(){function AnimationCurve(){this.keys=[];this.interpolation=void 0;this._valueSize=void 0;this._valueType=void 0;this._tempValue=void 0;this._length=0;this._currentIndex=0;}var _proto=AnimationCurve.prototype;/**
     * Add a new key to the curve.
     * @param key - The keyframe
     */_proto.addKey=function addKey(key){var time=key.time;this.keys.push(key);if(time>this._length){this._length=time;}if(!this._valueSize){if(typeof key.value=="number"){this._valueSize=1;this._valueType=exports.InterpolableValueType.Float;this._tempValue=0;}if(key.value instanceof Vector2){this._valueSize=2;this._valueType=exports.InterpolableValueType.Vector2;this._tempValue=new Vector2();}if(key.value instanceof Vector3){this._valueSize=3;this._valueType=exports.InterpolableValueType.Vector3;this._tempValue=new Vector3();}if(key.value instanceof Vector4){this._valueSize=4;this._valueType=exports.InterpolableValueType.Vector4;this._tempValue=new Vector4();}if(key.value instanceof Quaternion){this._valueSize=4;this._valueType=exports.InterpolableValueType.Quaternion;this._tempValue=new Quaternion();}if(key.value instanceof Float32Array){var size=key.value.length;this._valueSize=size;this._valueType=exports.InterpolableValueType.FloatArray;this._tempValue=new Float32Array(size);}}this.keys.sort(function(a,b){return a.time-b.time;});}/**
     * Evaluate the curve at time.
     * @param time - The time within the curve you want to evaluate
     */;_proto.evaluate=function evaluate(time){return this._evaluate(time,this._tempValue);}/**
     * Removes the keyframe at index and inserts key.
     * @param index - The index of the key to move
     * @param key - The key to insert
     */;_proto.moveKey=function moveKey(index,key){this.keys[index]=key;}/**
     * Removes a key.
     * @param index - The index of the key to remove
     */;_proto.removeKey=function removeKey(index){this.keys.splice(index,1);var keys=this.keys;var count=this.keys.length;var newLength=0;for(var i=count-1;i>=0;i--){if(keys[i].time>length){newLength=keys[i].time;}}this._length=newLength;}/**
     * @internal
     * Samples an animation at a given time.
     * @param time - The time to sample an animation
     * @param out - The value calculated
     */;_proto._evaluate=function _evaluate(time,out){var keys=this.keys,interpolation=this.interpolation;this._valueType;var length=this.keys.length;// Compute curIndex and nextIndex.
  var curIndex=this._currentIndex;// Reset loop.
  if(curIndex!==-1&&time<keys[curIndex].time){curIndex=-1;}var nextIndex=curIndex+1;while(nextIndex<length){if(time<keys[nextIndex].time){break;}curIndex++;nextIndex++;}this._currentIndex=curIndex;// Evaluate value.
  var value;if(curIndex===-1){value=this._evaluateStep(0,out);}else if(nextIndex===length){value=this._evaluateStep(curIndex,out);}else {// Time between first frame and end frame.
  var curFrameTime=keys[curIndex].time;var duration=keys[nextIndex].time-curFrameTime;var t=(time-curFrameTime)/duration;var dur=duration;switch(interpolation){case exports.InterpolationType.Linear:value=this._evaluateLinear(curIndex,nextIndex,t,out);break;case exports.InterpolationType.Step:value=this._evaluateStep(curIndex,out);break;case exports.InterpolationType.CubicSpine:case exports.InterpolationType.Hermite:value=this._evaluateHermite(curIndex,nextIndex,t,dur,out);}}return value;};_proto._evaluateLinear=function _evaluateLinear(frameIndex,nextFrameIndex,t,out){var _valueType=this._valueType,keys=this.keys;switch(_valueType){case exports.InterpolableValueType.Float:return keys[frameIndex].value*(1-t)+keys[nextFrameIndex].value*t;case exports.InterpolableValueType.FloatArray:var value=keys[frameIndex].value;var nextValue=keys[nextFrameIndex].value;for(var i=0,n=value.length;i<n;i++){out[i]=value[i]*(1-t)+nextValue[i]*t;}return out;case exports.InterpolableValueType.Vector2:Vector2.lerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,out);return out;case exports.InterpolableValueType.Vector3:Vector3.lerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,out);return out;case exports.InterpolableValueType.Vector4:Vector4.lerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,out);return out;case exports.InterpolableValueType.Quaternion:Quaternion.slerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,out);return out;}};_proto._evaluateStep=function _evaluateStep(frameIndex,out){var _valueType=this._valueType,keys=this.keys;switch(_valueType){case exports.InterpolableValueType.Float:return keys[frameIndex].value;case exports.InterpolableValueType.FloatArray:var value=keys[frameIndex].value;for(var i=0,n=value.length;i<n;i++){out[i]=value[i];}return out;case exports.InterpolableValueType.Vector2:case exports.InterpolableValueType.Vector3:case exports.InterpolableValueType.Vector4:case exports.InterpolableValueType.Quaternion:out.copyFrom(keys[frameIndex].value);return out;}};_proto._evaluateHermite=function _evaluateHermite(frameIndex,nextFrameIndex,t,dur,out){var _valueSize=this._valueSize,keys=this.keys;var curKey=keys[frameIndex];var nextKey=keys[nextFrameIndex];switch(_valueSize){case 1:{var t0=curKey.outTangent,t1=nextKey.inTangent,p0=curKey.value,p1=nextKey.value;if(Number.isFinite(t0)&&Number.isFinite(t1)){var t2=t*t;var t3=t2*t;var a=2.0*t3-3.0*t2+1.0;var b=t3-2.0*t2+t;var c=t3-t2;var d=-2.0*t3+3.0*t2;return a*p0+b*t0*dur+c*t1*dur+d*p1;}else {return curKey.value;}}case 2:{var _p=curKey.value;var tan0=curKey.outTangent;var _p2=nextKey.value;var tan1=nextKey.inTangent;var _t=t*t;var _t2=_t*t;var _a=2.0*_t2-3.0*_t+1.0;var _b=_t2-2.0*_t+t;var _c=_t2-_t;var _d=-2.0*_t2+3.0*_t;var _t3=tan0.x,_t4=tan1.x;if(Number.isFinite(_t3)&&Number.isFinite(_t4)){out.x=_a*_p.x+_b*_t3*dur+_c*_t4*dur+_d*_p2.x;}else {out.x=_p.x;}_t3=tan0.y,_t4=tan1.y;if(Number.isFinite(_t3)&&Number.isFinite(_t4))out.y=_a*_p.y+_b*_t3*dur+_c*_t4*dur+_d*_p2.y;else {out.y=_p.y;}return out;}case 3:{var _p3=curKey.value;var _tan=curKey.outTangent;var _p4=nextKey.value;var _tan2=nextKey.inTangent;var _t5=t*t;var _t6=_t5*t;var _a2=2.0*_t6-3.0*_t5+1.0;var _b2=_t6-2.0*_t5+t;var _c2=_t6-_t5;var _d2=-2.0*_t6+3.0*_t5;var _t7=_tan.x,_t8=_tan2.x;if(Number.isFinite(_t7)&&Number.isFinite(_t8)){out.x=_a2*_p3.x+_b2*_t7*dur+_c2*_t8*dur+_d2*_p4.x;}else {out.x=_p3.x;}_t7=_tan.y,_t8=_tan2.y;if(Number.isFinite(_t7)&&Number.isFinite(_t8)){out.y=_a2*_p3.y+_b2*_t7*dur+_c2*_t8*dur+_d2*_p4.y;}else {out.y=_p3.y;}_t7=_tan.z,_t8=_tan2.z;if(Number.isFinite(_t7)&&Number.isFinite(_t8)){out.z=_a2*_p3.z+_b2*_t7*dur+_c2*_t8*dur+_d2*_p4.z;}else {out.z=_p3.z;}return out;}case 4:{var _p5=curKey.value;var _tan3=curKey.outTangent;var _p6=nextKey.value;var _tan4=nextKey.inTangent;var _t9=t*t;var _t10=_t9*t;var _a3=2.0*_t10-3.0*_t9+1.0;var _b3=_t10-2.0*_t9+t;var _c3=_t10-_t9;var _d3=-2.0*_t10+3.0*_t9;var _t11=_tan3.x,_t12=_tan4.x;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){out.x=_a3*_p5.x+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.x;}else {out.x=_p5.x;}_t11=_tan3.y,_t12=_tan4.y;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){out.y=_a3*_p5.y+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.y;}else {out.y=_p5.y;}_t11=_tan3.z,_t12=_tan4.z;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){out.z=_a3*_p5.z+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.z;}else {out.z=_p5.z;}_t11=_tan3.w,_t12=_tan4.w;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){out.w=_a3*_p5.w+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.w;}else {out.w=_p5.w;}return out;}}};_createClass$3(AnimationCurve,[{key:"length",get:/**
       * Animation curve length in seconds.
       */function get(){return this._length;}}]);return AnimationCurve;}();/**
   * Keyframe.
   * @typeParam V - Type of Keyframe value
   */var Keyframe=function Keyframe(){this.time=void 0;this.value=void 0;};/**
   * InterpolableKeyframe.
   * @typeParam T - Type of Tangent value
   * @typeParam V - Type of Keyframe value
   */var InterpolableKeyframe=/*#__PURE__*/function(_Keyframe){_inheritsLoose$2(InterpolableKeyframe,_Keyframe);function InterpolableKeyframe(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Keyframe.call.apply(_Keyframe,[this].concat(args))||this;_this.inTangent=void 0;_this.outTangent=void 0;return _this;}return InterpolableKeyframe;}(Keyframe);exports.AnimatorConditionMode = void 0;(function(AnimatorConditionMode){AnimatorConditionMode[AnimatorConditionMode["If"]=0]="If";AnimatorConditionMode[AnimatorConditionMode["IfNot"]=1]="IfNot";AnimatorConditionMode[AnimatorConditionMode["Greater"]=2]="Greater";AnimatorConditionMode[AnimatorConditionMode["Less"]=3]="Less";AnimatorConditionMode[AnimatorConditionMode["Equals"]=4]="Equals";AnimatorConditionMode[AnimatorConditionMode["NotEquals"]=5]="NotEquals";})(exports.AnimatorConditionMode||(exports.AnimatorConditionMode={}));/**
   * SkyboxMaterial
   */var SkyBoxMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(SkyBoxMaterial,_Material);function SkyBoxMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("skybox"))||this;_this._decodeParam=new Vector4(0,5,0,0);_this.renderState.rasterState.cullMode=exports.CullMode.Off;_this.renderState.depthState.compareFunction=exports.CompareFunction.LessEqual;_this.shaderData.setVector4("u_cubeDecodeParam",_this._decodeParam);return _this;}_createClass$3(SkyBoxMaterial,[{key:"textureDecodeRGBM",get:/**
       * Whether to decode from texture with RGBM format.
       */function get(){return Boolean(this._decodeParam.x);},set:function set(value){this._decodeParam.x=Number(value);}/**
       * RGBM decode factor, default 5.0.
       */},{key:"RGBMDecodeFactor",get:function get(){return this._decodeParam.y;},set:function set(value){this._decodeParam.y=value;}/**
       * Texture cube map of the sky box material.
       */},{key:"textureCubeMap",get:function get(){return this.shaderData.getTexture("u_cube");},set:function set(v){this.shaderData.setTexture("u_cube",v);}}]);return SkyBoxMaterial;}(Material);var DirtyFlagType;/**
   * Blend mode enums of the particle renderer's material.
   */(function(DirtyFlagType){DirtyFlagType[DirtyFlagType["Position"]=1]="Position";DirtyFlagType[DirtyFlagType["Velocity"]=2]="Velocity";DirtyFlagType[DirtyFlagType["Acceleration"]=4]="Acceleration";DirtyFlagType[DirtyFlagType["Color"]=8]="Color";DirtyFlagType[DirtyFlagType["Alpha"]=16]="Alpha";DirtyFlagType[DirtyFlagType["Size"]=32]="Size";DirtyFlagType[DirtyFlagType["StartAngle"]=64]="StartAngle";DirtyFlagType[DirtyFlagType["StartTime"]=128]="StartTime";DirtyFlagType[DirtyFlagType["LifeTime"]=256]="LifeTime";DirtyFlagType[DirtyFlagType["RotateVelocity"]=512]="RotateVelocity";DirtyFlagType[DirtyFlagType["Scale"]=1024]="Scale";DirtyFlagType[DirtyFlagType["Everything"]=4294967295]="Everything";})(DirtyFlagType||(DirtyFlagType={}));exports.ParticleRendererBlendMode = void 0;/**
   * Particle Renderer Component.
   */(function(ParticleRendererBlendMode){ParticleRendererBlendMode[ParticleRendererBlendMode["Transparent"]=0]="Transparent";ParticleRendererBlendMode[ParticleRendererBlendMode["Additive"]=1]="Additive";})(exports.ParticleRendererBlendMode||(exports.ParticleRendererBlendMode={}));var ParticleRenderer=/*#__PURE__*/function(_MeshRenderer){_inheritsLoose$2(ParticleRenderer,_MeshRenderer);/** The max number of indices that Uint16Array can support. */ParticleRenderer._getRandom=function _getRandom(){return Math.random()-0.5;};function ParticleRenderer(props){var _this;_this=_MeshRenderer.call(this,props)||this;_this._vertexStride=void 0;_this._vertices=void 0;_this._vertexBuffer=void 0;_this._maxCount=1000;_this._position=new Vector3();_this._positionRandomness=new Vector3();_this._positionArray=void 0;_this._velocity=new Vector3();_this._velocityRandomness=new Vector3();_this._acceleration=new Vector3();_this._accelerationRandomness=new Vector3();_this._color=new Color(1,1,1,1);_this._colorRandomness=0;_this._size=1;_this._sizeRandomness=0;_this._alpha=1;_this._alphaRandomness=0;_this._startAngle=0;_this._startAngleRandomness=0;_this._rotateVelocity=0;_this._rotateVelocityRandomness=0;_this._lifetime=5;_this._startTimeRandomness=0;_this._scale=1;_this._isOnce=false;_this._onceTime=0;_this._time=0;_this._isInit=false;_this._isStart=false;_this._updateDirtyFlag=DirtyFlagType.Everything;_this._isRotateToVelocity=false;_this._isUseOriginColor=false;_this._isScaleByLifetime=false;_this._is2d=true;_this._isFadeIn=false;_this._isFadeOut=false;_this._playOnEnable=true;_this._blendMode=exports.ParticleRendererBlendMode.Transparent;_this.spriteSheet=void 0;_this.setMaterial(_this._createMaterial());return _this;}/**
     * @override
     * @internal
     */var _proto=ParticleRenderer.prototype;_proto.update=function update(deltaTime){if(!this._isInit||!this._isStart){return;}// Stop after play once
  if(this._isOnce&&this._time>this._onceTime){return this.stop();}if(this._updateDirtyFlag){this._updateBuffer();this._updateDirtyFlag=0;}this._time+=deltaTime/1000;this.shaderData.setFloat("u_time",this._time);}/**
     * @override
     * @internal
     */;_proto._onEnable=function _onEnable(){_MeshRenderer.prototype._onEnable.call(this);if(this._playOnEnable){this.start();}}/**
     * Start emitting.
     */;_proto.start=function start(){this._isStart=true;this._time=0;}/**
     * Stop emitting.
     */;_proto.stop=function stop(){this._isStart=false;};_proto._createMaterial=function _createMaterial(){var material=new Material(this.engine,Shader.find("particle-shader"));var renderState=material.renderState;var target=renderState.blendState.targetBlendState;target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;renderState.depthState.writeEnabled=false;material.renderQueueType=exports.RenderQueueType.Transparent;this.isUseOriginColor=true;this.is2d=true;this.isFadeOut=true;return material;};_proto._createMesh=function _createMesh(){var mesh=new BufferMesh(this._entity.engine,"particleMesh");var vertexStride=96;var vertexCount=this._maxCount*4;var vertexFloatCount=vertexCount*vertexStride;var vertices=new Float32Array(vertexFloatCount);var indices=null;var useUint32=false;if(vertexCount>ParticleRenderer._uint16VertexLimit){if(this.engine._hardwareRenderer.canIUse(exports.GLCapabilityType.elementIndexUint)){useUint32=true;indices=new Uint32Array(6*this._maxCount);}else {throw Error("The vertex count is over limit.");}}else {indices=new Uint16Array(6*this._maxCount);}for(var i=0,idx=0;i<this._maxCount;++i){var startIndex=i*4;indices[idx++]=startIndex;indices[idx++]=startIndex+1;indices[idx++]=startIndex+2;indices[idx++]=startIndex;indices[idx++]=startIndex+2;indices[idx++]=startIndex+3;}var vertexElements=[new VertexElement("a_position",0,exports.VertexElementFormat.Vector3,0),new VertexElement("a_velocity",12,exports.VertexElementFormat.Vector3,0),new VertexElement("a_acceleration",24,exports.VertexElementFormat.Vector3,0),new VertexElement("a_color",36,exports.VertexElementFormat.Vector4,0),new VertexElement("a_lifeAndSize",52,exports.VertexElementFormat.Vector4,0),new VertexElement("a_rotation",68,exports.VertexElementFormat.Vector2,0),new VertexElement("a_uv",76,exports.VertexElementFormat.Vector3,0),new VertexElement("a_normalizedUv",88,exports.VertexElementFormat.Vector2,0)];var vertexBuffer=new Buffer(this.engine,exports.BufferBindFlag.VertexBuffer,vertexFloatCount*4,exports.BufferUsage.Dynamic);var indexBuffer=new Buffer(this.engine,exports.BufferBindFlag.IndexBuffer,indices,exports.BufferUsage.Dynamic);mesh.setVertexBufferBinding(vertexBuffer,vertexStride);mesh.setIndexBufferBinding(indexBuffer,useUint32?exports.IndexFormat.UInt32:exports.IndexFormat.UInt16);mesh.setVertexElements(vertexElements);mesh.addSubMesh(0,indices.length);this._vertexBuffer=vertexBuffer;this._vertexStride=vertexStride/4;this._vertices=vertices;return mesh;};_proto._updateBuffer=function _updateBuffer(){for(var x=0;x<this._maxCount;x++){this._updateSingleBuffer(x);}this._vertexBuffer.setData(this._vertices);};_proto._updateSingleBuffer=function _updateSingleBuffer(i){var _updateDirtyFlag=this._updateDirtyFlag,vertices=this._vertices,vertexStride=this._vertexStride;var getRandom=ParticleRenderer._getRandom;var offset=i*4;var k0=offset*vertexStride;var k1=(offset+1)*vertexStride;var k2=(offset+2)*vertexStride;var k3=(offset+3)*vertexStride;if(_updateDirtyFlag&DirtyFlagType.Position){var _this$_position=this._position,x=_this$_position.x,y=_this$_position.y,z=_this$_position.z;var _positionArray=this._positionArray,_positionRandomness=this._positionRandomness;if(_positionArray){if(_positionArray.length!==this._maxCount){throw Error("The length of positionArray must be equal to maxCount.");}var pos=_positionArray[i];x+=pos.x;y+=pos.y;z+=pos.z;}else {x+=getRandom()*_positionRandomness.x;y+=getRandom()*_positionRandomness.y;z+=getRandom()*_positionRandomness.z;}vertices[k0]=vertices[k1]=vertices[k2]=vertices[k3]=x;vertices[k0+1]=vertices[k1+1]=vertices[k2+1]=vertices[k3+1]=y;vertices[k0+2]=vertices[k1+2]=vertices[k2+2]=vertices[k3+2]=z;}if(_updateDirtyFlag&DirtyFlagType.Velocity){var _velocity=this._velocity,_velocityRandomness=this._velocityRandomness;vertices[k0+3]=vertices[k1+3]=vertices[k2+3]=vertices[k3+3]=_velocity.x+getRandom()*_velocityRandomness.x;vertices[k0+4]=vertices[k1+4]=vertices[k2+4]=vertices[k3+4]=_velocity.y+getRandom()*_velocityRandomness.y;vertices[k0+5]=vertices[k1+5]=vertices[k2+5]=vertices[k3+5]=_velocity.z+getRandom()*_velocityRandomness.z;}if(_updateDirtyFlag&DirtyFlagType.Acceleration){var _acceleration=this._acceleration,_accelerationRandomness=this._accelerationRandomness;vertices[k0+6]=vertices[k1+6]=vertices[k2+6]=vertices[k3+6]=_acceleration.x+getRandom()*_accelerationRandomness.x;vertices[k0+7]=vertices[k1+7]=vertices[k2+7]=vertices[k3+7]=_acceleration.y+getRandom()*_accelerationRandomness.y;vertices[k0+8]=vertices[k1+8]=vertices[k2+8]=vertices[k3+8]=_acceleration.z+getRandom()*_accelerationRandomness.z;}if(_updateDirtyFlag&DirtyFlagType.Color){var _color=this._color,_colorRandomness=this._colorRandomness;vertices[k0+9]=vertices[k1+9]=vertices[k2+9]=vertices[k3+9]=MathUtil.clamp(_color.r+getRandom()*_colorRandomness,0,1);vertices[k0+10]=vertices[k1+10]=vertices[k2+10]=vertices[k3+10]=MathUtil.clamp(_color.g+getRandom()*_colorRandomness,0,1);vertices[k0+11]=vertices[k1+11]=vertices[k2+11]=vertices[k3+11]=MathUtil.clamp(_color.b+getRandom()*_colorRandomness,0,1);}if(_updateDirtyFlag&DirtyFlagType.Alpha){vertices[k0+12]=vertices[k1+12]=vertices[k2+12]=vertices[k3+12]=MathUtil.clamp(this._alpha+getRandom()*this._alphaRandomness,0,1);}if(_updateDirtyFlag&DirtyFlagType.StartTime){vertices[k0+13]=vertices[k1+13]=vertices[k2+13]=vertices[k3+13]=Math.random()*this._startTimeRandomness;}if(_updateDirtyFlag&DirtyFlagType.LifeTime){var _lifetime=this._lifetime;vertices[k0+14]=vertices[k1+14]=vertices[k2+14]=vertices[k3+14]=_lifetime+getRandom()*_lifetime;}// Update the duration of play once when startTime or lifetime changes.
  if(_updateDirtyFlag&DirtyFlagType.StartTime||_updateDirtyFlag&DirtyFlagType.LifeTime){this._onceTime=Math.max(this._onceTime,vertices[k0+13]+vertices[k0+14]);}if(_updateDirtyFlag&DirtyFlagType.Size){var _size=this._size;vertices[k0+15]=vertices[k1+15]=vertices[k2+15]=vertices[k3+15]=Math.max(_size+getRandom()*this._sizeRandomness*_size*2,0);}if(_updateDirtyFlag&DirtyFlagType.Scale){vertices[k0+16]=vertices[k1+16]=vertices[k2+16]=vertices[k3+16]=this._scale;}if(_updateDirtyFlag&DirtyFlagType.StartAngle){vertices[k0+17]=vertices[k1+17]=vertices[k2+17]=vertices[k3+17]=this._startAngle+getRandom()*Math.PI*this._startAngleRandomness*2;}if(_updateDirtyFlag&DirtyFlagType.RotateVelocity){vertices[k0+18]=vertices[k1+18]=vertices[k2+18]=vertices[k3+18]=this._rotateVelocity+getRandom()*this._rotateVelocityRandomness;}this._updateSingleUv(i,k0,k1,k2,k3);};_proto._updateSingleUv=function _updateSingleUv(i,k0,k1,k2,k3){var spriteSheet=this.spriteSheet;var texture=this.getMaterial().shaderData.getTexture("u_texture");var vertices=this._vertices;if(texture){var width=texture.width;var height=texture.height;if(spriteSheet){var _spriteSheet=spriteSheet[i%spriteSheet.length],x=_spriteSheet.x,y=_spriteSheet.y,w=_spriteSheet.w,h=_spriteSheet.h;var u=x/width;var v=y/height;var p=u+w/width;var q=v+h/height;var ratio=h/w;// left bottom
  vertices[k0+19]=u;vertices[k0+20]=q;vertices[k0+21]=ratio;// right bottom
  vertices[k1+19]=p;vertices[k1+20]=q;vertices[k1+21]=ratio;// right top
  vertices[k2+19]=p;vertices[k2+20]=v;vertices[k2+21]=ratio;// left top
  vertices[k3+19]=u;vertices[k3+20]=v;vertices[k3+21]=ratio;}else {var _ratio=height/width;// left bottom
  vertices[k0+19]=0;vertices[k0+20]=1;vertices[k0+21]=_ratio;// right bottom
  vertices[k1+19]=1;vertices[k1+20]=1;vertices[k1+21]=_ratio;// right top
  vertices[k2+19]=1;vertices[k2+20]=0;vertices[k2+21]=_ratio;// left top
  vertices[k3+19]=0;vertices[k3+20]=0;vertices[k3+21]=_ratio;}}else {// left bottom
  vertices[k0+19]=0;vertices[k0+20]=0;vertices[k0+21]=1;// right bottom
  vertices[k1+19]=1;vertices[k1+20]=0;vertices[k1+21]=1;// right top
  vertices[k2+19]=1;vertices[k2+20]=1;vertices[k2+21]=1;// left top
  vertices[k3+19]=0;vertices[k3+20]=1;vertices[k3+21]=1;}vertices[k0+22]=-0.5;vertices[k0+23]=-0.5;vertices[k1+22]=0.5;vertices[k1+23]=-0.5;vertices[k2+22]=0.5;vertices[k2+23]=0.5;vertices[k3+22]=-0.5;vertices[k3+23]=0.5;};_createClass$3(ParticleRenderer,[{key:"texture",get:/**
       * Texture of particle.
       */function get(){return this.getMaterial().shaderData.getTexture("u_texture");},set:function set(texture){if(texture){this.shaderData.enableMacro("particleTexture");this.getMaterial().shaderData.setTexture("u_texture",texture);}else {this.shaderData.disableMacro("particleTexture");}}/**
       * Position of particles.
       */},{key:"position",get:function get(){return this._position;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Position;this._position=value;}/**
       * Random range of positions.
       */},{key:"positionRandomness",get:function get(){return this._positionRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Position;this._positionRandomness=value;}/**
       * Array of fixed positions.
       */},{key:"positionArray",get:function get(){return this._positionArray;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Position;this._positionArray=value;}/**
       * Velocity of particles.
       */},{key:"velocity",get:function get(){return this._velocity;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Velocity;this._velocity=value;}/**
       * Random range of velocity.
       */},{key:"velocityRandomness",get:function get(){return this._velocityRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Velocity;this._velocityRandomness=value;}/**
       * Acceleration of particles.
       */},{key:"acceleration",get:function get(){return this._acceleration;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Acceleration;this._acceleration=value;}/**
       * Random range of acceleration.
       */},{key:"accelerationRandomness",get:function get(){return this._accelerationRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Acceleration;this._accelerationRandomness=value;}/**
       * Color of particles.
       */},{key:"color",get:function get(){return this._color;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Color;this._color=value;}/**
       * Random range of color.
       */},{key:"colorRandomness",get:function get(){return this._colorRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Color;this._colorRandomness=value;}/**
       * Size of particles.
       */},{key:"size",get:function get(){return this._size;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Size;this._size=value;}/**
       * Random range of size.
       */},{key:"sizeRandomness",get:function get(){return this._sizeRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Size;this._sizeRandomness=value;}/**
       * Alpha of particles.
       */},{key:"alpha",get:function get(){return this._alpha;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Alpha;this._alpha=value;}/**
       * Random range of alpha.
       */},{key:"alphaRandomness",get:function get(){return this._alphaRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Alpha;this._alphaRandomness=value;}/**
       * Angle of particles.
       */},{key:"angle",get:function get(){return this._startAngle;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.StartAngle;this._startAngle=value;}/**
       * Random range of angle.
       */},{key:"angleRandomness",get:function get(){return this._startAngleRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.StartAngle;this._startAngleRandomness=value;}/**
       * Rotate velocity of particles.
       */},{key:"rotateVelocity",get:function get(){return this._rotateVelocity;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.RotateVelocity;this._rotateVelocity=value;}/**
       * Random range of rotate velocity.
       */},{key:"rotateVelocityRandomness",get:function get(){return this._rotateVelocityRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.RotateVelocity;this._rotateVelocityRandomness=value;}/**
       * Lifetime of particles.
       */},{key:"lifetime",get:function get(){return this._lifetime;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.LifeTime;this._lifetime=value;this._onceTime=0;}/**
       * Random range of start time.
       */},{key:"startTimeRandomness",get:function get(){return this._startTimeRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.StartTime;this._startTimeRandomness=value;this._onceTime=0;}/**
       * Scale factor of particles.
       */},{key:"scale",get:function get(){return this._scale;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Scale;this._scale=value;}/**
       * Max count of particles.
       */},{key:"maxCount",get:function get(){return this._maxCount;},set:function set(value){this._isStart=false;this._isInit=false;this._maxCount=value;this._updateDirtyFlag=DirtyFlagType.Everything;this.mesh=this._createMesh();this._updateBuffer();this._isInit=true;this.shaderData.setFloat("u_time",0);}/**
       * Whether play once.
       */},{key:"isOnce",get:function get(){return this._isOnce;},set:function set(value){this._time=0;this.shaderData.setInt("u_once",value?1:0);this._isOnce=value;}/**
       * Whether follow the direction of velocity.
       */},{key:"isRotateToVelocity",get:function get(){return this._isRotateToVelocity;},set:function set(value){if(value){this.shaderData.enableMacro("rotateToVelocity");}else {this.shaderData.disableMacro("rotateToVelocity");}this._isRotateToVelocity=value;}/**
       * Whether use origin color.
       */},{key:"isUseOriginColor",get:function get(){return this._isUseOriginColor;},set:function set(value){if(value){this.shaderData.enableMacro("useOriginColor");}else {this.shaderData.disableMacro("useOriginColor");}this._isUseOriginColor=value;}/**
       * Whether scale by lifetime.
       */},{key:"isScaleByLifetime",get:function get(){return this._isScaleByLifetime;},set:function set(value){if(value){this.shaderData.enableMacro("isScaleByLifetime");}else {this.shaderData.disableMacro("isScaleByLifetime");}this._isScaleByLifetime=value;}/**
       * Whether 2D rendering.
       */},{key:"is2d",get:function get(){return this._is2d;},set:function set(value){if(value){this.shaderData.enableMacro("is2d");}else {this.shaderData.disableMacro("is2d");this.getMaterial().renderState.rasterState.cullMode=exports.CullMode.Off;}this._is2d=value;}/**
       * Whether fade in.
       */},{key:"isFadeIn",get:function get(){return this._isFadeIn;},set:function set(value){if(value){this.shaderData.enableMacro("fadeIn");}else {this.shaderData.disableMacro("fadeIn");}this._isFadeIn=value;}/**
       * Whether fade out.
       */},{key:"isFadeOut",get:function get(){return this._isFadeOut;},set:function set(value){if(value){this.shaderData.enableMacro("fadeOut");}else {this.shaderData.disableMacro("fadeOut");}this._isFadeOut=value;}/**
       * Whether play on enable.
       */},{key:"playOnEnable",get:function get(){return this._playOnEnable;},set:function set(value){this._playOnEnable=value;if(value){this.start();}else {this.stop();}}/**
       * Blend mode of the particle renderer's material.
       */},{key:"blendMode",get:function get(){return this._blendMode;},set:function set(value){var blendState=this.getMaterial().renderState.blendState;var target=blendState.targetBlendState;if(value===exports.ParticleRendererBlendMode.Transparent){target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;}else if(value===exports.ParticleRendererBlendMode.Additive){target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.One;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;}this._blendMode=value;}}]);return ParticleRenderer;}(MeshRenderer);ParticleRenderer._uint16VertexLimit=65535;var FRAG_SHADER="#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}";// eslint-disable-line
  var VERT_SHADER="#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";// eslint-disable-line
  Shader.create("trail",VERT_SHADER,FRAG_SHADER);var TrailMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(TrailMaterial,_Material);function TrailMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("trail"))||this;var target=_this.renderState.blendState.targetBlendState;target.enabled=true;target.sourceColorBlendFactor=target.sourceAlphaBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=target.destinationAlphaBlendFactor=exports.BlendFactor.One;_this.renderState.depthState.writeEnabled=false;return _this;}return TrailMaterial;}(Material);var _tempVector3=new Vector3();/**
   * @deprecated
   */var TrailRenderer=/*#__PURE__*/function(_MeshRenderer){_inheritsLoose$2(TrailRenderer,_MeshRenderer);/**
     * @deprecated
     */function TrailRenderer(entity,props){var _this;_this=_MeshRenderer.call(this,entity)||this;_this._vertexStride=void 0;_this._vertices=void 0;_this._vertexBuffer=void 0;_this._stroke=void 0;_this._minSeg=void 0;_this._lifetime=void 0;_this._maxPointNum=void 0;_this._points=void 0;_this._pointStates=void 0;_this._strapPoints=void 0;_this._curPointNum=void 0;_this._prePointsNum=void 0;_this._stroke=props.stroke||0.2;_this._minSeg=props.minSeg||0.02;_this._lifetime=props.lifetime||1000;_this._maxPointNum=_this._lifetime/1000.0*entity.engine.targetFrameRate;_this._points=[];_this._pointStates=[];_this._strapPoints=[];for(var i=0;i<_this._maxPointNum;i++){_this._points.push(new Vector3());_this._pointStates.push(_this._lifetime);_this._strapPoints.push(new Vector3());_this._strapPoints.push(new Vector3());}_this._curPointNum=0;var mtl=props.material||new TrailMaterial(_this.engine);_this.setMaterial(mtl);_this.setTexture(props.texture);_this._initGeometry();return _this;}/**
     * @internal
     */var _proto=TrailRenderer.prototype;_proto.update=function update(deltaTime){var mov=0,newIdx=0;for(var i=0;i<this._curPointNum;i++){this._pointStates[i]-=deltaTime;if(this._pointStates[i]<0){mov++;}else if(mov>0){newIdx=i-mov;// Move data
  this._pointStates[newIdx]=this._pointStates[i];// Move point
  this._points[newIdx].copyFrom(this._points[i]);}}this._curPointNum-=mov;var appendNewPoint=true;if(this._curPointNum===this._maxPointNum){appendNewPoint=false;}else if(this._curPointNum>0){var lastPoint=this._points[this._points.length-1];if(Vector3.distance(this.entity.transform.worldPosition,lastPoint)<this._minSeg){appendNewPoint=false;}}if(appendNewPoint){this._pointStates[this._curPointNum]=this._lifetime;this._points[this._curPointNum].copyFrom(this.entity.transform.worldPosition);this._curPointNum++;}}/**
     * @internal
     */;_proto._render=function _render(camera){this._updateStrapVertices(camera,this._points);this._updateStrapCoords();this._vertexBuffer.setData(this._vertices);_MeshRenderer.prototype._render.call(this,camera);}/**
     * @deprecated
     * Set trail texture.
     * @param texture
     */;_proto.setTexture=function setTexture(texture){if(texture){this.getMaterial().shaderData.setTexture("u_texture",texture);}};_proto._initGeometry=function _initGeometry(){var mesh=new BufferMesh(this._entity.engine);var vertexStride=20;var vertexCount=this._maxPointNum*2;var vertexFloatCount=vertexCount*vertexStride;var vertices=new Float32Array(vertexFloatCount);var vertexElements=[new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0),new VertexElement("TEXCOORD_0",12,exports.VertexElementFormat.Vector2,0)];var vertexBuffer=new Buffer(this.engine,vertexFloatCount*4,exports.BufferUsage.Dynamic);mesh.setVertexBufferBinding(vertexBuffer,vertexStride);mesh.setVertexElements(vertexElements);mesh.addSubMesh(0,vertexCount,exports.MeshTopology.TriangleStrip);this._vertexBuffer=vertexBuffer;this._vertexStride=vertexStride;this._vertices=vertices;this.mesh=mesh;};_proto._updateStrapVertices=function _updateStrapVertices(camera,points){var m=camera.viewMatrix;var e=m.elements;var vx=new Vector3(e[0],e[4],e[8]);var vy=new Vector3(e[1],e[5],e[9]);var vz=new Vector3(e[2],e[6],e[10]);var s=this._stroke;vy.scale(s);var up=new Vector3();var down=new Vector3();var rotation=new Quaternion();Vector3.transformByQuat(vx,rotation,vx);Vector3.transformByQuat(vy,rotation,vy);var dy=new Vector3();var cross=new Vector3();var perpVector=new Vector3();vx.normalize();var vertices=this._vertices;//-- quad pos
  for(var i=0;i<this._maxPointNum;i++){//-- center pos
  if(i<this._curPointNum){var p=points[i];if(i===this._curPointNum-1&&i!==0){Vector3.subtract(p,points[i-1],perpVector);}else {Vector3.subtract(points[i+1],p,perpVector);}this._projectOnPlane(perpVector,vz,perpVector);perpVector.normalize();// Calculate angle between vectors
  var angle=Math.acos(Vector3.dot(vx,perpVector));Vector3.cross(vx,perpVector,cross);if(Vector3.dot(cross,vz)<=0){angle=Math.PI*2-angle;}Quaternion.rotationAxisAngle(vz,angle,rotation);Vector3.transformByQuat(vy,rotation,dy);Vector3.add(p,dy,up);Vector3.subtract(p,dy,down);}var p0=i*2*this._vertexStride/4;var p1=(i*2+1)*this._vertexStride/4;vertices[p0]=up.x;vertices[p0+1]=up.y;vertices[p0+2]=up.z;vertices[p1]=down.x;vertices[p1+1]=down.y;vertices[p1+2]=down.z;}};_proto._updateStrapCoords=function _updateStrapCoords(){if(this._prePointsNum===this._curPointNum){return;}this._prePointsNum=this._curPointNum;var count=this._curPointNum;var texDelta=1.0/count;var vertices=this._vertices;for(var i=0;i<count;i++){var d=1.0-i*texDelta;var p0=i*2*this._vertexStride/4;var p1=(i*2+1)*this._vertexStride/4;vertices[p0]=0;vertices[p0+1]=d;vertices[p1]=1.0;vertices[p1+1]=d;}};_proto._projectOnVector=function _projectOnVector(a,p,out){var n_p=p.clone();Vector3.normalize(n_p,n_p);var cosine=Vector3.dot(a,n_p);out.x=n_p.x*cosine;out.y=n_p.y*cosine;out.z=n_p.z*cosine;};_proto._projectOnPlane=function _projectOnPlane(a,n,out){this._projectOnVector(a,n,_tempVector3);Vector3.subtract(a,_tempVector3,out);};return TrailRenderer;}(MeshRenderer);/**
   * Fog.
   */var Fog=/*#__PURE__*/function(_Component){_inheritsLoose$2(Fog,_Component);/**
     * @internal
     */function Fog(entity){var _this;_this=_Component.call(this,entity)||this;_this._color=new Color(1,0,0,1);_this.color=_this._color;return _this;}/**
     * @internal
     * @override
     */var _proto=Fog.prototype;_proto._onEnable=function _onEnable(){this.scene.shaderData.enableMacro("O3_HAS_FOG");}/**
     * @internal
     * @override
     */;_proto._onDisable=function _onDisable(){this.scene.shaderData.disableMacro("O3_HAS_FOG");};_createClass$3(Fog,[{key:"color",get:/**
       * Fog color.
       */function get(){return this._color;},set:function set(value){this._color=value;this.scene.shaderData.setColor(Fog._colorProperty,value);}}]);return Fog;}(Component);Fog._colorProperty=Shader.getPropertyByName("u_fogColor");/**
   * Exponential fog.
   */var EXP2Fog=/*#__PURE__*/function(_Fog){_inheritsLoose$2(EXP2Fog,_Fog);function EXP2Fog(entity){var _this;_this=_Fog.call(this,entity)||this;_this._density=0.0025;_this.density=_this._density;return _this;}/**
     * @internal
     * @override
     */var _proto=EXP2Fog.prototype;_proto._onEnable=function _onEnable(){this.scene.shaderData.enableMacro("O3_FOG_EXP2");}/**
     * @internal
     * @override
     */;_proto._onDisable=function _onDisable(){this.scene.shaderData.disableMacro("O3_FOG_EXP2");};_createClass$3(EXP2Fog,[{key:"density",get:/**
       * Density of fog.
       */function get(){return this._density;},set:function set(value){this._density=value;this.scene.shaderData.setFloat(EXP2Fog._densityProperty,value);}}]);return EXP2Fog;}(Fog);EXP2Fog._densityProperty=Shader.getPropertyByName("u_fogDensity");/**
   * Linear fog, according to the distance of the camera linear difference fog density.
   */var LinearFog=/*#__PURE__*/function(_Fog){_inheritsLoose$2(LinearFog,_Fog);function LinearFog(entity){var _this;_this=_Fog.call(this,entity)||this;_this._near=1;_this._far=1000;_this.near=_this._near;_this.far=_this._far;return _this;}_createClass$3(LinearFog,[{key:"near",get:/**
       * Start of fog.
       */function get(){return this._near;},set:function set(value){this._near=value;this.scene.shaderData.setFloat(LinearFog._nearProperty,value);}/**
       * End of fog.
       */},{key:"far",get:function get(){return this._far;},set:function set(value){this._far=value;this.scene.shaderData.setFloat(LinearFog._farProperty,value);}}]);return LinearFog;}(Fog);LinearFog._nearProperty=Shader.getPropertyByName("u_fogNear");LinearFog._farProperty=Shader.getPropertyByName("u_fogFar");/**
   * Environmental probes, providing necessary capabilities such as reflection and refraction.
   * @example
   * ```ts
   * const probe = cameraEntity.addComponent( CubeProbe )
   * probe.onTextureChange = cubeTexture => {
   *   envLight.specularTexture = cubeTexture;
   *   skybox.specularTexture = cubeTexture;
   * }
   * ```
   */var Probe=/*#__PURE__*/function(_Script){_inheritsLoose$2(Probe,_Script);function Probe(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Script.call.apply(_Script,[this].concat(args))||this;_this.probeLayer=exports.Layer.Everything;_this.width=1024;_this.height=1024;_this.antiAliasing=1;_this._isCube=false;_this._oriCameraRenderTarget=void 0;_this._renderTarget=void 0;_this._renderTargetSwap=void 0;_this._activeRenderTarget=void 0;_this._camera=void 0;_this._oriCameraCullingMask=void 0;return _this;}var _proto=Probe.prototype;/**
     * Provide hooks for users to exchange Texture.
     * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.
     */_proto.onTextureChange=function onTextureChange(renderColorTexture){}/**
     * @override
     */;_proto.onBeginRender=function onBeginRender(camera){if(!this.enabled)return;this._camera=camera;this._oriCameraCullingMask=camera.cullingMask;camera.cullingMask=this.probeLayer;if(!this._activeRenderTarget||this._activeRenderTarget.width!==this.width||this._activeRenderTarget.height!==this.height||this._activeRenderTarget.antiAliasing!==this.antiAliasing){this._renderTarget=new RenderTarget(this.engine,this.width,this.height,this._isCube?new TextureCube(this.engine,this.width):new Texture2D(this.engine,this.width,this.height),exports.RenderBufferDepthFormat.Depth,this.antiAliasing);this._renderTargetSwap=new RenderTarget(this.engine,this.width,this.height,this._isCube?new TextureCube(this.engine,this.width):new Texture2D(this.engine,this.width,this.height),exports.RenderBufferDepthFormat.Depth,this.antiAliasing);this._activeRenderTarget=this._renderTarget;}this._oriCameraRenderTarget=camera.renderTarget;camera.renderTarget=this._activeRenderTarget;}/**
     * @override
     */;_proto.onEndRender=function onEndRender(camera){if(!this.enabled)return;this.onTextureChange&&this.onTextureChange(this._texture);this._activeRenderTarget=this._activeRenderTarget===this._renderTarget?this._renderTargetSwap:this._renderTarget;};_proto._reset=function _reset(){if(!this.enabled)return;this._camera.renderTarget=this._oriCameraRenderTarget;this._camera.cullingMask=this._oriCameraCullingMask;};_createClass$3(Probe,[{key:"_texture",get:function get(){var _this$_activeRenderTa;return (_this$_activeRenderTa=this._activeRenderTarget)===null||_this$_activeRenderTa===void 0?void 0:_this$_activeRenderTa.getColorTexture();}}]);return Probe;}(Script);var cacheTarget=new Vector3();var cacheUp=new Vector3();var cacheDir=new Vector3();/**
   * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.
   */var CubeProbe=/*#__PURE__*/function(_Probe){_inheritsLoose$2(CubeProbe,_Probe);function CubeProbe(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Probe.call.apply(_Probe,[this].concat(args))||this;_this.position=new Vector3(0,0,0);_this._isCube=true;_this.oriViewMatrix=new Matrix();_this._oriFieldOfView=void 0;return _this;}var _proto=CubeProbe.prototype;/**
     * @override
     */_proto.onBeginRender=function onBeginRender(camera){if(!this.enabled)return;_Probe.prototype.onBeginRender.call(this,camera);this._storeCamera(camera);// Render 6 faces
  for(var faceIndex=0;faceIndex<6;faceIndex++){// Change camera parameters
  this._setCamera(faceIndex,camera);camera.render(exports.TextureCubeFace.PositiveX+faceIndex);}this._restoreCamera(camera);_Probe.prototype._reset.call(this);}/**
     * Store original camera parameters.
     */;_proto._storeCamera=function _storeCamera(camera){this.oriViewMatrix.copyFrom(camera.viewMatrix);this._oriFieldOfView=camera.fieldOfView;}/**
     * Restore camera parameters.
     */;_proto._restoreCamera=function _restoreCamera(camera){camera.viewMatrix.copyFrom(this.oriViewMatrix);camera.fieldOfView=this._oriFieldOfView;}/**
     * Set camera parameters according to the rendering surface.
     */;_proto._setCamera=function _setCamera(faceIndex,camera){switch(faceIndex){// positive_x
  case 0:cacheUp.set(0,-1,0);cacheDir.set(1,0,0);break;// negative_x
  case 1:cacheUp.set(0,-1,0);cacheDir.set(-1,0,0);break;// positive_y
  case 2:cacheUp.set(0,0,1);cacheDir.set(0,1,0);break;// negative_y
  case 3:cacheUp.set(0,0,-1);cacheDir.set(0,-1,0);break;// positive_z
  case 4:cacheUp.set(0,-1,0);cacheDir.set(0,0,1);break;// negative_z
  case 5:cacheUp.set(0,-1,0);cacheDir.set(0,0,-1);break;}Vector3.add(this.position,cacheDir,cacheTarget);Matrix.lookAt(this.position,cacheTarget,cacheUp,camera.viewMatrix);camera.fieldOfView=90;};return CubeProbe;}(Probe);/**
   * Shadow manager.
   */var LightShadow=/*#__PURE__*/function(){/**
     * @internal
     */LightShadow._updateShaderData=function _updateShaderData(shaderData){var data=LightShadow._combinedData;shaderData.setFloatArray(LightShadow._viewMatFromLightProperty,data.viewMatrix);shaderData.setFloatArray(LightShadow._projMatFromLightProperty,data.projectionMatrix);shaderData.setFloatArray(LightShadow._shadowBiasProperty,data.bias);shaderData.setFloatArray(LightShadow._shadowIntensityProperty,data.intensity);shaderData.setFloatArray(LightShadow._shadowRadiusProperty,data.radius);shaderData.setFloatArray(LightShadow._shadowMapSizeProperty,data.mapSize);shaderData.setTextureArray(LightShadow._shadowMapsProperty,data.map);}/**
     * Clear all shadow maps.
     */;LightShadow.clearMap=function clearMap(){LightShadow._combinedData.map.length=0;};function LightShadow(light,props){if(props===void 0){props={engine:null,width:512,height:512};}this._mapSize=void 0;this._renderTarget=void 0;this.light=void 0;this.bias=0.005;this.intensity=0.2;this.radius=1;this.projectionMatrix=new Matrix();this.light=light;var _props=props,engine=_props.engine,width=_props.width,height=_props.height;this._mapSize=new Vector2(width,height);this._renderTarget=new RenderTarget(engine,width,height,new Texture2D(engine,width,height));}/**
     * The RenderTarget corresponding to the shadow map.
     */var _proto=LightShadow.prototype;/**
     * Initialize the projection matrix for lighting.
     * @param light - The light to generate shadow
     */_proto.initShadowProjectionMatrix=function initShadowProjectionMatrix(light){/**
       * Directional light projection matrix, the default coverage area is left: -5, right: 5, bottom: -5, up: 5, near: 0.5, far: 50.
       */if(light instanceof DirectLight){Matrix.ortho(-5,5,-5,5,0.1,50,this.projectionMatrix);}/**
       * Point light projection matrix, default configuration: fov: 50, aspect: 1, near: 0.5, far: 50.
       */if(light instanceof PointLight){Matrix.perspective(MathUtil.degreeToRadian(50),1,0.5,50,this.projectionMatrix);}/**
       * Spotlight projection matrix, the default configuration: fov: this.angle * 2 * Math.sqrt(2), aspect: 1, near: 0.1, far: this.distance + 5
       */if(light instanceof SpotLight){var fov=Math.min(Math.PI/2,light.angle*2*Math.sqrt(2));Matrix.perspective(fov,1,0.1,light.distance+5,this.projectionMatrix);}};_proto.appendData=function appendData(lightIndex){var viewStart=lightIndex*16;var projectionStart=lightIndex*16;var biasStart=lightIndex;var intensityStart=lightIndex;var radiusStart=lightIndex;var mapSizeStart=lightIndex*2;var mapStart=lightIndex;var data=LightShadow._combinedData;data.viewMatrix.set(this.light.viewMatrix.elements,viewStart);data.projectionMatrix.set(this.projectionMatrix.elements,projectionStart);data.bias[biasStart]=this.bias;data.intensity[intensityStart]=this.intensity;data.radius[radiusStart]=this.radius;data.mapSize[mapSizeStart]=this.mapSize.x;data.mapSize[mapSizeStart+1]=this.mapSize.y;data.map[mapStart]=this.map;};_createClass$3(LightShadow,[{key:"renderTarget",get:function get(){return this._renderTarget;}/**
       * Shadow map's color render texture.
       */},{key:"map",get:function get(){return this._renderTarget.getColorTexture();}/**
       * Shadow map size.
       */},{key:"mapSize",get:function get(){return this._mapSize;}}]);return LightShadow;}();LightShadow._viewMatFromLightProperty=Shader.getPropertyByName("u_viewMatFromLight");LightShadow._projMatFromLightProperty=Shader.getPropertyByName("u_projMatFromLight");LightShadow._shadowBiasProperty=Shader.getPropertyByName("u_shadowBias");LightShadow._shadowIntensityProperty=Shader.getPropertyByName("u_shadowIntensity");LightShadow._shadowRadiusProperty=Shader.getPropertyByName("u_shadowRadius");LightShadow._shadowMapSizeProperty=Shader.getPropertyByName("u_shadowMapSize");LightShadow._shadowMapsProperty=Shader.getPropertyByName("u_shadowMaps");LightShadow._maxLight=3;LightShadow._combinedData={viewMatrix:new Float32Array(16*LightShadow._maxLight),projectionMatrix:new Float32Array(16*LightShadow._maxLight),bias:new Float32Array(LightShadow._maxLight),intensity:new Float32Array(LightShadow._maxLight),radius:new Float32Array(LightShadow._maxLight),mapSize:new Float32Array(2*LightShadow._maxLight),map:[]};/**
   * Set whether the light to generate shadows.
   */Object.defineProperty(Light.prototype,"enableShadow",{get:function get(){return this._enableShadow;},set:function set(enabled){this._enableShadow=enabled;if(this._enableShadow){if(this instanceof AmbientLight){this._enableShadow=false;Logger.warn("Has no shadow!");return;}this.shadow=this.shadow||new LightShadow(this,{engine:this.engine,width:512,height:512});this.shadow.initShadowProjectionMatrix(this);}}});/**
   * Set whether the renderer to receive shadows.
   */Object.defineProperty(Component.prototype,"receiveShadow",{get:function get(){return this._receiveShadow;},set:function set(enabled){this._receiveShadow=enabled;}});/**
   * Set whether the renderer to cast shadows.
   */Object.defineProperty(Component.prototype,"castShadow",{get:function get(){return this._castShadow;},set:function set(enabled){this._castShadow=enabled;}});/**
   * Shadow Map material.
   */var ShadowMapMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(ShadowMapMaterial,_Material);function ShadowMapMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("shadow-map"))||this;_this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");return _this;}return ShadowMapMaterial;}(Material);/**
   * RenderPass for rendering shadow map.
   */var ShadowMapPass=/*#__PURE__*/function(_RenderPass){_inheritsLoose$2(ShadowMapPass,_RenderPass);/**
     * Constructor.
     * @param light  - The light that the shadow belongs to
     */function ShadowMapPass(name,priority,renderTarget,replaceMaterial,mask,light){var _this;_this=_RenderPass.call(this,name,priority,renderTarget,replaceMaterial,mask)||this;_this.light=void 0;_this.light=light;_this.clearColor=new Color(1,1,1,1);return _this;}/**
     * @override
     */var _proto=ShadowMapPass.prototype;_proto.preRender=function preRender(camera,queue){// The viewProjection matrix from the light.
  var shaderData=this.replaceMaterial.shaderData;shaderData.setMatrix(ShadowMapPass._viewMatFromLightProperty,this.light.viewMatrix);shaderData.setMatrix(ShadowMapPass._projMatFromLightProperty,this.light.shadow.projectionMatrix);};return ShadowMapPass;}(RenderPass);ShadowMapPass._viewMatFromLightProperty=Shader.getPropertyByName("u_viewMatFromLight");ShadowMapPass._projMatFromLightProperty=Shader.getPropertyByName("u_projMatFromLight");/**
   * Shadow material.
   */var ShadowMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(ShadowMaterial,_Material);function ShadowMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("shadow"))||this;var targetBlendState=_this.renderState.blendState.targetBlendState;targetBlendState.enabled=true;targetBlendState.sourceColorBlendFactor=targetBlendState.sourceAlphaBlendFactor=exports.BlendFactor.DestinationColor;targetBlendState.destinationColorBlendFactor=targetBlendState.destinationAlphaBlendFactor=exports.BlendFactor.Zero;_this.renderState.depthState.compareFunction=exports.CompareFunction.LessEqual;_this.renderQueueType=exports.RenderQueueType.Transparent;return _this;}return ShadowMaterial;}(Material);/**
   * RenderPass for rendering shadow.
   */var ShadowPass=/*#__PURE__*/function(_RenderPass){_inheritsLoose$2(ShadowPass,_RenderPass);function ShadowPass(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_RenderPass.call.apply(_RenderPass,[this].concat(args))||this;_this.clearFlags=exports.CameraClearFlags.None;return _this;}/**
     * @override
     */var _proto=ShadowPass.prototype;_proto.preRender=function preRender(camera,queue){this.enabled=false;var lightMgr=camera.scene.findFeature(LightFeature);var lights=lightMgr.visibleLights;var shaderData=this.replaceMaterial.shaderData;// keep render based on default render pass
  var pass=camera._renderPipeline.defaultRenderPass;this.renderTarget=pass.renderTarget;var shadowMapCount=0;LightShadow.clearMap();for(var i=0,len=lights.length;i<len;i++){var lgt=lights[i];if(lgt.enableShadow){lgt.shadow.appendData(shadowMapCount++);}}if(shadowMapCount){this.enabled=true;LightShadow._updateShaderData(shaderData);shaderData.enableMacro("O3_SHADOW_MAP_COUNT",shadowMapCount.toString());}else {shaderData.disableMacro("O3_SHADOW_MAP_COUNT");}};return ShadowPass;}(RenderPass);/**
   * Shadow plug-in.
   */var ShadowFeature=/*#__PURE__*/function(_SceneFeature){_inheritsLoose$2(ShadowFeature,_SceneFeature);function ShadowFeature(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_SceneFeature.call.apply(_SceneFeature,[this].concat(args))||this;_this._shadowPass=void 0;_this._shadowMapMaterial=void 0;return _this;}var _proto=ShadowFeature.prototype;/**
     * @override
     */_proto.preRender=function preRender(scene,camera){var lights=scene.findFeature(LightFeature).visibleLights;if(lights.length>0){// Check RenderPass for rendering shadows.
  if(!this._shadowPass){this.addShadowPass(camera);}// Check RenderPass for rendering shadow map.
  var renderPipeline=camera._renderPipeline;for(var i=0,len=lights.length;i<len;i++){var lgt=lights[i];if(lgt.enableShadow&&!lgt.shadowMapPass){lgt.shadowMapPass=this.addShadowMapPass(camera,lgt);}else if(!lgt.enableShadow&&lgt.shadowMapPass){renderPipeline.removeRenderPass(lgt.shadowMapPass);lgt.shadowMapPass=null;}}this.updatePassRenderFlag(renderPipeline._opaqueQueue);this.updatePassRenderFlag(renderPipeline._alphaTestQueue);this.updatePassRenderFlag(renderPipeline._transparentQueue);}}/**
     * Add RenderPass for rendering shadows.
     * @param camera - The camera for rendering
     */;_proto.addShadowPass=function addShadowPass(camera){var shadowMaterial=new ShadowMaterial(camera.engine);this._shadowPass=new ShadowPass("ShadowPass",1,null,shadowMaterial,exports.Layer.Layer30);// SHADOW
  var renderer=camera._renderPipeline;renderer.addRenderPass(this._shadowPass);}/**
     * Add RenderPass for rendering shadow map.
     * @param camera - The camera for rendering
     * @param light - The light that the shadow belongs to
     */;_proto.addShadowMapPass=function addShadowMapPass(camera,light){// Share shadow map material.
  this._shadowMapMaterial=this._shadowMapMaterial||new ShadowMapMaterial(camera.engine);var shadowMapPass=new ShadowMapPass("ShadowMapPass",-1,light.shadow.renderTarget,this._shadowMapMaterial,exports.Layer.Layer31,// SHADOW_MAP
  light);var renderer=camera._renderPipeline;renderer.addRenderPass(shadowMapPass);return shadowMapPass;}/**
     * Update the renderPassFlag state of renderers in the scene.
     * @param renderQueue - Render queue
     */;_proto.updatePassRenderFlag=function updatePassRenderFlag(renderQueue){var items=renderQueue.items;for(var i=0,len=items.length;i<len;i++){var item=items[i];var component=item.component;var receiveShadow=component.receiveShadow;var castShadow=component.castShadow;if(receiveShadow===true){component.entity.layer|=exports.Layer.Layer30;//SHADOW;
  }else if(receiveShadow===false){component.entity.layer&=~exports.Layer.Layer30;//SHADOW;
  }if(castShadow===true){component.entity.layer|=exports.Layer.Layer31;//SHADOW_MAP;
  }else if(castShadow===false){component.entity.layer&=~exports.Layer.Layer31;//SHADOW_MAP;
  }}};return ShadowFeature;}(SceneFeature);Scene.registerFeature(ShadowFeature);Scene.registerFeature(LightFeature);Scene.prototype.hasLight=hasLight;

  var CoreObjects = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AmbientLight: AmbientLight,
    AnimationClip: AnimationClip,
    AnimationClipCurveBinding: AnimationClipCurveBinding,
    AnimationCurve: AnimationCurve,
    AnimationEvent: AnimationEvent,
    get AnimationProperty () { return exports.AnimationProperty; },
    Animator: Animator,
    get AnimatorConditionMode () { return exports.AnimatorConditionMode; },
    AnimatorController: AnimatorController,
    AnimatorControllerLayer: AnimatorControllerLayer,
    get AnimatorLayerBlendingMode () { return exports.AnimatorLayerBlendingMode; },
    AnimatorState: AnimatorState,
    AnimatorStateMachine: AnimatorStateMachine,
    AnimatorStateTransition: AnimatorStateTransition,
    AssetPromise: AssetPromise,
    get AssetPromiseStatus () { return exports.AssetPromiseStatus; },
    get AssetType () { return exports.AssetType; },
    Background: Background,
    get BackgroundMode () { return exports.BackgroundMode; },
    get BackgroundTextureFillMode () { return exports.BackgroundTextureFillMode; },
    BaseMaterial: BaseMaterial,
    BasicRenderPipeline: BasicRenderPipeline,
    get BlendFactor () { return exports.BlendFactor; },
    get BlendMode () { return exports.BlendMode; },
    get BlendOperation () { return exports.BlendOperation; },
    BlendShape: BlendShape,
    BlendShapeFrame: BlendShapeFrame,
    BlinnPhongMaterial: BlinnPhongMaterial,
    BoolUpdateFlag: BoolUpdateFlag,
    BoxColliderShape: BoxColliderShape,
    Buffer: Buffer,
    get BufferBindFlag () { return exports.BufferBindFlag; },
    BufferMesh: BufferMesh,
    get BufferUsage () { return exports.BufferUsage; },
    BufferUtil: BufferUtil,
    Camera: Camera,
    get CameraClearFlags () { return exports.CameraClearFlags; },
    CapsuleColliderShape: CapsuleColliderShape,
    CharacterController: CharacterController,
    CloneManager: CloneManager,
    Collider: Collider,
    ColliderShape: ColliderShape,
    get ColliderShapeUpAxis () { return exports.ColliderShapeUpAxis; },
    get CollisionDetectionMode () { return exports.CollisionDetectionMode; },
    get ColorSpace () { return exports.ColorSpace; },
    get ColorWriteMask () { return exports.ColorWriteMask; },
    get CompareFunction () { return exports.CompareFunction; },
    Component: Component,
    get ControllerCollisionFlag () { return exports.ControllerCollisionFlag; },
    get ControllerNonWalkableMode () { return exports.ControllerNonWalkableMode; },
    CubeProbe: CubeProbe,
    get CullMode () { return exports.CullMode; },
    get DataType () { return exports.DataType; },
    get DiffuseMode () { return exports.DiffuseMode; },
    DirectLight: DirectLight,
    DynamicCollider: DynamicCollider,
    get DynamicColliderConstraints () { return exports.DynamicColliderConstraints; },
    EXP2Fog: EXP2Fog,
    Engine: Engine,
    EngineFeature: EngineFeature,
    EngineObject: EngineObject,
    Entity: Entity,
    Event: Event,
    EventDispatcher: EventDispatcher,
    FixedJoint: FixedJoint,
    Fog: Fog,
    Font: Font,
    get FontStyle () { return exports.FontStyle; },
    get GLCapabilityType () { return exports.GLCapabilityType; },
    HingeJoint: HingeJoint,
    HitResult: HitResult,
    IndexBufferBinding: IndexBufferBinding,
    get IndexFormat () { return exports.IndexFormat; },
    InputManager: InputManager,
    InterpolableKeyframe: InterpolableKeyframe,
    get InterpolableValueType () { return exports.InterpolableValueType; },
    get InterpolationType () { return exports.InterpolationType; },
    Joint: Joint,
    JointLimits: JointLimits,
    JointMotor: JointMotor,
    Keyframe: Keyframe,
    get Keys () { return exports.Keys; },
    get Layer () { return exports.Layer; },
    Light: Light,
    LinearFog: LinearFog,
    ListenerUpdateFlag: ListenerUpdateFlag,
    Loader: Loader,
    Logger: Logger,
    Material: Material,
    Mesh: Mesh,
    MeshRenderElement: MeshRenderElement,
    MeshRenderer: MeshRenderer,
    get MeshTopology () { return exports.MeshTopology; },
    ModelMesh: ModelMesh,
    ObjectValues: ObjectValues,
    get OverflowMode () { return exports.OverflowMode; },
    PBRBaseMaterial: PBRBaseMaterial,
    PBRMaterial: PBRMaterial,
    PBRSpecularMaterial: PBRSpecularMaterial,
    ParticleRenderer: ParticleRenderer,
    get ParticleRendererBlendMode () { return exports.ParticleRendererBlendMode; },
    PhysicsManager: PhysicsManager,
    PhysicsMaterial: PhysicsMaterial,
    get PhysicsMaterialCombineMode () { return exports.PhysicsMaterialCombineMode; },
    PlaneColliderShape: PlaneColliderShape,
    PointLight: PointLight,
    Pointer: Pointer,
    get PointerButton () { return exports.PointerButton; },
    get PointerPhase () { return exports.PointerPhase; },
    PrimitiveMesh: PrimitiveMesh,
    Probe: Probe,
    RefObject: RefObject,
    get RenderBufferDepthFormat () { return exports.RenderBufferDepthFormat; },
    get RenderFace () { return exports.RenderFace; },
    RenderPass: RenderPass,
    RenderQueue: RenderQueue,
    get RenderQueueType () { return exports.RenderQueueType; },
    RenderTarget: RenderTarget,
    Renderer: Renderer,
    ResourceManager: ResourceManager,
    Scene: Scene,
    SceneFeature: SceneFeature,
    SceneManager: SceneManager,
    Script: Script,
    get SetDataOptions () { return exports.SetDataOptions; },
    Shader: Shader,
    ShaderData: ShaderData,
    ShaderFactory: ShaderFactory,
    ShaderProperty: ShaderProperty,
    get ShaderPropertyType () { return exports.ShaderPropertyType; },
    Skin: Skin,
    SkinnedMeshRenderer: SkinnedMeshRenderer,
    Sky: Sky,
    SkyBoxMaterial: SkyBoxMaterial,
    SphereColliderShape: SphereColliderShape,
    SpotLight: SpotLight,
    SpringJoint: SpringJoint,
    Sprite: Sprite,
    SpriteAtlas: SpriteAtlas,
    get SpriteDrawMode () { return exports.SpriteDrawMode; },
    SpriteElement: SpriteElement,
    SpriteMask: SpriteMask,
    get SpriteMaskInteraction () { return exports.SpriteMaskInteraction; },
    get SpriteMaskLayer () { return exports.SpriteMaskLayer; },
    SpriteRenderer: SpriteRenderer,
    StateMachineScript: StateMachineScript,
    StaticCollider: StaticCollider,
    get StencilOperation () { return exports.StencilOperation; },
    SubMesh: SubMesh,
    SystemInfo: SystemInfo,
    get TextHorizontalAlignment () { return exports.TextHorizontalAlignment; },
    TextRenderer: TextRenderer,
    get TextVerticalAlignment () { return exports.TextVerticalAlignment; },
    Texture: Texture,
    Texture2D: Texture2D,
    Texture2DArray: Texture2DArray,
    get TextureCoordinate () { return exports.TextureCoordinate; },
    TextureCube: TextureCube,
    get TextureCubeFace () { return exports.TextureCubeFace; },
    get TextureFilterMode () { return exports.TextureFilterMode; },
    get TextureFormat () { return exports.TextureFormat; },
    get TextureWrapMode () { return exports.TextureWrapMode; },
    Time: Time,
    TrailMaterial: TrailMaterial,
    TrailRenderer: TrailRenderer,
    Transform: Transform,
    UnlitMaterial: UnlitMaterial,
    Util: Util,
    VertexBufferBinding: VertexBufferBinding,
    VertexElement: VertexElement,
    get VertexElementFormat () { return exports.VertexElementFormat; },
    get WrapMode () { return exports.WrapMode; },
    assignmentClone: assignmentClone,
    deepClone: deepClone,
    dependentComponents: dependentComponents,
    ignoreClone: ignoreClone,
    request: request,
    resourceLoader: resourceLoader,
    shallowClone: shallowClone
  });

  /**
   * Smoothing plug-in.
   * */

  /**
   * @deprecated
   */
  exports.GLCompressedTextureInternalFormat = void 0;
  (function (GLCompressedTextureInternalFormat) {
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["R11_EAC"] = 37488] = "R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 37490] = "RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
  })(exports.GLCompressedTextureInternalFormat || (exports.GLCompressedTextureInternalFormat = {}));
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }
  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$1(o, p);
  }

  /**
   * The canvas used on the web, which can support HTMLCanvasElement and OffscreenCanvas.
   */
  var WebCanvas = /*#__PURE__*/function () {
    var _proto = WebCanvas.prototype;
    /**
     * Resize the rendering size according to the clientWidth and clientHeight of the canvas.
     * @param pixelRatio - Pixel ratio
     */
    _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
      if (pixelRatio === void 0) {
        pixelRatio = window.devicePixelRatio;
      }
      var webCanvas = this._webCanvas;
      if (typeof OffscreenCanvas === "undefined" || !(webCanvas instanceof OffscreenCanvas)) {
        this.width = webCanvas.clientWidth * pixelRatio;
        this.height = webCanvas.clientHeight * pixelRatio;
      }
    }

    /**
     * Create a web canvas.
     * @param webCanvas - Web native canvas
     */;
    function WebCanvas(webCanvas) {
      this._webCanvas = void 0;
      this._width = void 0;
      this._height = void 0;
      this._scale = new Vector2();
      var width = webCanvas.width;
      var height = webCanvas.height;
      this._webCanvas = webCanvas;
      this._width = width;
      this._height = height;
    }

    /**
     * Set scale.
     * @param x - Scale along the X axis
     * @param y - Scale along the Y axis
     */
    _proto.setScale = function setScale(x, y) {
      this._scale.set(x, y);
      this.scale = this._scale;
    };
    _createClass$2(WebCanvas, [{
      key: "width",
      get:
      /**
       * @inheritdoc
       */
      function get() {
        return this._width;
      },
      set: function set(value) {
        if (this._width !== value) {
          this._webCanvas.width = value;
          this._width = value;
        }
      }

      /**
       * @inheritdoc
       */
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        if (this._height !== value) {
          this._webCanvas.height = value;
          this._height = value;
        }
      }

      /**
       * The scale of canvas, the value is visible width/height divide the render width/height.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */
    }, {
      key: "scale",
      get: function get() {
        var webCanvas = this._webCanvas;
        if (typeof OffscreenCanvas === "undefined" || !(webCanvas instanceof OffscreenCanvas)) {
          this._scale.set(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
        }
        return this._scale;
      },
      set: function set(value) {
        var webCanvas = this._webCanvas;
        if (typeof OffscreenCanvas === "undefined" || !(webCanvas instanceof OffscreenCanvas)) {
          webCanvas.style.transformOrigin = "left top";
          webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
        }
      }
    }]);
    return WebCanvas;
  }();

  /**
   * GL capability.
   */
  var GLCapability = /*#__PURE__*/function () {
    function GLCapability(rhi) {
      this._maxDrawBuffers = void 0;
      this._maxAnisoLevel = void 0;
      this._maxAntiAliasing = void 0;
      this._rhi = void 0;
      this.capabilityList = void 0;
      this._rhi = rhi;
      this.capabilityList = new Map();
      this._init();
      this._compatibleAllInterface();
    }

    /**
     * Check device capabilities.
     */
    var _proto = GLCapability.prototype;
    _proto.canIUse = function canIUse(capabilityType) {
      return this.capabilityList.get(capabilityType);
    }

    /**
     * Check if can use some compressed texture format.
     */;
    _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
      var RGBA_ASTC_4X4_KHR = exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
        RGBA_ASTC_12X12_KHR = exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
        SRGB8_ALPHA8_ASTC_4X4_KHR = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR,
        SRGB8_ALPHA8_ASTC_12X12_KHR = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR,
        RGB_ETC1_WEBGL = exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
        R11_EAC = exports.GLCompressedTextureInternalFormat.R11_EAC,
        SRGB8_ALPHA8_ETC2_EAC = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC,
        RGB_PVRTC_4BPPV1_IMG = exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
        RGBA_PVRTC_2BPPV1_IMG = exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
        RGB_S3TC_DXT1_EXT = exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
        RGBA_S3TC_DXT5_EXT = exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;
      if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
        return this.canIUse(exports.GLCapabilityType.astc);
      } else if (internalType === RGB_ETC1_WEBGL) {
        return this.canIUse(exports.GLCapabilityType.etc1);
      } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
        return this.canIUse(exports.GLCapabilityType.etc);
      } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
        return this.canIUse(exports.GLCapabilityType.pvrtc);
      } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
        return this.canIUse(exports.GLCapabilityType.s3tc);
      }
      return false;
    }

    /**
     *  Init capabilities.
     */;
    _proto._init = function _init() {
      var cap = this.capabilityList;
      var isWebGL2 = this.rhi.isWebGL2;
      var requireExtension = this.rhi.requireExtension.bind(this.rhi);
      var shaderVertexID = exports.GLCapabilityType.shaderVertexID,
        standardDerivatives = exports.GLCapabilityType.standardDerivatives,
        shaderTextureLod = exports.GLCapabilityType.shaderTextureLod,
        elementIndexUint = exports.GLCapabilityType.elementIndexUint,
        depthTexture = exports.GLCapabilityType.depthTexture,
        vertexArrayObject = exports.GLCapabilityType.vertexArrayObject,
        instancedArrays = exports.GLCapabilityType.instancedArrays,
        multipleSample = exports.GLCapabilityType.multipleSample,
        drawBuffers = exports.GLCapabilityType.drawBuffers,
        astc = exports.GLCapabilityType.astc,
        astc_webkit = exports.GLCapabilityType.astc_webkit,
        etc = exports.GLCapabilityType.etc,
        etc_webkit = exports.GLCapabilityType.etc_webkit,
        etc1 = exports.GLCapabilityType.etc1,
        etc1_webkit = exports.GLCapabilityType.etc1_webkit,
        pvrtc = exports.GLCapabilityType.pvrtc,
        pvrtc_webkit = exports.GLCapabilityType.pvrtc_webkit,
        s3tc = exports.GLCapabilityType.s3tc,
        s3tc_webkit = exports.GLCapabilityType.s3tc_webkit,
        textureFloat = exports.GLCapabilityType.textureFloat,
        textureHalfFloat = exports.GLCapabilityType.textureHalfFloat,
        textureFloatLinear = exports.GLCapabilityType.textureFloatLinear,
        textureHalfFloatLinear = exports.GLCapabilityType.textureHalfFloatLinear,
        WEBGL_colorBufferFloat = exports.GLCapabilityType.WEBGL_colorBufferFloat,
        colorBufferFloat = exports.GLCapabilityType.colorBufferFloat,
        colorBufferHalfFloat = exports.GLCapabilityType.colorBufferHalfFloat,
        textureFilterAnisotropic = exports.GLCapabilityType.textureFilterAnisotropic;
      cap.set(shaderVertexID, isWebGL2);
      cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
      cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
      cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
      cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
      cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
      cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
      cap.set(multipleSample, isWebGL2);
      cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
      cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
      cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
      cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
      cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
      cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
      cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
      cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
      cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
      cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
      cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
      cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
      cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
    }

    /**
     * If there are extensions that can supplement this ability, smooth out the difference.
     * @example
     * compatible(GLCapabilityType.depthTexture,{
     *    UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
     * })
     * gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL
     */;
    _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
      var rhi = this.rhi;
      var gl = rhi.gl;
      var ext = null;
      if (ext = rhi.requireExtension(capabilityType)) {
        for (var _glKey in flatItem) {
          var _extensionKey = flatItem[_glKey];
          var extensionVal = ext[_extensionKey];

          // Mini game hack the native function,use â€œ.bindâ€ to smooth out if is â€œFuncionâ€.
          if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
            gl[_glKey] = extensionVal.bind(ext);
          } else {
            gl[_glKey] = extensionVal;
          }
        }
      }
    };
    _proto._compatibleAllInterface = function _compatibleAllInterface() {
      var depthTexture = exports.GLCapabilityType.depthTexture,
        vertexArrayObject = exports.GLCapabilityType.vertexArrayObject,
        instancedArrays = exports.GLCapabilityType.instancedArrays,
        drawBuffers = exports.GLCapabilityType.drawBuffers,
        textureFilterAnisotropic = exports.GLCapabilityType.textureFilterAnisotropic,
        textureHalfFloat = exports.GLCapabilityType.textureHalfFloat,
        colorBufferHalfFloat = exports.GLCapabilityType.colorBufferHalfFloat,
        WEBGL_colorBufferFloat = exports.GLCapabilityType.WEBGL_colorBufferFloat;
      var isWebGL2 = this.rhi.isWebGL2;
      if (!isWebGL2) {
        this._compatibleInterface(depthTexture, {
          UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
        });
        this._compatibleInterface(vertexArrayObject, {
          createVertexArray: "createVertexArrayOES",
          deleteVertexArray: "deleteVertexArrayOES",
          isVertexArray: "isVertexArrayOES",
          bindVertexArray: "bindVertexArrayOES"
        });
        this._compatibleInterface(instancedArrays, {
          drawArraysInstanced: "drawArraysInstancedANGLE",
          drawElementsInstanced: "drawElementsInstancedANGLE",
          vertexAttribDivisor: "vertexAttribDivisorANGLE"
        });
        this._compatibleInterface(drawBuffers, {
          MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
        });
        var items = {};
        if (this.canIUse(exports.GLCapabilityType.drawBuffers)) {
          var maxDrawBuffers = this.maxDrawBuffers;
          for (var i = 0; i < maxDrawBuffers; i++) {
            i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
            items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
          }
          this._compatibleInterface(drawBuffers, _objectSpread2$1({
            drawBuffers: "drawBuffersWEBGL"
          }, items));
        }
        this._compatibleInterface(textureHalfFloat, {
          HAFL_FLOAT: "HALF_FLOAT_OES"
        });
        this._compatibleInterface(colorBufferHalfFloat, {
          RGBA16F: "RBGA16F_EXT"
        });
        this._compatibleInterface(WEBGL_colorBufferFloat, {
          RGBA32F: "RBGA32F_EXT"
        });
      }
      this._compatibleInterface(textureFilterAnisotropic, {
        TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
      });
    };
    _createClass$2(GLCapability, [{
      key: "maxTextureSize",
      get: function get() {
        return this.rhi.renderStates.getParameter(this.rhi.gl.MAX_TEXTURE_SIZE);
      }
    }, {
      key: "canUseFloatTextureBlendShape",
      get: function get() {
        return this.canIUse(exports.GLCapabilityType.shaderVertexID) && this.canIUse(exports.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }

      /**
       * Whether can use more joints.
       */
    }, {
      key: "canIUseMoreJoints",
      get: function get() {
        return this.canIUse(exports.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }
    }, {
      key: "maxDrawBuffers",
      get: function get() {
        if (!this._maxDrawBuffers) {
          if (this.canIUse(exports.GLCapabilityType.drawBuffers)) {
            this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
          } else {
            this._maxDrawBuffers = 1;
          }
        }
        return this._maxDrawBuffers;
      }

      /**
       * Max anisoLevel.
       */
    }, {
      key: "maxAnisoLevel",
      get: function get() {
        if (!this._maxAnisoLevel) {
          var ext = this._rhi.requireExtension(exports.GLCapabilityType.textureFilterAnisotropic);
          this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
        }
        return this._maxAnisoLevel;
      }

      /**
       * Max MSAA count.
       */
    }, {
      key: "maxAntiAliasing",
      get: function get() {
        if (!this._maxAntiAliasing) {
          var gl = this._rhi.gl;
          var canMSAA = this.canIUse(exports.GLCapabilityType.multipleSample);
          this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
        }
        return this._maxAntiAliasing;
      }
    }, {
      key: "rhi",
      get: function get() {
        return this._rhi;
      }
    }]);
    return GLCapability;
  }();

  /**
   * GLContext extension.
   */
  var GLExtensions = /*#__PURE__*/function () {
    function GLExtensions(rhi) {
      this.rhi = void 0;
      this._requireResult = void 0;
      this.rhi = rhi;
      this._requireResult = {};
    }

    /**
     * Require an extension.
     */
    var _proto = GLExtensions.prototype;
    _proto.requireExtension = function requireExtension(ext) {
      if (this._requireResult[ext] !== undefined) {
        return this._requireResult[ext];
      }
      this._requireResult[ext] = this.rhi.gl.getExtension(ext);
      return this._requireResult[ext];
    };
    return GLExtensions;
  }();

  /**
   * Improvement of VAO:
   * 1) WebGL2.0 must support VAO, almost all devices support vao extensions in webgl1.0, we can use PollyFill,only keep VAO mode.
   * 2) VAO implementation now has bugs, change IndexBufferã€VertexBufferã€VertexElements need to update VAO.
   */

  /**
   * @internal
   * GL platform primitive.
   */
  var GLPrimitive = /*#__PURE__*/function () {
    function GLPrimitive(rhi, primitive) {
      this.attribLocArray = [];
      this._primitive = void 0;
      this.canUseInstancedArrays = void 0;
      this.gl = void 0;
      this.vao = new Map();
      this._useVao = void 0;
      this._primitive = primitive;
      this.canUseInstancedArrays = rhi.canIUse(exports.GLCapabilityType.instancedArrays);
      this._useVao = rhi.canIUse(exports.GLCapabilityType.vertexArrayObject);
      this.gl = rhi.gl;
    }

    /**
     * Draw the primitive.
     */
    var _proto = GLPrimitive.prototype;
    _proto.draw = function draw(shaderProgram, subMesh) {
      var gl = this.gl;
      var primitive = this._primitive;
      // @ts-ignore
      var useVao = this._useVao && primitive._enableVAO;
      if (useVao) {
        if (!this.vao.has(shaderProgram.id)) {
          this.registerVAO(shaderProgram);
        }
        var vao = this.vao.get(shaderProgram.id);
        gl.bindVertexArray(vao);
      } else {
        this.bindBufferAndAttrib(shaderProgram);
      }

      // @ts-ignore
      var _indexBufferBinding = primitive._indexBufferBinding,
        _instanceCount = primitive._instanceCount,
        _glIndexType = primitive._glIndexType,
        _glIndexByteCount = primitive._glIndexByteCount;
      var topology = subMesh.topology,
        start = subMesh.start,
        count = subMesh.count;
      if (!_instanceCount) {
        if (_indexBufferBinding) {
          if (useVao) {
            gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
          } else {
            var _nativeBuffer = _indexBufferBinding.buffer._nativeBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
            gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArrays(topology, start, count);
        }
      } else {
        if (this.canUseInstancedArrays) {
          if (_indexBufferBinding) {
            if (this._useVao) {
              gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
            } else {
              var _nativeBuffer2 = _indexBufferBinding.buffer._nativeBuffer;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
              gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }
          } else {
            gl.drawArraysInstanced(topology, start, count, _instanceCount);
          }
        } else {
          Logger.error("ANGLE_instanced_arrays extension is not supported");
        }
      }

      // unbind
      if (this._useVao) {
        gl.bindVertexArray(null);
      } else {
        this.disableAttrib();
      }
    };
    _proto.destroy = function destroy() {
      if (this._useVao) {
        var gl = this.gl;
        this.vao.forEach(function (vao) {
          gl.deleteVertexArray(vao);
        });
        this.vao.clear();
      }
    }

    /**
     * Bind buffer and attribute.
     */;
    _proto.bindBufferAndAttrib = function bindBufferAndAttrib(shaderProgram) {
      var gl = this.gl;
      var primitive = this._primitive;
      // @ts-ignore
      var vertexBufferBindings = primitive._vertexBufferBindings;
      this.attribLocArray.length = 0;
      var attributeLocation = shaderProgram.attributeLocation;
      var attributes = primitive._vertexElementMap;
      var vbo;
      var lastBoundVbo;
      for (var name in attributeLocation) {
        var loc = attributeLocation[name];
        if (loc === -1) continue;
        var element = attributes[name];
        if (element) {
          var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex],
            buffer = _vertexBufferBindings.buffer,
            stride = _vertexBufferBindings.stride;
          vbo = buffer._nativeBuffer;
          // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.
          if (lastBoundVbo !== vbo) {
            lastBoundVbo = vbo;
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          }
          gl.enableVertexAttribArray(loc);
          var elementInfo = element._glElementInfo;
          gl.vertexAttribPointer(loc, elementInfo.size, elementInfo.type, elementInfo.normalized, stride, element.offset);
          if (this.canUseInstancedArrays) {
            gl.vertexAttribDivisor(loc, element.instanceStepRate);
          }
          this.attribLocArray.push(loc);
        } else {
          Logger.warn("vertex attribute not found: " + name);
        }
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    };
    _proto.disableAttrib = function disableAttrib() {
      var gl = this.gl;
      for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
        gl.disableVertexAttribArray(this.attribLocArray[i]);
      }
    };
    _proto.registerVAO = function registerVAO(shaderProgram) {
      var gl = this.gl;
      var vao = gl.createVertexArray();

      /** register VAO */
      gl.bindVertexArray(vao);

      // @ts-ignore
      var _indexBufferBinding = this._primitive._indexBufferBinding;
      if (_indexBufferBinding) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._nativeBuffer);
      }
      this.bindBufferAndAttrib(shaderProgram);

      /** unbind */
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      this.disableAttrib();
      this.vao.set(shaderProgram.id, vao);
    };
    return GLPrimitive;
  }();

  /**
   * @private
   */
  var GLRenderStates = /*#__PURE__*/function () {
    /**
     * @param {WebGLRenderingContext} gl
     */
    function GLRenderStates(gl) {
      this._gl = void 0;
      this._parameters = {};
      this._gl = gl;
      this._parameters = {}; // current gl state parameters

      /** cache */
      this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
      this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);

      // init blend state same as BlendState default value.
      gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      gl.colorMask(true, true, true, true);
      gl.blendColor(0, 0, 0, 0);
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);

      // init depth state same as DepthState default value.
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);
      gl.depthMask(true);

      // init stencil state same as StencilState default value.
      gl.disable(gl.STENCIL_TEST);
      gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 0xff);
      gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 0xff);
      gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
      gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
      gl.stencilMask(0xff);

      // init raster state same as RasterState default value.
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.polygonOffset(0, 0);
    }

    /**
     * Get a parameter.
     */
    var _proto = GLRenderStates.prototype;
    _proto.getParameter = function getParameter(pname) {
      return this._parameters[pname];
    };
    return GLRenderStates;
  }();

  /**
   * Texture in WebGL platform.
   */
  var GLTexture = /*#__PURE__*/function () {
    /** @internal */
    GLTexture._isPowerOf2 = function _isPowerOf2(v) {
      return (v & v - 1) === 0;
    }

    /**
     * Get more texture info from TextureFormat.
     * @internal
     */;
    GLTexture._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.TextureFormat.R8G8B8:
          return {
            internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };
        case exports.TextureFormat.R8G8B8A8:
          return {
            internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };
        case exports.TextureFormat.R4G4B4A4:
          return {
            internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_4_4_4_4,
            isCompressed: false
          };
        case exports.TextureFormat.R5G5B5A1:
          return {
            internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_5_5_5_1,
            isCompressed: false
          };
        case exports.TextureFormat.R5G6B5:
          return {
            internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_SHORT_5_6_5,
            isCompressed: false
          };
        case exports.TextureFormat.Alpha8:
          return {
            internalFormat: gl.ALPHA,
            baseFormat: gl.ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };
        case exports.TextureFormat.LuminanceAlpha:
          return {
            internalFormat: gl.LUMINANCE_ALPHA,
            baseFormat: gl.LUMINANCE_ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };
        case exports.TextureFormat.R16G16B16A16:
          return {
            internalFormat: gl.RGBA16F,
            baseFormat: gl.RGBA,
            dataType: gl.HALF_FLOAT,
            isCompressed: false
          };
        case exports.TextureFormat.R32G32B32A32:
          return {
            internalFormat: gl.RGBA32F,
            baseFormat: gl.RGBA,
            dataType: gl.FLOAT,
            isCompressed: false
          };
        case exports.TextureFormat.DXT1:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
            isCompressed: true
          };
        case exports.TextureFormat.DXT5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
            isCompressed: true
          };
        case exports.TextureFormat.ETC1_RGB:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
            isCompressed: true
          };
        case exports.TextureFormat.ETC2_RGB:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_ETC2,
            isCompressed: true
          };
        case exports.TextureFormat.ETC2_RGBA5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            isCompressed: true
          };
        case exports.TextureFormat.ETC2_RGBA8:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
            isCompressed: true
          };
        case exports.TextureFormat.PVRTC_RGB2:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
            isCompressed: true
          };
        case exports.TextureFormat.PVRTC_RGBA2:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
            isCompressed: true
          };
        case exports.TextureFormat.PVRTC_RGB4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
            isCompressed: true
          };
        case exports.TextureFormat.PVRTC_RGBA4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
            isCompressed: true
          };
        case exports.TextureFormat.ASTC_4x4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
            isCompressed: true
          };
        case exports.TextureFormat.ASTC_5x5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
            isCompressed: true
          };
        case exports.TextureFormat.ASTC_6x6:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
            isCompressed: true
          };
        case exports.TextureFormat.ASTC_8x8:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
            isCompressed: true
          };
        case exports.TextureFormat.ASTC_10x10:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
            isCompressed: true
          };
        case exports.TextureFormat.ASTC_12x12:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
            isCompressed: true
          };
        default:
          throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
      }
    }

    /**
     * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D.
     * @internal
     */;
    GLTexture._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.TextureFormat.Depth:
        case exports.RenderBufferDepthFormat.Depth:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };
        case exports.TextureFormat.DepthStencil:
        case exports.RenderBufferDepthFormat.DepthStencil:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.UNSIGNED_INT_24_8,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };
        case exports.TextureFormat.Stencil:
        case exports.RenderBufferDepthFormat.Stencil:
          return {
            internalFormat: gl.STENCIL_INDEX8,
            baseFormat: gl.STENCIL_ATTACHMENT,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false,
            attachment: gl.STENCIL_ATTACHMENT
          };
        case exports.TextureFormat.Depth16:
        case exports.RenderBufferDepthFormat.Depth16:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };
        case exports.TextureFormat.Depth24:
        case exports.RenderBufferDepthFormat.Depth24:
          return {
            internalFormat: gl.DEPTH_COMPONENT24,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };
        case exports.TextureFormat.Depth32:
        case exports.RenderBufferDepthFormat.Depth32:
          return {
            internalFormat: gl.DEPTH_COMPONENT32F,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.FLOAT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };
        case exports.TextureFormat.Depth24Stencil8:
        case exports.RenderBufferDepthFormat.Depth24Stencil8:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.UNSIGNED_INT_24_8,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };
        case exports.TextureFormat.Depth32Stencil8:
        case exports.RenderBufferDepthFormat.Depth32Stencil8:
          return {
            internalFormat: gl.DEPTH32F_STENCIL8,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };
        default:
          throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
      }
    }

    /**
     * Check whether the corresponding texture format is supported.
     * @internal
     */;
    GLTexture._supportTextureFormat = function _supportTextureFormat(format, rhi) {
      var isSupported = true;
      switch (format) {
        case exports.TextureFormat.R16G16B16A16:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.textureHalfFloat)) {
              isSupported = false;
            }
          }
          break;
        case exports.TextureFormat.R32G32B32A32:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
              isSupported = false;
            }
          }
          break;
      }
      return isSupported;
    }

    /**
     * @internal
     */;
    GLTexture._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
      var isSupported = true;
      switch (format) {
        case exports.TextureFormat.R16G16B16A16:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(exports.GLCapabilityType.textureHalfFloat)) {
              isSupported = false;
            }
          }
          break;
        case exports.TextureFormat.R32G32B32A32:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.colorBufferFloat) || !rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
              isSupported = false;
            }
          }
          break;
      }
      return isSupported;
    }

    /**
     * @internal
     */;
    GLTexture._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
      var isWebGL2 = rhi.isWebGL2;
      var isSupported = true;
      if (isTexture && !rhi.canIUse(exports.GLCapabilityType.depthTexture)) {
        return false;
      }
      switch (format) {
        case exports.RenderBufferDepthFormat.Stencil:
        case exports.TextureFormat.Stencil:
          isSupported = false;
          break;
        case exports.TextureFormat.Depth24:
        case exports.TextureFormat.Depth32:
        case exports.TextureFormat.Depth32Stencil8:
        case exports.RenderBufferDepthFormat.Depth24:
        case exports.RenderBufferDepthFormat.Depth32:
        case exports.RenderBufferDepthFormat.Depth32Stencil8:
          if (!isWebGL2) {
            isSupported = false;
          }
          break;
      }
      return isSupported;
    }

    /** @internal */;

    /**
     * Create texture in WebGL platform.
     */
    function GLTexture(rhi, texture, target) {
      this._texture = void 0;
      this._glTexture = void 0;
      this._rhi = void 0;
      this._gl = void 0;
      this._isWebGL2 = void 0;
      this._target = void 0;
      this._formatDetail = void 0;
      this._texture = texture;
      this._rhi = rhi;
      this._gl = rhi.gl;
      this._isWebGL2 = rhi.isWebGL2;
      this._target = target;
      this._glTexture = this._gl.createTexture();
    }

    /**
     * Destroy texture.
     */
    var _proto = GLTexture.prototype;
    _proto.destroy = function destroy() {
      this._gl.deleteTexture(this._glTexture);
      this._texture = null;
      this._glTexture = null;
      this._formatDetail = null;
    }

    /**
     * Generate multi-level textures based on the 0th level data.
     */;
    _proto.generateMipmaps = function generateMipmaps() {
      this._bind();
      this._gl.generateMipmap(this._target);
    };
    _proto._bind = function _bind() {
      this._rhi.bindTexture(this);
    }

    /**
     * Pre-development mipmapping GPU memory.
     */;
    _proto._initMipmap = function _initMipmap(isCube) {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType;
      var _this$_texture = this._texture,
        mipmapCount = _this$_texture.mipmapCount,
        width = _this$_texture.width,
        height = _this$_texture.height;
      this._bind();
      if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA)) {
        gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
      } else {
        // In WebGL 1, internalformat must be the same as baseFormat
        if (baseFormat !== internalFormat) {
          internalFormat = baseFormat;
        }
        if (!isCube) {
          for (var i = 0; i < mipmapCount; i++) {
            var mipWidth = Math.max(1, width >> i);
            var mipHeight = Math.max(1, height >> i);
            gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
          }
        } else {
          for (var _i = 0; _i < mipmapCount; _i++) {
            var size = Math.max(1, width >> _i);
            for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
            }
          }
        }
      }
    }

    /**
     * Get the pixel color buffer according to the specified cube face and area.
     * @param face - You can choose which cube face to read
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     * @param mipLevel - Set mip level the data want to get from
     */;
    _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, mipLevel, out) {
      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
      if (mipLevel > 0 && !this._isWebGL2) {
        mipLevel = 0;
        Logger.error("mipLevel only take effect in WebGL2.0");
      }
      if (face != null) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, mipLevel);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, mipLevel);
      }
      gl.readPixels(x, y, width, height, baseFormat, dataType, out);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    _proto._setWrapMode = function _setWrapMode(value, pname) {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var target = this._target;
      var _this$_texture2 = this._texture,
        width = _this$_texture2.width,
        height = _this$_texture2.height;
      if (!isWebGL2 && value !== exports.TextureWrapMode.Clamp && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
        value = exports.TextureWrapMode.Clamp;
      }
      switch (value) {
        case exports.TextureWrapMode.Clamp:
          gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
          break;
        case exports.TextureWrapMode.Repeat:
          gl.texParameteri(target, pname, gl.REPEAT);
          break;
        case exports.TextureWrapMode.Mirror:
          gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
          break;
      }
    };
    _proto._getReadFrameBuffer = function _getReadFrameBuffer() {
      var frameBuffer = this._rhi._readFrameBuffer;
      if (!frameBuffer) {
        this._rhi._readFrameBuffer = frameBuffer = this._gl.createFramebuffer();
      }
      return frameBuffer;
    };
    _createClass$2(GLTexture, [{
      key: "wrapModeU",
      set:
      /**
       * Wrapping mode for texture coordinate S.
       */
      function set(value) {
        this._bind();
        this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
      }

      /**
       * Wrapping mode for texture coordinate T.
       */
    }, {
      key: "wrapModeV",
      set: function set(value) {
        this._bind();
        this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
      }

      /**
       * Filter mode for texture.
       */
    }, {
      key: "filterMode",
      set: function set(value) {
        var gl = this._gl;
        var target = this._target;
        /** @ts-ignore */
        var _mipmap = this._texture._mipmap;
        this._bind();
        switch (value) {
          case exports.TextureFilterMode.Point:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
            break;
          case exports.TextureFilterMode.Bilinear:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
            break;
          case exports.TextureFilterMode.Trilinear:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
            break;
        }
      }

      /**
       * Anisotropic level for texture.
       */
    }, {
      key: "anisoLevel",
      set: function set(value) {
        var gl = this._gl;
        this._bind();
        gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
      }
    }]);
    return GLTexture;
  }();

  /**
   * The render target in WebGL platform is used for off-screen rendering.
   */
  var GLRenderTarget = /*#__PURE__*/function () {
    /**
     * Create render target in WebGL platform.
     */
    function GLRenderTarget(rhi, target) {
      this._gl = void 0;
      this._isWebGL2 = void 0;
      this._target = void 0;
      this._frameBuffer = void 0;
      this._MSAAFrameBuffer = void 0;
      this._depthRenderBuffer = void 0;
      this._MSAAColorRenderBuffers = [];
      this._MSAADepthRenderBuffer = void 0;
      this._oriDrawBuffers = void 0;
      this._blitDrawBuffers = void 0;
      this._curMipLevel = 0;
      this._gl = rhi.gl;
      this._isWebGL2 = rhi.isWebGL2;
      this._target = target;

      /** @ts-ignore */
      var _colorTextures = target._colorTextures,
        _depth = target._depth,
        width = target.width,
        height = target.height;
      var isDepthTexture = _depth instanceof Texture;

      /** todo
       * MRT + Cube + [,MSAA]
       * MRT + MSAA
       */

      for (var i = 0, n = _colorTextures.length; i < n; i++) {
        var format = _colorTextures[i]._format;
        if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
          throw new Error("TextureFormat is not supported:" + exports.TextureFormat[format] + " in RenderTarget");
        }
      }
      if (!GLTexture._supportRenderBufferDepthFormat(isDepthTexture ? _depth.format : _depth, rhi, isDepthTexture)) {
        throw new Error("TextureFormat is not supported:" + exports.TextureFormat[_depth] + " in RenderTarget");
      }
      if (_colorTextures.length > 1 && !rhi.canIUse(exports.GLCapabilityType.drawBuffers)) {
        throw new Error("MRT is not supported");
      }
      if (_colorTextures.some(function (v) {
        return v.width !== width || v.height !== height;
      })) {
        throw new Error("ColorTexture's size must as same as RenderTarget");
      }
      if (isDepthTexture && (_depth.width !== width || _depth.height !== height)) {
        throw new Error("DepthTexture's size must as same as RenderTarget");
      }

      // todo: necessary to support MRT + Cube + [,MSAA] ?
      if (_colorTextures.length > 1 && _colorTextures.some(function (v) {
        return v instanceof TextureCube;
      })) {
        throw new Error("MRT+Cube+[,MSAA] is not supported");
      }
      var maxAntiAliasing = rhi.capability.maxAntiAliasing;
      if (target.antiAliasing > maxAntiAliasing) {
        Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);

        /** @ts-ignore */
        target._antiAliasing = maxAntiAliasing;
      }
      this._frameBuffer = this._gl.createFramebuffer();

      // bind main FBO
      this._bindMainFBO();

      // bind MSAA FBO
      if (target.antiAliasing > 1) {
        this._MSAAFrameBuffer = this._gl.createFramebuffer();
        this._bindMSAAFBO();
      }
    }

    /**
     * Set which face and mipLevel of the cube texture to render to.
     * @param faceIndex - Cube texture face
     * @param mipLevel - Set mip level the data want to write
     */
    var _proto = GLRenderTarget.prototype;
    _proto.setRenderTargetInfo = function setRenderTargetInfo(faceIndex, mipLevel) {
      var gl = this._gl,
        target = this._target;
      var depthTexture = target.depthTexture;
      var colorTexture = target.getColorTexture(0);
      var mipChanged = mipLevel !== this._curMipLevel;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      if (colorTexture) {
        var isCube = colorTexture instanceof TextureCube;
        if (mipChanged || isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, /** @ts-ignore */
          colorTexture._platformTexture._glTexture, mipLevel);
        }
      }
      if (depthTexture) {
        var _isCube = depthTexture instanceof TextureCube;
        if (mipChanged || _isCube) {
          /** @ts-ignore */
          var platformTexture = depthTexture._platformTexture;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, _isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, platformTexture._glTexture, mipLevel);
        }
      } else {
        if (mipChanged) {
          // @ts-ignore
          var _GLTexture$_getRender = GLTexture._getRenderBufferDepthFormatDetail(target._depth, gl, this._isWebGL2),
            internalFormat = _GLTexture$_getRender.internalFormat;
          gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width >> mipLevel, target.height >> mipLevel);
        }
      }
      this._curMipLevel = mipLevel;

      // revert current activated render target
      this._activeRenderTarget();
    }

    /**
     * Blit FBO.
     */;
    _proto.blitRenderTarget = function blitRenderTarget() {
      if (!this._MSAAFrameBuffer) return;
      var gl = this._gl;
      var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
      var _this$_target = this._target,
        colorTextureCount = _this$_target.colorTextureCount,
        width = _this$_target.width,
        height = _this$_target.height;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
      for (var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {
        var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
        this._blitDrawBuffers[textureIndex] = attachment;
        gl.readBuffer(attachment);
        gl.drawBuffers(this._blitDrawBuffers);
        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
        this._blitDrawBuffers[textureIndex] = gl.NONE;
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    /**
     * Destroy render target.
     */;
    _proto.destroy = function destroy() {
      var gl = this._gl;
      this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
      this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
      this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
      this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
      for (var i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
        gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
      }
      this._frameBuffer = null;
      this._depthRenderBuffer = null;
      this._MSAAFrameBuffer = null;
      this._MSAAColorRenderBuffers.length = 0;
      this._MSAADepthRenderBuffer = null;
    }

    /**
     * Activate this RenderTarget.
     * @internal
     * @remarks
     * If MSAA is turned on, MSAA FBO is activated, and then this._blitRenderTarget() is performed to exchange FBO.
     * If MSAA is not turned on, activate the main FBO.
     */;
    _proto._activeRenderTarget = function _activeRenderTarget() {
      var gl = this._gl;
      if (this._MSAAFrameBuffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      }
    };
    _proto._bindMainFBO = function _bindMainFBO() {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;

      /** @ts-ignore */
      var _this$_target2 = this._target,
        _depth = _this$_target2._depth,
        colorTextureCount = _this$_target2.colorTextureCount,
        width = _this$_target2.width,
        height = _this$_target2.height;
      var drawBuffers = new Array(colorTextureCount);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);

      /** color render buffer */
      for (var i = 0; i < colorTextureCount; i++) {
        var colorTexture = this._target.getColorTexture(i);
        var attachment = gl.COLOR_ATTACHMENT0 + i;
        drawBuffers[i] = attachment;
        if (!(colorTexture instanceof TextureCube)) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, /** @ts-ignore */
          colorTexture._platformTexture._glTexture, 0);
        }
      }
      if (colorTextureCount > 1) {
        gl.drawBuffers(drawBuffers);
      }
      this._oriDrawBuffers = drawBuffers;

      /** depth render buffer */
      if (_depth !== null) {
        if (_depth instanceof Texture) {
          if (!(_depth instanceof TextureCube)) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, /** @ts-ignore */
            _depth._platformTexture._formatDetail.attachment, gl.TEXTURE_2D, /** @ts-ignore */
            _depth._platformTexture._glTexture, 0);
          }
        } else if (this._target.antiAliasing <= 1) {
          var _GLTexture$_getRender2 = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2),
            internalFormat = _GLTexture$_getRender2.internalFormat,
            _attachment = _GLTexture$_getRender2.attachment;
          var depthRenderBuffer = gl.createRenderbuffer();
          this._depthRenderBuffer = depthRenderBuffer;
          gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
        }
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    _proto._bindMSAAFBO = function _bindMSAAFBO() {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var MSAADepthRenderBuffer = gl.createRenderbuffer();

      /** @ts-ignore */
      var _this$_target3 = this._target,
        _depth = _this$_target3._depth,
        colorTextureCount = _this$_target3.colorTextureCount,
        antiAliasing = _this$_target3.antiAliasing,
        width = _this$_target3.width,
        height = _this$_target3.height;
      this._blitDrawBuffers = new Array(colorTextureCount);
      this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);

      // prepare MRT+MSAA color RBOs
      for (var i = 0; i < colorTextureCount; i++) {
        var MSAAColorRenderBuffer = gl.createRenderbuffer();
        this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
        this._blitDrawBuffers[i] = gl.NONE;
        gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, /** @ts-ignore */
        this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
      }
      gl.drawBuffers(this._oriDrawBuffers);

      // prepare MSAA depth RBO
      if (_depth !== null) {
        var _ref = _depth instanceof Texture ? /** @ts-ignore */
          _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2),
          internalFormat = _ref.internalFormat,
          attachment = _ref.attachment;
        gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
      }
      this._checkFrameBuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    _proto._checkFrameBuffer = function _checkFrameBuffer() {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      switch (e) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("There is no attachment");
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(" Height and width of the attachment are not the same.");
        case gl.FRAMEBUFFER_UNSUPPORTED:
          throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
      }
      if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
        throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
      }
    };
    return GLRenderTarget;
  }();

  /**
   * Texture 2d in WebGL platform.
   */
  var GLTexture2D = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLTexture2D, _GLTexture);
    /** Backward compatible with WebGL1.0. */

    function GLTexture2D(rhi, texture2D) {
      var _this;
      _this = _GLTexture.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;

      /** @ts-ignore */
      _this._compressedMipFilled = 0;
      var format = texture2D.format,
        _mipmap = texture2D._mipmap,
        width = texture2D.width,
        height = texture2D.height;
      var isWebGL2 = _this._isWebGL2;
      if (!GLTexture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:" + exports.TextureFormat[format]);
      }
      if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");

        /** @ts-ignore */
        texture2D._mipmap = false;
        /** @ts-ignore */
        texture2D._mipmapCount = texture2D._getMipmapCount();
      }
      _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
      _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
      return _this;
    }

    /**
     * {@inheritDoc IPlatformTexture2D.setPixelBuffer}
     */
    var _proto = GLTexture2D.prototype;
    _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType,
        isCompressed = _this$_formatDetail.isCompressed;
      var mipWidth = Math.max(1, this._texture.width >> mipLevel);
      var mipHeight = Math.max(1, this._texture.height >> mipLevel);
      width = width || mipWidth - x;
      height = height || mipHeight - y;
      this._bind();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      if (isCompressed) {
        var mipBit = 1 << mipLevel;
        if (isWebGL2 || this._compressedMipFilled & mipBit) {
          gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
        } else {
          gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
          this._compressedMipFilled |= mipBit;
        }
      } else {
        gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
      }
    }

    /**
     * {@inheritDoc IPlatformTexture2D.setImageSource}
     */;
    _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;
      this._bind();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    }

    /**
     * {@inheritDoc IPlatformTexture2D.getPixelBuffer }
     */;
    _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, mipLevel, out) {
      if (this._formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }
      _GLTexture.prototype._getPixelBuffer.call(this, null, x, y, width, height, mipLevel, out);
    };
    return GLTexture2D;
  }(GLTexture);

  /**
   * Texture 2D array in WebGL platform.
   */
  var GLTexture2DArray = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLTexture2DArray, _GLTexture);
    function GLTexture2DArray(rhi, texture2DArray) {
      var _this;
      _this = _GLTexture.call(this, rhi, texture2DArray, rhi.gl.TEXTURE_2D_ARRAY) || this;
      var format = texture2DArray.format,
        width = texture2DArray.width,
        height = texture2DArray.height,
        length = texture2DArray.length,
        mipmapCount = texture2DArray.mipmapCount;
      if (!_this._isWebGL2) {
        throw new Error("Texture2D Array is not supported in WebGL1.0");
      }
      if (!GLTexture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:" + exports.TextureFormat[format]);
      }
      _this._bind();
      _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, true);
      _this._gl.texStorage3D(_this._target, mipmapCount, _this._formatDetail.internalFormat, width, height, length);
      return _this;
    }

    /**
     * {@inheritDoc IPlatformTexture2DArray.setPixelBuffer}
     */
    var _proto = GLTexture2DArray.prototype;
    _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length) {
      var target = this._target,
        gl = this._gl;
      var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType,
        isCompressed = _this$_formatDetail.isCompressed;
      width = width || Math.max(1, this._texture.width >> mipLevel) - x;
      height = height || Math.max(1, this._texture.height >> mipLevel) - y;
      length = length || this._texture.length;
      this._bind();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      if (isCompressed) {
        gl.compressedTexSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length, internalFormat, colorBuffer);
      } else {
        gl.texSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length, baseFormat, dataType, colorBuffer);
      }
    }

    /**
     * {@inheritDoc IPlatformTexture2DArray.setImageSource}
     */;
    _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;
      this._bind();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage3D(this._target, mipLevel, x, y, elementIndex, imageSource.width, imageSource.height, 1, baseFormat, dataType, imageSource);
    }

    /**
     * {@inheritDoc IPlatformTexture2DArray.getPixelBuffer}
     */;
    _proto.getPixelBuffer = function getPixelBuffer(elementIndex, x, y, width, height, mipLevel, out) {
      var gl = this._gl,
        formatDetail = this._formatDetail;
      if (formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this._glTexture, mipLevel, elementIndex);
      gl.readPixels(x, y, width, height, formatDetail.baseFormat, formatDetail.dataType, out);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    return GLTexture2DArray;
  }(GLTexture);

  /**
   * Cube texture in WebGL platform.
   */
  var GLTextureCube = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLTextureCube, _GLTexture);
    /** Backward compatible with WebGL1.0. */

    function GLTextureCube(rhi, textureCube) {
      var _this;
      _this = _GLTexture.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;

      /** @ts-ignore */
      _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
      var format = textureCube.format,
        _mipmap = textureCube._mipmap,
        size = textureCube.width;
      var isWebGL2 = _this._isWebGL2;
      if (!GLTexture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:" + exports.TextureFormat[format]);
      }
      if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");

        /** @ts-ignore */
        textureCube._mipmap = false;
        /** @ts-ignore */
        textureCube._mipmapCount = textureCube._getMipmapCount();
      }
      _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
      _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
      return _this;
    }

    /**
     * {@inheritDoc IPlatformTextureCube.setPixelBuffer}
     */
    var _proto = GLTextureCube.prototype;
    _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType,
        isCompressed = _this$_formatDetail.isCompressed;
      var mipSize = Math.max(1, this._texture.width >> mipLevel);
      width = width || mipSize - x;
      height = height || mipSize - y;
      this._bind();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      if (isCompressed) {
        var mipBit = 1 << mipLevel;
        if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
        } else {
          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
          this._compressedFaceFilled[face] |= mipBit;
        }
      } else {
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
      }
    }

    /**
     * {@inheritDoc IPlatformTextureCube.setImageSource}
     */;
    _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;
      this._bind();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    }

    /**
     * {@inheritDoc IPlatformTextureCube.getPixelBuffer}
     */;
    _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, mipLevel, out) {
      if (this._formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }
      _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, mipLevel, out);
    };
    return GLTextureCube;
  }(GLTexture);

  /**
   * WebGL mode.
   */
  exports.WebGLMode = void 0;

  /**
   * WebGL renderer options.
   */
  (function (WebGLMode) {
    WebGLMode[WebGLMode["Auto"] = 0] = "Auto";
    WebGLMode[WebGLMode["WebGL2"] = 1] = "WebGL2";
    WebGLMode[WebGLMode["WebGL1"] = 2] = "WebGL1";
  })(exports.WebGLMode || (exports.WebGLMode = {}));
  /**
   * WebGL renderer, including WebGL1.0 and WebGL2.0.
   */
  var WebGLRenderer = /*#__PURE__*/function () {
    function WebGLRenderer(options) {
      if (options === void 0) {
        options = {};
      }
      this._readFrameBuffer = void 0;
      this._currentBind = void 0;
      this._options = void 0;
      this._gl = void 0;
      this._renderStates = void 0;
      this._extensions = void 0;
      this._capability = void 0;
      this._isWebGL2 = void 0;
      this._webCanvas = void 0;
      this._activeTextureID = void 0;
      this._activeTextures = new Array(32);
      this._lastViewport = new Vector4(null, null, null, null);
      this._lastClearColor = new Color(null, null, null, null);
      this._scissorEnable = false;
      this._options = options;
    }
    var _proto = WebGLRenderer.prototype;
    _proto.init = function init(canvas) {
      var option = this._options;
      option.alpha === undefined && (option.alpha = false);
      option.stencil === undefined && (option.stencil = true);
      var webCanvas = this._webCanvas = canvas._webCanvas;
      var webGLMode = option.webGLMode || exports.WebGLMode.Auto;
      var gl;
      if (webGLMode == exports.WebGLMode.Auto || webGLMode == exports.WebGLMode.WebGL2) {
        gl = webCanvas.getContext("webgl2", option);
        if (!gl && (typeof OffscreenCanvas === "undefined" || !(webCanvas instanceof OffscreenCanvas))) {
          gl = webCanvas.getContext("experimental-webgl2", option);
        }
        this._isWebGL2 = true;

        // Prevent weird browsers to lie (such as safari!)
        if (gl && !gl.deleteQuery) {
          this._isWebGL2 = false;
        }
      }
      if (!gl) {
        if (webGLMode == exports.WebGLMode.Auto || webGLMode == exports.WebGLMode.WebGL1) {
          gl = webCanvas.getContext("webgl", option);
          if (!gl && (typeof OffscreenCanvas === "undefined" || !(webCanvas instanceof OffscreenCanvas))) {
            gl = webCanvas.getContext("experimental-webgl", option);
          }
          this._isWebGL2 = false;
        }
      }
      if (!gl) {
        throw new Error("Get GL Context FAILED.");
      }
      this._gl = gl;
      this._activeTextureID = gl.TEXTURE0;
      this._renderStates = new GLRenderStates(gl);
      this._extensions = new GLExtensions(this);
      this._capability = new GLCapability(this);
      // Make sure the active texture in gl context is on default, because gl context may be used in other webgl renderer.
      gl.activeTexture(gl.TEXTURE0);
      this._options = null;
    };
    _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
      return new GLPrimitive(this, primitive);
    };
    _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
      return new GLTexture2D(this, texture2D);
    };
    _proto.createPlatformTexture2DArray = function createPlatformTexture2DArray(texture2D) {
      return new GLTexture2DArray(this, texture2D);
    };
    _proto.createPlatformTextureCube = function createPlatformTextureCube(textureCube) {
      return new GLTextureCube(this, textureCube);
    };
    _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
      return new GLRenderTarget(this, target);
    };
    _proto.requireExtension = function requireExtension(ext) {
      return this._extensions.requireExtension(ext);
    };
    _proto.canIUse = function canIUse(capabilityType) {
      return this.capability.canIUse(capabilityType);
    };
    _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
      return this.capability.canIUseCompressedTextureInternalFormat(type);
    };
    _proto.viewport = function viewport(x, y, width, height) {
      var gl = this._gl,
        lv = this._lastViewport;
      if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
        var webCanvas = this._webCanvas;
        if (x === 0 && y === 0 && width === webCanvas.width && height === webCanvas.height) {
          if (this._scissorEnable) {
            gl.disable(gl.SCISSOR_TEST);
            this._scissorEnable = false;
          }
        } else {
          if (!this._scissorEnable) {
            gl.enable(gl.SCISSOR_TEST);
            this._scissorEnable = true;
          }
          gl.scissor(x, y, width, height);
        }
        gl.viewport(x, y, width, height);
        lv.set(x, y, width, height);
      }
    };
    _proto.colorMask = function colorMask(r, g, b, a) {
      this._gl.colorMask(r, g, b, a);
    };
    _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
      var gl = this._gl;
      var _engine$_lastRenderSt = engine._lastRenderState,
        targetBlendState = _engine$_lastRenderSt.blendState.targetBlendState,
        depthState = _engine$_lastRenderSt.depthState,
        stencilState = _engine$_lastRenderSt.stencilState;
      var clearFlag = 0;
      if (clearFlags & exports.CameraClearFlags.Color) {
        clearFlag |= gl.COLOR_BUFFER_BIT;
        var lc = this._lastClearColor;
        var r = clearColor.r,
          g = clearColor.g,
          b = clearColor.b,
          a = clearColor.a;
        if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
          gl.clearColor(r, g, b, a);
          lc.set(r, g, b, a);
        }
        if (targetBlendState.colorWriteMask !== exports.ColorWriteMask.All) {
          gl.colorMask(true, true, true, true);
          targetBlendState.colorWriteMask = exports.ColorWriteMask.All;
        }
      }
      if (clearFlags & exports.CameraClearFlags.Depth) {
        clearFlag |= gl.DEPTH_BUFFER_BIT;
        if (depthState.writeEnabled !== true) {
          gl.depthMask(true);
          depthState.writeEnabled = true;
        }
      }
      if (clearFlags & exports.CameraClearFlags.Stencil) {
        clearFlag |= gl.STENCIL_BUFFER_BIT;
        if (stencilState.writeMask !== 0xff) {
          gl.stencilMask(0xff);
          stencilState.writeMask = 0xff;
        }
      }
      gl.clear(clearFlag);
    };
    _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
      // todo: VAO not support morph animation
      if (primitive) {
        //@ts-ignore
        primitive._draw(shaderProgram, subPrimitive);
      } else {
        Logger.error("draw primitive failed.");
      }
    };
    _proto.activeRenderTarget = function activeRenderTarget(renderTarget, camera, mipLevel) {
      var gl = this._gl;
      if (renderTarget) {
        var _renderTarget$_platfo;
        /** @ts-ignore */
        (_renderTarget$_platfo = renderTarget._platformRenderTarget) === null || _renderTarget$_platfo === void 0 ? void 0 : _renderTarget$_platfo._activeRenderTarget();
        var width = renderTarget.width,
          height = renderTarget.height;
        this.viewport(0, 0, width >> mipLevel, height >> mipLevel);
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        var viewport = camera.viewport;
        var drawingBufferWidth = gl.drawingBufferWidth,
          drawingBufferHeight = gl.drawingBufferHeight;
        var _width = drawingBufferWidth * viewport.z;
        var _height = drawingBufferHeight * viewport.w;
        var x = viewport.x * drawingBufferWidth;
        var y = drawingBufferHeight - viewport.y * drawingBufferHeight - _height;
        this.viewport(x, y, _width, _height);
      }
    };
    _proto.destroy = function destroy() {};
    _proto.activeTexture = function activeTexture(textureID) {
      if (this._activeTextureID !== textureID) {
        this._gl.activeTexture(textureID);
        this._activeTextureID = textureID;
      }
    };
    _proto.bindTexture = function bindTexture(texture) {
      var index = this._activeTextureID - this._gl.TEXTURE0;
      if (this._activeTextures[index] !== texture) {
        this._gl.bindTexture(texture._target, texture._glTexture);
        this._activeTextures[index] = texture;
      }
    };
    _createClass$2(WebGLRenderer, [{
      key: "isWebGL2",
      get: /** @internal */

      // cache value

      function get() {
        return this._isWebGL2;
      }

      /**
       * GL Context
       * @member {WebGLRenderingContext}
       */
    }, {
      key: "gl",
      get: function get() {
        return this._gl;
      }
    }, {
      key: "renderStates",
      get: function get() {
        return this._renderStates;
      }
    }, {
      key: "capability",
      get: function get() {
        return this._capability;
      }
    }, {
      key: "canIUseMoreJoints",
      get: function get() {
        return this.capability.canIUseMoreJoints;
      }
    }]);
    return WebGLRenderer;
  }();

  /**
   * WebGL platform engine,support includes WebGL1.0 and WebGL2.0.
   */
  var WebGLEngine = /*#__PURE__*/function (_Engine) {
    _inheritsLoose$1(WebGLEngine, _Engine);
    /**
     * Create an engine suitable for the WebGL platform.
     * @param canvas - Native web canvas
     * @param webGLRendererOptions - WebGL renderer options
     */
    function WebGLEngine(canvas, webGLRendererOptions) {
      var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
      var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
      return _Engine.call(this, webCanvas, hardwareRenderer) || this;
    }

    /**
     * Web canvas.
     */
    _createClass$2(WebGLEngine, [{
      key: "canvas",
      get: function get() {
        return this._canvas;
      }
    }]);
    return WebGLEngine;
  }(Engine);

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  var DRACOWorker = /*#__PURE__*/function () {
    function DRACOWorker(workerSourceURL, decoderWASMBinary) {
      var _this = this;
      this._worker = void 0;
      this._costs = {};
      this._currentLoad = 0;
      this._callbacks = {};
      this._worker = new Worker(workerSourceURL);
      this._worker.onmessage = function (e) {
        var message = e.data;
        switch (message.type) {
          case "decode":
            _this._callbacks[message.id].resolve(message.geometry);
            break;
          case "error":
            _this._callbacks[message.id].reject(message);
            break;
          default:
            Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
        }
      };
      if (decoderWASMBinary) {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {
            wasmBinary: decoderWASMBinary
          }
        });
      } else {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {}
        });
      }
    }
    var _proto = DRACOWorker.prototype;
    _proto.setCosts = function setCosts(taskId, cost) {
      this._costs[taskId] = cost;
    };
    _proto.addCurrentLoad = function addCurrentLoad(cost) {
      this._currentLoad += cost;
    };
    _proto.setCallback = function setCallback(taskId, resolve, reject) {
      this._callbacks[taskId] = {
        resolve: resolve,
        reject: reject
      };
    };
    _proto.decode = function decode(taskId, taskConfig, buffer) {
      this._worker.postMessage({
        type: "decode",
        id: taskId,
        taskConfig: taskConfig,
        buffer: buffer
      }, [buffer]);
    };
    _proto.releaseTask = function releaseTask(taskId) {
      this._currentLoad -= this._costs[taskId];
      delete this._callbacks[taskId];
      delete this._costs[taskId];
    };
    _createClass$1(DRACOWorker, [{
      key: "currentLoad",
      get:
      // Worker instance.

      // Record byteLength of each task.

      // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.

      function get() {
        return this._currentLoad;
      }
    }]);
    return DRACOWorker;
  }();
  var workerString = "let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n";
  var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
  var JS_FILE = "draco_decoder_gltf.js";
  var WASM_FILE = "draco_decoder_gltf.r3bin";
  var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
  var DRACODecoder = /*#__PURE__*/function () {
    function DRACODecoder(config) {
      if (config === void 0) {
        config = {
          type: "wasm",
          workerLimit: 4
        };
      }
      this.pool = [];
      this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
      this.useJS = void 0;
      this.currentTaskId = 1;
      this.taskCache = new WeakMap();
      this.loadLibPromise = void 0;
      if (config.workerLimit > this.workerLimit) {
        Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
      } else {
        var _config$workerLimit;
        this.workerLimit = (_config$workerLimit = config.workerLimit) != null ? _config$workerLimit : 4;
      }
      this.useJS = typeof WebAssembly !== "object" || config.type === "js";
      this.loadLibPromise = this.preloadLib();
    }
    var _proto = DRACODecoder.prototype;
    _proto.preloadLib = function preloadLib() {
      var _this = this;
      if (this.loadLibPromise) {
        return this.loadLibPromise;
      }
      return new Promise(function (resolve, reject) {
        if (_this.useJS) {
          request("" + LIB_PATH + JS_FILE, {
            type: "text"
          }).then(function (jsSource) {
            var body = [jsSource, workerString].join("\n");
            var workerSourceURL = URL.createObjectURL(new Blob([body]));
            resolve({
              workerSourceURL: workerSourceURL,
              decoderWASMBinary: null
            });
          }).catch(function (reason) {
            reject(reason);
          });
        } else {
          Promise.all([request("" + LIB_PATH + WASM_WRAPPER_FILE, {
            type: "text"
          }), request("" + LIB_PATH + WASM_FILE, {
            type: "arraybuffer"
          })]).then(function (resources) {
            var wrapperSource = resources[0],
              decoderWASMBinary = resources[1];
            var body = [wrapperSource, workerString].join("\n");
            var workerSourceURL = URL.createObjectURL(new Blob([body]));
            resolve({
              workerSourceURL: workerSourceURL,
              decoderWASMBinary: decoderWASMBinary
            });
          }).catch(function (reason) {
            reject(reason);
          });
        }
      });
    };
    _proto.getWorker = function getWorker() {
      var _this2 = this;
      return this.preloadLib().then(function (worderResources) {
        if (_this2.pool.length < _this2.workerLimit) {
          var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
          _this2.pool.push(dracoWorker);
        } else {
          _this2.pool.sort(function (a, b) {
            return a.currentLoad > b.currentLoad ? -1 : 1;
          });
        }
        return _this2.pool[_this2.pool.length - 1];
      });
    };
    _proto.decode = function decode(buffer, taskConfig) {
      var _this3 = this;
      var taskKey = JSON.stringify(taskConfig);

      // Check for an existing task using this buffer. A transferred buffer cannot be transferred.
      // again from this thread.
      if (this.taskCache.has(buffer)) {
        var cachedTask = this.taskCache.get(buffer);
        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.
          // Technically, it would be possible to wait for the previous task to complete,
          // transfer the buffer back, and decode again with the second configuration. That
          // is complex, and I don't know of any reason to decode a Draco buffer twice in
          // different ways, so this is left unimplemented.
          throw new Error("DRACODecoder: Unable to re-decode a buffer with different " + "settings. Buffer has already been transferred.");
        }
      }
      var taskId = this.currentTaskId++;
      var cost = buffer.byteLength;
      var taskWorker;
      var task = new Promise(function (resolve, reject) {
        _this3.getWorker().then(function (worker) {
          taskWorker = worker;
          worker.setCosts(taskId, cost);
          worker.addCurrentLoad(cost);
          worker.setCallback(taskId, resolve, reject);
          worker.decode(taskId, taskConfig, buffer);
        }).catch(function (e) {
          reject(e);
        });
      });
      task.finally(function () {
        if (taskWorker && taskId) {
          taskWorker.releaseTask(taskId);
        }
      });
      this.taskCache.set(buffer, {
        key: taskKey,
        promise: task
      });
      return task;
    };
    return DRACODecoder;
  }();

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function _regeneratorRuntime() {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) {
                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              }
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) {
        keys.push(key);
      }
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
        }
      },
      stop: function stop() {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var _dec$r, _class$r;
  function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
  }
  _dec$r = resourceLoader(exports.AssetType.Buffer, ["bin", "r3bin"], false), _dec$r(_class$r = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(BufferLoader, _Loader);
    function BufferLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = BufferLoader.prototype;
    _proto.load = function load(item) {
      var url = item.url;
      if (isBase64(url)) {
        return new AssetPromise(function (resolve) {
          var base64Str = url.slice(13 + RegExp.$1.length);
          var result = Uint8Array.from(atob(base64Str), function (c) {
            return c.charCodeAt(0);
          });
          resolve(result.buffer);
        });
      }
      return this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "arraybuffer"
      }));
    };
    return BufferLoader;
  }(Loader)) || _class$r;

  /**
   * Module for glTF 2.0 Interface
   */

  /**
   * The datatype of the components in the attribute
   */
  var AccessorComponentType;

  /**
   * Specifies if the attirbute is a scalar, vector, or matrix
   */
  (function (AccessorComponentType) {
    AccessorComponentType[AccessorComponentType["BYTE"] = 5120] = "BYTE";
    AccessorComponentType[AccessorComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    AccessorComponentType[AccessorComponentType["SHORT"] = 5122] = "SHORT";
    AccessorComponentType[AccessorComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    AccessorComponentType[AccessorComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    AccessorComponentType[AccessorComponentType["FLOAT"] = 5126] = "FLOAT";
  })(AccessorComponentType || (AccessorComponentType = {}));
  var AccessorType;

  /**
   * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates
   */
  (function (AccessorType) {
    AccessorType["SCALAR"] = "SCALAR";
    AccessorType["VEC2"] = "VEC2";
    AccessorType["VEC3"] = "VEC3";
    AccessorType["VEC4"] = "VEC4";
    AccessorType["MAT2"] = "MAT2";
    AccessorType["MAT3"] = "MAT3";
    AccessorType["MAT4"] = "MAT4";
  })(AccessorType || (AccessorType = {}));
  var AnimationChannelTargetPath;

  /**
   * Interpolation algorithm
   */
  (function (AnimationChannelTargetPath) {
    AnimationChannelTargetPath["TRANSLATION"] = "translation";
    AnimationChannelTargetPath["ROTATION"] = "rotation";
    AnimationChannelTargetPath["SCALE"] = "scale";
    AnimationChannelTargetPath["WEIGHTS"] = "weights";
  })(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
  var AnimationSamplerInterpolation;

  /**
   * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
   */
  (function (AnimationSamplerInterpolation) {
    AnimationSamplerInterpolation["Linear"] = "LINEAR";
    AnimationSamplerInterpolation["Step"] = "STEP";
    AnimationSamplerInterpolation["CubicSpine"] = "CUBICSPLINE";
  })(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
  var CameraType;

  /**
   * The mime-type of the image
   */
  (function (CameraType) {
    CameraType["PERSPECTIVE"] = "perspective";
    CameraType["ORTHOGRAPHIC"] = "orthographic";
  })(CameraType || (CameraType = {}));
  var ImageMimeType;

  /**
   * The alpha rendering mode of the material
   */
  (function (ImageMimeType) {
    ImageMimeType["JPEG"] = "image/jpeg";
    ImageMimeType["PNG"] = "image/png";
  })(ImageMimeType || (ImageMimeType = {}));
  var MaterialAlphaMode;

  /**
   * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
   */
  (function (MaterialAlphaMode) {
    MaterialAlphaMode["OPAQUE"] = "OPAQUE";
    MaterialAlphaMode["MASK"] = "MASK";
    MaterialAlphaMode["BLEND"] = "BLEND";
  })(MaterialAlphaMode || (MaterialAlphaMode = {}));
  var TextureMagFilter;

  /**
   * Minification filter.  All valid values correspond to WebGL enums
   */
  (function (TextureMagFilter) {
    TextureMagFilter[TextureMagFilter["NEAREST"] = 9728] = "NEAREST";
    TextureMagFilter[TextureMagFilter["LINEAR"] = 9729] = "LINEAR";
  })(TextureMagFilter || (TextureMagFilter = {}));
  var TextureMinFilter;

  /**
   * S (U) wrapping mode.  All valid values correspond to WebGL enums
   */
  (function (TextureMinFilter) {
    TextureMinFilter[TextureMinFilter["NEAREST"] = 9728] = "NEAREST";
    TextureMinFilter[TextureMinFilter["LINEAR"] = 9729] = "LINEAR";
    TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  })(TextureMinFilter || (TextureMinFilter = {}));
  var TextureWrapMode;

  /**
   * glTF Property
   */
  (function (TextureWrapMode) {
    TextureWrapMode[TextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    TextureWrapMode[TextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
  })(TextureWrapMode || (TextureWrapMode = {}));

  /**
   * @internal
   */
  var GLTFUtil = /*#__PURE__*/function () {
    function GLTFUtil() {}
    GLTFUtil.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 2);
      for (var i = 0; i < bufferLen; i += 2) {
        array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
      }
      return array;
    };
    GLTFUtil.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 3);
      for (var i = 0; i < bufferLen; i += 3) {
        array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
      }
      return array;
    };
    GLTFUtil.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 4);
      for (var i = 0; i < bufferLen; i += 4) {
        array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
      }
      return array;
    };
    GLTFUtil.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
      var bufferLen = buffer.length;
      var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
      if (isColor3) {
        for (var i = 0; i < bufferLen; i += 3) {
          colors[i / 3] = new Color(buffer[i], buffer[i + 1], buffer[i + 2], 1.0);
        }
      } else {
        for (var _i = 0; _i < bufferLen; _i += 4) {
          colors[_i / 4] = new Color(buffer[_i], buffer[_i + 1], buffer[_i + 2], buffer[_i + 3]);
        }
      }
      return colors;
    }

    /**
     * Parse binary text for glb loader.
     */;
    GLTFUtil.decodeText = function decodeText(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }

      // TextDecoder polyfill
      var s = "";
      for (var i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }
      return decodeURIComponent(encodeURIComponent(s));
    }

    /**
     * Get the number of bytes occupied by accessor type.
     */;
    GLTFUtil.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
      switch (accessorType) {
        case AccessorType.SCALAR:
          return 1;
        case AccessorType.VEC2:
          return 2;
        case AccessorType.VEC3:
          return 3;
        case AccessorType.VEC4:
          return 4;
        case AccessorType.MAT2:
          return 4;
        case AccessorType.MAT3:
          return 9;
        case AccessorType.MAT4:
          return 16;
      }
    }

    /**
     * Get the TypedArray corresponding to the component type.
     */;
    GLTFUtil.getComponentType = function getComponentType(componentType) {
      switch (componentType) {
        case AccessorComponentType.BYTE:
          return Int8Array;
        case AccessorComponentType.UNSIGNED_BYTE:
          return Uint8Array;
        case AccessorComponentType.SHORT:
          return Int16Array;
        case AccessorComponentType.UNSIGNED_SHORT:
          return Uint16Array;
        case AccessorComponentType.UNSIGNED_INT:
          return Uint32Array;
        case AccessorComponentType.FLOAT:
          return Float32Array;
      }
    }

    /**
     * Get accessor data.
     */;
    GLTFUtil.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
      var _bufferView$byteStrid;
      var bufferViews = gltf.bufferViews;
      var bufferView = bufferViews[accessor.bufferView];
      var arrayBuffer = buffers[bufferView.buffer];
      var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
      var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
      var byteOffset = accessorByteOffset + bufferViewByteOffset;
      var accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);
      var length = accessorTypeSize * accessor.count;
      var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
      var arrayType = GLTFUtil.getComponentType(accessor.componentType);
      var uint8Array;
      if (byteStride) {
        var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
        uint8Array = new Uint8Array(accessor.count * accessorByteSize);
        var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
        for (var i = 0; i < accessor.count; i++) {
          for (var j = 0; j < accessorByteSize; j++) {
            uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
          }
        }
      } else {
        uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));
      }
      var typedArray = new arrayType(uint8Array.buffer);
      if (accessor.sparse) {
        var _indices$byteOffset, _indicesBufferView$by, _values$byteOffset, _valuesBufferView$byt;
        var _accessor$sparse = accessor.sparse,
          count = _accessor$sparse.count,
          indices = _accessor$sparse.indices,
          values = _accessor$sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        var indicesArrayBuffer = buffers[indicesBufferView.buffer];
        var valuesArrayBuffer = buffers[valuesBufferView.buffer];
        var indicesByteOffset = ((_indices$byteOffset = indices.byteOffset) != null ? _indices$byteOffset : 0) + ((_indicesBufferView$by = indicesBufferView.byteOffset) != null ? _indicesBufferView$by : 0);
        var indicesByteLength = indicesBufferView.byteLength;
        var valuesByteOffset = ((_values$byteOffset = values.byteOffset) != null ? _values$byteOffset : 0) + ((_valuesBufferView$byt = valuesBufferView.byteOffset) != null ? _valuesBufferView$byt : 0);
        var valuesByteLength = valuesBufferView.byteLength;
        var indicesType = GLTFUtil.getComponentType(indices.componentType);
        var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
        var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
        for (var _i2 = 0; _i2 < count; _i2++) {
          var replaceIndex = indicesArray[_i2];
          for (var _j = 0; _j < accessorTypeSize; _j++) {
            typedArray[replaceIndex * accessorTypeSize + _j] = valuesArray[_i2 * accessorTypeSize + _j];
          }
        }
      }
      return typedArray;
    };
    GLTFUtil.getBufferViewData = function getBufferViewData(bufferView, buffers) {
      var buffer = bufferView.buffer,
        _bufferView$byteOffse = bufferView.byteOffset,
        byteOffset = _bufferView$byteOffse === void 0 ? 0 : _bufferView$byteOffse,
        byteLength = bufferView.byteLength;
      var arrayBuffer = buffers[buffer];
      return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    };
    GLTFUtil.getVertexStride = function getVertexStride(gltf, accessor) {
      var _accessor$bufferView;
      var stride = gltf.bufferViews[(_accessor$bufferView = accessor.bufferView) != null ? _accessor$bufferView : 0].byteStride;
      if (stride) {
        return stride;
      }
      var size = GLTFUtil.getAccessorTypeSize(accessor.type);
      var componentType = GLTFUtil.getComponentType(accessor.componentType);
      return size * componentType.BYTES_PER_ELEMENT;
    };
    GLTFUtil.createVertexElement = function createVertexElement(semantic, accessor, index) {
      var size = GLTFUtil.getAccessorTypeSize(accessor.type);
      return new VertexElement(semantic, 0, GLTFUtil.getElementFormat(accessor.componentType, size, accessor.normalized), index);
    };
    GLTFUtil.getIndexFormat = function getIndexFormat(type) {
      switch (type) {
        case AccessorComponentType.UNSIGNED_BYTE:
          return exports.IndexFormat.UInt8;
        case AccessorComponentType.UNSIGNED_SHORT:
          return exports.IndexFormat.UInt16;
        case AccessorComponentType.UNSIGNED_INT:
          return exports.IndexFormat.UInt32;
      }
    };
    GLTFUtil.getElementFormat = function getElementFormat(type, size, normalized) {
      if (normalized === void 0) {
        normalized = false;
      }
      if (type == AccessorComponentType.FLOAT) {
        switch (size) {
          case 1:
            return exports.VertexElementFormat.Float;
          case 2:
            return exports.VertexElementFormat.Vector2;
          case 3:
            return exports.VertexElementFormat.Vector3;
          case 4:
            return exports.VertexElementFormat.Vector4;
        }
      }
      if (type == AccessorComponentType.SHORT) {
        switch (size) {
          case 2:
            return normalized ? exports.VertexElementFormat.NormalizedShort2 : exports.VertexElementFormat.Short2;
          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedShort4 : exports.VertexElementFormat.Short4;
        }
      }
      if (type == AccessorComponentType.UNSIGNED_SHORT) {
        switch (size) {
          case 2:
            return normalized ? exports.VertexElementFormat.NormalizedUShort2 : exports.VertexElementFormat.UShort2;
          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedUShort4 : exports.VertexElementFormat.UShort4;
        }
      }
      if (type == AccessorComponentType.BYTE) {
        switch (size) {
          case 2:
          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedByte4 : exports.VertexElementFormat.Byte4;
        }
      }
      if (type == AccessorComponentType.UNSIGNED_BYTE) {
        switch (size) {
          case 2:
          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedUByte4 : exports.VertexElementFormat.UByte4;
        }
      }
    }

    /**
     * Load image buffer
     */;
    GLTFUtil.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
      return new Promise(function (resolve, reject) {
        var blob = new window.Blob([imageBuffer], {
          type: type
        });
        var img = new Image();
        img.onerror = function () {
          reject(new Error("Failed to load image buffer"));
        };
        img.onload = function () {
          // Call requestAnimationFrame to avoid iOS's bug.
          requestAnimationFrame(function () {
            resolve(img);
            img.onload = null;
            img.onerror = null;
            img.onabort = null;
          });
        };
        img.crossOrigin = "anonymous";
        img.src = URL.createObjectURL(blob);
      });
    };
    GLTFUtil.isAbsoluteUrl = function isAbsoluteUrl(url) {
      return /^(?:http|blob|data:|\/)/.test(url);
    };
    GLTFUtil.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
      if (GLTFUtil.isAbsoluteUrl(relativeUrl)) {
        return relativeUrl;
      }
      var char0 = relativeUrl.charAt(0);
      if (char0 === ".") {
        return GLTFUtil._formatRelativePath(relativeUrl + relativeUrl);
      }
      return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
    }

    /**
     * Parse the glb format.
     */;
    GLTFUtil.parseGLB = function parseGLB(glb) {
      var UINT32_LENGTH = 4;
      var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'
      var GLB_HEADER_LENGTH = 12;
      var GLB_CHUNK_TYPES = {
        JSON: 0x4e4f534a,
        BIN: 0x004e4942
      };
      var dataView = new DataView(glb);

      // read header
      var header = {
        magic: dataView.getUint32(0, true),
        version: dataView.getUint32(UINT32_LENGTH, true),
        length: dataView.getUint32(2 * UINT32_LENGTH, true)
      };
      if (header.magic !== GLB_HEADER_MAGIC) {
        console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
        return null;
      }

      // read main data
      var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
      var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);

      // read glTF json
      if (chunkType !== GLB_CHUNK_TYPES.JSON) {
        console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
        return null;
      }
      var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
      var gltf = JSON.parse(GLTFUtil.decodeText(glTFData));

      // read all buffers
      var buffers = [];
      var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
      while (byteOffset < header.length) {
        chunkLength = dataView.getUint32(byteOffset, true);
        chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
        if (chunkType !== GLB_CHUNK_TYPES.BIN) {
          console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
          return null;
        }
        var currentOffset = byteOffset + 2 * UINT32_LENGTH;
        var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
        buffers.push(buffer);
        byteOffset += chunkLength + 2 * UINT32_LENGTH;
      }
      return {
        gltf: gltf,
        buffers: buffers
      };
    };
    GLTFUtil._formatRelativePath = function _formatRelativePath(value) {
      var parts = value.split("/");
      for (var i = 0, n = parts.length; i < n; i++) {
        if (parts[i] == "..") {
          parts.splice(i - 1, 2);
          i -= 2;
        }
      }
      return parts.join("/");
    };
    return GLTFUtil;
  }();
  var Parser = /*#__PURE__*/function () {
    function Parser() {}
    Parser.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
      var parsers = Parser._extensionParsers[extensionName];
      if (parsers !== null && parsers !== void 0 && parsers.length) {
        for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
          extra[_key - 4] = arguments[_key];
        }
        for (var i = 0; i < parsers.length; i++) {
          var _parsers$i;
          (_parsers$i = parsers[i]).parseEngineResource.apply(_parsers$i, [extensionSchema, parseResource, context].concat(extra));
        }
      }
    };
    Parser.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
      var parsers = Parser._extensionParsers[extensionName];
      if (parsers !== null && parsers !== void 0 && parsers.length) {
        var _parsers$;
        for (var _len2 = arguments.length, extra = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          extra[_key2 - 3] = arguments[_key2];
        }
        return (_parsers$ = parsers[0]).createEngineResource.apply(_parsers$, [extensionSchema, context].concat(extra));
      }
    };
    Parser.hasExtensionParser = function hasExtensionParser(extensionName) {
      var parsers = Parser._extensionParsers[extensionName];
      return !!(parsers !== null && parsers !== void 0 && parsers.length);
    };
    Parser.initialize = function initialize(extensionName) {
      var parsers = Parser._extensionParsers[extensionName];
      if (parsers !== null && parsers !== void 0 && parsers.length) {
        for (var i = 0; i < parsers.length; i++) {
          parsers[i].initialize();
        }
      }
    }

    /**
     * @internal
     */;
    Parser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
      if (!Parser._extensionParsers[extensionName]) {
        Parser._extensionParsers[extensionName] = [];
      }
      Parser._extensionParsers[extensionName].push(extensionParser);
    };
    return Parser;
  }();

  /**
   * Declare ExtensionParser's decorator.
   * @param extensionName - Extension name
   */
  Parser._extensionParsers = {};
  function registerExtension(extensionName) {
    return function (parser) {
      var extensionParser = new parser();
      Parser._addExtensionParser(extensionName, extensionParser);
    };
  }
  var AnimationParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(AnimationParser, _Parser);
    function AnimationParser() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = AnimationParser.prototype;
    _proto.parse = function parse(context) {
      var gltf = context.gltf,
        buffers = context.buffers,
        entities = context.entities;
      var animations = gltf.animations,
        accessors = gltf.accessors;
      if (!animations) {
        return;
      }
      var animationClipCount = animations.length;
      var animationClips = new Array(animationClipCount);
      var animationsIndices = new Array(animationClipCount);
      for (var i = 0; i < animationClipCount; i++) {
        var gltfAnimation = animations[i];
        var channels = gltfAnimation.channels,
          samplers = gltfAnimation.samplers,
          _gltfAnimation$name = gltfAnimation.name,
          name = _gltfAnimation$name === void 0 ? "AnimationClip" + i : _gltfAnimation$name;
        var animationClip = new AnimationClip(name);
        var sampleDataCollection = new Array();

        // parse samplers
        for (var _i = 0; _i < samplers.length; _i++) {
          var _gltfSampler$interpol;
          var gltfSampler = samplers[_i];
          var inputAccessor = accessors[gltfSampler.input];
          var outputAccessor = accessors[gltfSampler.output];
          var input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);
          var output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);
          var outputAccessorSize = output.length / input.length;
          var interpolation = (_gltfSampler$interpol = gltfSampler.interpolation) != null ? _gltfSampler$interpol : AnimationSamplerInterpolation.Linear;
          var samplerInterpolation = void 0;
          switch (interpolation) {
            case AnimationSamplerInterpolation.CubicSpine:
              samplerInterpolation = exports.InterpolationType.CubicSpine;
              break;
            case AnimationSamplerInterpolation.Step:
              samplerInterpolation = exports.InterpolationType.Step;
              break;
            case AnimationSamplerInterpolation.Linear:
              samplerInterpolation = exports.InterpolationType.Linear;
              break;
          }
          input[input.length - 1];
          sampleDataCollection.push({
            type: outputAccessor.type,
            interpolation: samplerInterpolation,
            input: input,
            output: output,
            outputSize: outputAccessorSize
          });
        }
        for (var _i2 = 0; _i2 < channels.length; _i2++) {
          var gltfChannel = channels[_i2];
          var target = gltfChannel.target;
          var channelTargetEntity = entities[target.node];
          var relativePath = "";
          var entity = channelTargetEntity;
          while (entity.parent) {
            relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
            entity = entity.parent;
          }
          var compType = void 0;
          var propertyName = void 0;
          var interpolableValueType = void 0;
          switch (target.path) {
            case AnimationChannelTargetPath.TRANSLATION:
              compType = Transform;
              propertyName = "position";
              interpolableValueType = exports.InterpolableValueType.Vector3;
              break;
            case AnimationChannelTargetPath.ROTATION:
              compType = Transform;
              propertyName = "rotation";
              interpolableValueType = exports.InterpolableValueType.Quaternion;
              break;
            case AnimationChannelTargetPath.SCALE:
              compType = Transform;
              propertyName = "scale";
              interpolableValueType = exports.InterpolableValueType.Vector3;
              break;
            case AnimationChannelTargetPath.WEIGHTS:
              compType = SkinnedMeshRenderer;
              propertyName = "blendShapeWeights";
              interpolableValueType = exports.InterpolableValueType.FloatArray;
              break;
          }
          var curve = this._addCurve(interpolableValueType, gltfChannel, sampleDataCollection);
          animationClip.addCurveBinding(relativePath, compType, propertyName, curve);
        }
        animationClips[i] = animationClip;
        animationsIndices[i] = {
          name: name,
          index: i
        };
      }
      context.animations = animationClips;
      // @ts-ignore for editor
      context._animationsIndices = animationsIndices;
    };
    _proto._addCurve = function _addCurve(interpolableValueType, gltfChannel, sampleDataCollection) {
      var curve = new AnimationCurve();
      var sampleData = sampleDataCollection[gltfChannel.sampler];
      var input = sampleData.input,
        output = sampleData.output,
        outputSize = sampleData.outputSize;
      curve.interpolation = sampleData.interpolation;
      for (var j = 0, n = input.length; j < n; j++) {
        var offset = j * outputSize;
        if (interpolableValueType === exports.InterpolableValueType.Float) {
          var keyframe = new InterpolableKeyframe();
          keyframe.time = input[j];
          keyframe.inTangent = 0;
          keyframe.outTangent = 0;
          keyframe.value = output[offset];
          curve.addKey(keyframe);
        } else if (interpolableValueType === exports.InterpolableValueType.FloatArray) {
          var _keyframe = new InterpolableKeyframe();
          _keyframe.time = input[j];
          _keyframe.inTangent = new Float32Array(outputSize);
          _keyframe.outTangent = new Float32Array(outputSize);
          _keyframe.value = output.subarray(offset, offset + outputSize);
          curve.addKey(_keyframe);
        } else if (interpolableValueType === exports.InterpolableValueType.Vector2) {
          var _keyframe2 = new InterpolableKeyframe();
          _keyframe2.time = input[j];
          _keyframe2.value = new Vector2(output[offset], output[offset + 1]);
          _keyframe2.inTangent = new Vector2();
          _keyframe2.outTangent = new Vector2();
          curve.addKey(_keyframe2);
        } else if (interpolableValueType === exports.InterpolableValueType.Vector3) {
          var _keyframe3 = new InterpolableKeyframe();
          _keyframe3.time = input[j];
          _keyframe3.value = new Vector3(output[offset], output[offset + 1], output[offset + 2]);
          _keyframe3.inTangent = new Vector3();
          _keyframe3.outTangent = new Vector3();
          curve.addKey(_keyframe3);
        } else if (interpolableValueType === exports.InterpolableValueType.Vector4) {
          var _keyframe4 = new InterpolableKeyframe();
          _keyframe4.time = input[j];
          _keyframe4.value = new Vector4(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
          _keyframe4.inTangent = new Vector4();
          _keyframe4.outTangent = new Vector4();
          curve.addKey(_keyframe4);
        } else if (interpolableValueType === exports.InterpolableValueType.Quaternion) {
          var _keyframe5 = new InterpolableKeyframe();
          _keyframe5.time = input[j];
          _keyframe5.value = new Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
          _keyframe5.inTangent = new Vector4();
          _keyframe5.outTangent = new Vector4();
          curve.addKey(_keyframe5);
        }
      }
      return curve;
    };
    return AnimationParser;
  }(Parser);
  var BufferParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(BufferParser, _Parser);
    function BufferParser() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = BufferParser.prototype;
    _proto.parse = function parse(context) {
      var url = context.url,
        engine = context.engine;
      if (this._isGLB(url)) {
        return engine.resourceManager.load({
          url: url,
          type: exports.AssetType.Buffer
        }).then(GLTFUtil.parseGLB).then(function (_ref) {
          var gltf = _ref.gltf,
            buffers = _ref.buffers;
          context.gltf = gltf;
          context.buffers = buffers;
        });
      } else {
        return engine.resourceManager.load({
          url: url,
          type: exports.AssetType.JSON
        }).then(function (gltf) {
          context.gltf = gltf;
          return Promise.all(gltf.buffers.map(function (buffer) {
            return engine.resourceManager.load({
              type: exports.AssetType.Buffer,
              url: GLTFUtil.parseRelativeUrl(url, buffer.uri)
            });
          })).then(function (buffers) {
            context.buffers = buffers;
          });
        });
      }
    };
    _proto._isGLB = function _isGLB(url) {
      return url.substring(url.lastIndexOf(".") + 1) === "glb";
    };
    return BufferParser;
  }(Parser);
  var EntityParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(EntityParser, _Parser);
    function EntityParser() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = EntityParser.prototype;
    /** @internal */
    _proto.parse = function parse(context) {
      var engine = context.engine,
        nodes = context.gltf.nodes;
      if (!nodes) return;
      var entities = [];
      for (var i = 0; i < nodes.length; i++) {
        var gltfNode = nodes[i];
        var matrix = gltfNode.matrix,
          translation = gltfNode.translation,
          rotation = gltfNode.rotation,
          scale = gltfNode.scale;
        var entity = new Entity(engine, gltfNode.name || "" + EntityParser._defaultName + i);
        var _entity = entity,
          transform = _entity.transform;
        if (matrix) {
          var localMatrix = transform.localMatrix;
          localMatrix.copyFromArray(matrix);
          transform.localMatrix = localMatrix;
        } else {
          if (translation) {
            transform.setPosition(translation[0], translation[1], translation[2]);
          }
          if (rotation) {
            transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
          }
          if (scale) {
            transform.setScale(scale[0], scale[1], scale[2]);
          }
        }
        entities[i] = entity;
      }
      context.entities = entities;
      this._buildEntityTree(context);
      this._createSceneRoots(context);
    };
    _proto._buildEntityTree = function _buildEntityTree(context) {
      var nodes = context.gltf.nodes,
        entities = context.entities;
      for (var i = 0; i < nodes.length; i++) {
        var children = nodes[i].children;
        var entity = entities[i];
        if (children) {
          for (var j = 0; j < children.length; j++) {
            var childEntity = entities[children[j]];
            entity.addChild(childEntity);
          }
        }
      }
    };
    _proto._createSceneRoots = function _createSceneRoots(context) {
      var engine = context.engine,
        _context$gltf = context.gltf,
        _context$gltf$scene = _context$gltf.scene,
        sceneID = _context$gltf$scene === void 0 ? 0 : _context$gltf$scene,
        scenes = _context$gltf.scenes,
        entities = context.entities;
      if (!scenes) return;
      var sceneRoots = [];
      for (var i = 0; i < scenes.length; i++) {
        var nodes = scenes[i].nodes;
        if (!nodes) continue;
        if (nodes.length === 1) {
          sceneRoots[i] = entities[nodes[0]];
        } else {
          var rootEntity = new Entity(engine, "GLTF_ROOT");
          for (var j = 0; j < nodes.length; j++) {
            rootEntity.addChild(entities[nodes[j]]);
          }
          sceneRoots[i] = rootEntity;
        }
      }
      context.sceneRoots = sceneRoots;
      context.defaultSceneRoot = sceneRoots[sceneID];
    };
    return EntityParser;
  }(Parser);
  EntityParser._defaultName = "_GLTF_ENTITY_";
  var MaterialParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(MaterialParser, _Parser);
    function MaterialParser() {
      return _Parser.apply(this, arguments) || this;
    }
    /** @internal */
    MaterialParser._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
      if (extensions === void 0) {
        extensions = {};
      }
      var schema = extensions.KHR_texture_transform;
      if (schema) {
        Parser.parseEngineResource("KHR_texture_transform", schema, material, context);
      }
    };
    var _proto = MaterialParser.prototype;
    _proto.parse = function parse(context) {
      var gltf = context.gltf,
        engine = context.engine,
        textures = context.textures;
      if (!gltf.materials) return;
      var materials = [];
      for (var i = 0; i < gltf.materials.length; i++) {
        var _gltf$materials$i = gltf.materials[i],
          _gltf$materials$i$ext = _gltf$materials$i.extensions,
          extensions = _gltf$materials$i$ext === void 0 ? {} : _gltf$materials$i$ext,
          pbrMetallicRoughness = _gltf$materials$i.pbrMetallicRoughness,
          normalTexture = _gltf$materials$i.normalTexture,
          occlusionTexture = _gltf$materials$i.occlusionTexture,
          emissiveTexture = _gltf$materials$i.emissiveTexture,
          emissiveFactor = _gltf$materials$i.emissiveFactor,
          alphaMode = _gltf$materials$i.alphaMode,
          alphaCutoff = _gltf$materials$i.alphaCutoff,
          doubleSided = _gltf$materials$i.doubleSided,
          _gltf$materials$i$nam = _gltf$materials$i.name,
          name = _gltf$materials$i$nam === void 0 ? "" : _gltf$materials$i$nam;
        var KHR_materials_unlit = extensions.KHR_materials_unlit,
          KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness,
          KHR_materials_clearcoat = extensions.KHR_materials_clearcoat,
          OASIS_materials_remap = extensions.OASIS_materials_remap;
        var material = null;
        if (KHR_materials_unlit) {
          material = Parser.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
        } else if (KHR_materials_pbrSpecularGlossiness) {
          material = Parser.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
        } else {
          material = new PBRMaterial(engine);
        }
        material.name = name;
        if (KHR_materials_clearcoat) {
          Parser.parseEngineResource("KHR_materials_clearcoat", KHR_materials_clearcoat, material, context);
        }
        if (pbrMetallicRoughness) {
          var baseColorFactor = pbrMetallicRoughness.baseColorFactor,
            baseColorTexture = pbrMetallicRoughness.baseColorTexture,
            metallicFactor = pbrMetallicRoughness.metallicFactor,
            roughnessFactor = pbrMetallicRoughness.roughnessFactor,
            metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
          if (baseColorFactor) {
            material.baseColor = new Color(Color.linearToGammaSpace(baseColorFactor[0]), Color.linearToGammaSpace(baseColorFactor[1]), Color.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
          }
          if (baseColorTexture) {
            material.baseTexture = textures[baseColorTexture.index];
            MaterialParser._parseTextureTransform(material, baseColorTexture.extensions, context);
          }
          if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
            var m = material;
            m.metallic = metallicFactor != null ? metallicFactor : 1;
            m.roughness = roughnessFactor != null ? roughnessFactor : 1;
            if (metallicRoughnessTexture) {
              m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
              MaterialParser._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
            }
          }
        }
        if (!KHR_materials_unlit) {
          var _m = material;
          if (emissiveTexture) {
            _m.emissiveTexture = textures[emissiveTexture.index];
            MaterialParser._parseTextureTransform(material, emissiveTexture.extensions, context);
          }
          if (emissiveFactor) {
            _m.emissiveColor = new Color(Color.linearToGammaSpace(emissiveFactor[0]), Color.linearToGammaSpace(emissiveFactor[1]), Color.linearToGammaSpace(emissiveFactor[2]));
          }
          if (normalTexture) {
            var index = normalTexture.index,
              scale = normalTexture.scale;
            _m.normalTexture = textures[index];
            MaterialParser._parseTextureTransform(material, normalTexture.extensions, context);
            if (scale !== undefined) {
              _m.normalTextureIntensity = scale;
            }
          }
          if (occlusionTexture) {
            var _index = occlusionTexture.index,
              strength = occlusionTexture.strength,
              texCoord = occlusionTexture.texCoord;
            _m.occlusionTexture = textures[_index];
            MaterialParser._parseTextureTransform(material, occlusionTexture.extensions, context);
            if (strength !== undefined) {
              _m.occlusionTextureIntensity = strength;
            }
            if (texCoord === exports.TextureCoordinate.UV1) {
              _m.occlusionTextureCoord = exports.TextureCoordinate.UV1;
            } else if (texCoord > exports.TextureCoordinate.UV1) {
              Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
            }
          }
        }
        if (OASIS_materials_remap) {
          var _context$gltf$extensi, _context$gltf$extensi2;
          context.gltf.extensions = (_context$gltf$extensi = context.gltf.extensions) != null ? _context$gltf$extensi : {};
          context.gltf.extensions["OASIS_materials_remap"] = (_context$gltf$extensi2 = context.gltf.extensions["OASIS_materials_remap"]) != null ? _context$gltf$extensi2 : {};
          context.gltf.extensions["OASIS_materials_remap"][i] = Parser.createEngineResource("OASIS_materials_remap", OASIS_materials_remap, context);
        }
        if (doubleSided) {
          material.renderFace = exports.RenderFace.Double;
        } else {
          material.renderFace = exports.RenderFace.Front;
        }
        switch (alphaMode) {
          case MaterialAlphaMode.OPAQUE:
            material.isTransparent = false;
            break;
          case MaterialAlphaMode.BLEND:
            material.isTransparent = true;
            break;
          case MaterialAlphaMode.MASK:
            material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
            break;
        }
        materials[i] = material;
      }
      context.materials = materials;
    };
    return MaterialParser;
  }(Parser);
  var MeshParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(MeshParser, _Parser);
    function MeshParser() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = MeshParser.prototype;
    _proto.parse = function parse(context) {
      var _this = this;
      var engine = context.engine,
        gltf = context.gltf,
        buffers = context.buffers;
      if (!gltf.meshes) return;
      var meshPromises = [];
      var _loop = function _loop(i) {
        var gltfMesh = gltf.meshes[i];
        var primitivePromises = [];
        var _loop2 = function _loop2(j) {
          var gltfPrimitive = gltfMesh.primitives[j];
          var _gltfPrimitive$extens = gltfPrimitive.extensions,
            extensions = _gltfPrimitive$extens === void 0 ? {} : _gltfPrimitive$extens;
          var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
          primitivePromises.push(new Promise(function (resolve) {
            var mesh = new ModelMesh(engine, gltfMesh.name || j + "");
            if (KHR_draco_mesh_compression) {
              Parser.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function (decodedGeometry) {
                return _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
                  for (var _j = 0; _j < decodedGeometry.attributes.length; _j++) {
                    if (decodedGeometry.attributes[_j].name === attributeSemantic) {
                      return decodedGeometry.attributes[_j].array;
                    }
                  }
                  return null;
                }, function (attributeSemantic, shapeIndex) {
                  throw "BlendShape animation is not supported when using draco.";
                }, function () {
                  return decodedGeometry.index.array;
                }, engine);
              }).then(resolve);
            } else {
              _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
                var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
                var accessor = gltf.accessors[accessorIdx];
                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
              }, function (attributeName, shapeIndex) {
                var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
                var attributeAccessorIdx = shapeAccessorIdx[attributeName];
                if (attributeAccessorIdx) {
                  var accessor = gltf.accessors[attributeAccessorIdx];
                  return GLTFUtil.getAccessorData(gltf, accessor, buffers);
                } else {
                  return null;
                }
              }, function () {
                var indexAccessor = gltf.accessors[gltfPrimitive.indices];
                return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
              }, engine).then(resolve);
            }
          }));
        };
        for (var j = 0; j < gltfMesh.primitives.length; j++) {
          _loop2(j);
        }
        meshPromises.push(Promise.all(primitivePromises));
      };
      for (var i = 0; i < gltf.meshes.length; i++) {
        _loop(i);
      }
      return Promise.all(meshPromises).then(function (meshes) {
        context.meshes = meshes;
      });
    };
    _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, engine) {
      var attributes = gltfPrimitive.attributes,
        targets = gltfPrimitive.targets,
        indices = gltfPrimitive.indices,
        mode = gltfPrimitive.mode;
      var vertexCount;
      var accessors = gltf.accessors;
      var accessor = accessors[attributes["POSITION"]];
      var positionBuffer = getVertexBufferData("POSITION");
      var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
      mesh.setPositions(positions);
      var bounds = mesh.bounds;
      vertexCount = accessor.count;
      if (accessor.min && accessor.max) {
        bounds.min.copyFromArray(accessor.min);
        bounds.max.copyFromArray(accessor.max);
      } else {
        var position = MeshParser._tempVector3;
        var min = bounds.min,
          max = bounds.max;
        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        var stride = positionBuffer.length / vertexCount;
        for (var j = 0; j < vertexCount; j++) {
          var offset = j * stride;
          position.copyFromArray(positionBuffer, offset);
          Vector3.min(min, position, min);
          Vector3.max(max, position, max);
        }
      }
      for (var attributeSemantic in attributes) {
        if (attributeSemantic === "POSITION") {
          continue;
        }
        var bufferData = getVertexBufferData(attributeSemantic);
        switch (attributeSemantic) {
          case "NORMAL":
            var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
            mesh.setNormals(normals);
            break;
          case "TEXCOORD_0":
            var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords, 0);
            break;
          case "TEXCOORD_1":
            var texturecoords1 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords1, 1);
            break;
          case "TEXCOORD_2":
            var texturecoords2 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords2, 2);
            break;
          case "TEXCOORD_3":
            var texturecoords3 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords3, 3);
            break;
          case "TEXCOORD_4":
            var texturecoords4 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords4, 4);
            break;
          case "TEXCOORD_5":
            var texturecoords5 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords5, 5);
            break;
          case "TEXCOORD_6":
            var texturecoords6 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords6, 6);
            break;
          case "TEXCOORD_7":
            var texturecoords7 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords7, 7);
            break;
          case "COLOR_0":
            var colors = GLTFUtil.floatBufferToColorArray(bufferData, accessors[attributes["COLOR_0"]].type === AccessorType.VEC3);
            mesh.setColors(colors);
            break;
          case "TANGENT":
            var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setTangents(tangents);
            break;
          case "JOINTS_0":
            var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setBoneIndices(joints);
            break;
          case "WEIGHTS_0":
            var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setBoneWeights(weights);
            break;
        }
      }

      // Indices
      if (indices !== undefined) {
        var indexAccessor = gltf.accessors[indices];
        var indexData = getIndexBufferData();
        mesh.setIndices(indexData);
        mesh.addSubMesh(0, indexAccessor.count, mode);
      } else {
        mesh.addSubMesh(0, vertexCount, mode);
      }

      // BlendShapes
      targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
      mesh.uploadData(true);
      return Promise.resolve(mesh);
    };
    _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
      var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
      for (var i = 0, n = glTFTargets.length; i < n; i++) {
        var _name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
        var deltaPosBuffer = getBlendShapeData("POSITION", i);
        var deltaNorBuffer = getBlendShapeData("NORMAL", i);
        var deltaTanBuffer = getBlendShapeData("TANGENT", i);
        var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
        var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
        var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
        var blendShape = new BlendShape(_name);
        blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);
        mesh.addBlendShape(blendShape);
      }
    };
    return MeshParser;
  }(Parser);
  MeshParser._tempVector3 = new Vector3();
  var SceneParser$1 = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(SceneParser, _Parser);
    function SceneParser() {
      return _Parser.apply(this, arguments) || this;
    }
    SceneParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
      if (!SceneParser._defaultMaterial) {
        SceneParser._defaultMaterial = new BlinnPhongMaterial(engine);
      }
      return SceneParser._defaultMaterial;
    };
    var _proto = SceneParser.prototype;
    _proto.parse = function parse(context) {
      var _context$gltf = context.gltf,
        nodes = _context$gltf.nodes,
        gltfCameras = _context$gltf.cameras,
        entities = context.entities;
      if (!nodes) return;
      var promises = [];
      for (var i = 0; i < nodes.length; i++) {
        var gltfNode = nodes[i];
        var cameraID = gltfNode.camera,
          meshID = gltfNode.mesh,
          _gltfNode$extensions = gltfNode.extensions,
          extensions = _gltfNode$extensions === void 0 ? {} : _gltfNode$extensions;
        var KHR_lights_punctual = extensions.KHR_lights_punctual;
        var entity = entities[i];
        if (cameraID !== undefined) {
          this._createCamera(context, gltfCameras[cameraID], entity);
        }
        if (meshID !== undefined) {
          promises.push(this._createRenderer(context, gltfNode, entity));
        }
        if (KHR_lights_punctual) {
          var lightIndex = KHR_lights_punctual.light;
          var lights = context.gltf.extensions.KHR_lights_punctual.lights;
          Parser.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
        }
      }
      if (context.defaultSceneRoot) {
        this._createAnimator(context);
      }
      context.gltf.extensions && delete context.gltf.extensions["OASIS_materials_remap"];
      return Promise.all(promises);
    };
    _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
      var orthographic = cameraSchema.orthographic,
        perspective = cameraSchema.perspective,
        type = cameraSchema.type;
      var camera = entity.addComponent(Camera);
      if (type === CameraType.ORTHOGRAPHIC) {
        var xmag = orthographic.xmag,
          ymag = orthographic.ymag,
          zfar = orthographic.zfar,
          znear = orthographic.znear;
        camera.isOrthographic = true;
        if (znear !== undefined) {
          camera.nearClipPlane = znear;
        }
        if (zfar !== undefined) {
          camera.farClipPlane = zfar;
        }
        camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
      } else if (type === CameraType.PERSPECTIVE) {
        var aspectRatio = perspective.aspectRatio,
          yfov = perspective.yfov,
          _zfar = perspective.zfar,
          _znear = perspective.znear;
        if (aspectRatio !== undefined) {
          camera.aspectRatio = aspectRatio;
        }
        if (yfov !== undefined) {
          camera.fieldOfView = yfov * 180 / Math.PI;
        }
        if (_zfar !== undefined) {
          camera.farClipPlane = _zfar;
        }
        if (_znear !== undefined) {
          camera.nearClipPlane = _znear;
        }
      }
      if (!context.cameras) context.cameras = [];
      context.cameras.push(camera);
      // @todo: use engine camera by default
      camera.enabled = false;
    };
    _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
      var engine = context.engine,
        gltfMeshes = context.gltf.meshes,
        meshes = context.meshes,
        materials = context.materials,
        skins = context.skins;
      var meshID = gltfNode.mesh,
        skinID = gltfNode.skin;
      var glTFMesh = gltfMeshes[meshID];
      var gltfMeshPrimitives = glTFMesh.primitives;
      var blendShapeWeights = gltfNode.weights || glTFMesh.weights;
      var promises = [];
      var _loop = function _loop(i) {
        var mesh = meshes[meshID][i];
        var renderer = void 0;
        if (skinID !== undefined || blendShapeWeights) {
          var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
          skinRenderer.mesh = mesh;
          if (skinID !== undefined) {
            skinRenderer.skin = skins[skinID];
          }
          if (blendShapeWeights) {
            skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
          }
          renderer = skinRenderer;
        } else {
          renderer = entity.addComponent(MeshRenderer);
          renderer.mesh = mesh;
        }
        var materialIndex = gltfMeshPrimitives[i].material;
        var remapMaterials = context.gltf.extensions && context.gltf.extensions["OASIS_materials_remap"];
        if (remapMaterials && remapMaterials[materialIndex]) {
          promises.push(remapMaterials[materialIndex].then(function (mtl) {
            renderer.setMaterial(mtl);
          }));
        } else {
          var material = (materials === null || materials === void 0 ? void 0 : materials[materialIndex]) || SceneParser._getDefaultMaterial(engine);
          renderer.setMaterial(material);
        }
        var _gltfMeshPrimitives$i = gltfMeshPrimitives[i].extensions,
          extensions = _gltfMeshPrimitives$i === void 0 ? {} : _gltfMeshPrimitives$i;
        var KHR_materials_variants = extensions.KHR_materials_variants;
        if (KHR_materials_variants) {
          Parser.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
        }
      };
      for (var i = 0; i < gltfMeshPrimitives.length; i++) {
        _loop(i);
      }
      return Promise.all(promises);
    };
    _proto._createAnimator = function _createAnimator(context) {
      var defaultSceneRoot = context.defaultSceneRoot,
        animations = context.animations;
      if (!animations) return;
      var animator = defaultSceneRoot.addComponent(Animator);
      var animatorController = new AnimatorController();
      var layer = new AnimatorControllerLayer("layer");
      var animatorStateMachine = new AnimatorStateMachine();
      animatorController.addLayer(layer);
      animator.animatorController = animatorController;
      layer.stateMachine = animatorStateMachine;
      if (animations) {
        for (var i = 0; i < animations.length; i++) {
          var animationClip = animations[i];
          var name = animationClip.name;
          var uniqueName = animatorStateMachine.makeUniqueStateName(name);
          if (uniqueName !== name) {
            console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
          }
          var animatorState = animatorStateMachine.addState(uniqueName);
          animatorState.clip = animationClip;
        }
      }
    };
    return SceneParser;
  }(Parser);
  SceneParser$1._defaultMaterial = void 0;
  var SkinParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(SkinParser, _Parser);
    function SkinParser() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = SkinParser.prototype;
    _proto.parse = function parse(context) {
      var gltf = context.gltf,
        buffers = context.buffers,
        entities = context.entities,
        defaultSceneRoot = context.defaultSceneRoot;
      var gltfSkins = gltf.skins;
      if (!gltfSkins) return;
      var skins = [];
      for (var i = 0; i < gltfSkins.length; i++) {
        var _gltfSkins$i = gltfSkins[i],
          inverseBindMatrices = _gltfSkins$i.inverseBindMatrices,
          skeleton = _gltfSkins$i.skeleton,
          joints = _gltfSkins$i.joints,
          _gltfSkins$i$name = _gltfSkins$i.name,
          name = _gltfSkins$i$name === void 0 ? "SKIN_" + i : _gltfSkins$i$name;
        var jointCount = joints.length;
        var skin = new Skin(name);
        skin.inverseBindMatrices.length = jointCount;

        // parse IBM
        var accessor = gltf.accessors[inverseBindMatrices];
        var buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);
        for (var _i = 0; _i < jointCount; _i++) {
          var inverseBindMatrix = new Matrix();
          inverseBindMatrix.copyFromArray(buffer, _i * 16);
          skin.inverseBindMatrices[_i] = inverseBindMatrix;
        }

        // get joints
        for (var _i2 = 0; _i2 < jointCount; _i2++) {
          skin.joints[_i2] = entities[joints[_i2]].name;
        }

        // get skeleton
        if (skeleton !== undefined) {
          skin.skeleton = entities[skeleton].name;
        } else {
          skin.skeleton = defaultSceneRoot.name;
        }
        skins[i] = skin;
      }
      context.skins = skins;
    };
    return SkinParser;
  }(Parser);
  var TextureParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(TextureParser, _Parser);
    function TextureParser() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = TextureParser.prototype;
    _proto.parse = function parse(context) {
      var _this = this;
      var gltf = context.gltf,
        buffers = context.buffers,
        engine = context.engine,
        url = context.url;
      if (gltf.textures) {
        return Promise.all(gltf.textures.map(function (_ref, index) {
          var sampler = _ref.sampler,
            _ref$source = _ref.source,
            source = _ref$source === void 0 ? 0 : _ref$source,
            textureName = _ref.name;
          var _gltf$images$source = gltf.images[source],
            uri = _gltf$images$source.uri,
            bufferViewIndex = _gltf$images$source.bufferView,
            mimeType = _gltf$images$source.mimeType,
            imageName = _gltf$images$source.name;
          if (uri) {
            return engine.resourceManager.load({
              url: GLTFUtil.parseRelativeUrl(url, uri),
              type: exports.AssetType.Texture2D
            }).then(function (texture) {
              if (!texture.name) {
                texture.name = textureName || imageName || "texture_" + index;
              }
              if (sampler !== undefined) {
                _this._parseSampler(texture, gltf.samplers[sampler]);
              }
              return texture;
            });
          } else {
            var bufferView = gltf.bufferViews[bufferViewIndex];
            var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
            return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then(function (image) {
              var texture = new Texture2D(engine, image.width, image.height);
              texture.setImageSource(image);
              texture.generateMipmaps();
              texture.name = textureName || imageName || "texture_" + index;
              if (sampler !== undefined) {
                _this._parseSampler(texture, gltf.samplers[sampler]);
              }
              return texture;
            });
          }
        })).then(function (textures) {
          context.textures = textures;
        });
      }
    };
    _proto._parseSampler = function _parseSampler(texture, sampler) {
      var magFilter = sampler.magFilter,
        minFilter = sampler.minFilter,
        wrapS = sampler.wrapS,
        wrapT = sampler.wrapT;
      if (magFilter || minFilter) {
        Logger.warn("texture use filterMode in engine");
      }
      if (wrapS) {
        texture.wrapModeU = TextureParser._wrapMap[wrapS];
      }
      if (wrapT) {
        texture.wrapModeV = TextureParser._wrapMap[wrapT];
      }
    };
    return TextureParser;
  }(Parser);
  TextureParser._wrapMap = {
    33071: exports.TextureWrapMode.Clamp,
    33648: exports.TextureWrapMode.Mirror,
    10497: exports.TextureWrapMode.Repeat
  };
  var Validator = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(Validator, _Parser);
    function Validator() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = Validator.prototype;
    _proto.parse = function parse(context) {
      var _context$gltf = context.gltf,
        version = _context$gltf.asset.version,
        extensionsUsed = _context$gltf.extensionsUsed,
        extensionsRequired = _context$gltf.extensionsRequired;
      var gltfVersion = Number(version);
      if (!(gltfVersion >= 2 && gltfVersion < 3)) {
        throw "Only support gltf 2.x.";
      }
      if (extensionsUsed) {
        Logger.info("extensionsUsed: ", extensionsUsed);
        for (var i = 0; i < extensionsUsed.length; i++) {
          if (!Parser.hasExtensionParser(extensionsUsed[i])) {
            Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
          }
        }
      }
      if (extensionsRequired) {
        Logger.info("extensionsRequired: " + extensionsRequired);
        for (var _i = 0; _i < extensionsRequired.length; _i++) {
          var extensionRequired = extensionsRequired[_i];
          if (!Parser.hasExtensionParser(extensionRequired)) {
            Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
          } else {
            Parser.initialize(extensionRequired);
          }
        }
      }
    };
    return Validator;
  }(Parser);
  var GLTFParser = /*#__PURE__*/function () {
    function GLTFParser(pipes) {
      var _this = this;
      this._pipes = [];
      pipes.forEach(function (pipe, index) {
        _this._pipes[index] = new pipe();
      });
    }
    var _proto = GLTFParser.prototype;
    _proto.parse = function parse(context) {
      var _this2 = this;
      var lastPipe;
      return new Promise(function (resolve, reject) {
        _this2._pipes.forEach(function (parser) {
          if (lastPipe) {
            lastPipe = lastPipe.then(function () {
              return parser.parse(context);
            });
          } else {
            lastPipe = parser.parse(context);
          }
        });
        if (lastPipe) {
          lastPipe.then(function () {
            resolve(context);
          }).catch(reject);
        } else {
          resolve(context);
        }
      });
    };
    return GLTFParser;
  }();
  GLTFParser.instance = new GLTFParser([BufferParser, Validator, TextureParser, MaterialParser, MeshParser, EntityParser, SkinParser, AnimationParser, SceneParser$1]);

  /**
   * Product after GLTF parser, usually, `defaultSceneRoot` is only needed to use.
   */
  var GLTFResource = /*#__PURE__*/function (_EngineObject) {
    _inheritsLoose(GLTFResource, _EngineObject);
    function GLTFResource() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
      _this.url = void 0;
      _this.gltf = void 0;
      _this.buffers = void 0;
      _this.textures = void 0;
      _this.materials = void 0;
      _this.meshes = void 0;
      _this.skins = void 0;
      _this.animations = void 0;
      _this.entities = void 0;
      _this.cameras = void 0;
      _this.lights = void 0;
      _this.sceneRoots = void 0;
      _this.defaultSceneRoot = void 0;
      _this.variants = void 0;
      return _this;
    }
    return GLTFResource;
  }(EngineObject);
  var _dec$q, _class$q;
  _dec$q = resourceLoader(exports.AssetType.Prefab, ["gltf", "glb"]), _dec$q(_class$q = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(GLTFLoader, _Loader);
    function GLTFLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = GLTFLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var url = item.url;
      return new AssetPromise(function (resolve, reject) {
        var resource = new GLTFResource(resourceManager.engine);
        resource.url = url;
        GLTFParser.instance.parse(resource).then(resolve).catch(function (e) {
          console.error(e);
          reject("Error loading glTF model from " + url + " .");
        });
      });
    };
    return GLTFLoader;
  }(Loader)) || _class$q;
  var _dec$p, _class$p;
  _dec$p = resourceLoader(exports.AssetType.JSON, ["json"], false), _dec$p(_class$p = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(JSONLoader, _Loader);
    function JSONLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = JSONLoader.prototype;
    _proto.load = function load(item) {
      return this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      }));
    };
    return JSONLoader;
  }(Loader)) || _class$p;

  /**
   *
   * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts
   */
  var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)

  // load types
  var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()

  function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];

    // initialize width & height for level 1
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
    for (var level = 0; level < mipmapCount; level++) {
      var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
      dataOffset += 4; // size of the image + 4 for the imageSize field

      for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
        var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
        mipmaps.push({
          data: byteArray,
          width: width,
          height: height
        });
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
      }

      width = Math.max(1.0, width * 0.5);
      height = Math.max(1.0, height * 0.5);
    }
    return mipmaps;
  }

  /**
   * Checks if the given data starts with a KTX file identifier.
   * @param data the data to check
   * @returns true if the data is a KTX file or false otherwise
   */
  function isValid(data) {
    if (data.byteLength >= 12) {
      // 'Â«', 'K', 'T', 'X', ' ', '1', '1', 'Â»', '\r', '\n', '\x1A', '\n'
      var identifier = new Uint8Array(data, 0, 12);
      if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
        return true;
      }
    }
    return false;
  }
  function getEngineFormat(internalFormat) {
    switch (internalFormat) {
      // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
      // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      // break;
      case exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
        return exports.TextureFormat.DXT1;
      case exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        return exports.TextureFormat.DXT5;
      case exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
        return exports.TextureFormat.ETC1_RGB;
      case exports.GLCompressedTextureInternalFormat.RGB8_ETC2:
        return exports.TextureFormat.ETC2_RGB;
      case exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
        return exports.TextureFormat.ETC2_RGBA5;
      case exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
        return exports.TextureFormat.ETC2_RGBA8;
      case exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGB2;
      case exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGBA2;
      case exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGB4;
      case exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGBA4;
      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
        return exports.TextureFormat.ASTC_4x4;
      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
        return exports.TextureFormat.ASTC_5x5;
      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
        return exports.TextureFormat.ASTC_6x6;
      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
        return exports.TextureFormat.ASTC_8x8;
      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
        return exports.TextureFormat.ASTC_10x10;
      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
        return exports.TextureFormat.ASTC_12x12;
      default:
        var formatName = exports.GLCompressedTextureInternalFormat[internalFormat];
        throw new Error("this format is not supported in Oasis Engine: " + formatName);
    }
  }
  /**
   * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
   * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
   */
  var khronosTextureContainerParser = {
    /**
     *
     * @param buffer contents of the KTX container file
     * @param facesExpected should be either 1 or 6, based whether a cube texture or or
     * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
     * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
     * @param mapEngineFormat get Oasis Engine native TextureFormat?
     */
    parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
      if (mapEngineFormat === void 0) {
        mapEngineFormat = false;
      }
      if (!isValid(buffer)) {
        throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
      }

      // load the reset of the header in native 32 bit uint
      var dataSize = Uint32Array.BYTES_PER_ELEMENT;
      var headerDataView = new DataView(buffer, 12, 13 * dataSize);
      var endianness = headerDataView.getUint32(0, true);
      var littleEndian = endianness === 0x04030201;
      var parsedResult = {
        buffer: buffer,
        glType: headerDataView.getUint32(1 * dataSize, littleEndian),
        // must be 0 for compressed textures
        glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
        // must be 1 for compressed textures
        glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
        // must be 0 for compressed textures
        glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
        // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
        // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
        // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
        // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
        // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
        // used for texture arrays
        numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
        // used for cubemap textures, should either be 1 or 6
        numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
        // number of levels; disregard possibility of 0 for compressed textures
        bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
        // the amount of space after the header for meta-data
        // would need to make this more elaborate & adjust checks above to support more than one load type
        loadType: COMPRESSED_2D
      };

      // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
      if (parsedResult.glType !== 0) {
        throw new Error("only compressed formats currently supported");
      } else {
        // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
        parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
      }
      if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
        throw new Error("only 2D textures currently supported");
      }
      if (parsedResult.numberOfArrayElements !== 0) {
        throw new Error("texture arrays not currently supported");
      }
      if (parsedResult.numberOfFaces !== facesExpected) {
        throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
      }
      if (withMipmaps) {
        parsedResult.mipmaps = getMipmaps(parsedResult, true);
      }
      if (mapEngineFormat) {
        parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
      }
      return parsedResult;
    }
  };
  function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
      mipmaps: ktx.mipmaps,
      engineFormat: ktx.engineFormat,
      internalFormat: ktx.glInternalFormat,
      width: ktx.pixelWidth,
      height: ktx.pixelHeight
    };
  }
  function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;
    for (var i = 0; i < dataArray.length; i++) {
      var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
      mipmapsFaces.push(ktx.mipmaps);
      if (i === 0) {
        width = ktx.pixelWidth;
        height = ktx.pixelHeight;
        internalFormat = ktx.glInternalFormat;
        engineFormat = ktx.engineFormat;
      }
    }
    return {
      mipmapsFaces: mipmapsFaces,
      engineFormat: engineFormat,
      internalFormat: internalFormat,
      width: width,
      height: height
    };
  }
  var _dec$o, _class$o;
  _dec$o = resourceLoader(exports.AssetType.KTXCube, []), _dec$o(_class$o = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(KTXCubeLoader, _Loader);
    function KTXCubeLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = KTXCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        Promise.all(item.urls.map(function (url) {
          return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "arraybuffer"
          }));
        })).then(function (data) {
          var parsedData = parseCubeKTX(data);
          var width = parsedData.width,
            mipmapsFaces = parsedData.mipmapsFaces,
            engineFormat = parsedData.engineFormat;
          var mipmap = mipmapsFaces[0].length > 1;
          var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
          for (var face = 0; face < 6; face++) {
            var length = mipmapsFaces[face].length;
            for (var miplevel = 0; miplevel < length; miplevel++) {
              var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel],
                _data = _mipmapsFaces$face$mi.data,
                _width = _mipmapsFaces$face$mi.width,
                height = _mipmapsFaces$face$mi.height;
              texture.setPixelBuffer(exports.TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
            }
          }
          resolve(texture);
        }).catch(function (e) {
          reject(e);
        });
      });
    };
    return KTXCubeLoader;
  }(Loader)) || _class$o;
  var _dec$n, _class$n;
  _dec$n = resourceLoader(exports.AssetType.KTX, ["ktx"]), _dec$n(_class$n = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(KTXLoader, _Loader);
    function KTXLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = KTXLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        })).then(function (bin) {
          var parsedData = parseSingleKTX(bin);
          var width = parsedData.width,
            height = parsedData.height,
            mipmaps = parsedData.mipmaps,
            engineFormat = parsedData.engineFormat;
          var mipmap = mipmaps.length > 1;
          var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
          for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
            var _mipmaps$miplevel = mipmaps[miplevel],
              _width = _mipmaps$miplevel.width,
              _height = _mipmaps$miplevel.height,
              data = _mipmaps$miplevel.data;
            texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
          }
          resolve(texture);
        }).catch(function (e) {
          reject(e);
        });
      });
    };
    return KTXLoader;
  }(Loader)) || _class$n;
  var _dec$m, _class$m;
  _dec$m = resourceLoader(exports.AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$m(_class$m = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(Texture2DLoader, _Loader);
    function Texture2DLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = Texture2DLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "image"
        })).then(function (image) {
          var texture = new Texture2D(resourceManager.engine, image.width, image.height);
          /** @ts-ignore */
          if (!texture._platformTexture) return;
          texture.setImageSource(image);
          texture.generateMipmaps();
          if (item.url.indexOf("data:") !== 0) {
            var splitPath = item.url.split("/");
            texture.name = splitPath[splitPath.length - 1];
          }
          resolve(texture);
        }).catch(function (e) {
          reject(e);
        });
      });
    };
    return Texture2DLoader;
  }(Loader)) || _class$m;
  var _dec$l, _class$l;
  _dec$l = resourceLoader(exports.AssetType.TextureCube, [""]), _dec$l(_class$l = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(TextureCubeLoader, _Loader);
    function TextureCubeLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = TextureCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        Promise.all(item.urls.map(function (url) {
          return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "image"
          }));
        })).then(function (images) {
          var _images$ = images[0],
            width = _images$.width,
            height = _images$.height;
          if (width !== height) {
            console.error("The cube texture must have the same width and height");
            return;
          }
          var tex = new TextureCube(resourceManager.engine, width);

          /** @ts-ignore */
          if (!tex._platformTexture) return;
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            tex.setImageSource(exports.TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
          }
          tex.generateMipmaps();
          resolve(tex);
        }).catch(function (e) {
          reject(e);
        });
      });
    };
    return TextureCubeLoader;
  }(Loader)) || _class$l;
  var _dec$k, _class$k;
  _dec$k = resourceLoader(exports.AssetType.Sprite, ["sprite"], false), _dec$k(_class$k = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(SpriteLoader, _Loader);
    function SpriteLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = SpriteLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function (data) {
          resourceManager.getResourceByRef(data.texture).then(function (texture) {
            var sprite = new Sprite(resourceManager.engine, texture);
            sprite.region = data.region;
            sprite.pivot = data.pivot;
            resolve(sprite);
          });
        });
      });
    };
    return SpriteLoader;
  }(Loader)) || _class$k;
  var _dec$j, _class$j;
  _dec$j = resourceLoader(exports.AssetType.SpriteAtlas, ["atlas"], false), _dec$j(_class$j = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(SpriteAtlasLoader, _Loader);
    function SpriteAtlasLoader() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _Loader.call.apply(_Loader, [this].concat(args)) || this;
      _this._tempRect = new Rect();
      _this._tempVec2 = new Vector2();
      return _this;
    }
    var _proto = SpriteAtlasLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this2 = this;
      return new AssetPromise(function (resolve, reject) {
        _this2.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function (atlasData) {
          var atlasItems = atlasData.atlasItems,
            format = atlasData.format;
          var atlasItemsLen = atlasItems.length;
          Promise.all(atlasItems.map(function (_ref) {
            var img = _ref.img;
            return _this2.request(GLTFUtil.parseRelativeUrl(item.url, img), _objectSpread2(_objectSpread2({}, item), {}, {
              type: "image"
            }));
          })).then(function (imgs) {
            var engine = resourceManager.engine;
            // Generate a SpriteAtlas object.
            var tempRect = _this2._tempRect,
              tempVec2 = _this2._tempVec2;
            var spriteAtlas = new SpriteAtlas(engine);
            for (var i = 0; i < atlasItemsLen; i++) {
              // Generate Texture2D according to configuration.
              var originalImg = imgs[i];
              var width = originalImg.width,
                height = originalImg.height;
              var texture = new Texture2D(engine, width, height, format);
              texture.setImageSource(originalImg);
              texture.generateMipmaps();
              // Generate all the sprites on this texture.
              var atlasItem = atlasItems[i];
              var sprites = atlasItem.sprites;
              var sourceWidthReciprocal = 1.0 / width;
              var sourceHeightReciprocal = 1.0 / height;
              for (var j = sprites.length - 1; j >= 0; j--) {
                var atlasSprite = sprites[j];
                var region = atlasSprite.region,
                  atlasRegionOffset = atlasSprite.atlasRegionOffset,
                  atlasRegion = atlasSprite.atlasRegion,
                  id = atlasSprite.id,
                  pivot = atlasSprite.pivot;
                var sprite = new Sprite(engine, texture, region ? tempRect.set(region.x, region.y, region.w, region.h) : undefined, pivot ? tempVec2.set(pivot.x, pivot.y) : undefined, undefined, atlasSprite.name);
                sprite.atlasRegion.set(atlasRegion.x * sourceWidthReciprocal, atlasRegion.y * sourceHeightReciprocal, atlasRegion.w * sourceWidthReciprocal, atlasRegion.h * sourceHeightReciprocal);
                atlasSprite.atlasRotated && (sprite.atlasRotated = true);
                if (atlasRegionOffset) {
                  var offsetLeft = atlasRegionOffset.x,
                    offsetTop = atlasRegionOffset.y,
                    offsetRight = atlasRegionOffset.z,
                    offsetBottom = atlasRegionOffset.w;
                  sprite.atlasRegionOffset.set(offsetLeft * sourceWidthReciprocal, offsetTop * sourceHeightReciprocal, offsetRight * sourceWidthReciprocal, offsetBottom * sourceHeightReciprocal);
                }
                if (id !== undefined) {
                  // @ts-ignore
                  sprite._assetID = id;
                }
                // @ts-ignore
                spriteAtlas._addSprite(sprite);
              }
            }
            resolve(spriteAtlas);
          });
        }).catch(function (e) {
          reject(e);
        });
      });
    };
    return SpriteAtlasLoader;
  }(Loader)) || _class$j;
  var _dec$i, _class$i;
  _dec$i = resourceLoader(exports.AssetType.Env, ["env"]), _dec$i(_class$i = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(EnvLoader, _Loader);
    function EnvLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = EnvLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function (arraybuffer) {
          var _Uint16Array;
          var shArray = new Float32Array(arraybuffer, 0, 27);
          var shByteLength = 27 * 4;
          var size = (_Uint16Array = new Uint16Array(arraybuffer, shByteLength, 1)) === null || _Uint16Array === void 0 ? void 0 : _Uint16Array[0];
          var texture = new TextureCube(resourceManager.engine, size);
          texture.filterMode = exports.TextureFilterMode.Trilinear;
          var mipmapCount = texture.mipmapCount;
          var offset = shByteLength + 2;
          for (var mipLevel = 0; mipLevel < mipmapCount; mipLevel++) {
            var mipSize = size >> mipLevel;
            for (var face = 0; face < 6; face++) {
              var dataSize = mipSize * mipSize * 4;
              var data = new Uint8Array(arraybuffer, offset, dataSize);
              offset += dataSize;
              texture.setPixelBuffer(exports.TextureCubeFace.PositiveX + face, data, mipLevel);
            }
          }
          var ambientLight = new AmbientLight();
          var sh = new SphericalHarmonics3();
          ambientLight.diffuseMode = exports.DiffuseMode.SphericalHarmonics;
          sh.copyFromArray(shArray);
          ambientLight.diffuseSphericalHarmonics = sh;
          ambientLight.specularTexture = texture;
          ambientLight.specularTextureDecodeRGBM = true;
          resolve(ambientLight);
        }).catch(function (e) {
          reject(e);
        });
      });
    };
    return EnvLoader;
  }(Loader)) || _class$i;
  var _dec$h, _class$h, _class2$1;
  var PI = Math.PI;
  _dec$h = resourceLoader(exports.AssetType.HDR, ["hdr"]), _dec$h(_class$h = (_class2$1 = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(HDRLoader, _Loader);
    function HDRLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    HDRLoader._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
      if (!pixels) {
        throw "ConvertPanoramaToCubemap: input cannot be null";
      }
      if (pixels.length != inputWidth * inputHeight * 4) {
        throw "ConvertPanoramaToCubemap: input size is wrong";
      }
      var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
      var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
      var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
      var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
      var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
      var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
      return [textureRight, textureLeft, textureUp, textureDown, textureFront, textureBack];
    };
    HDRLoader._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
      var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
      var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
      var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
      var dy = 1 / texSize;
      var fy = 0;
      for (var y = 0; y < texSize; y++) {
        var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
        var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
        for (var x = 0; x < texSize; x++) {
          var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
          v.normalize();
          var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
          this._RGBEToLinear(color);
          this._linearToRGBM(color, 5);

          // 4 channels per pixels
          var index = y * texSize * 4 + x * 4;
          textureArray[index] = color.r;
          textureArray[index + 1] = color.g;
          textureArray[index + 2] = color.b;
          textureArray[index + 3] = color.a;
          xv1.add(rotDX1);
          xv2.add(rotDX2);
        }
        fy += dy;
      }
      return textureArray;
    };
    HDRLoader._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
      var theta = Math.atan2(vDir.z, -vDir.x);
      var phi = Math.acos(vDir.y);
      while (theta < -PI) {
        theta += 2 * PI;
      }
      while (theta > PI) {
        theta -= 2 * PI;
      }
      var dx = theta / PI;
      var dy = phi / PI;

      // recenter.
      dx = dx * 0.5 + 0.5;
      var px = Math.round(dx * inputWidth);
      if (px < 0) {
        px = 0;
      } else if (px >= inputWidth) {
        px = inputWidth - 1;
      }
      var py = Math.round(dy * inputHeight);
      if (py < 0) {
        py = 0;
      } else if (py >= inputHeight) {
        py = inputHeight - 1;
      }
      var inputY = inputHeight - py - 1;
      var index = inputY * inputWidth * 4 + px * 4;
      var r = pixels[index];
      var g = pixels[index + 1];
      var b = pixels[index + 2];
      var a = pixels[index + 3];
      return new Color(r, g, b, a);
    };
    HDRLoader._readStringLine = function _readStringLine(uint8array, startIndex) {
      var line = "";
      var character = "";
      for (var i = startIndex; i < uint8array.length - startIndex; i++) {
        character = String.fromCharCode(uint8array[i]);
        if (character == "\n") {
          break;
        }
        line += character;
      }
      return line;
    };
    HDRLoader._parseHeader = function _parseHeader(uint8array) {
      var height = 0;
      var width = 0;
      var line = this._readStringLine(uint8array, 0);
      if (line[0] != "#" || line[1] != "?") {
        throw "Bad HDR Format.";
      }
      var endOfHeader = false;
      var findFormat = false;
      var lineIndex = 0;
      do {
        lineIndex += line.length + 1;
        line = this._readStringLine(uint8array, lineIndex);
        if (line == "FORMAT=32-bit_rle_rgbe") {
          findFormat = true;
        } else if (line.length == 0) {
          endOfHeader = true;
        }
      } while (!endOfHeader);
      if (!findFormat) {
        throw "HDR Bad header format, unsupported FORMAT";
      }
      lineIndex += line.length + 1;
      line = this._readStringLine(uint8array, lineIndex);
      var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
      var match = sizeRegexp.exec(line);

      // TODO. Support +Y and -X if needed.
      if (!match || match.length < 3) {
        throw "HDR Bad header format, no size";
      }
      width = parseInt(match[2]);
      height = parseInt(match[1]);
      if (width < 8 || width > 0x7fff) {
        throw "HDR Bad header format, unsupported size";
      }
      lineIndex += line.length + 1;
      return {
        height: height,
        width: width,
        dataPosition: lineIndex
      };
    };
    HDRLoader._readPixels = function _readPixels(buffer, width, height) {
      var scanLineWidth = width;
      var byteLength = buffer.byteLength;
      var dataRGBA = new Uint8Array(4 * width * height);
      var offset = 0,
        pos = 0;
      var ptrEnd = 4 * scanLineWidth;
      var rgbeStart = new Uint8Array(4);
      var scanLineBuffer = new Uint8Array(ptrEnd);
      var numScanLines = height; // read in each successive scanLine

      while (numScanLines > 0 && pos < byteLength) {
        rgbeStart[0] = buffer[pos++];
        rgbeStart[1] = buffer[pos++];
        rgbeStart[2] = buffer[pos++];
        rgbeStart[3] = buffer[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanLineWidth) {
          throw "HDR Bad header format, wrong scan line width";
        }

        // read each of the four channels for the scanline into the buffer
        // first red, then green, then blue, then exponent

        var ptr = 0,
          count = void 0;
        while (ptr < ptrEnd && pos < byteLength) {
          count = buffer[pos++];
          var isEncodedRun = count > 128;
          if (isEncodedRun) count -= 128;
          if (0 === count || ptr + count > ptrEnd) {
            throw "HDR Bad Format, bad scanline data (run)";
          }
          if (isEncodedRun) {
            // a (encoded) run of the same value
            var byteValue = buffer[pos++];
            for (var i = 0; i < count; i++) {
              scanLineBuffer[ptr++] = byteValue;
            } //ptr += count;
          } else {
            // a literal-run
            scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        } // now convert data from buffer into rgba
        // first red, then green, then blue, then exponent (alpha)

        var l = scanLineWidth; //scanLine_buffer.byteLength;

        for (var _i = 0; _i < l; _i++) {
          var off = 0;
          dataRGBA[offset] = scanLineBuffer[_i + off];
          off += scanLineWidth;
          dataRGBA[offset + 1] = scanLineBuffer[_i + off];
          off += scanLineWidth;
          dataRGBA[offset + 2] = scanLineBuffer[_i + off];
          off += scanLineWidth;
          dataRGBA[offset + 3] = scanLineBuffer[_i + off];
          offset += 4;
        }
        numScanLines--;
      }
      return dataRGBA;
    };
    HDRLoader._RGBEToLinear = function _RGBEToLinear(color) {
      var scaleFactor = Math.pow(2, color.a - 128) / 255;
      color.r *= scaleFactor;
      color.g *= scaleFactor;
      color.b *= scaleFactor;
      color.a = 1;
    };
    HDRLoader._linearToRGBM = function _linearToRGBM(color, maxRange) {
      var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
      var M = Math.min(maxRGB / maxRange, 1);
      M = Math.ceil(M * 255);
      var scaleFactor = 65025 / (M * maxRange); // 255 * (255 / (M * maxRange) )

      color.r *= scaleFactor;
      color.g *= scaleFactor;
      color.b *= scaleFactor;
      color.a *= M;
    };
    var _proto = HDRLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        var engine = resourceManager.engine;
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function (buffer) {
          var uint8Array = new Uint8Array(buffer);
          var _HDRLoader$_parseHead = HDRLoader._parseHeader(uint8Array),
            width = _HDRLoader$_parseHead.width,
            height = _HDRLoader$_parseHead.height,
            dataPosition = _HDRLoader$_parseHead.dataPosition;
          var pixels = HDRLoader._readPixels(uint8Array.subarray(dataPosition), width, height);
          var cubeSize = height >> 1;
          var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
          var texture = new TextureCube(engine, cubeSize);
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            texture.setPixelBuffer(exports.TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
          }
          texture.generateMipmaps();
          resolve(texture);
        }).catch(reject);
      });
    };
    return HDRLoader;
  }(Loader), _class2$1._rightBottomBack = new Vector3(1.0, -1.0, -1.0), _class2$1._rightBottomFront = new Vector3(1.0, -1.0, 1.0), _class2$1._rightUpBack = new Vector3(1.0, 1.0, -1.0), _class2$1._rightUpFront = new Vector3(1.0, 1.0, 1.0), _class2$1._leftBottomBack = new Vector3(-1.0, -1.0, -1.0), _class2$1._leftBottomFront = new Vector3(-1.0, -1.0, 1.0), _class2$1._leftUpBack = new Vector3(-1.0, 1.0, -1.0), _class2$1._leftUpFront = new Vector3(-1.0, 1.0, 1.0), _class2$1._faceRight = [_class2$1._rightBottomBack, _class2$1._rightBottomFront, _class2$1._rightUpBack, _class2$1._rightUpFront], _class2$1._faceLeft = [_class2$1._leftBottomFront, _class2$1._leftBottomBack, _class2$1._leftUpFront, _class2$1._leftUpBack], _class2$1._faceUp = [_class2$1._leftBottomFront, _class2$1._rightBottomFront, _class2$1._leftBottomBack, _class2$1._rightBottomBack], _class2$1._faceBottom = [_class2$1._leftUpBack, _class2$1._rightUpBack, _class2$1._leftUpFront, _class2$1._rightUpFront], _class2$1._faceFront = [_class2$1._leftBottomBack, _class2$1._rightBottomBack, _class2$1._leftUpBack, _class2$1._rightUpBack], _class2$1._faceBack = [_class2$1._rightBottomFront, _class2$1._leftBottomFront, _class2$1._rightUpFront, _class2$1._leftUpFront], _class2$1._tempVector3 = new Vector3(), _class2$1._temp2Vector3 = new Vector3(), _class2$1._temp3Vector3 = new Vector3(), _class2$1._temp4Vector3 = new Vector3(), _class2$1._temp5Vector3 = new Vector3(), _class2$1)) || _class$h;
  var ExtensionParser = /*#__PURE__*/function () {
    function ExtensionParser() {}
    var _proto = ExtensionParser.prototype;
    _proto.initialize = function initialize() {};
    _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {};
    _proto.createEngineResource = function createEngineResource(schema, context) {
      return null;
    };
    return ExtensionParser;
  }();
  var _dec$g, _class$g, _class2;
  _dec$g = registerExtension("KHR_draco_mesh_compression"), _dec$g(_class$g = (_class2 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_draco_mesh_compression, _ExtensionParser);
    function KHR_draco_mesh_compression() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_draco_mesh_compression.prototype;
    _proto.initialize = function initialize() {
      if (!KHR_draco_mesh_compression._decoder) {
        KHR_draco_mesh_compression._decoder = new DRACODecoder();
      }
    };
    _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
      var gltf = context.gltf,
        buffers = context.buffers;
      var bufferViews = gltf.bufferViews,
        accessors = gltf.accessors;
      var bufferViewIndex = schema.bufferView,
        gltfAttributeMap = schema.attributes;
      var attributeMap = {};
      var attributeTypeMap = {};
      for (var attributeName in gltfAttributeMap) {
        attributeMap[attributeName] = gltfAttributeMap[attributeName];
      }
      for (var _attributeName in gltfPrimitive.attributes) {
        if (gltfAttributeMap[_attributeName] !== undefined) {
          var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
          attributeTypeMap[_attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;
        }
      }
      var indexAccessor = accessors[gltfPrimitive.indices];
      var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
      var taskConfig = {
        attributeIDs: attributeMap,
        attributeTypes: attributeTypeMap,
        useUniqueIDs: true,
        indexType: indexType
      };
      var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
      return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function (parsedGeometry) {
        return parsedGeometry;
      });
    };
    return KHR_draco_mesh_compression;
  }(ExtensionParser), _class2._decoder = void 0, _class2)) || _class$g;
  var _dec$f, _class$f;
  _dec$f = registerExtension("KHR_lights_punctual"), _dec$f(_class$f = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_lights_punctual, _ExtensionParser);
    function KHR_lights_punctual() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_lights_punctual.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
      var color = schema.color,
        _schema$intensity = schema.intensity,
        intensity = _schema$intensity === void 0 ? 1 : _schema$intensity,
        type = schema.type,
        range = schema.range,
        spot = schema.spot;
      var light;
      if (type === "directional") {
        light = entity.addComponent(DirectLight);
      } else if (type === "point") {
        light = entity.addComponent(PointLight);
      } else if (type === "spot") {
        light = entity.addComponent(SpotLight);
      }
      if (color) {
        light.color.set(color[0], color[1], color[2], 1);
      }
      light.intensity = intensity;
      if (range && !(light instanceof DirectLight)) {
        light.distance = range;
      }
      if (spot && light instanceof SpotLight) {
        var _spot$innerConeAngle = spot.innerConeAngle,
          innerConeAngle = _spot$innerConeAngle === void 0 ? 0 : _spot$innerConeAngle,
          _spot$outerConeAngle = spot.outerConeAngle,
          outerConeAngle = _spot$outerConeAngle === void 0 ? Math.PI / 4 : _spot$outerConeAngle;
        light.angle = innerConeAngle;
        light.penumbra = outerConeAngle - innerConeAngle;
      }
      if (!context.lights) context.lights = [];
      context.lights.push(light);
    };
    return KHR_lights_punctual;
  }(ExtensionParser)) || _class$f;
  var _dec$e, _class$e;
  _dec$e = registerExtension("KHR_materials_clearcoat"), _dec$e(_class$e = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_clearcoat, _ExtensionParser);
    function KHR_materials_clearcoat() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_clearcoat.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
      var textures = context.textures;
      var _schema$clearcoatFact = schema.clearcoatFactor,
        clearcoatFactor = _schema$clearcoatFact === void 0 ? 0 : _schema$clearcoatFact,
        clearcoatTexture = schema.clearcoatTexture,
        _schema$clearcoatRoug = schema.clearcoatRoughnessFactor,
        clearcoatRoughnessFactor = _schema$clearcoatRoug === void 0 ? 0 : _schema$clearcoatRoug,
        clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture,
        clearcoatNormalTexture = schema.clearcoatNormalTexture;
      material.clearCoat = clearcoatFactor;
      material.clearCoatRoughness = clearcoatRoughnessFactor;
      if (clearcoatTexture) {
        material.clearCoatTexture = textures[clearcoatTexture.index];
        MaterialParser._parseTextureTransform(material, clearcoatTexture.extensions, context);
      }
      if (clearcoatRoughnessTexture) {
        material.clearCoatRoughnessTexture = textures[clearcoatRoughnessTexture.index];
        MaterialParser._parseTextureTransform(material, clearcoatRoughnessTexture.extensions, context);
      }
      if (clearcoatNormalTexture) {
        material.clearCoatNormalTexture = textures[clearcoatNormalTexture.index];
        MaterialParser._parseTextureTransform(material, clearcoatNormalTexture.extensions, context);
      }
    };
    return KHR_materials_clearcoat;
  }(ExtensionParser)) || _class$e;
  var _dec$d, _class$d;
  _dec$d = registerExtension("KHR_materials_pbrSpecularGlossiness"), _dec$d(_class$d = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_pbrSpecularGlossiness, _ExtensionParser);
    function KHR_materials_pbrSpecularGlossiness() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine,
        textures = context.textures;
      var material = new PBRSpecularMaterial(engine);
      var diffuseFactor = schema.diffuseFactor,
        diffuseTexture = schema.diffuseTexture,
        specularFactor = schema.specularFactor,
        glossinessFactor = schema.glossinessFactor,
        specularGlossinessTexture = schema.specularGlossinessTexture;
      if (diffuseFactor) {
        material.baseColor = new Color(Color.linearToGammaSpace(diffuseFactor[0]), Color.linearToGammaSpace(diffuseFactor[1]), Color.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
      }
      if (diffuseTexture) {
        material.baseTexture = textures[diffuseTexture.index];
        MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
      }
      if (specularFactor) {
        material.specularColor = new Color(Color.linearToGammaSpace(specularFactor[0]), Color.linearToGammaSpace(specularFactor[1]), Color.linearToGammaSpace(specularFactor[2]));
      }
      if (glossinessFactor !== undefined) {
        material.glossiness = glossinessFactor;
      }
      if (specularGlossinessTexture) {
        material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
        MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
      }
      return material;
    };
    return KHR_materials_pbrSpecularGlossiness;
  }(ExtensionParser)) || _class$d;
  var _dec$c, _class$c;
  _dec$c = registerExtension("KHR_materials_unlit"), _dec$c(_class$c = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_unlit, _ExtensionParser);
    function KHR_materials_unlit() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_unlit.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine;
      var material = new UnlitMaterial(engine);
      return material;
    };
    return KHR_materials_unlit;
  }(ExtensionParser)) || _class$c;
  var _dec$b, _class$b;
  _dec$b = registerExtension("KHR_materials_variants"), _dec$b(_class$b = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_variants, _ExtensionParser);
    function KHR_materials_variants() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_variants.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
      var variantNames = context.gltf.extensions.KHR_materials_variants.variants,
        materials = context.materials;
      var mappings = schema.mappings;
      for (var i = 0; i < mappings.length; i++) {
        var _mappings$i = mappings[i],
          material = _mappings$i.material,
          variants = _mappings$i.variants;
        if (!context.variants) context.variants = [];
        context.variants.push({
          renderer: renderer,
          material: materials[material],
          variants: variants.map(function (index) {
            return variantNames[index].name;
          })
        });
      }
    };
    return KHR_materials_variants;
  }(ExtensionParser)) || _class$b;
  var _dec$a, _class$a;
  _dec$a = registerExtension("KHR_mesh_quantization"), _dec$a(_class$a = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_mesh_quantization, _ExtensionParser);
    function KHR_mesh_quantization() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    return KHR_mesh_quantization;
  }(ExtensionParser)) || _class$a;
  var _dec$9, _class$9;
  _dec$9 = registerExtension("KHR_texture_transform"), _dec$9(_class$9 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_texture_transform, _ExtensionParser);
    function KHR_texture_transform() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_texture_transform.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
      var offset = schema.offset,
        rotation = schema.rotation,
        scale = schema.scale,
        texCoord = schema.texCoord;
      if (offset) {
        material.tilingOffset.z = offset[0];
        material.tilingOffset.w = offset[1];
      }
      if (scale) {
        material.tilingOffset.x = scale[0];
        material.tilingOffset.y = scale[1];
      }
      if (rotation) {
        Logger.warn("rotation in KHR_texture_transform is not supported now");
      }
      if (texCoord) {
        Logger.warn("texCoord in KHR_texture_transform is not supported now");
      }
    };
    return KHR_texture_transform;
  }(ExtensionParser)) || _class$9;
  var _dec$8, _class$8;
  _dec$8 = registerExtension("OASIS_materials_remap"), _dec$8(_class$8 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(OasisMaterialsRemap, _ExtensionParser);
    function OasisMaterialsRemap() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = OasisMaterialsRemap.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine;
      return engine.resourceManager.getResourceByRef(schema);
    };
    return OasisMaterialsRemap;
  }(ExtensionParser)) || _class$8;
  var _dec$7, _class$7;
  _dec$7 = resourceLoader(exports.AssetType.Material, ["json"]), _dec$7(_class$7 = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(MaterialLoader, _Loader);
    function MaterialLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = MaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function (json) {
          var engine = resourceManager.engine;
          var shader = json.shader,
            shaderData = json.shaderData,
            macros = json.macros,
            renderState = json.renderState;
          var material;
          switch (shader) {
            case "pbr":
              material = new PBRMaterial(engine);
              break;
            case "pbr-specular":
              material = new PBRSpecularMaterial(engine);
              break;
            case "unlit":
              material = new UnlitMaterial(engine);
              break;
            case "blinn-phong":
              material = new BlinnPhongMaterial(engine);
              break;
          }
          var texturePromises = new Array();
          var materialShaderData = material.shaderData;
          var _loop = function _loop(_key) {
            var _shaderData$_key = shaderData[_key],
              type = _shaderData$_key.type,
              value = _shaderData$_key.value;
            switch (type) {
              case "Vector2":
                materialShaderData.setVector2(_key, new Vector2(value.x, value.y));
                break;
              case "Vector3":
                materialShaderData.setVector3(_key, new Vector3(value.x, value.y, value.z));
                break;
              case "Vector4":
                materialShaderData.setVector4(_key, new Vector4(value.x, value.y, value.z, value.w));
                break;
              case "Color":
                materialShaderData.setColor(_key, new Color(value.r, value.g, value.b, value.a));
                break;
              case "Float":
                materialShaderData.setFloat(_key, value);
                break;
              case "Texture":
                texturePromises.push(resourceManager.getResourceByRef(value).then(function (texture) {
                  materialShaderData.setTexture(_key, texture);
                }));
                break;
            }
          };
          for (var _key in shaderData) {
            _loop(_key);
          }
          for (var i = 0, length = macros.length; i < length; i++) {
            var _macros$i = macros[i],
              name = _macros$i.name,
              value = _macros$i.value;
            if (value == undefined) {
              materialShaderData.enableMacro(name);
            } else {
              materialShaderData.enableMacro(name, value);
            }
          }
          for (var _key2 in renderState) {
            material[_key2] = renderState[_key2];
          }
          Promise.all(texturePromises).then(function () {
            resolve(material);
          });
        });
      });
    };
    return MaterialLoader;
  }(Loader)) || _class$7;
  var BufferReader = /*#__PURE__*/function () {
    function BufferReader(buffer, byteOffset, byteLength, littleEndian) {
      if (byteOffset === void 0) {
        byteOffset = 0;
      }
      if (littleEndian === void 0) {
        littleEndian = true;
      }
      this.buffer = buffer;
      this._dataView = void 0;
      this._littleEndian = void 0;
      this._offset = void 0;
      // byteLength = byteLength ?? _buffer.byteLength;
      this._dataView = new DataView(buffer);
      this._littleEndian = littleEndian;
      this._offset = byteOffset;
    }
    var _proto = BufferReader.prototype;
    _proto.nextUint8 = function nextUint8() {
      var value = this._dataView.getUint8(this._offset);
      this._offset += 1;
      return value;
    };
    _proto.nextUint16 = function nextUint16() {
      var value = this._dataView.getUint16(this._offset, this._littleEndian);
      this._offset += 2;
      return value;
    };
    _proto.nextUint32 = function nextUint32() {
      var value = this._dataView.getUint32(this._offset, this._littleEndian);
      this._offset += 4;
      return value;
    };
    _proto.nextInt32 = function nextInt32() {
      var value = this._dataView.getInt32(this._offset, this._littleEndian);
      this._offset += 4;
      return value;
    };
    _proto.nextInt32Array = function nextInt32Array(len) {
      var value = new Int32Array(this.buffer, this._offset, len);
      this._offset += 4 * len;
      return value;
    };
    _proto.nextFloat32 = function nextFloat32() {
      var value = this._dataView.getFloat32(this._offset, this._littleEndian);
      this._offset += 4;
      return value;
    };
    _proto.nextFloat32Array = function nextFloat32Array(len) {
      var value = new Float32Array(this.buffer, this._offset, len);
      this._offset += 4 * len;
      return value;
    };
    _proto.nextUint32Array = function nextUint32Array(len) {
      var value = new Uint32Array(this.buffer, this._offset, len);
      this._offset += 4 * len;
      return value;
    };
    _proto.nextUint8Array = function nextUint8Array(len) {
      var value = new Uint8Array(this.buffer, this._offset, len);
      this._offset += len;
      return value;
    };
    _proto.nextUint64 = function nextUint64() {
      var left = this._dataView.getUint32(this._offset, this._littleEndian);
      var right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
      var value = left + Math.pow(2, 32) * right;
      this._offset += 8;
      return value;
    };
    _proto.nextStr = function nextStr() {
      var strByteLength = this.nextUint16();
      var uint8Array = new Uint8Array(this.buffer, this._offset, strByteLength);
      this._offset += strByteLength;
      return GLTFUtil.decodeText(uint8Array);
    }

    /**
     * image data æ”¾åœ¨æœ€åŽ
     */;
    _proto.nextImageData = function nextImageData(count) {
      return this.buffer.slice(this._offset);
    };
    _proto.nextImagesData = function nextImagesData(count) {
      var imagesLen = new Array(count);
      // Start offset of Uint32Array should be a multiple of 4. ref: https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
      for (var i = 0; i < count; i++) {
        var len = this._dataView.getUint32(this._offset, this._littleEndian);
        imagesLen[i] = len;
        this._offset += 4;
      }
      var imagesData = [];
      for (var _i = 0; _i < count; _i++) {
        var _len = imagesLen[_i];
        var _buffer = this.buffer.slice(this._offset, this._offset + _len);
        this._offset += _len;
        imagesData.push(_buffer);
      }
      return imagesData;
    };
    _proto.skip = function skip(bytes) {
      this._offset += bytes;
      return this;
    };
    _proto.scan = function scan(maxByteLength, term) {
      if (term === void 0) {
        term = 0x00;
      }
      var byteOffset = this._offset;
      var byteLength = 0;
      while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
        byteLength++;
        this._offset++;
      }
      if (byteLength < maxByteLength) this._offset++;
      return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
    };
    _createClass(BufferReader, [{
      key: "offset",
      get: function get() {
        return this._offset;
      }
    }]);
    return BufferReader;
  }();
  BufferReader.imageMapping = {
    0: "image/png",
    1: "image/jpg",
    2: "image/webp",
    3: "ktx"
  };
  var decoderMap = {};

  /**
   * Decoder decorator generator.
   * @param type - resource file type.
   * @returns Decoder decorator
   */
  function decoder(type) {
    return function (target) {
      decoderMap[type] = target;
    };
  }
  var FileHeader = /*#__PURE__*/function () {
    function FileHeader() {
      this.totalLength = 0;
      this.version = 0;
      this.type = "";
      this.name = "";
      this.headerLength = 0;
    }
    FileHeader.decode = function decode(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      var totalLen = dataView.getUint32(0, true);
      var fileVersion = dataView.getUint8(4);
      var typeLen = dataView.getUint16(5, true);
      var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
      var nameLen = dataView.getUint16(7 + typeLen, true);
      var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
      var name = GLTFUtil.decodeText(nameUint8Array);
      var type = GLTFUtil.decodeText(typeUint8Array);
      var header = new FileHeader();
      header.totalLength = totalLen;
      header.name = name;
      header.type = type;
      header.version = fileVersion;
      header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
      return header;
    };
    _createClass(FileHeader, [{
      key: "dataLength",
      get: function get() {
        return this.totalLength - this.headerLength;
      }
    }]);
    return FileHeader;
  }();
  var _dec$6, _class$6;
  var MeshDecoder = (_dec$6 = decoder("Mesh"), _dec$6(_class$6 = /*#__PURE__*/function () {
    function MeshDecoder() {}
    MeshDecoder.decode = function decode(engine, bufferReader) {
      return new Promise(function (resolve) {
        var modelMesh = new ModelMesh(engine);
        var jsonDataString = bufferReader.nextStr();
        var encodedMeshData = JSON.parse(jsonDataString);
        var offset = Math.ceil(bufferReader.offset / 4) * 4;
        var float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
        var vertexCount = float32Array.length / 3;
        var positions = float32ArrayToVector3(float32Array, vertexCount);
        modelMesh.setPositions(positions);
        if (encodedMeshData.normals) {
          var _float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
          var normals = float32ArrayToVector3(_float32Array, vertexCount);
          modelMesh.setNormals(normals);
        }
        if (encodedMeshData.uvs) {
          var _float32Array2 = new Float32Array(bufferReader.buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array2, vertexCount));
        }
        if (encodedMeshData.uv1) {
          var _float32Array3 = new Float32Array(bufferReader.buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array3, vertexCount), 1);
        }
        if (encodedMeshData.uv2) {
          var _float32Array4 = new Float32Array(bufferReader.buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array4, vertexCount), 2);
        }
        if (encodedMeshData.uv3) {
          var _float32Array5 = new Float32Array(bufferReader.buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array5, vertexCount), 3);
        }
        if (encodedMeshData.uv4) {
          var _float32Array6 = new Float32Array(bufferReader.buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array6, vertexCount), 4);
        }
        if (encodedMeshData.uv5) {
          var _float32Array7 = new Float32Array(bufferReader.buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array7, vertexCount), 5);
        }
        if (encodedMeshData.uv6) {
          var _float32Array8 = new Float32Array(bufferReader.buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array8, vertexCount), 6);
        }
        if (encodedMeshData.uv7) {
          var _float32Array9 = new Float32Array(bufferReader.buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array9, vertexCount), 7);
        }
        if (encodedMeshData.colors) {
          var _float32Array10 = new Float32Array(bufferReader.buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
          modelMesh.setColors(float32ArrayToVColor(_float32Array10, vertexCount));
        }
        if (encodedMeshData.boneWeights) {
          var _float32Array11 = new Float32Array(bufferReader.buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
          modelMesh.setBoneWeights(float32ArrayToVector4(_float32Array11, vertexCount));
        }
        if (encodedMeshData.boneIndices) {
          var _float32Array12 = new Float32Array(bufferReader.buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
          modelMesh.setBoneIndices(float32ArrayToVector4(_float32Array12, vertexCount));
        }
        if (encodedMeshData.blendShapes) {
          encodedMeshData.blendShapes.forEach(function (blendShapeData) {
            var blendShape = new BlendShape(blendShapeData.name);
            blendShapeData.frames.forEach(function (frameData) {
              var positionArray = new Float32Array(bufferReader.buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
              var count = positionArray.length / 3;
              var deltaPosition = float32ArrayToVector3(positionArray, count);
              if (frameData.deltaNormals) {
                var normalsArray = new Float32Array(bufferReader.buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
                float32ArrayToVector3(normalsArray, count);
              }
              if (frameData.deltaTangents) {
                var tangentsArray = new Float32Array(bufferReader.buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
                float32ArrayToVector4(tangentsArray, count);
              }
              blendShape.addFrame(frameData.weight, deltaPosition);
            });
            modelMesh.addBlendShape(blendShape);
          });
        }
        if (encodedMeshData.indices) {
          var indices = null;
          if (encodedMeshData.indices.type === 0) {
            indices = new Uint16Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
          } else {
            indices = new Uint32Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
          }
          modelMesh.setIndices(indices);
        }
        encodedMeshData.subMeshes.forEach(function (subMesh) {
          modelMesh.addSubMesh(subMesh);
        });
        modelMesh.uploadData(false);
        resolve(modelMesh);
      });
    };
    return MeshDecoder;
  }()) || _class$6);
  function float32ArrayToVColor(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new Color(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
  }
  function float32ArrayToVector4(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
  }
  function float32ArrayToVector3(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
    }
    return array;
  }
  function float32ArrayToVector2(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
    }
    return array;
  }
  var _dec$5, _class$5;
  var Texture2DDecoder = (_dec$5 = decoder("Texture2D"), _dec$5(_class$5 = /*#__PURE__*/function () {
    function Texture2DDecoder() {}
    Texture2DDecoder.decode = function decode(engine, bufferReader) {
      return new Promise(function (resolve, reject) {
        var objectId = bufferReader.nextStr();
        var mipmap = !!bufferReader.nextUint8();
        var filterMode = bufferReader.nextUint8();
        var anisoLevel = bufferReader.nextUint8();
        var wrapModeU = bufferReader.nextUint8();
        var wrapModeV = bufferReader.nextUint8();
        var format = bufferReader.nextUint8();
        var width = bufferReader.nextUint16();
        var height = bufferReader.nextUint16();
        var isPixelBuffer = bufferReader.nextUint8();
        var mipCount = bufferReader.nextUint8();
        var imagesData = bufferReader.nextImagesData(mipCount);
        var texture2D = new Texture2D(engine, width, height, format, mipmap);
        texture2D.filterMode = filterMode;
        texture2D.anisoLevel = anisoLevel;
        texture2D.wrapModeU = wrapModeU;
        texture2D.wrapModeV = wrapModeV;
        if (isPixelBuffer) {
          var pixelBuffer = new Uint8Array(imagesData[0]);
          texture2D.setPixelBuffer(pixelBuffer);
          if (mipmap) {
            texture2D.generateMipmaps();
            for (var i = 1; i < mipCount; i++) {
              var _pixelBuffer = new Uint8Array(imagesData[i]);
              texture2D.setPixelBuffer(_pixelBuffer, i);
            }
          }
          // @ts-ignore
          engine.resourceManager._objectPool[objectId] = texture2D;
          resolve(texture2D);
        } else {
          var blob = new window.Blob([imagesData[0]]);
          var img = new Image();
          img.onload = function () {
            texture2D.setImageSource(img);
            var completedCount = 0;
            var onComplete = function onComplete() {
              completedCount++;
              if (completedCount >= mipCount) {
                resolve(texture2D);
              }
            };
            onComplete();
            if (mipmap) {
              texture2D.generateMipmaps();
              var _loop = function _loop(_i) {
                var blob = new window.Blob([imagesData[_i]]);
                var img = new Image();
                img.onload = function () {
                  texture2D.setImageSource(img, _i);
                  onComplete();
                };
                img.src = URL.createObjectURL(blob);
              };
              for (var _i = 1; _i < mipCount; _i++) {
                _loop(_i);
              }
            }
          };
          img.src = URL.createObjectURL(blob);
        }
      });
    };
    return Texture2DDecoder;
  }()) || _class$5);
  var ReflectionParser = /*#__PURE__*/function () {
    function ReflectionParser() {}
    ReflectionParser.parseEntity = function parseEntity(entityConfig, engine) {
      var _this = this;
      return ReflectionParser.getEntityByConfig(entityConfig, engine).then(function (entity) {
        var _entityConfig$isActiv;
        entity.isActive = (_entityConfig$isActiv = entityConfig.isActive) != null ? _entityConfig$isActiv : true;
        var position = entityConfig.position,
          rotation = entityConfig.rotation,
          scale = entityConfig.scale;
        if (position) {
          entity.transform.setPosition(position.x, position.y, position.z);
        }
        if (rotation) {
          entity.transform.setRotation(rotation.x, rotation.y, rotation.z);
        }
        if (scale) {
          entity.transform.setScale(scale.x, scale.y, scale.z);
        }
        var promises = [];
        for (var i = 0; i < entityConfig.components.length; i++) {
          var componentConfig = entityConfig.components[i];
          var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
          var component = void 0;
          if (key === "Animator") {
            component = entity.getComponent(Loader.getClass(key));
          }
          component = component || entity.addComponent(Loader.getClass(key));
          var promise = _this.parsePropsAndMethods(component, componentConfig, engine);
          promises.push(promise);
        }
        return Promise.all(promises).then(function () {
          return entity;
        });
      });
    };
    ReflectionParser.getEntityByConfig = function getEntityByConfig(entityConfig, engine) {
      // @ts-ignore
      var assetRefId = entityConfig.assetRefId;
      if (assetRefId) {
        // @ts-ignore
        return engine.resourceManager.getResourceByRef({
          refId: assetRefId,
          key: entityConfig.key
        });
      } else {
        var entity = new Entity(engine, entityConfig.name);
        return Promise.resolve(entity);
      }
    };
    ReflectionParser.parseClassObject = function parseClassObject(item, engine, resourceManager) {
      var _item$constructParams;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      var Class = Loader.getClass(item.class);
      var params = (_item$constructParams = item.constructParams) != null ? _item$constructParams : [];
      var instance = _construct(Class, params);
      return this.parsePropsAndMethods(instance, item, engine, resourceManager);
    };
    ReflectionParser.parseBasicType = function parseBasicType(value, engine, resourceManager) {
      var _this2 = this;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      if (Array.isArray(value)) {
        return Promise.all(value.map(function (item) {
          return _this2.parseBasicType(item, engine, resourceManager);
        }));
      } else if (typeof value === "object" && value != null) {
        if (this._isClass(value)) {
          // ç±»å¯¹è±¡
          return this.parseClassObject(value, engine, resourceManager);
        } else if (this._isRef(value)) {
          // å¼•ç”¨å¯¹è±¡
          return resourceManager.getResourceByRef(value);
        } else {
          // åŸºç¡€ç±»åž‹
          return Promise.resolve(value);
        }
      } else {
        return Promise.resolve(value);
      }
    };
    ReflectionParser.parsePropsAndMethods = function parsePropsAndMethods(instance, item, engine, resourceManager) {
      var _this3 = this;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      var promises = [];
      if (item.methods) {
        for (var methodName in item.methods) {
          var methodParams = item.methods[methodName];
          for (var i = 0, count = methodParams.length; i < count; i++) {
            var params = methodParams[i];
            var promise = this.parseMethod(instance, methodName, params, engine, resourceManager);
            promises.push(promise);
          }
        }
      }
      if (item.props) {
        var _loop = function _loop(key) {
          var value = item.props[key];
          var promise = _this3.parseBasicType(value, engine).then(function (v) {
            return instance[key] = v;
          });
          promises.push(promise);
        };
        for (var key in item.props) {
          _loop(key);
        }
      }
      return Promise.all(promises).then(function () {
        return instance;
      });
    };
    ReflectionParser.parseMethod = function parseMethod(instance, methodName, methodParams, engine, resourceManager) {
      var _this4 = this;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      return Promise.all(methodParams.map(function (param) {
        return _this4.parseBasicType(param, engine, resourceManager);
      })).then(function (result) {
        return instance[methodName].apply(instance, result);
      });
    };
    ReflectionParser._isClass = function _isClass(value) {
      return value["class"] != undefined;
    };
    ReflectionParser._isRef = function _isRef(value) {
      return value["refId"] != undefined;
    };
    return ReflectionParser;
  }();
  var PrefabParser = /*#__PURE__*/function () {
    function PrefabParser(_engine) {
      this._engine = _engine;
    }
    var _proto = PrefabParser.prototype;
    _proto.parse = function parse(data) {
      var entitiesMap = {};
      var entitiesConfigMap = {};
      var promises = [];
      var entitiesConfig = data.entities;
      for (var _iterator = _createForOfIteratorHelperLoose(entitiesConfig), _step; !(_step = _iterator()).done;) {
        var entity = _step.value;
        entitiesConfigMap[entity.id] = entity;
        promises.push(ReflectionParser.parseEntity(entity, this._engine));
      }
      return Promise.all(promises).then(function (entities) {
        var rootId = entitiesConfig[0].id;
        entities.forEach(function (entity, index) {
          entitiesMap[entitiesConfig[index].id] = entity;
        });
        PrefabParser.parseChildren(entitiesConfigMap, entitiesMap, rootId);
        return entitiesMap[rootId];
      });
    };
    PrefabParser.parseChildren = function parseChildren(entitiesConfig, entities, parentId) {
      var children = entitiesConfig[parentId].children;
      if (children && children.length > 0) {
        var parent = entities[parentId];
        for (var i = 0; i < children.length; i++) {
          var childId = children[i];
          var entity = entities[childId];
          parent.addChild(entity);
          this.parseChildren(entitiesConfig, entities, childId);
        }
      }
    };
    return PrefabParser;
  }();
  var SceneParser = /*#__PURE__*/function () {
    function SceneParser() {}
    SceneParser.parse = function parse(engine, sceneData) {
      var scene = new Scene(engine);
      var entitiesMap = {};
      var entitiesConfigMap = {};
      var promises = [];
      var entitiesConfig = sceneData.entities;
      for (var _iterator = _createForOfIteratorHelperLoose(entitiesConfig), _step; !(_step = _iterator()).done;) {
        var entity = _step.value;
        entitiesConfigMap[entity.id] = entity;
        promises.push(ReflectionParser.parseEntity(entity, engine));
      }
      return Promise.all(promises).then(function (entities) {
        var rootIds = [];
        entities.forEach(function (entity, index) {
          entitiesMap[entitiesConfig[index].id] = entity;
          if (!entitiesConfig[index].parent) {
            rootIds.push(entitiesConfig[index].id);
          }
        });
        for (var _i = 0, _rootIds = rootIds; _i < _rootIds.length; _i++) {
          var rootId = _rootIds[_i];
          PrefabParser.parseChildren(entitiesConfigMap, entitiesMap, rootId);
        }
        var rootEntities = rootIds.map(function (id) {
          return entitiesMap[id];
        });
        for (var i = 0; i < rootEntities.length; i++) {
          scene.addRootEntity(rootEntities[i]);
        }
        return scene;
      });
    };
    return SceneParser;
  }();
  var _dec$4, _class$4;
  var MeshLoader = (_dec$4 = resourceLoader("Mesh", ["prefab"], true), _dec$4(_class$4 = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(MeshLoader, _Loader);
    function MeshLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function (data) {
          decode(data, resourceManager.engine).then(function (mesh) {
            resolve(mesh);
          });
        });
      });
    };
    return MeshLoader;
  }(Loader)) || _class$4);
  var _dec$3, _class$3;
  var EditorTextureLoader = (_dec$3 = resourceLoader("EditorTexture2D", ["prefab"], true), _dec$3(_class$3 = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(EditorTextureLoader, _Loader);
    function EditorTextureLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = EditorTextureLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve) {
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function (data) {
          decode(data, resourceManager.engine).then(function (texture) {
            resolve(texture);
          });
        });
      });
    };
    return EditorTextureLoader;
  }(Loader)) || _class$3);

  /**
   * Decode engine binary resource.
   * @param arrayBuffer - array buffer of decode binary file
   * @param engine - engine
   * @returns
   */
  function decode(arrayBuffer, engine) {
    var header = FileHeader.decode(arrayBuffer);
    var bufferReader = new BufferReader(arrayBuffer, header.headerLength, header.dataLength);
    return decoderMap[header.type].decode(engine, bufferReader).then(function (object) {
      object.name = header.name;
      return object;
    });
  }
  var _dec$2, _class$2;
  _dec$2 = resourceLoader(exports.AssetType.Mesh, ["mesh"]), _dec$2(_class$2 = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(MeshLoader, _Loader);
    function MeshLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        })).then(function (data) {
          return decode(data, resourceManager.engine);
        }).then(function (mesh) {
          resolve(mesh);
        });
      });
    };
    return MeshLoader;
  }(Loader)) || _class$2;
  var _dec$1, _class$1;
  _dec$1 = resourceLoader(exports.AssetType.AnimatorController, ["json"], false), _dec$1(_class$1 = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(AnimatorControllerLoader, _Loader);
    function AnimatorControllerLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = AnimatorControllerLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {
            var animatorController, layers, promises;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    animatorController = new AnimatorController();
                    layers = data.layers;
                    promises = [];
                    layers.forEach(function (layerData, layerIndex) {
                      var name = layerData.name,
                        blendingMode = layerData.blendingMode,
                        weight = layerData.weight,
                        stateMachineData = layerData.stateMachine;
                      var layer = new AnimatorControllerLayer(name);
                      layer.blendingMode = blendingMode;
                      layer.weight = weight;
                      if (stateMachineData) {
                        var states = stateMachineData.states;
                        var stateMachine = layer.stateMachine = new AnimatorStateMachine();
                        states.forEach(function (stateData, stateIndex) {
                          var name = stateData.name,
                            speed = stateData.speed,
                            wrapMode = stateData.wrapMode,
                            clipStartNormalizedTime = stateData.clipStartNormalizedTime,
                            clipEndNormalizedTime = stateData.clipEndNormalizedTime;
                          stateData.isDefaultState;
                          var clipData = stateData.clip;
                          var state = stateMachine.addState(name);
                          state.speed = speed;
                          state.wrapMode = wrapMode;
                          state.clipStartTime = clipStartNormalizedTime;
                          state.clipEndTime = clipEndNormalizedTime;
                          if (clipData) {
                            promises.push(new Promise( /*#__PURE__*/function () {
                              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve) {
                                return _regeneratorRuntime().wrap(function _callee$(_context) {
                                  while (1) {
                                    switch (_context.prev = _context.next) {
                                      case 0:
                                        _context.t0 = resolve;
                                        _context.t1 = layerIndex;
                                        _context.t2 = stateIndex;
                                        _context.next = 5;
                                        return resourceManager.getResourceByRef(clipData);
                                      case 5:
                                        _context.t3 = _context.sent;
                                        _context.t4 = {
                                          layerIndex: _context.t1,
                                          stateIndex: _context.t2,
                                          clip: _context.t3
                                        };
                                        (0, _context.t0)(_context.t4);
                                      case 8:
                                      case "end":
                                        return _context.stop();
                                    }
                                  }
                                }, _callee);
                              }));
                              return function (_x2) {
                                return _ref2.apply(this, arguments);
                              };
                            }()));
                          }
                        });
                        states.forEach(function (stateData) {
                          var name = stateData.name,
                            transitions = stateData.transitions;
                          transitions.forEach(function (transitionData) {
                            var targetStateName = transitionData.targetStateName,
                              duration = transitionData.duration,
                              offset = transitionData.offset,
                              exitTime = transitionData.exitTime;
                            var sourceState = stateMachine.findStateByName(name);
                            var destState = stateMachine.findStateByName(targetStateName);
                            var transition = new AnimatorStateTransition();
                            transition.destinationState = destState;
                            transition.duration = duration;
                            transition.exitTime = exitTime;
                            transition.offset = offset;
                            sourceState.addTransition(transition);
                          });
                        });
                      }
                      animatorController.addLayer(layer);
                    });
                    Promise.all(promises).then(function (clipData) {
                      clipData.forEach(function (data) {
                        var layerIndex = data.layerIndex,
                          stateIndex = data.stateIndex,
                          clip = data.clip;
                        animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                      });
                      resolve(animatorController);
                    });
                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());
      });
    };
    return AnimatorControllerLoader;
  }(Loader)) || _class$1;
  var _dec, _class;
  _dec = resourceLoader(exports.AssetType.Scene, ["prefab"], true), _dec(_class = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(SceneLoader, _Loader);
    function SceneLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = SceneLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      var engine = resourceManager.engine;
      return new AssetPromise(function (resolve, reject) {
        return _this.request(item.url, {
          type: "json"
        }).then(function (data) {
          // @ts-ignore
          engine.resourceManager.initVirtualResources(data.files);
          return SceneParser.parse(engine, data).then(function (scene) {
            var ambient = data.scene.ambient;
            var ambientLightPromise = Promise.resolve();
            if (ambient.ambientLight) {
              ambientLightPromise = resourceManager.getResourceByRef(data.scene.ambient.ambientLight).then(function (light) {
                scene.ambientLight = light;
                scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                scene.ambientLight.specularIntensity = ambient.specularIntensity;
              });
            }
            var background = data.scene.background;
            scene.background.mode = background.mode;
            var backgroundPromise = Promise.resolve();
            switch (scene.background.mode) {
              case exports.BackgroundMode.SolidColor:
                scene.background.solidColor.copyFrom(background.color);
                break;
              case exports.BackgroundMode.Sky:
                if (background.sky) {
                  backgroundPromise = resourceManager.getResourceByRef(background.sky).then(function (light) {
                    var sky = scene.background.sky;
                    var skyMaterial = new SkyBoxMaterial(engine);
                    skyMaterial.textureCubeMap = light.specularTexture;
                    skyMaterial.textureDecodeRGBM = true;
                    sky.material = skyMaterial;
                    sky.mesh = PrimitiveMesh.createCuboid(engine, 1, 1, 1);
                  });
                }
                break;
              case exports.BackgroundMode.Texture:
                if (background.texture) {
                  backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function (texture) {
                    scene.background.texture = texture;
                  });
                }
                break;
            }
            Promise.all([ambientLightPromise, backgroundPromise]).then(function () {
              resolve(scene);
            });
          });
        });
        //
      });
    };

    return SceneLoader;
  }(Loader)) || _class;

  //@ts-ignore
  var version = "0.8.2";
  console.log("oasis engine version: " + version);
  for (var key in CoreObjects) {
    Loader.registerClass(key, CoreObjects[key]);
  }

  exports.AmbientLight = AmbientLight;
  exports.AnimationClip = AnimationClip;
  exports.AnimationClipCurveBinding = AnimationClipCurveBinding;
  exports.AnimationCurve = AnimationCurve;
  exports.AnimationEvent = AnimationEvent;
  exports.Animator = Animator;
  exports.AnimatorController = AnimatorController;
  exports.AnimatorControllerLayer = AnimatorControllerLayer;
  exports.AnimatorState = AnimatorState;
  exports.AnimatorStateMachine = AnimatorStateMachine;
  exports.AnimatorStateTransition = AnimatorStateTransition;
  exports.AssetPromise = AssetPromise;
  exports.Background = Background;
  exports.BaseMaterial = BaseMaterial;
  exports.BasicRenderPipeline = BasicRenderPipeline;
  exports.BlendShape = BlendShape;
  exports.BlendShapeFrame = BlendShapeFrame;
  exports.BlinnPhongMaterial = BlinnPhongMaterial;
  exports.BoolUpdateFlag = BoolUpdateFlag;
  exports.BoundingBox = BoundingBox;
  exports.BoundingFrustum = BoundingFrustum;
  exports.BoundingSphere = BoundingSphere;
  exports.BoxColliderShape = BoxColliderShape;
  exports.Buffer = Buffer;
  exports.BufferMesh = BufferMesh;
  exports.BufferUtil = BufferUtil;
  exports.Camera = Camera;
  exports.CapsuleColliderShape = CapsuleColliderShape;
  exports.CharacterController = CharacterController;
  exports.CloneManager = CloneManager;
  exports.Collider = Collider;
  exports.ColliderShape = ColliderShape;
  exports.CollisionUtil = CollisionUtil;
  exports.Color = Color;
  exports.Component = Component;
  exports.CubeProbe = CubeProbe;
  exports.DirectLight = DirectLight;
  exports.DynamicCollider = DynamicCollider;
  exports.EXP2Fog = EXP2Fog;
  exports.EditorTextureLoader = EditorTextureLoader;
  exports.Engine = Engine;
  exports.EngineFeature = EngineFeature;
  exports.EngineObject = EngineObject;
  exports.Entity = Entity;
  exports.Event = Event;
  exports.EventDispatcher = EventDispatcher;
  exports.FixedJoint = FixedJoint;
  exports.Fog = Fog;
  exports.Font = Font;
  exports.GLTFResource = GLTFResource;
  exports.HingeJoint = HingeJoint;
  exports.HitResult = HitResult;
  exports.IndexBufferBinding = IndexBufferBinding;
  exports.InputManager = InputManager;
  exports.InterpolableKeyframe = InterpolableKeyframe;
  exports.Joint = Joint;
  exports.JointLimits = JointLimits;
  exports.JointMotor = JointMotor;
  exports.Keyframe = Keyframe;
  exports.Light = Light;
  exports.LinearFog = LinearFog;
  exports.ListenerUpdateFlag = ListenerUpdateFlag;
  exports.Loader = Loader;
  exports.Logger = Logger;
  exports.Material = Material;
  exports.MathUtil = MathUtil;
  exports.Matrix = Matrix;
  exports.Matrix3x3 = Matrix3x3;
  exports.Mesh = Mesh;
  exports.MeshDecoder = MeshDecoder;
  exports.MeshLoader = MeshLoader;
  exports.MeshRenderElement = MeshRenderElement;
  exports.MeshRenderer = MeshRenderer;
  exports.ModelMesh = ModelMesh;
  exports.ObjectValues = ObjectValues;
  exports.PBRBaseMaterial = PBRBaseMaterial;
  exports.PBRMaterial = PBRMaterial;
  exports.PBRSpecularMaterial = PBRSpecularMaterial;
  exports.ParticleRenderer = ParticleRenderer;
  exports.PhysicsManager = PhysicsManager;
  exports.PhysicsMaterial = PhysicsMaterial;
  exports.Plane = Plane;
  exports.PlaneColliderShape = PlaneColliderShape;
  exports.PointLight = PointLight;
  exports.Pointer = Pointer;
  exports.PrefabParser = PrefabParser;
  exports.PrimitiveMesh = PrimitiveMesh;
  exports.Probe = Probe;
  exports.Quaternion = Quaternion;
  exports.Ray = Ray;
  exports.Rect = Rect;
  exports.RefObject = RefObject;
  exports.ReflectionParser = ReflectionParser;
  exports.RenderPass = RenderPass;
  exports.RenderQueue = RenderQueue;
  exports.RenderTarget = RenderTarget;
  exports.Renderer = Renderer;
  exports.ResourceManager = ResourceManager;
  exports.Scene = Scene;
  exports.SceneFeature = SceneFeature;
  exports.SceneManager = SceneManager;
  exports.SceneParser = SceneParser;
  exports.Script = Script;
  exports.Shader = Shader;
  exports.ShaderData = ShaderData;
  exports.ShaderFactory = ShaderFactory;
  exports.ShaderProperty = ShaderProperty;
  exports.Skin = Skin;
  exports.SkinnedMeshRenderer = SkinnedMeshRenderer;
  exports.Sky = Sky;
  exports.SkyBoxMaterial = SkyBoxMaterial;
  exports.SphereColliderShape = SphereColliderShape;
  exports.SphericalHarmonics3 = SphericalHarmonics3;
  exports.SpotLight = SpotLight;
  exports.SpringJoint = SpringJoint;
  exports.Sprite = Sprite;
  exports.SpriteAtlas = SpriteAtlas;
  exports.SpriteElement = SpriteElement;
  exports.SpriteMask = SpriteMask;
  exports.SpriteRenderer = SpriteRenderer;
  exports.StateMachineScript = StateMachineScript;
  exports.StaticCollider = StaticCollider;
  exports.SubMesh = SubMesh;
  exports.SystemInfo = SystemInfo;
  exports.TextRenderer = TextRenderer;
  exports.Texture = Texture;
  exports.Texture2D = Texture2D;
  exports.Texture2DArray = Texture2DArray;
  exports.Texture2DDecoder = Texture2DDecoder;
  exports.TextureCube = TextureCube;
  exports.Time = Time;
  exports.TrailMaterial = TrailMaterial;
  exports.TrailRenderer = TrailRenderer;
  exports.Transform = Transform;
  exports.UnlitMaterial = UnlitMaterial;
  exports.Util = Util;
  exports.Vector2 = Vector2;
  exports.Vector3 = Vector3;
  exports.Vector4 = Vector4;
  exports.VertexBufferBinding = VertexBufferBinding;
  exports.VertexElement = VertexElement;
  exports.WebCanvas = WebCanvas;
  exports.WebGLEngine = WebGLEngine;
  exports.WebGLRenderer = WebGLRenderer;
  exports.assignmentClone = assignmentClone;
  exports.decode = decode;
  exports.deepClone = deepClone;
  exports.dependentComponents = dependentComponents;
  exports.ignoreClone = ignoreClone;
  exports.parseSingleKTX = parseSingleKTX;
  exports.request = request;
  exports.resourceLoader = resourceLoader;
  exports.shallowClone = shallowClone;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
