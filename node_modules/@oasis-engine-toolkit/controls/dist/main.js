'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var oasisEngine = require('oasis-engine');

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

// Prevent gimbal lock.
var ESP$1 = oasisEngine.MathUtil.zeroTolerance;

// Spherical.
var Spherical = /*#__PURE__*/function () {
  function Spherical(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    this.radius = radius !== undefined ? radius : 1.0;
    this.phi = phi !== undefined ? phi : 0;
    this.theta = theta !== undefined ? theta : 0;
  }
  var _proto = Spherical.prototype;
  _proto.set = function set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  };
  _proto.makeSafe = function makeSafe() {
    this.phi = oasisEngine.MathUtil.clamp(this.phi, ESP$1, Math.PI - ESP$1);
    return this;
  };
  _proto.setFromVec3 = function setFromVec3(value) {
    this.radius = value.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(value.x, value.z);
      this.phi = Math.acos(oasisEngine.MathUtil.clamp(value.y / this.radius, -1, 1));
    }
    return this;
  };
  _proto.setToVec3 = function setToVec3(value) {
    var radius = this.radius,
      phi = this.phi,
      theta = this.theta;
    var sinPhiRadius = Math.sin(phi) * radius;
    value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
    return this;
  };
  return Spherical;
}();

// Prevent universal lock.
var ESP = oasisEngine.MathUtil.zeroTolerance;
function includes(array) {
  for (var _len = arguments.length, filterArray = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    filterArray[_key - 1] = arguments[_key];
  }
  return filterArray.some(function (e) {
    return array.indexOf(e) !== -1;
  });
}

/**
 * The camera's roaming controller, can move up and down, left and right, and rotate the viewing angle.
 */
var FreeControl = /*#__PURE__*/function (_Script) {
  _inheritsLoose(FreeControl, _Script);
  /**
   * Movement distance per second, the unit is the unit before MVP conversion.
   */

  /**
   * Rotate speed.
   */

  /**
   * Simulate a ground.
   */

  /**
   * Simulated ground height.
   */

  /**
   * Only rotate when press=true
   */

  /**
   * Radian of spherical.theta.
   */

  /**
   * Radian of spherical.phi.
   */

  function FreeControl(entity) {
    var _this;
    _this = _Script.call(this, entity) || this;
    _this._forward = new oasisEngine.Vector3();
    _this._right = new oasisEngine.Vector3();
    _this.camera = void 0;
    _this.mainElement = void 0;
    _this.domElement = void 0;
    _this.movementSpeed = void 0;
    _this.rotateSpeed = void 0;
    _this.floorMock = void 0;
    _this.floorY = void 0;
    _this.press = void 0;
    _this.keysForward = void 0;
    _this.keysBackward = void 0;
    _this.keysLeft = void 0;
    _this.keysRight = void 0;
    _this._theta = void 0;
    _this._phi = void 0;
    _this._moveForward = void 0;
    _this._moveBackward = void 0;
    _this._moveLeft = void 0;
    _this._moveRight = void 0;
    _this._v3Cache = void 0;
    _this._spherical = void 0;
    _this._rotateOri = void 0;
    _this._events = void 0;
    _this.camera = entity;
    // @ts-ignore
    // @todo In the future, the dependence on html elements will be removed and realized through the input of the packaging engine.
    _this.mainElement = _this.engine.canvas._webCanvas;
    _this.domElement = document;
    _this.movementSpeed = 1.0;
    _this.rotateSpeed = 1.0;
    _this.floorMock = true;
    _this.floorY = 0;
    _this.press = false;
    _this.keysForward = ["KeyW", "ArrowUp"];
    _this.keysBackward = ["KeyS", "ArrowDown"];
    _this.keysLeft = ["KeyA", "ArrowLeft"];
    _this.keysRight = ["KeyD", "ArrowRight"];
    _this._theta = 0;
    _this._phi = 0;

    // private variables
    _this._moveForward = false;
    _this._moveBackward = false;
    _this._moveLeft = false;
    _this._moveRight = false;
    _this._v3Cache = new oasisEngine.Vector3();
    _this._spherical = new Spherical();
    _this._rotateOri = [0, 0];
    _this._events = [{
      type: "mousemove",
      listener: _this.onMouseMove.bind(_assertThisInitialized(_this))
    }, {
      type: "touchmove",
      listener: _this.onMouseMove.bind(_assertThisInitialized(_this))
    }, {
      type: "mousedown",
      listener: _this.onMouseDown.bind(_assertThisInitialized(_this))
    }, {
      type: "touchstart",
      listener: _this.onMouseDown.bind(_assertThisInitialized(_this))
    }, {
      type: "mouseup",
      listener: _this.onMouseUp.bind(_assertThisInitialized(_this))
    }, {
      type: "touchend",
      listener: _this.onMouseUp.bind(_assertThisInitialized(_this))
    }, {
      type: "keydown",
      listener: _this.onKeyDown.bind(_assertThisInitialized(_this)),
      element: window
    }, {
      type: "keyup",
      listener: _this.onKeyUp.bind(_assertThisInitialized(_this)),
      element: window
    }, {
      type: "contextmenu",
      listener: _this.onContextMenu.bind(_assertThisInitialized(_this))
    }];
    _this.initEvents();

    // init spherical
    _this.updateSpherical();
    return _this;
  }

  /**
   * Browser right click event.
   */
  var _proto = FreeControl.prototype;
  _proto.onContextMenu = function onContextMenu(event) {
    event.preventDefault();
  }

  /**
   * Keyboard press event.
   */;
  _proto.onKeyDown = function onKeyDown(event) {
    var code = event.code,
      key = event.key,
      keyCode = event.keyCode;
    if (includes(this.keysForward, code, key, keyCode)) {
      this._moveForward = true;
    } else if (includes(this.keysBackward, code, key, keyCode)) {
      this._moveBackward = true;
    } else if (includes(this.keysLeft, code, key, keyCode)) {
      this._moveLeft = true;
    } else if (includes(this.keysRight, code, key, keyCode)) {
      this._moveRight = true;
    }
  }

  /**
   * Keyboard up event.
   */;
  _proto.onKeyUp = function onKeyUp(event) {
    var code = event.code,
      key = event.key,
      keyCode = event.keyCode;
    if (includes(this.keysForward, code, key, keyCode)) {
      this._moveForward = false;
    } else if (includes(this.keysBackward, code, key, keyCode)) {
      this._moveBackward = false;
    } else if (includes(this.keysLeft, code, key, keyCode)) {
      this._moveLeft = false;
    } else if (includes(this.keysRight, code, key, keyCode)) {
      this._moveRight = false;
    }
  }

  /**
   * Mouse press event.
   */;
  _proto.onMouseDown = function onMouseDown(event) {
    event.stopPropagation();
    event = event.changedTouches && event.changedTouches[0] || event;
    if (this.domElement !== document) {
      this.domElement.focus();
    }
    this.press = true;
    this._rotateOri = [event.clientX, event.clientY];
  }

  /**
   * Mouse up event.
   */;
  _proto.onMouseUp = function onMouseUp(event) {
    event.preventDefault();
    event.stopPropagation();
    this.press = false;
  }

  /**
   * Mouse movement event.
   */;
  _proto.onMouseMove = function onMouseMove(event) {
    if (this.press === false) return;
    if (this.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();
    event = event.changedTouches && event.changedTouches[0] || event;
    var movementX = event.clientX - this._rotateOri[0];
    var movementY = event.clientY - this._rotateOri[1];
    this._rotateOri[0] = event.clientX;
    this._rotateOri[1] = event.clientY;
    var factorX = 180 / this.mainElement.width;
    var factorY = 180 / this.mainElement.height;
    var actualX = movementX * factorX;
    var actualY = movementY * factorY;
    this.rotate(-actualX, actualY);
  }

  /**
   * The angle of rotation around the y axis and the x axis respectively.
   * @param alpha - Radian to rotate around the y axis
   * @param beta - Radian to rotate around the x axis
   */;
  _proto.rotate = function rotate(alpha, beta) {
    if (alpha === void 0) {
      alpha = 0;
    }
    if (beta === void 0) {
      beta = 0;
    }
    this._theta += oasisEngine.MathUtil.degreeToRadian(alpha);
    this._phi += oasisEngine.MathUtil.degreeToRadian(beta);
    this._phi = oasisEngine.MathUtil.clamp(this._phi, ESP, Math.PI - ESP);
    this._spherical.theta = this._theta;
    this._spherical.phi = this._phi;
    this._spherical.setToVec3(this._v3Cache);
    oasisEngine.Vector3.add(this.camera.transform.position, this._v3Cache, this._v3Cache);
    this.camera.transform.lookAt(this._v3Cache, new oasisEngine.Vector3(0, 1, 0));
  };
  _proto.onUpdate = function onUpdate(delta) {
    if (this.enabled === false) return;
    var actualMoveSpeed = delta / 1000 * this.movementSpeed;
    this.camera.transform.getWorldForward(this._forward);
    this.camera.transform.getWorldRight(this._right);
    if (this._moveForward) {
      this.camera.transform.translate(this._forward.scale(actualMoveSpeed), false);
    }
    if (this._moveBackward) {
      this.camera.transform.translate(this._forward.scale(-actualMoveSpeed), false);
    }
    if (this._moveLeft) {
      this.camera.transform.translate(this._right.scale(-actualMoveSpeed), false);
    }
    if (this._moveRight) {
      this.camera.transform.translate(this._right.scale(actualMoveSpeed), false);
    }
    if (this.floorMock) {
      var position = this.camera.transform.position;
      if (position.y !== this.floorY) {
        this.camera.transform.setPosition(position.x, this.floorY, position.z);
      }
    }
  }

  /**
   * Register browser events.
   */;
  _proto.initEvents = function initEvents() {
    var _this2 = this;
    this._events.forEach(function (ele) {
      if (ele.element) {
        ele.element.addEventListener(ele.type, ele.listener, false);
      } else {
        _this2.mainElement.addEventListener(ele.type, ele.listener, false);
      }
    });
  };
  _proto.onDestroy = function onDestroy() {
    var _this3 = this;
    this._events.forEach(function (ele) {
      if (ele.element) {
        ele.element.removeEventListener(ele.type, ele.listener, false);
      } else {
        _this3.mainElement.removeEventListener(ele.type, ele.listener, false);
      }
    });
  }

  /**
   * must updateSpherical after quaternion has been changed
   * @example
   * Entity#lookAt([0,1,0],[0,1,0]);
   * AFreeControls#updateSpherical();
   */;
  _proto.updateSpherical = function updateSpherical() {
    this._v3Cache.set(0, 0, -1);
    oasisEngine.Vector3.transformByQuat(this._v3Cache, this.camera.transform.rotationQuaternion, this._v3Cache);
    this._spherical.setFromVec3(this._v3Cache);
    this._theta = this._spherical.theta;
    this._phi = this._spherical.phi;
  };
  return FreeControl;
}(oasisEngine.Script);

exports.ControlHandlerType = void 0;
(function (ControlHandlerType) {
  ControlHandlerType[ControlHandlerType["None"] = 0] = "None";
  ControlHandlerType[ControlHandlerType["ROTATE"] = 1] = "ROTATE";
  ControlHandlerType[ControlHandlerType["ZOOM"] = 2] = "ZOOM";
  ControlHandlerType[ControlHandlerType["PAN"] = 4] = "PAN";
  ControlHandlerType[ControlHandlerType["All"] = 7] = "All";
})(exports.ControlHandlerType || (exports.ControlHandlerType = {}));

/**
 *  Static interface implement decorator.
 *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
 */
function StaticInterfaceImplement() {
  return function (constructor) {
  };
}

var _dec$2, _class$2;
var ControlKeyboard = (_dec$2 = StaticInterfaceImplement(), _dec$2(_class$2 = /*#__PURE__*/function () {
  function ControlKeyboard() {}
  ControlKeyboard.onUpdateHandler = function onUpdateHandler(input) {
    if (input.isKeyHeldDown(oasisEngine.Keys.ArrowLeft) || input.isKeyHeldDown(oasisEngine.Keys.ArrowRight) || input.isKeyHeldDown(oasisEngine.Keys.ArrowUp) || input.isKeyHeldDown(oasisEngine.Keys.ArrowDown)) {
      return exports.ControlHandlerType.PAN;
    } else {
      return exports.ControlHandlerType.None;
    }
  };
  ControlKeyboard.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    var keyPanSpeed = control.keyPanSpeed,
      input = control.input;
    outDelta.x = outDelta.y = 0;
    if (input.isKeyHeldDown(oasisEngine.Keys.ArrowLeft)) {
      outDelta.x += keyPanSpeed;
    }
    if (input.isKeyHeldDown(oasisEngine.Keys.ArrowRight)) {
      outDelta.x -= keyPanSpeed;
    }
    if (input.isKeyHeldDown(oasisEngine.Keys.ArrowUp)) {
      outDelta.y += keyPanSpeed;
    }
    if (input.isKeyHeldDown(oasisEngine.Keys.ArrowDown)) {
      outDelta.y -= keyPanSpeed;
    }
  };
  return ControlKeyboard;
}()) || _class$2);

var _dec$1, _class$1, _class2;
var DeltaType;
(function (DeltaType) {
  DeltaType[DeltaType["Moving"] = 0] = "Moving";
  DeltaType[DeltaType["Distance"] = 1] = "Distance";
})(DeltaType || (DeltaType = {}));
var ControlPointer = (_dec$1 = StaticInterfaceImplement(), _dec$1(_class$1 = (_class2 = /*#__PURE__*/function () {
  function ControlPointer() {}
  ControlPointer.onUpdateHandler = function onUpdateHandler(input) {
    ++this._frameIndex;
    var pointers = input.pointers;
    switch (pointers.length) {
      case 1:
        if (input.isPointerHeldDown(oasisEngine.PointerButton.Secondary)) {
          this._updateType(exports.ControlHandlerType.PAN, DeltaType.Moving);
        } else if (input.isPointerHeldDown(oasisEngine.PointerButton.Auxiliary)) {
          this._updateType(exports.ControlHandlerType.ZOOM, DeltaType.Moving);
        } else if (input.isPointerHeldDown(oasisEngine.PointerButton.Primary)) {
          this._updateType(exports.ControlHandlerType.ROTATE, DeltaType.Moving);
        } else {
          // When `onPointerMove` happens on the same frame as `onPointerUp`
          // Need to record the movement of this frame
          if (input.pointerMovingDelta.x !== 0 && input.pointerMovingDelta.y !== 0) {
            if (input.isPointerUp(oasisEngine.PointerButton.Secondary)) {
              this._updateType(exports.ControlHandlerType.PAN, DeltaType.Moving);
            } else if (input.isPointerUp(oasisEngine.PointerButton.Auxiliary)) {
              this._updateType(exports.ControlHandlerType.ZOOM, DeltaType.Moving);
            } else if (input.isPointerUp(oasisEngine.PointerButton.Primary)) {
              this._updateType(exports.ControlHandlerType.ROTATE, DeltaType.Moving);
            } else {
              this._updateType(exports.ControlHandlerType.None, DeltaType.Moving);
            }
          } else {
            this._updateType(exports.ControlHandlerType.None, DeltaType.Moving);
          }
        }
        break;
      case 2:
        this._updateType(exports.ControlHandlerType.ZOOM, DeltaType.Distance);
        break;
      case 3:
        this._updateType(exports.ControlHandlerType.PAN, DeltaType.Moving);
        break;
      default:
        this._updateType(exports.ControlHandlerType.None, DeltaType.Moving);
        break;
    }
    return this._handlerType;
  };
  ControlPointer.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    var frameIndex = this._frameIndex;
    switch (this._deltaType) {
      case DeltaType.Moving:
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          var pointerMovingDelta = control.input.pointerMovingDelta;
          outDelta.x = pointerMovingDelta.x;
          outDelta.y = pointerMovingDelta.y;
        } else {
          outDelta.x = 0;
          outDelta.y = 0;
        }
        break;
      case DeltaType.Distance:
        var pointers = control.input.pointers;
        var pointer1 = pointers[0];
        var pointer2 = pointers[1];
        var curDistance = oasisEngine.Vector2.distance(pointer1.position, pointer2.position);
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          outDelta.set(0, this._distanceOfPointers - curDistance, 0);
        } else {
          outDelta.set(0, 0, 0);
        }
        this._distanceOfPointers = curDistance;
        break;
    }
    this._lastUsefulFrameIndex = frameIndex;
  };
  ControlPointer._updateType = function _updateType(handlerType, deltaType) {
    if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
      this._handlerType = handlerType;
      this._deltaType = deltaType;
      this._lastUsefulFrameIndex = -1;
    }
  };
  return ControlPointer;
}(), _class2._deltaType = DeltaType.Moving, _class2._handlerType = exports.ControlHandlerType.None, _class2._frameIndex = 0, _class2._lastUsefulFrameIndex = -1, _class2._distanceOfPointers = 0, _class2)) || _class$1);

var _dec, _class;
var ControlWheel = (_dec = StaticInterfaceImplement(), _dec(_class = /*#__PURE__*/function () {
  function ControlWheel() {}
  ControlWheel.onUpdateHandler = function onUpdateHandler(input) {
    var wheelDelta = input.wheelDelta;
    if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
      return exports.ControlHandlerType.None;
    } else {
      return exports.ControlHandlerType.ZOOM;
    }
  };
  ControlWheel.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    outDelta.copyFrom(control.input.wheelDelta);
  };
  return ControlWheel;
}()) || _class);

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */
var OrbitControl = /*#__PURE__*/function (_Script) {
  _inheritsLoose(OrbitControl, _Script);
  function OrbitControl() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Script.call.apply(_Script, [this].concat(args)) || this;
    _this.canvas = void 0;
    _this.input = void 0;
    _this.inputDevices = [ControlKeyboard, ControlPointer, ControlWheel];
    _this.camera = void 0;
    _this.cameraTransform = void 0;
    _this.target = new oasisEngine.Vector3();
    _this.up = new oasisEngine.Vector3(0, 1, 0);
    _this.autoRotate = false;
    _this.autoRotateSpeed = Math.PI;
    _this.enableDamping = true;
    _this.rotateSpeed = 1.0;
    _this.zoomSpeed = 1.0;
    _this.keyPanSpeed = 7.0;
    _this.dampingFactor = 0.1;
    _this.zoomFactor = 0.2;
    _this.minDistance = 0.1;
    _this.maxDistance = Infinity;
    _this.minZoom = 0.0;
    _this.maxZoom = Infinity;
    _this.minPolarAngle = 0.0;
    _this.maxPolarAngle = Math.PI;
    _this.minAzimuthAngle = -Infinity;
    _this.maxAzimuthAngle = Infinity;
    _this._enableKeys = true;
    _this._spherical = new Spherical();
    _this._sphericalDelta = new Spherical();
    _this._sphericalDump = new Spherical();
    _this._zoomFrag = 0;
    _this._scale = 1;
    _this._panOffset = new oasisEngine.Vector3();
    _this._tempVec3 = new oasisEngine.Vector3();
    _this._enableHandler = exports.ControlHandlerType.All;
    return _this;
  }
  var _proto = OrbitControl.prototype;
  _proto.onAwake = function onAwake() {
    var engine = this.engine,
      entity = this.entity;
    this.canvas = engine.canvas;
    this.input = engine.inputManager;
    this.camera = entity.getComponent(oasisEngine.Camera);
    this.cameraTransform = entity.transform;
  };
  _proto.onUpdate = function onUpdate(deltaTime) {
    /** Update this._sphericalDelta, this._scale and this._panOffset. */
    this._updateInputDelta(deltaTime);
    /** Update camera's transform. */
    this._updateTransform();
  };
  _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
    var curHandlerType = exports.ControlHandlerType.None;
    var delta = this._tempVec3,
      enableHandler = this._enableHandler;
    var inputDevices = this.inputDevices,
      input = this.input;
    for (var i = inputDevices.length - 1; i >= 0; i--) {
      var handler = inputDevices[i];
      var handlerType = handler.onUpdateHandler(input);
      if (handlerType & enableHandler) {
        curHandlerType |= handlerType;
        handler.onUpdateDelta(this, delta);
        switch (handlerType) {
          case exports.ControlHandlerType.ROTATE:
            this._rotate(delta);
            break;
          case exports.ControlHandlerType.ZOOM:
            this._zoom(delta);
            break;
          case exports.ControlHandlerType.PAN:
            this._pan(delta);
            break;
        }
      }
    }
    var _sphericalDump = this._sphericalDump,
      _sphericalDelta = this._sphericalDelta;
    if (this.enableDamping) {
      if (enableHandler & exports.ControlHandlerType.ZOOM && curHandlerType ^ exports.ControlHandlerType.ZOOM) {
        this._zoomFrag *= 1 - this.zoomFactor;
      }
      if (enableHandler & exports.ControlHandlerType.ROTATE && curHandlerType ^ exports.ControlHandlerType.ROTATE) {
        _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
        _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
      }
    }
    if (curHandlerType === exports.ControlHandlerType.None && this.autoRotate) {
      var rotateAngle = this.autoRotateSpeed / 1000 * deltaTime;
      _sphericalDelta.theta -= rotateAngle;
    }
  };
  _proto._rotate = function _rotate(delta) {
    var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
    this._sphericalDelta.theta -= radianLeft;
    var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
    this._sphericalDelta.phi -= radianUp;
    if (this.enableDamping) {
      this._sphericalDump.theta = -radianLeft;
      this._sphericalDump.phi = -radianUp;
    }
  };
  _proto._zoom = function _zoom(delta) {
    if (delta.y > 0) {
      this._scale /= Math.pow(0.95, this.zoomSpeed);
    } else if (delta.y < 0) {
      this._scale *= Math.pow(0.95, this.zoomSpeed);
    }
  };
  _proto._pan = function _pan(delta) {
    var cameraTransform = this.cameraTransform;
    var elements = cameraTransform.worldMatrix.elements;
    var height = this.canvas.height;
    var targetDistance = oasisEngine.Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
    var distanceLeft = -2 * delta.x * (targetDistance / height);
    var distanceUp = 2 * delta.y * (targetDistance / height);
    this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
    this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
    this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
  };
  _proto._updateTransform = function _updateTransform() {
    var cameraTransform = this.cameraTransform,
      target = this.target,
      _tempVec3 = this._tempVec3,
      _spherical = this._spherical,
      _sphericalDelta = this._sphericalDelta,
      _panOffset = this._panOffset;
    oasisEngine.Vector3.subtract(cameraTransform.position, target, _tempVec3);
    _spherical.setFromVec3(_tempVec3);
    _spherical.theta += _sphericalDelta.theta;
    _spherical.phi += _sphericalDelta.phi;
    _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
    _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
    _spherical.makeSafe();
    if (this._scale !== 1) {
      this._zoomFrag = _spherical.radius * (this._scale - 1);
    }
    _spherical.radius += this._zoomFrag;
    _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
    _spherical.setToVec3(_tempVec3);
    oasisEngine.Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.position);
    cameraTransform.lookAt(target, this.up);
    /** Reset cache value. */
    this._zoomFrag = 0;
    this._scale = 1;
    _sphericalDelta.set(0, 0, 0);
    _panOffset.set(0, 0, 0);
  };
  _createClass(OrbitControl, [{
    key: "enableKeys",
    get:
    /**
     * Return whether to enable keyboard.
     */
    function get() {
      return this._enableKeys;
    },
    set: function set(value) {
      if (this._enableKeys !== value) {
        this._enableKeys = value;
        var inputDevices = this.inputDevices;
        if (value) {
          inputDevices.push(ControlKeyboard);
        } else {
          for (var i = inputDevices.length - 1; i >= 0; i--) {
            if (inputDevices[i] === ControlKeyboard) {
              inputDevices.splice(i, 1);
              break;
            }
          }
        }
      }
    }

    /**
     *  Return Whether to enable rotation, the default is true.
     */
  }, {
    key: "enableRotate",
    get: function get() {
      return (this._enableHandler & exports.ControlHandlerType.ROTATE) !== 0;
    },
    set: function set(value) {
      if (value) {
        this._enableHandler |= exports.ControlHandlerType.ROTATE;
      } else {
        this._enableHandler &= ~exports.ControlHandlerType.ROTATE;
      }
    }

    /**
     *  Whether to enable camera damping, the default is true.
     */
  }, {
    key: "enableZoom",
    get: function get() {
      return (this._enableHandler & exports.ControlHandlerType.ZOOM) !== 0;
    },
    set: function set(value) {
      if (value) {
        this._enableHandler |= exports.ControlHandlerType.ZOOM;
      } else {
        this._enableHandler &= ~exports.ControlHandlerType.ZOOM;
      }
    }

    /**
     *  Whether to enable translation, the default is true.
     */
  }, {
    key: "enablePan",
    get: function get() {
      return (this._enableHandler & exports.ControlHandlerType.PAN) !== 0;
    },
    set: function set(value) {
      if (value) {
        this._enableHandler |= exports.ControlHandlerType.PAN;
      } else {
        this._enableHandler &= ~exports.ControlHandlerType.PAN;
      }
    }
  }]);
  return OrbitControl;
}(oasisEngine.Script);

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */
var OrthoControl = /*#__PURE__*/function (_Script) {
  _inheritsLoose(OrthoControl, _Script);
  function OrthoControl(entity) {
    var _this;
    _this = _Script.call(this, entity) || this;
    _this.canvas = void 0;
    _this.input = void 0;
    _this.inputDevices = [ControlKeyboard, ControlPointer, ControlWheel];
    _this.camera = void 0;
    _this.cameraTransform = void 0;
    _this.target = new oasisEngine.Vector3();
    _this.up = new oasisEngine.Vector3(0, 1, 0);
    _this.autoRotate = false;
    _this.autoRotateSpeed = Math.PI;
    _this.enableKeys = false;
    _this.enableDamping = true;
    _this.rotateSpeed = 1.0;
    _this.zoomSpeed = 1.0;
    _this.keyPanSpeed = 7.0;
    _this.dampingFactor = 0.1;
    _this.zoomFactor = 0.2;
    _this.minDistance = 0.1;
    _this.maxDistance = Infinity;
    _this.minZoom = 0.0;
    _this.maxZoom = Infinity;
    _this.minPolarAngle = 0.0;
    _this.maxPolarAngle = Math.PI;
    _this.minAzimuthAngle = -Infinity;
    _this.maxAzimuthAngle = Infinity;
    _this._zoomScaleUnit = 25;
    _this._scale = 1;
    _this._panOffset = new oasisEngine.Vector3();
    _this._tempVec3 = new oasisEngine.Vector3();
    _this._enableHandler = exports.ControlHandlerType.All;
    _this.enableRotate = false;
    return _this;
  }
  var _proto = OrthoControl.prototype;
  _proto.onAwake = function onAwake() {
    var engine = this.engine,
      entity = this.entity;
    this.canvas = engine.canvas;
    this.input = engine.inputManager;
    this.camera = entity.getComponent(oasisEngine.Camera);
    this.cameraTransform = entity.transform;
  };
  _proto.onUpdate = function onUpdate(deltaTime) {
    /** Update this._sphericalDelta, this._scale and this._panOffset. */
    this._updateInputDelta(deltaTime);
    /** Update camera's transform. */
    this._updateCamera();
  };
  _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
    exports.ControlHandlerType.None;
    var delta = this._tempVec3,
      enableHandler = this._enableHandler;
    var inputDevices = this.inputDevices,
      input = this.input;
    for (var i = inputDevices.length - 1; i >= 0; i--) {
      var handler = inputDevices[i];
      var handlerType = handler.onUpdateHandler(input);
      if (handlerType & enableHandler) {
        handler.onUpdateDelta(this, delta);
        switch (handlerType) {
          case exports.ControlHandlerType.ZOOM:
            this._zoom(delta);
            break;
          case exports.ControlHandlerType.PAN:
            this._pan(delta);
            break;
        }
      }
    }
  };
  _proto._zoom = function _zoom(delta) {
    if (delta.y > 0) {
      this._scale /= Math.pow(0.95, this.zoomSpeed);
    } else if (delta.y < 0) {
      this._scale *= Math.pow(0.95, this.zoomSpeed);
    }
  };
  _proto._pan = function _pan(delta) {
    this._panOffset.copyFrom(delta);
  };
  _proto._updateCamera = function _updateCamera() {
    var cameraTransform = this.cameraTransform,
      camera = this.camera,
      _panOffset = this._panOffset;

    // Update Zoom
    var sizeDiff = this._zoomScaleUnit * (this._scale - 1);
    var size = camera.orthographicSize + sizeDiff;
    camera.orthographicSize = Math.max(this.minZoom, Math.min(this.maxZoom, size));

    // Update X and Y
    var _this$canvas = this.canvas,
      width = _this$canvas.width,
      height = _this$canvas.height;
    var x = _panOffset.x,
      y = _panOffset.y;
    var doubleOrthographicSize = camera.orthographicSize * 2;
    var width3D = doubleOrthographicSize * camera.aspectRatio;
    var height3D = doubleOrthographicSize;
    var cameraPosition = cameraTransform.position;
    var curPosition = this._tempVec3;
    curPosition.x = cameraPosition.x - x * width3D / width;
    curPosition.y = cameraPosition.y + y * height3D / height;
    curPosition.z = cameraPosition.z;

    // Update camera transform
    cameraTransform.position = curPosition;
    /** Reset cache value. */
    this._scale = 1;
    _panOffset.set(0, 0, 0);
  };
  _createClass(OrthoControl, [{
    key: "enableRotate",
    get: /** Target position. */

    /** Up vector */

    /** Whether to automatically rotate the camera, the default is false. */

    /** The radian of automatic rotation per second. */

    /** Whether to enable keyboard. */

    /** Whether to enable camera damping, the default is true. */

    /** Rotation speed, default is 1.0 . */

    /** Camera zoom speed, the default is 1.0. */

    /** Keyboard translation speed, the default is 7.0 . */

    /** Rotation damping parameter, default is 0.1 . */

    /** Zoom damping parameter, default is 0.2 . */

    /**  The minimum distance, the default is 0.1, should be greater than 0. */

    /** The maximum distance, the default is infinite, should be greater than the minimum distance. */

    /** Minimum zoom speed, the default is 0.0. */

    /** Maximum zoom speed, the default is positive infinity. */

    /** The minimum radian in the vertical direction, the default is 0 radian, the value range is 0 - Math.PI. */

    /** The maximum radian in the vertical direction, the default is Math.PI, and the value range is 0 - Math.PI. */

    /** The minimum radian in the horizontal direction, the default is negative infinity. */

    /** The maximum radian in the horizontal direction, the default is positive infinity.  */

    /**
     *  Return Whether to enable rotation, the default is true.
     */
    function get() {
      return (this._enableHandler & exports.ControlHandlerType.ROTATE) !== 0;
    },
    set: function set(value) {
      if (value) {
        this._enableHandler |= exports.ControlHandlerType.ROTATE;
      } else {
        this._enableHandler &= ~exports.ControlHandlerType.ROTATE;
      }
    }

    /**
     *  Whether to enable camera damping, the default is true.
     */
  }, {
    key: "enableZoom",
    get: function get() {
      return (this._enableHandler & exports.ControlHandlerType.ZOOM) !== 0;
    },
    set: function set(value) {
      if (value) {
        this._enableHandler |= exports.ControlHandlerType.ZOOM;
      } else {
        this._enableHandler &= ~exports.ControlHandlerType.ZOOM;
      }
    }

    /**
     *  Whether to enable translation, the default is true.
     */
  }, {
    key: "enablePan",
    get: function get() {
      return (this._enableHandler & exports.ControlHandlerType.PAN) !== 0;
    },
    set: function set(value) {
      if (value) {
        this._enableHandler |= exports.ControlHandlerType.PAN;
      } else {
        this._enableHandler &= ~exports.ControlHandlerType.PAN;
      }
    }
  }]);
  return OrthoControl;
}(oasisEngine.Script);

exports.ControlKeyboard = ControlKeyboard;
exports.ControlPointer = ControlPointer;
exports.ControlWheel = ControlWheel;
exports.FreeControl = FreeControl;
exports.OrbitControl = OrbitControl;
exports.OrthoControl = OrthoControl;
exports.StaticInterfaceImplement = StaticInterfaceImplement;
//# sourceMappingURL=main.js.map
