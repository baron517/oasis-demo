import { Vector3, Quaternion, Matrix3x3, Matrix, MathUtil, Vector2, Ray, Color, Vector4, BoundingBox, BoundingFrustum, Rect } from '@oasis-engine/math';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}

var Util = {
  isArray: "isArray" in Array ? Array.isArray : function (value) {
    return toString.call(value) === "[object Array]";
  },
  isArrayLike: function isArrayLike(x) {
    return !!x && typeof x.length === "number" && typeof x !== "function";
  },
  clone: function clone(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (Util.isArrayLike(obj)) {
      rst = obj.slice();
      for (var i = 0, l = obj.length; i < l; i++) {
        rst[i] = Util.clone(obj[i]);
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
          rst[k] = Util.clone(obj[k]);
        }
      }
    }
    return rst;
  },
  downloadBlob: function downloadBlob(blob, fileName) {
    if (fileName === void 0) {
      fileName = "";
    }
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function () {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
};

/**
 * Fastly remove an element from array.
 * @param array - Array
 * @param item - Element
 */
function removeFromArray(array, item) {
  var index = array.indexOf(item);
  if (index < 0) {
    return false;
  }
  var last = array.length - 1;
  if (index !== last) {
    var end = array[last];
    array[index] = end;
  }
  array.length--;
  return true;
}
function ObjectValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

var Utils = /*#__PURE__*/function () {
  function Utils() {}
  /**
   * @internal
   * Simplify lodash get: https://github.com/lodash/lodash/blob/master/get.js.
   * @param target - The object to query.
   * @param path - The path of the property to get.
   * @returns Returns the resolved value.
   */
  Utils._reflectGet = function _reflectGet(target, path) {
    var pathArr = this._stringToPath(path);
    var object = target;
    var index = 0;
    var length = pathArr.length;
    while (object != null && index < length) {
      object = object[pathArr[index++]];
    }
    return index && index == length ? object : undefined;
  };
  Utils._stringToPath = function _stringToPath(string) {
    var result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
      result.push("");
    }
    string.replace(rePropName, function (match, expression, quote, subString) {
      var key = match;
      if (quote) {
        key = subString.replace(reEscapeChar, "$1");
      } else if (expression) {
        key = expression.trim();
      }
      result.push(key);
    });
    return result;
  };
  return Utils;
}();
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(
// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" +
// Or match property names within brackets.
"\\[(?:" +
// Match a non-string expression.
"([^\"'][^[]*)" + "|" +
// Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" +
// Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");

/**
 * Asset Promise Status
 */
var AssetPromiseStatus;
/**
 * Asset Loading Promise.
 */
(function (AssetPromiseStatus) {
  AssetPromiseStatus[AssetPromiseStatus["Success"] = 0] = "Success";
  AssetPromiseStatus[AssetPromiseStatus["Pending"] = 1] = "Pending";
  AssetPromiseStatus[AssetPromiseStatus["Failed"] = 2] = "Failed";
})(AssetPromiseStatus || (AssetPromiseStatus = {}));
var AssetPromise = /*#__PURE__*/function (_Promise) {
  _inheritsLoose(AssetPromise, _Promise);
  /**
   * Return a new resource Promise through the provided asset promise collection.
   * The resolved of the new AssetPromise will be triggered when all the Promises in the provided set are completed.
   * @param - AssetPromise Collection
   * @returns AssetPromise
   */
  AssetPromise.all = function all(promises) {
    return new AssetPromise(function (resolve, reject, setProgress) {
      if (!Array.isArray(promises)) {
        return resolve([promises]);
      }
      var completed = 0;
      var total = promises.length;
      var results = new Array(total);
      promises.forEach(function (value, index) {
        Promise.resolve(value).then(function (result) {
          results[index] = result;
          completed += 1;
          setProgress(completed / total);
          if (completed == total) {
            resolve(results);
          }
        }).catch(function (err) {
          return reject(err);
        });
      });
    });
  };
  var _proto = AssetPromise.prototype;
  /**
   * Progress callback.
   * @param callback - Progress callback
   * @returns Asset Promise
   */
  _proto.onProgress = function onProgress(callback) {
    this._listeners.add(callback);
    return this;
  }

  /**
   * Cancel promise request.
   * @returns Asset promise
   */;
  _proto.cancel = function cancel() {
    if (this._status !== AssetPromiseStatus.Pending) {
      return this;
    }
    this._reject("Promise Canceled");
    return this;
  }

  /**
   * Create an asset loading Promise.
   * @param executor - A callback used to initialize the promise. This callback is passed two arguments:
   * a resolve callback used to resolve the promise with a value or the result of another promise,
   * and a reject callback used to reject the promise with a provided reason or error.
   * and a setProgress callback used to set promise progress with a percent.
   */;
  function AssetPromise(executor) {
    var _this;
    var newReject;
    var setProgress = function setProgress(progress) {
      if (progress <= _this._progress) {
        return;
      }
      _this._progress = progress;
      for (var _iterator = _createForOfIteratorHelperLoose(_this._listeners), _step; !(_step = _iterator()).done;) {
        var listener = _step.value;
        listener(progress);
      }
    };
    _this = _Promise.call(this, function (resolve, reject) {
      newReject = function newReject(reason) {
        // Add it to the micro task to avoid reporting an error when calling this directly.
        Promise.resolve().then(function () {
          _this._status = AssetPromiseStatus.Failed;
          reject(reason);
        });
      };
      executor(function (value) {
        // Add it to the micro task to avoid reporting an error when calling this directly.
        Promise.resolve().then(function () {
          setProgress(1);
          _this._status = AssetPromiseStatus.Success;
          resolve(value);
        });
      }, newReject, function (progress) {
        // Add it to the micro task to avoid reporting an error when calling this directly
        Promise.resolve().then(function () {
          setProgress(progress);
        });
      });
    }) || this;
    _this._status = void 0;
    _this._progress = void 0;
    _this._reject = void 0;
    _this._listeners = void 0;
    _this._reject = newReject;
    _this._listeners = new Set();
    _this._progress = 0;
    _this._status = AssetPromiseStatus.Pending;
    return _this;
  }
  _createClass(AssetPromise, [{
    key: "status",
    get:
    /**
     * Current promise state.
     */
    function get() {
      return this._status;
    }

    /**
     * Loading progress.
     */
  }, {
    key: "progress",
    get: function get() {
      return this._progress;
    }
  }]);
  return AssetPromise;
}( /*#__PURE__*/_wrapNativeSuper(Promise));

/**
 * ResourceManager
 */
var ResourceManager = /*#__PURE__*/function () {
  /** Loader collection. */
  /**
   * @internal
   */
  ResourceManager._addLoader = function _addLoader(type, loader, extNames) {
    this._loaders[type] = loader;
    for (var i = 0, len = extNames.length; i < len; i++) {
      this._extTypeMapping[extNames[i]] = type;
    }
  };
  ResourceManager._getTypeByUrl = function _getTypeByUrl(url) {
    var path = url.split("?")[0];
    return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
  }

  /** The number of retries after failing to load assets. */;

  /**
   * Create a ResourceManager.
   * @param engine - Engine to which the current ResourceManager belongs
   */
  function ResourceManager(engine) {
    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = Infinity;
    this._objectPool = Object.create(null);
    this._editorResourceConfig = Object.create(null);
    this._virtualPathMap = Object.create(null);
    this._assetPool = Object.create(null);
    this._assetUrlPool = Object.create(null);
    this._refObjectPool = Object.create(null);
    this._loadingPromises = {};
  }

  /**
   * Load asset asynchronously through the path.
   * @param path - Path
   * @returns Asset promise
   */
  var _proto = ResourceManager.prototype;
  _proto.load = function load(assetInfo) {
    var _this = this;
    // single item
    if (!Array.isArray(assetInfo)) {
      return this._loadSingleItem(assetInfo);
    }
    // multi items
    var promises = assetInfo.map(function (item) {
      return _this._loadSingleItem(item);
    });
    return AssetPromise.all(promises);
  }

  /**
   * Cancel all assets that have not finished loading.
   */;
  _proto.cancelNotLoaded = function cancelNotLoaded(url) {
    var _this2 = this;
    if (!url) {
      ObjectValues(this._loadingPromises).forEach(function (promise) {
        promise.cancel();
      });
    } else if (typeof url === "string") {
      var _this$_loadingPromise;
      (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
    } else {
      url.forEach(function (p) {
        var _this2$_loadingPromis;
        (_this2$_loadingPromis = _this2._loadingPromises[p]) === null || _this2$_loadingPromis === void 0 ? void 0 : _this2$_loadingPromis.cancel();
      });
    }
  }

  /**
   * Garbage collection will release resource objects managed by reference counting.
   * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
   */;
  _proto.gc = function gc() {
    this._gc(false);
  }

  /**
   * Get asset url from instanceId.
   * @param instanceId - Engine instance id
   * @returns Asset url
   */;
  _proto.getAssetPath = function getAssetPath(instanceId) {
    return this._assetPool[instanceId];
  }

  /**
   * @beta Just for internal editor, not recommended for developers.
   */;
  _proto.getResourceByRef = function getResourceByRef(ref) {
    var refId = ref.refId,
      key = ref.key,
      isClone = ref.isClone;
    var obj = this._objectPool[refId];
    var promise = obj ? Promise.resolve(obj) : this.load({
      type: this._editorResourceConfig[refId].type,
      url: this._editorResourceConfig[refId].path
    });
    return promise.then(function (res) {
      return key ? Utils._reflectGet(res, key) : res;
    }).then(function (item) {
      return isClone ? item.clone() : item;
    });
  }

  /**
   * @internal
   * @beta Just for internal editor, not recommended for developers.
   */;
  _proto.initVirtualResources = function initVirtualResources(config) {
    var _this3 = this;
    config.forEach(function (element) {
      _this3._virtualPathMap[element.virtualPath] = element.path;
      _this3._editorResourceConfig[element.id] = element;
    });
  }

  /**
   * @internal
   */;
  _proto._addAsset = function _addAsset(path, asset) {
    this._assetPool[asset.instanceId] = path;
    this._assetUrlPool[path] = asset;
  }

  /**
   * @internal
   */;
  _proto._deleteAsset = function _deleteAsset(asset) {
    var id = asset.instanceId;
    var path = this._assetPool[id];
    if (path) {
      delete this._assetPool[id];
      delete this._assetUrlPool[path];
    }
  }

  /**
   * @internal
   */;
  _proto._addRefObject = function _addRefObject(id, asset) {
    this._refObjectPool[id] = asset;
  }

  /**
   * @internal
   */;
  _proto._deleteRefObject = function _deleteRefObject(id) {
    delete this._refObjectPool[id];
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    this.cancelNotLoaded();
    this._gc(true);
    this._assetPool = null;
    this._assetUrlPool = null;
    this._refObjectPool = null;
    this._loadingPromises = null;
  };
  _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
    var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;
    assetInfo.type = (_assetInfo$type = assetInfo.type) != null ? _assetInfo$type : ResourceManager._getTypeByUrl(assetInfo.url);
    if (assetInfo.type === undefined) {
      throw "asset type should be specified: " + assetInfo.url;
    }
    assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) != null ? _assetInfo$retryCount : this.retryCount;
    assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) != null ? _assetInfo$timeout : this.timeout;
    assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) != null ? _assetInfo$retryInter : this.retryInterval;
    assetInfo.url = (_assetInfo$url = assetInfo.url) != null ? _assetInfo$url : assetInfo.urls.join(",");
    return assetInfo;
  };
  _proto._loadSingleItem = function _loadSingleItem(item) {
    var _this4 = this;
    var info = this._assignDefaultOptions(typeof item === "string" ? {
      url: item
    } : item);
    var infoUrl = info.url;
    // check url mapping
    var url = this._virtualPathMap[infoUrl] ? this._virtualPathMap[infoUrl] : infoUrl;
    // has cache
    if (this._assetUrlPool[url]) {
      return new AssetPromise(function (resolve) {
        resolve(_this4._assetUrlPool[url]);
      });
    }
    // loading
    if (this._loadingPromises[url]) {
      return this._loadingPromises[info.url];
    }
    var loader = ResourceManager._loaders[info.type];
    if (!loader) {
      throw "loader not found: " + info.type;
    }
    info.url = url;
    var promise = loader.load(info, this);
    this._loadingPromises[url] = promise;
    promise.then(function (res) {
      if (loader.useCache) _this4._addAsset(url, res);
      if (_this4._loadingPromises) {
        delete _this4._loadingPromises[url];
      }
    }).catch(function (err) {
      Promise.reject(err);
      if (_this4._loadingPromises) {
        delete _this4._loadingPromises[url];
      }
    });
    return promise;
  };
  _proto._gc = function _gc(forceDestroy) {
    var objects = ObjectValues(this._refObjectPool);
    for (var i = 0, len = objects.length; i < len; i++) {
      if (!objects[i].isGCIgnored || forceDestroy) {
        objects[i].destroy();
      }
    }
  };
  return ResourceManager;
}();

/**
 * Declare ResourceLoader's decorator.
 * @param assetType - Type of asset
 * @param extnames - Name of file extension
 */
ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
function resourceLoader(assetType, extnames, useCache) {
  if (useCache === void 0) {
    useCache = true;
  }
  return function (Target) {
    var loader = new Target(useCache);
    ResourceManager._addLoader(assetType, loader, extnames);
  };
}

/** Event Object. * @class */
var Event = /*#__PURE__*/function () {
  function Event(type, target, data, bubbles) {
    if (target === void 0) {
      target = null;
    }
    if (data === void 0) {
      data = {};
    }
    if (bubbles === void 0) {
      bubbles = true;
    }
    this.data = void 0;
    this._timeStamp = void 0;
    this._target = void 0;
    this._currentTarget = void 0;
    this._bubbles = void 0;
    this._propagationStopped = void 0;
    this._type = void 0;
    this._timeStamp = new Date().getTime();
    this._target = target;
    this.data = data;
    this._currentTarget = null;
    this._bubbles = bubbles;
    this._propagationStopped = false;
    this._type = type;
  }
  var _proto = Event.prototype;
  _proto.stopPropagation = function stopPropagation() {
    this._propagationStopped = true;
  };
  _createClass(Event, [{
    key: "propagationStopped",
    get: function get() {
      return this._propagationStopped;
    }
  }, {
    key: "target",
    get: function get() {
      return this._target;
    },
    set: function set(t) {
      this._target = t;
    }
  }, {
    key: "timeStamp",
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: "currentTarget",
    get: function get() {
      return this._currentTarget;
    },
    set: function set(t) {
      this._currentTarget = t;
    }
  }, {
    key: "bubbles",
    get: function get() {
      return this._bubbles;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);
  return Event;
}();

/**
 * Clone mode.
 */
var CloneMode;
(function (CloneMode) {
  CloneMode[CloneMode["Ignore"] = 0] = "Ignore";
  CloneMode[CloneMode["Assignment"] = 1] = "Assignment";
  CloneMode[CloneMode["Shallow"] = 2] = "Shallow";
  CloneMode[CloneMode["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));

/**
 * Property decorator, ignore the property when cloning.
 */
function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}

/**
 * Property decorator, assign value to the property when cloning.
 *
 * @remarks
 * If it's a primitive type, the value will be copied.
 * If it's a class type, the reference will be copied.
 */
function assignmentClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}

/**
 * Property decorator, shallow clone the property when cloning.
 * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.
 * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.。
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 */
function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}

/**
 * Property decorator, deep clone the property when cloning.
 * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.
 * Custom cloning requires the object to implement the IClone interface.
 */
function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}

/**
 * @internal
 * Clone manager.
 */
var CloneManager = /*#__PURE__*/function () {
  function CloneManager() {}
  /** @internal */
  /** @internal */
  /**
   * Register clone mode.
   * @param target - Clone target
   * @param propertyKey - Clone property name
   * @param mode - Clone mode
   */
  CloneManager.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
    var targetMap = CloneManager._subCloneModeMap.get(target.constructor);
    if (!targetMap) {
      targetMap = Object.create(null);
      CloneManager._subCloneModeMap.set(target.constructor, targetMap);
    }
    targetMap[propertyKey] = mode;
  }

  /**
   * Get the clone mode according to the prototype chain.
   */;
  CloneManager.getCloneMode = function getCloneMode(type) {
    var cloneModes = CloneManager._cloneModeMap.get(type);
    if (!cloneModes) {
      cloneModes = Object.create(null);
      CloneManager._cloneModeMap.set(type, cloneModes);
      var objectType = CloneManager._objectType;
      var cloneModeMap = CloneManager._subCloneModeMap;
      while (type !== objectType) {
        var subCloneModes = cloneModeMap.get(type);
        if (subCloneModes) {
          _extends(cloneModes, subCloneModes);
        }
        type = Object.getPrototypeOf(type);
      }
    }
    return cloneModes;
  }

  /**
   * Deep clone the object.
   * @param source - Clone source
   * @param target - Clone target
   */;
  CloneManager.deepCloneObject = function deepCloneObject(source, target) {
    var type = source.constructor;
    switch (type) {
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case Float32Array:
      case Float64Array:
        // Type array clone.
        target.set(source);
        break;
      case Array:
        // Array clone.
        for (var i = 0, n = source.length; i < n; i++) {
          CloneManager._deepCloneObjectItem(source, target, i);
        }
        break;
      default:
        var customSource = source;
        if (customSource.clone && customSource.cloneTo) {
          // Custom clone.
          customSource.cloneTo(target);
        } else {
          // Object or other class not implements custom clone.
          var keys = Object.keys(source);
          for (var _i = 0, _n = keys.length; _i < _n; _i++) {
            CloneManager._deepCloneObjectItem(source, target, keys[_i]);
          }
        }
    }
  };
  CloneManager._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k) {
    var sourceItem = source[k];
    if (sourceItem instanceof Object) {
      var itemType = sourceItem.constructor;
      switch (itemType) {
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          // Type array clone.
          var sourceTypeArrayItem = sourceItem;
          var targetTypeArrayItem = target[k];
          if (targetTypeArrayItem == null) {
            target[k] = sourceTypeArrayItem.slice();
          } else {
            targetTypeArrayItem.set(sourceTypeArrayItem);
          }
          break;
        case Array:
          // Array clone.
          var sourceArrayItem = sourceItem;
          var targetArrayItem = target[k];
          if (targetArrayItem == null) {
            target[k] = new Array(sourceArrayItem.length);
          } else {
            targetArrayItem.length = sourceArrayItem.length;
          }
          CloneManager.deepCloneObject(sourceArrayItem, targetArrayItem);
          break;
        default:
          if (sourceItem.clone && sourceItem.cloneTo) {
            // Custom clone.
            var sourceCustomItem = sourceItem;
            var targetCustomItem = target[k];
            if (targetCustomItem) {
              sourceCustomItem.cloneTo(targetCustomItem);
            } else {
              target[k] = sourceCustomItem.clone();
            }
          } else {
            // Object or other class not implements custom clone.
            var targetItem = target[k];
            targetItem == null && (target[k] = targetItem = new sourceItem.constructor());
            CloneManager.deepCloneObject(sourceItem, targetItem);
            break;
          }
      }
    } else {
      // Null or undefined and primitive type.
      target[k] = sourceItem;
    }
  };
  return CloneManager;
}();
CloneManager._subCloneModeMap = new Map();
CloneManager._cloneModeMap = new Map();
CloneManager._objectType = Object.getPrototypeOf(Object);

var _class$g, _descriptor$d;
/**
 * EventDispatcher, which can be inherited as a base class.
 */
var EventDispatcher = (_class$g = /*#__PURE__*/function () {
  function EventDispatcher() {
    _initializerDefineProperty(this, "_evts", _descriptor$d, this);
    this._evtCount = 0;
  }
  var _proto = EventDispatcher.prototype;
  /**
   * Determine whether there is event listening.
   * @param event - Event name
   * @returns Returns whether there is a corresponding event
   */
  _proto.hasEvent = function hasEvent(event) {
    return this._evts[event] != null;
  }

  /**
   * Returns the names of all registered events.
   * @returns All event names
   */;
  _proto.eventNames = function eventNames() {
    if (this._evtCount === 0) return [];
    return Object.keys(this._evts);
  }

  /**
   * Returns the number of listeners with the specified event name.
   * @param event - Event name
   * @returns The count of listeners
   */;
  _proto.listenerCount = function listenerCount(event) {
    var listeners = this._evts[event];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  }

  /**
   * Dispatch the event with the specified event name.
   * @param event - Event name
   * @param data - Data
   * @returns - Whether the dispatching is successful
   */;
  _proto.dispatch = function dispatch(event, data) {
    if (!this._evts[event]) {
      return false;
    }
    var listeners = this._evts[event];
    if (listeners.fn) {
      if (listeners.once) this.removeEventListener(event, listeners.fn);
      listeners.fn(data);
    } else {
      var l = listeners.length;
      for (var i = 0; i < l; i++) {
        if (listeners[i].once) this.removeEventListener(event, listeners[i].fn);
        listeners[i].fn(data);
      }
    }
    return true;
  }

  /**
   * Add a listener/
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */;
  _proto.on = function on(event, fn) {
    return this.addEventListener(event, fn);
  }

  /**
   * Add a one-time listener.
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */;
  _proto.once = function once(event, fn) {
    return this.addEventListener(event, fn, true);
  }

  /**
   * @deprecated Use `on/once` instead.
   * Add a listener function with the specified event name.
   * @param event - Event name
   * @param fn - Function
   * @param once - Is it a one-time listener
   * @returns this
   */;
  _proto.addEventListener = function addEventListener(event, fn, once) {
    var listener = {
      fn: fn,
      once: once
    };
    var events = this._evts;
    if (!events[event]) {
      events[event] = listener;
      this._evtCount++;
    } else if (!events[event].fn) {
      events[event].push(listener);
    } else {
      events[event] = [events[event], listener];
    }
    return this;
  }

  /**
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */;
  _proto.off = function off(event, fn) {
    if (!this._evts[event]) return this;
    if (!fn) {
      this._clearEvent(event);
      return this;
    }
    var listeners = this._evts[event];
    if (listeners.fn && listeners.fn === fn) {
      this._clearEvent(event);
    } else {
      var index = listeners.indexOf(fn);
      if (index > -1) {
        var temp = listeners[listeners.length - 1];
        listeners[index] = temp;
        listeners.length--;
        if (listeners.length === 1) {
          this._evts[event] = listeners[0];
        }
      }
    }
    return this;
  }

  /**
   * @deprecated Use `off` instead.
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */;
  _proto.removeEventListener = function removeEventListener(event, fn) {
    return this.off(event, fn);
  }

  /**
   * Remove all event listeners.
   * @param event - Event name, delete all events if not passed
   */;
  _proto.removeAllEventListeners = function removeAllEventListeners(event) {
    if (event) {
      if (this._evts[event]) this._clearEvent(event);
    } else {
      this._evts = Object.create(null);
      this._evtCount = 0;
    }
  }

  /**
   * @deprecated Use `dispatch` instead.
   */;
  _proto.trigger = function trigger(e) {
    this.dispatch(e.type, e.data);
  };
  _proto._clearEvent = function _clearEvent(event) {
    if (--this._evtCount === 0) {
      this._evts = Object.create(null);
    } else {
      delete this._evts[event];
    }
  };
  return EventDispatcher;
}(), (_descriptor$d = _applyDecoratedDescriptor(_class$g.prototype, "_evts", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return Object.create(null);
  }
})), _class$g);

/**
 * @class
 * @private
 */
/* tslint:disable */
var noop = function noop(message) {};
var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,
  /** Turn on log */enable: function enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },
  /** Turn off log */disable: function disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};

/**
 * Tools for calculating the time per frame.
 */
var Time = /*#__PURE__*/function () {
  /**
   * Constructor of the Time.
   */
  function Time() {
    this._clock = void 0;
    this._timeScale = void 0;
    this._deltaTime = void 0;
    this._startTime = void 0;
    this._lastTickTime = void 0;
    this._clock = performance ? performance : Date;
    this._timeScale = 1.0;
    this._deltaTime = 0.0001;
    var now = this._clock.now();
    this._startTime = now;
    this._lastTickTime = now;
  }
  var _proto = Time.prototype;
  _proto.reset = function reset() {
    this._lastTickTime = this._clock.now();
  }

  /**
   * Current Time
   */;
  /**
   * Call every frame, update delta time and other data.
   */
  _proto.tick = function tick() {
    var now = this.nowTime;
    this._deltaTime = (now - this._lastTickTime) * this._timeScale;
    this._lastTickTime = now;
  };
  _createClass(Time, [{
    key: "nowTime",
    get: function get() {
      return this._clock.now();
    }

    /**
     * Time between two ticks
     */
  }, {
    key: "deltaTime",
    get: function get() {
      return this._deltaTime;
    }

    /**
     * Scaled delta time.
     */
  }, {
    key: "timeScale",
    get: function get() {
      return this._timeScale;
    },
    set: function set(s) {
      this._timeScale = s;
    }

    /**
     * Unscaled delta time.
     */
  }, {
    key: "unscaledDeltaTime",
    get: function get() {
      return this._deltaTime / this._timeScale;
    }

    /**
     * The elapsed time, after the clock is initialized.
     */
  }, {
    key: "timeSinceStartup",
    get: function get() {
      return this.nowTime - this._startTime;
    }
  }]);
  return Time;
}();

var _class$f, _descriptor$c, _descriptor2$b, _class2$c;
/**
 * EngineObject.
 */
var EngineObject = (_class$f = (_class2$c = /*#__PURE__*/function () {
  function EngineObject(engine) {
    _initializerDefineProperty(this, "instanceId", _descriptor$c, this);
    _initializerDefineProperty(this, "_engine", _descriptor2$b, this);
    this._destroyed = false;
    this._engine = engine;
  }

  /**
   * Destroy self.
   */
  var _proto = EngineObject.prototype;
  _proto.destroy = function destroy() {
    var _this$_engine$resourc;
    if (this._destroyed) return;
    (_this$_engine$resourc = this._engine.resourceManager) === null || _this$_engine$resourc === void 0 ? void 0 : _this$_engine$resourc._deleteAsset(this);
    this._destroyed = true;
  };
  _createClass(EngineObject, [{
    key: "engine",
    get: /** Engine unique id. */

    /**
     * Get the engine which the object belongs.
     */
    function get() {
      return this._engine;
    }

    /**
     * Whether it has been destroyed.
     */
  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
  }]);
  return EngineObject;
}(), _class2$c._instanceIdCounter = 0, _class2$c), (_descriptor$c = _applyDecoratedDescriptor(_class$f.prototype, "instanceId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return ++EngineObject._instanceIdCounter;
  }
}), _descriptor2$b = _applyDecoratedDescriptor(_class$f.prototype, "_engine", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class$f);

/**
 * Data type enumeration
 */
var DataType;

/**
 * GL Capabilities
 * Some capabilities can be smoothed out by extension, and some capabilities must use WebGL 2.0.
 * */
(function (DataType) {
  DataType[DataType["FLOAT"] = 5126] = "FLOAT";
  DataType[DataType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType[DataType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType[DataType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType[DataType["INT"] = 5124] = "INT";
  DataType[DataType["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType[DataType["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType[DataType["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType[DataType["BOOL"] = 35670] = "BOOL";
  DataType[DataType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType[DataType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType[DataType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType[DataType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType[DataType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType[DataType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType[DataType["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType[DataType["FLOAT_VEC2_ARRAY"] = 100000] = "FLOAT_VEC2_ARRAY";
  DataType[DataType["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType[DataType["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType[DataType["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType[DataType["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType[DataType["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType[DataType["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType[DataType["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType[DataType["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType[DataType["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType[DataType["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType[DataType["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType[DataType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType[DataType["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType[DataType["BYTE"] = 5120] = "BYTE";
  DataType[DataType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType[DataType["SHORT"] = 5122] = "SHORT";
  DataType[DataType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType[DataType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(DataType || (DataType = {}));
var GLCapabilityType;
(function (GLCapabilityType) {
  GLCapabilityType["shaderVertexID"] = "shaderVertexID";
  GLCapabilityType["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType["textureFloat"] = "OES_texture_float";
  GLCapabilityType["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType["blendMinMax"] = "EXT_blend_minmax";
  GLCapabilityType["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
})(GLCapabilityType || (GLCapabilityType = {}));

/**
 * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.
 */
var DisorderedArray = /*#__PURE__*/function () {
  function DisorderedArray(count) {
    if (count === void 0) {
      count = 0;
    }
    this._elements = void 0;
    this.length = 0;
    this._elements = new Array(count);
  }
  var _proto = DisorderedArray.prototype;
  _proto.add = function add(element) {
    if (this.length === this._elements.length) this._elements.push(element);else this._elements[this.length] = element;
    this.length++;
  };
  _proto.delete = function _delete(element) {
    //TODO: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.
    var index = this._elements.indexOf(element);
    this.deleteByIndex(index);
  };
  _proto.get = function get(index) {
    if (index >= this.length) {
      throw "Index is out of range.";
    }
    return this._elements[index];
  }

  /**
   *
   * @param index
   * @returns The replaced item is used to reset its index.
   */;
  _proto.deleteByIndex = function deleteByIndex(index) {
    var elements = this._elements;
    var end = null;
    var lastIndex = this.length - 1;
    if (index !== lastIndex) {
      end = elements[lastIndex];
      elements[index] = end;
    }
    this.length--;
    return end;
  };
  _proto.garbageCollection = function garbageCollection() {
    this._elements.length = this.length;
  };
  return DisorderedArray;
}();

/**
 * Shader macro collection.
 * @internal
 */
var ShaderMacroCollection = /*#__PURE__*/function () {
  function ShaderMacroCollection() {
    this._mask = [];
    this._length = 0;
  }
  /**
   * Union of two macro collection.
   * @param left - input macro collection
   * @param right - input macro collection
   * @param out - union output macro collection
   */
  ShaderMacroCollection.unionCollection = function unionCollection(left, right, out) {
    var outMask = out._mask;
    var minSize, maxSize;
    var minMask, maxMask;
    if (left._length < right._length) {
      minSize = left._length;
      maxSize = right._length;
      minMask = left._mask;
      maxMask = right._mask;
    } else {
      minSize = right._length;
      maxSize = left._length;
      minMask = right._mask;
      maxMask = left._mask;
    }
    var i = 0;
    outMask.length < maxSize && (outMask.length = maxSize);
    for (; i < minSize; i++) {
      outMask[i] = minMask[i] | maxMask[i];
    }
    for (; i < maxSize; i++) {
      outMask[i] = maxMask[i];
    }
    out._length = maxSize;
  }

  /** @internal */;
  var _proto = ShaderMacroCollection.prototype;
  /**
   * Enable one macro in this macro collection.
   * @param macro - ShaderMacro
   */
  _proto.enable = function enable(macro) {
    var index = macro._maskIndex;
    var size = index + 1;
    var mask = this._mask;
    var maskStart = this._length; // must from this._length because this._length maybe less than mask.length and have dirty data should clear.
    if (maskStart < size) {
      mask.length < size && (mask.length = size); // mask.length maybe small than size,maybe not.
      for (; maskStart < index; maskStart++) {
        mask[maskStart] = 0;
      }
      mask[index] = macro._maskValue;
      this._length = size;
    } else {
      mask[index] |= macro._maskValue;
    }
  }

  /**
   * Disable one macro in this macro collection.
   * @param macro - ShaderMacro
   */;
  _proto.disable = function disable(macro) {
    var index = macro._maskIndex;
    var mask = this._mask;
    var endIndex = this._length - 1;
    if (index > endIndex) {
      return;
    }
    var newValue = mask[index] & ~macro._maskValue;
    if (index == endIndex && newValue === 0) {
      this._length--;
    } else {
      mask[index] = newValue;
    }
  }

  /**
   * Union of this and other macro collection.
   * @param macroCollection - macro collection
   */;
  _proto.unionCollection = function unionCollection(macroCollection) {
    var addMask = macroCollection._mask;
    var addSize = macroCollection._length;
    var mask = this._mask;
    var maskSize = this._length;
    if (maskSize < addSize) {
      mask.length < addSize && (mask.length = addSize);
      var i = 0;
      for (; i < maskSize; i++) {
        mask[i] |= addMask[i];
      }
      for (; i < addSize; i++) {
        mask[i] = addMask[i];
      }
      this._length = addSize;
    } else {
      for (var _i = 0; _i < addSize; _i++) {
        mask[_i] |= addMask[_i];
      }
    }
  }

  /**
   * Complementarity of this and other macro collection.
   * @param macroCollection - macro collection
   */;
  _proto.complementaryCollection = function complementaryCollection(macroCollection) {
    var removeMask = macroCollection._mask;
    var mask = this._mask;
    var endIndex = this._length - 1;
    var i = Math.min(macroCollection._length - 1, endIndex);
    for (; i >= 0; i--) {
      var newValue = mask[i] & ~removeMask[i];
      if (i == endIndex && newValue === 0) {
        endIndex--;
        this._length--;
      } else {
        mask[i] = newValue;
      }
    }
  }

  /**
   * Intersection of this and other macro collection.
   * @param macroCollection - macro collection
   */;
  _proto.intersectionCollection = function intersectionCollection(macroCollection) {
    var unionMask = macroCollection._mask;
    var mask = this._mask;
    for (var i = this._length - 1; i >= 0; i--) {
      var value = mask[i] & unionMask[i];
      if (value == 0 && i == this._length - 1) {
        this._length--;
      } else {
        mask[i] = value;
      }
    }
  }

  /**
   * Whether macro is enabled in this macro collection.
   * @param macro - ShaderMacro
   */;
  _proto.isEnable = function isEnable(macro) {
    var index = macro._maskIndex;
    if (index >= this._length) {
      return false;
    }
    return (this._mask[index] & macro._maskValue) !== 0;
  }

  /**
   * Clear this macro collection.
   */;
  _proto.clear = function clear() {
    this._length = 0;
  };
  return ShaderMacroCollection;
}();

/**
 * The manager of the components.
 */
var ComponentsManager = /*#__PURE__*/function () {
  function ComponentsManager() {
    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._onPhysicsUpdateScripts = new DisorderedArray();
    this._disableScripts = [];
    this._destroyScripts = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._renderers = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }
  var _proto = ComponentsManager.prototype;
  _proto.addRenderer = function addRenderer(renderer) {
    renderer._rendererIndex = this._renderers.length;
    this._renderers.add(renderer);
  };
  _proto.removeRenderer = function removeRenderer(renderer) {
    var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
    replaced && (replaced._rendererIndex = renderer._rendererIndex);
    renderer._rendererIndex = -1;
  };
  _proto.addOnStartScript = function addOnStartScript(script) {
    script._onStartIndex = this._onStartScripts.length;
    this._onStartScripts.add(script);
  };
  _proto.removeOnStartScript = function removeOnStartScript(script) {
    var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);
    replaced && (replaced._onStartIndex = script._onStartIndex);
    script._onStartIndex = -1;
  };
  _proto.addOnUpdateScript = function addOnUpdateScript(script) {
    script._onUpdateIndex = this._onUpdateScripts.length;
    this._onUpdateScripts.add(script);
  };
  _proto.removeOnUpdateScript = function removeOnUpdateScript(script) {
    var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
    script._onUpdateIndex = -1;
  };
  _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script) {
    script._onLateUpdateIndex = this._onLateUpdateScripts.length;
    this._onLateUpdateScripts.add(script);
  };
  _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script) {
    var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);
    replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
    script._onLateUpdateIndex = -1;
  };
  _proto.addOnPhysicsUpdateScript = function addOnPhysicsUpdateScript(script) {
    script._onPhysicsUpdateIndex = this._onPhysicsUpdateScripts.length;
    this._onPhysicsUpdateScripts.add(script);
  };
  _proto.removeOnPhysicsUpdateScript = function removeOnPhysicsUpdateScript(script) {
    var replaced = this._onPhysicsUpdateScripts.deleteByIndex(script._onPhysicsUpdateIndex);
    replaced && (replaced._onPhysicsUpdateIndex = script._onPhysicsUpdateIndex);
    script._onPhysicsUpdateIndex = -1;
  };
  _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
    //@ts-ignore
    animation._onUpdateIndex = this._onUpdateAnimations.length;
    this._onUpdateAnimations.add(animation);
  };
  _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
    //@ts-ignore
    var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
    //@ts-ignore
    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
    //@ts-ignore
    animation._onUpdateIndex = -1;
  };
  _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
    renderer._onUpdateIndex = this._onUpdateRenderers.length;
    this._onUpdateRenderers.add(renderer);
  };
  _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
    var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
    renderer._onUpdateIndex = -1;
  };
  _proto.addDisableScript = function addDisableScript(component) {
    this._disableScripts.push(component);
  };
  _proto.addDestroyScript = function addDestroyScript(component) {
    this._destroyScripts.push(component);
  };
  _proto.callScriptOnStart = function callScriptOnStart() {
    var onStartScripts = this._onStartScripts;
    if (onStartScripts.length > 0) {
      var elements = onStartScripts._elements;
      // The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()
      for (var i = 0; i < onStartScripts.length; i++) {
        var script = elements[i];
        if (!script._waitHandlingInValid) {
          script._started = true;
          script._onStartIndex = -1;
          script.onStart();
        }
      }
      onStartScripts.length = 0;
    }
  };
  _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
    var elements = this._onUpdateScripts._elements;
    for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!element._waitHandlingInValid && element._started) {
        element.onUpdate(deltaTime);
      }
    }
  };
  _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
    var elements = this._onLateUpdateScripts._elements;
    for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!element._waitHandlingInValid && element._started) {
        element.onLateUpdate(deltaTime);
      }
    }
  };
  _proto.callScriptOnPhysicsUpdate = function callScriptOnPhysicsUpdate() {
    var elements = this._onPhysicsUpdateScripts._elements;
    for (var i = this._onPhysicsUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!element._waitHandlingInValid && element._started) {
        element.onPhysicsUpdate();
      }
    }
  };
  _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
    var elements = this._onUpdateAnimations._elements;
    for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
      //@ts-ignore
      elements[i].update(deltaTime);
    }
  };
  _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
    var elements = this._onUpdateRenderers._elements;
    for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };
  _proto.callRender = function callRender(context) {
    var camera = context._camera;
    var elements = this._renderers._elements;
    for (var i = this._renderers.length - 1; i >= 0; --i) {
      var element = elements[i];

      // filter by camera culling mask.
      if (!(camera.cullingMask & element._entity.layer)) {
        continue;
      }

      // filter by camera frustum.
      if (camera.enableFrustumCulling) {
        element.isCulled = !camera._frustum.intersectsBox(element.bounds);
        if (element.isCulled) {
          continue;
        }
      }
      var transform = camera.entity.transform;
      var position = transform.worldPosition;
      var center = element.bounds.getCenter(ComponentsManager._tempVector0);
      if (camera.isOrthographic) {
        var forward = transform.getWorldForward(ComponentsManager._tempVector1);
        Vector3.subtract(center, position, center);
        element._distanceForSort = Vector3.dot(center, forward);
      } else {
        element._distanceForSort = Vector3.distanceSquared(center, position);
      }
      element._updateShaderData(context);
      element._render(camera);

      // union camera global macro and renderer macro.
      ShaderMacroCollection.unionCollection(camera._globalShaderMacro, element.shaderData._macroCollection, element._globalShaderMacro);
    }
  };
  _proto.handlingInvalidScripts = function handlingInvalidScripts() {
    var disableScripts = this._disableScripts,
      destroyScripts = this._destroyScripts;
    var length = disableScripts.length;
    if (length > 0) {
      for (var i = length - 1; i >= 0; i--) {
        var disableScript = disableScripts[i];
        disableScript._waitHandlingInValid && disableScript._handlingInValid();
      }
      disableScripts.length = 0;
    }
    length = destroyScripts.length;
    if (length > 0) {
      for (var _i = length - 1; _i >= 0; _i--) {
        destroyScripts[_i].onDestroy();
      }
      destroyScripts.length = 0;
    }
  };
  _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
    var scripts = camera.entity._scripts;
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = scripts.get(i);
      script._waitHandlingInValid || script.onBeginRender(camera);
    }
  };
  _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
    var scripts = camera.entity._scripts;
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = scripts.get(i);
      script._waitHandlingInValid || script.onEndRender(camera);
    }
  };
  _proto.getActiveChangedTempList = function getActiveChangedTempList() {
    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
  };
  _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
    componentContainer.length = 0;
    this._componentsContainerPool.push(componentContainer);
  };
  return ComponentsManager;
}();
ComponentsManager._tempVector0 = new Vector3();
ComponentsManager._tempVector1 = new Vector3();

/**
 * Custom clone interface.
 */

var ComponentCloner = /*#__PURE__*/function () {
  function ComponentCloner() {}
  /**
   * Clone component.
   * @param source - Clone source
   * @param target - Clone target
   */
  ComponentCloner.cloneComponent = function cloneComponent(source, target) {
    var cloneModes = CloneManager.getCloneMode(source.constructor);
    var keys = Object.keys(source);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var cloneMode = cloneModes[k];
      switch (cloneMode) {
        case undefined:
        case CloneMode.Assignment:
          target[k] = source[k];
          break;
        case CloneMode.Shallow:
          var sourcePropS = source[k];
          if (sourcePropS instanceof Object) {
            var tarProp = target[k];
            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());
            _extends(tarProp, sourcePropS);
          } else {
            // Null or undefined and primitive type.
            target[k] = sourcePropS;
          }
          break;
        case CloneMode.Deep:
          var sourcePropD = source[k];
          if (sourcePropD instanceof Object) {
            var _tarProp = target[k];
            _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());
            CloneManager.deepCloneObject(sourcePropD, _tarProp);
          } else {
            // Null or undefined and primitive type.
            target[k] = sourcePropD;
          }
          break;
      }
    }
    if (source._cloneTo) {
      source._cloneTo(target);
    }
  };
  return ComponentCloner;
}();

/**
 * Used for component dependency registration.
 */
var ComponentsDependencies = /*#__PURE__*/function () {
  /**
   * @internal
   */
  /**
   * @internal
   */
  ComponentsDependencies._register = function _register(currentComponent, dependentComponent) {
    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);
    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
  }

  /**
   * @internal
   */;
  ComponentsDependencies._addCheck = function _addCheck(entity, type) {
    // Check if there are dependent components.
    var dependentComponents = ComponentsDependencies._dependenciesMap.get(type);
    if (dependentComponents) {
      for (var i = 0, n = dependentComponents.length; i < n; i++) {
        var dependentComponent = dependentComponents[i];
        if (!entity.getComponent(dependentComponent)) {
          entity.addComponent(dependentComponent);
        }
      }
    }
  }

  /**
   * @internal
   */;
  ComponentsDependencies._removeCheck = function _removeCheck(entity, type) {
    var invDependencies = ComponentsDependencies._invDependenciesMap.get(type);
    if (invDependencies) {
      for (var i = 0, len = invDependencies.length; i < len; i++) {
        if (entity.getComponent(invDependencies[i])) {
          throw "you should remove " + invDependencies[i] + " before adding " + type;
        }
      }
    }
  };
  ComponentsDependencies._addDependency = function _addDependency(currentComponent, dependentComponent, map) {
    var components = map.get(currentComponent);
    if (!components) {
      components = [];
      map.set(currentComponent, components);
    }
    if (components.indexOf(dependentComponent) === -1) {
      components.push(dependentComponent);
    }
  };
  function ComponentsDependencies() {}
  return ComponentsDependencies;
}();

/**
 * Dependent components, automatically added if they do not exist.
 * @param components -  Dependent components
 */
ComponentsDependencies._dependenciesMap = new Map();
ComponentsDependencies._invDependenciesMap = new Map();
function dependentComponents() {
  for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
    components[_key] = arguments[_key];
  }
  return function (target) {
    components.forEach(function (component) {
      return ComponentsDependencies._register(target, component);
    });
  };
}

/**
 * Layer, used for bit operations.
 */
var Layer;
(function (Layer) {
  Layer[Layer["Layer0"] = 1] = "Layer0";
  Layer[Layer["Layer1"] = 2] = "Layer1";
  Layer[Layer["Layer2"] = 4] = "Layer2";
  Layer[Layer["Layer3"] = 8] = "Layer3";
  Layer[Layer["Layer4"] = 16] = "Layer4";
  Layer[Layer["Layer5"] = 32] = "Layer5";
  Layer[Layer["Layer6"] = 64] = "Layer6";
  Layer[Layer["Layer7"] = 128] = "Layer7";
  Layer[Layer["Layer8"] = 256] = "Layer8";
  Layer[Layer["Layer9"] = 512] = "Layer9";
  Layer[Layer["Layer10"] = 1024] = "Layer10";
  Layer[Layer["Layer11"] = 2048] = "Layer11";
  Layer[Layer["Layer12"] = 4096] = "Layer12";
  Layer[Layer["Layer13"] = 8192] = "Layer13";
  Layer[Layer["Layer14"] = 16384] = "Layer14";
  Layer[Layer["Layer15"] = 32768] = "Layer15";
  Layer[Layer["Layer16"] = 65536] = "Layer16";
  Layer[Layer["Layer17"] = 131072] = "Layer17";
  Layer[Layer["Layer18"] = 262144] = "Layer18";
  Layer[Layer["Layer19"] = 524288] = "Layer19";
  Layer[Layer["Layer20"] = 1048576] = "Layer20";
  Layer[Layer["Layer21"] = 2097152] = "Layer21";
  Layer[Layer["Layer22"] = 4194304] = "Layer22";
  Layer[Layer["Layer23"] = 8388608] = "Layer23";
  Layer[Layer["Layer24"] = 16777216] = "Layer24";
  Layer[Layer["Layer25"] = 33554432] = "Layer25";
  Layer[Layer["Layer26"] = 67108864] = "Layer26";
  Layer[Layer["Layer27"] = 134217728] = "Layer27";
  Layer[Layer["Layer28"] = 268435456] = "Layer28";
  Layer[Layer["Layer29"] = 536870912] = "Layer29";
  Layer[Layer["Layer30"] = 1073741824] = "Layer30";
  Layer[Layer["Layer31"] = 2147483648] = "Layer31";
  Layer[Layer["Everything"] = 4294967295] = "Everything";
  Layer[Layer["Nothing"] = 0] = "Nothing";
})(Layer || (Layer = {}));

/**
 * Used to update tags.
 */
var UpdateFlag = /*#__PURE__*/function () {
  function UpdateFlag() {
    this._flagManagers = [];
  }
  var _proto = UpdateFlag.prototype;
  /**
   * Clear.
   */
  _proto.clearFromManagers = function clearFromManagers() {
    this._removeFromManagers();
    this._flagManagers.length = 0;
  }

  /**
   * Destroy.
   */;
  _proto.destroy = function destroy() {
    this._removeFromManagers();
    this._flagManagers = null;
  };
  _proto._removeFromManagers = function _removeFromManagers() {
    var flagManagers = this._flagManagers;
    for (var i = 0, n = flagManagers.length; i < n; i++) {
      removeFromArray(flagManagers[i]._updateFlags, this);
    }
  };
  return UpdateFlag;
}();

/**
 * Used to update tags.
 */
var BoolUpdateFlag = /*#__PURE__*/function (_UpdateFlag) {
  _inheritsLoose(BoolUpdateFlag, _UpdateFlag);
  function BoolUpdateFlag() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _UpdateFlag.call.apply(_UpdateFlag, [this].concat(args)) || this;
    _this.flag = true;
    return _this;
  }
  var _proto = BoolUpdateFlag.prototype;
  /**
   * @inheritdoc
   */
  _proto.dispatch = function dispatch() {
    this.flag = true;
  };
  return BoolUpdateFlag;
}(UpdateFlag);

var _class$e, _descriptor$b, _descriptor2$a, _descriptor3$9, _descriptor4$9, _descriptor5$9;
/**
 * The base class of the components.
 */
var Component = (_class$e = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Component, _EngineObject);
  function Component(entity) {
    var _this;
    _this = _EngineObject.call(this, entity.engine) || this;
    _initializerDefineProperty(_this, "_entity", _descriptor$b, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_awoken", _descriptor2$a, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_destroyed", _descriptor3$9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_phasedActive", _descriptor4$9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_enabled", _descriptor5$9, _assertThisInitialized(_this));
    _this._entity = entity;
    return _this;
  }

  /**
   * Destroy this instance.
   */
  var _proto = Component.prototype;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._entity._removeComponent(this);
    if (this._entity.isActiveInHierarchy) {
      this._enabled && this._onDisable();
    }
    this._destroyed = true;
    this._onDestroy();
  }

  /**
   * @internal
   */;
  _proto._onAwake = function _onAwake() {}

  /**
   * @internal
   */;
  _proto._onEnable = function _onEnable() {}

  /**
   * @internal
   */;
  _proto._onDisable = function _onDisable() {}

  /**
   * @internal
   */;
  _proto._onDestroy = function _onDestroy() {}

  /**
   * @internal
   */;
  _proto._setActive = function _setActive(value) {
    var entity = this._entity;
    if (value) {
      // Awake condition is un awake && current entity is active in hierarchy
      if (!this._awoken && entity._isActiveInHierarchy) {
        this._awoken = true;
        this._onAwake();
      }
      // Developer maybe do `isActive = false` in `onAwake` method
      // Enable condition is phased active state is false && current compoment is active in hierarchy
      if (!this._phasedActive && entity._isActiveInHierarchy && this._enabled) {
        this._phasedActive = true;
        this._onEnable();
      }
    } else {
      // Disable condition is phased active state is true && current compoment is inActive in hierarchy
      if (this._phasedActive && !(entity._isActiveInHierarchy && this._enabled)) {
        this._phasedActive = false;
        this._onDisable();
      }
    }
  };
  _createClass(Component, [{
    key: "enabled",
    get: /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Indicates whether the component is enabled.
     */
    function get() {
      return this._enabled;
    },
    set: function set(value) {
      if (value !== this._enabled) {
        this._enabled = value;
        if (this._entity.isActiveInHierarchy) {
          if (value) {
            this._phasedActive = true;
            this._onEnable();
          } else {
            this._phasedActive = false;
            this._onDisable();
          }
        }
      }
    }

    /**
     * Indicates whether the component is destroyed.
     */
  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }

    /**
     * The entity which the component belongs to.
     */
  }, {
    key: "entity",
    get: function get() {
      return this._entity;
    }

    /**
     * The scene which the component's entity belongs to.
     */
  }, {
    key: "scene",
    get: function get() {
      return this._entity.scene;
    }
  }]);
  return Component;
}(EngineObject), (_descriptor$b = _applyDecoratedDescriptor(_class$e.prototype, "_entity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$a = _applyDecoratedDescriptor(_class$e.prototype, "_awoken", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor3$9 = _applyDecoratedDescriptor(_class$e.prototype, "_destroyed", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor4$9 = _applyDecoratedDescriptor(_class$e.prototype, "_phasedActive", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor5$9 = _applyDecoratedDescriptor(_class$e.prototype, "_enabled", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
})), _class$e);

/**
 * Used to update tags.
 */
var ListenerUpdateFlag = /*#__PURE__*/function (_UpdateFlag) {
  _inheritsLoose(ListenerUpdateFlag, _UpdateFlag);
  function ListenerUpdateFlag() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _UpdateFlag.call.apply(_UpdateFlag, [this].concat(args)) || this;
    _this.listener = void 0;
    return _this;
  }
  var _proto = ListenerUpdateFlag.prototype;
  /**
   * @inheritdoc
   */
  _proto.dispatch = function dispatch(param) {
    this.listener && this.listener(param);
  };
  return ListenerUpdateFlag;
}(UpdateFlag);

/**
 * @internal
 */
var UpdateFlagManager = /*#__PURE__*/function () {
  function UpdateFlagManager() {
    this._updateFlags = [];
  }
  var _proto = UpdateFlagManager.prototype;
  /**
   * Create a UpdateFlag.
   * @returns - The UpdateFlag.
   */
  _proto.createFlag = function createFlag(type) {
    var flag = new type();
    this.addFlag(flag);
    return flag;
  }

  /**
   * Add a UpdateFlag.
   * @param flag - The UpdateFlag.
   */;
  _proto.addFlag = function addFlag(flag) {
    this._updateFlags.push(flag);
    flag._flagManagers.push(this);
  }

  /**
   * Dispatch.
   */;
  _proto.dispatch = function dispatch(param) {
    var updateFlags = this._updateFlags;
    for (var i = updateFlags.length - 1; i >= 0; i--) {
      updateFlags[i].dispatch(param);
    }
  };
  return UpdateFlagManager;
}();

var _class$d, _descriptor$a, _descriptor2$9, _descriptor3$8, _descriptor4$8, _descriptor5$8, _descriptor6$8, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$4, _descriptor11$4, _descriptor12$4, _descriptor13$3, _class2$b;

/**
 * Used to implement transformation related functions.
 */
var Transform = (_class$d = (_class2$b = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Transform, _Component);
  /**
   * @internal
   */
  function Transform(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _initializerDefineProperty(_this, "_position", _descriptor$a, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rotation", _descriptor2$9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rotationQuaternion", _descriptor3$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_scale", _descriptor4$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldPosition", _descriptor5$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldRotation", _descriptor6$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldRotationQuaternion", _descriptor7$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lossyWorldScale", _descriptor8$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_localMatrix", _descriptor9$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldMatrix", _descriptor10$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_updateFlagManager", _descriptor11$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isParentDirty", _descriptor12$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_parentTransformCache", _descriptor13$3, _assertThisInitialized(_this));
    _this._dirtyFlag = TransformFlag.WmWpWeWqWs;
    _this._onPositionChanged = _this._onPositionChanged.bind(_assertThisInitialized(_this));
    _this._onWorldPositionChanged = _this._onWorldPositionChanged.bind(_assertThisInitialized(_this));
    _this._onRotationChanged = _this._onRotationChanged.bind(_assertThisInitialized(_this));
    _this._onWorldRotationChanged = _this._onWorldRotationChanged.bind(_assertThisInitialized(_this));
    _this._onRotationQuaternionChanged = _this._onRotationQuaternionChanged.bind(_assertThisInitialized(_this));
    _this._onWorldRotationQuaternionChanged = _this._onWorldRotationQuaternionChanged.bind(_assertThisInitialized(_this));
    _this._onScaleChanged = _this._onScaleChanged.bind(_assertThisInitialized(_this));

    //@ts-ignore
    _this._position._onValueChanged = _this._onPositionChanged;
    //@ts-ignore
    _this._worldPosition._onValueChanged = _this._onWorldPositionChanged;
    //@ts-ignore
    _this._rotation._onValueChanged = _this._onRotationChanged;
    //@ts-ignore
    _this._worldRotation._onValueChanged = _this._onWorldRotationChanged;
    //@ts-ignore
    _this._rotationQuaternion._onValueChanged = _this._onRotationQuaternionChanged;
    //@ts-ignore
    _this._worldRotationQuaternion._onValueChanged = _this._onWorldRotationQuaternionChanged;
    //@ts-ignore
    _this._scale._onValueChanged = _this._onScaleChanged;
    return _this;
  }

  /**
   * Set local position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */
  var _proto = Transform.prototype;
  _proto.setPosition = function setPosition(x, y, z) {
    this._position.set(x, y, z);
  }

  /**
   * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */;
  _proto.setRotation = function setRotation(x, y, z) {
    this._rotation.set(x, y, z);
  }

  /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */;
  _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
    this._rotationQuaternion.set(x, y, z, w);
  }

  /**
   * Set local scaling by scaling values along X, Y, Z axis.
   * @param x - Scaling along X axis
   * @param y - Scaling along Y axis
   * @param z - Scaling along Z axis
   */;
  _proto.setScale = function setScale(x, y, z) {
    this._scale.set(x, y, z);
  }

  /**
   * Set world position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */;
  _proto.setWorldPosition = function setWorldPosition(x, y, z) {
    this._worldPosition.set(x, y, z);
  }

  /**
   * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */;
  _proto.setWorldRotation = function setWorldRotation(x, y, z) {
    this._worldRotation.set(x, y, z);
  }

  /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */;
  _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
    this._worldRotationQuaternion.set(x, y, z, w);
  }

  /**
   * Get the forward direction in world space.
   * @param forward - Forward vector
   * @returns Forward vector
   */;
  _proto.getWorldForward = function getWorldForward(forward) {
    var e = this.worldMatrix.elements;
    forward.set(-e[8], -e[9], -e[10]);
    return forward.normalize();
  }

  /**
   * Get the right direction in world space.
   * @param right - Right vector
   * @returns Right vector
   */;
  _proto.getWorldRight = function getWorldRight(right) {
    var e = this.worldMatrix.elements;
    right.set(e[0], e[1], e[2]);
    return right.normalize();
  }

  /**
   * Get the up direction in world space.
   * @param up - Up vector
   * @returns Up vector
   */;
  _proto.getWorldUp = function getWorldUp(up) {
    var e = this.worldMatrix.elements;
    up.set(e[4], e[5], e[6]);
    return up.normalize();
  }

  /**
   * Translate in the direction and distance of the translation.
   * @param translation - Direction and distance of translation
   * @param relativeToLocal = `true` - Is relative to the local coordinate system
   */;
  _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof translationOrX === "number") {
      var _translate2 = Transform._tempVec30;
      _translate2.set(translationOrX, relativeToLocalOrY, z);
      this._translate(_translate2, relativeToLocal);
    } else {
      this._translate(translationOrX, relativeToLocalOrY);
    }
  }

  /**
   * Rotate around the passed Vector3.
   * @param rotation - Euler angle in degrees
   * @param relativeToLocal = `true` - Is relative to the local coordinate system
   */;
  _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof rotationOrX === "number") {
      this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
    } else {
      this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
    }
  }

  /**
   * Rotate around the specified axis according to the specified angle.
   * @param axis - Rotate axis
   * @param angle - Rotate angle in degrees
   * @param relativeToLocal = `true` - Relative to local space
   */;
  _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    var rad = angle * MathUtil.degreeToRadFactor;
    Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);
    this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
  }

  /**
   * Rotate and ensure that the world front vector points to the target world position.
   * @param targetPosition - Target world position
   * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)
   */;
  _proto.lookAt = function lookAt(targetPosition, worldUp) {
    var zAxis = Transform._tempVec30;
    Vector3.subtract(this.worldPosition, targetPosition, zAxis);
    var axisLen = zAxis.length();
    if (axisLen <= MathUtil.zeroTolerance) {
      // The current position and the target position are almost the same.
      return;
    }
    zAxis.scale(1 / axisLen);
    var xAxis = Transform._tempVec31;
    if (worldUp) {
      Vector3.cross(worldUp, zAxis, xAxis);
    } else {
      xAxis.set(zAxis.z, 0, -zAxis.x);
    }
    axisLen = xAxis.length();
    if (axisLen <= MathUtil.zeroTolerance) {
      // @todo:
      // 1.worldUp is（0,0,0）
      // 2.worldUp is parallel to zAxis
      return;
    }
    xAxis.scale(1 / axisLen);
    var yAxis = Transform._tempVec32;
    Vector3.cross(zAxis, xAxis, yAxis);
    var rotMat = Transform._tempMat41;
    var e = rotMat.elements;
    e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
    e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
    e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
    rotMat.getRotation(this._worldRotationQuaternion);
  }

  /**
   * Register world transform change flag.
   * @returns Change flag
   */;
  _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
    return this._updateFlagManager.createFlag(BoolUpdateFlag);
  }

  /**
   * @internal
   */;
  _proto._registerWorldChangeListener = function _registerWorldChangeListener() {
    return this._updateFlagManager.createFlag(ListenerUpdateFlag);
  }

  /**
   * @internal
   */;
  _proto._parentChange = function _parentChange() {
    this._isParentDirty = true;
    this._updateAllWorldFlag();
  }

  /**
   * @internal
   */;
  _proto._isFrontFaceInvert = function _isFrontFaceInvert() {
    var scale = this.lossyWorldScale;
    var isInvert = scale.x < 0;
    scale.y < 0 && (isInvert = !isInvert);
    scale.z < 0 && (isInvert = !isInvert);
    return isInvert;
  }

  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */;
  _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWp)) {
      this._worldAssociatedChange(TransformFlag.WmWp);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans;
        (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
      }
    }
  }

  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */;
  _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWeWq)) {
      this._worldAssociatedChange(TransformFlag.WmWeWq);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans2;
        (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag(); // Rotation update of parent entity will trigger world position and rotation update of all child entity.
      }
    }
  }

  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */;
  _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWq)) {
      this._worldAssociatedChange(TransformFlag.WmWpWeWq);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans3;
        (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
      }
    }
  }

  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   */;
  _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWs)) {
      this._worldAssociatedChange(TransformFlag.WmWs);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans4;
        (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
      }
    }
  }

  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   */;
  _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWs)) {
      this._worldAssociatedChange(TransformFlag.WmWpWs);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans5;
        (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
      }
    }
  }

  /**
   * Update all world transform property dirty flag, the principle is the same as above.
   */;
  _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)) {
      this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans6;
        (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
      }
    }
  };
  _proto._getParentTransform = function _getParentTransform() {
    if (!this._isParentDirty) {
      return this._parentTransformCache;
    }
    var parentCache = null;
    var parent = this._entity.parent;
    while (parent) {
      var transform = parent.transform;
      if (transform) {
        parentCache = transform;
        break;
      } else {
        parent = parent.parent;
      }
    }
    this._parentTransformCache = parentCache;
    this._isParentDirty = false;
    return parentCache;
  };
  _proto._getScaleMatrix = function _getScaleMatrix() {
    var invRotation = Transform._tempQuat0;
    var invRotationMat = Transform._tempMat30;
    var worldRotScaMat = Transform._tempMat31;
    var scaMat = Transform._tempMat32;
    worldRotScaMat.copyFromMatrix(this.worldMatrix);
    Quaternion.invert(this.worldRotationQuaternion, invRotation);
    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
    return scaMat;
  };
  _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
    this._dirtyFlag |= type;
    this._updateFlagManager.dispatch();
  };
  _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
    if (relativeToLocal) {
      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
    } else {
      Quaternion.multiply(rotateQuat, this.worldRotationQuaternion, this._worldRotationQuaternion);
    }
  };
  _proto._translate = function _translate(translation, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    if (relativeToLocal) {
      var _tempVec30 = Transform._tempVec30;
      Vector3.transformByQuat(translation, this.worldRotationQuaternion, _tempVec30);
      this._worldPosition.add(_tempVec30);
    } else {
      this._worldPosition.add(translation);
    }
  };
  _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    var radFactor = MathUtil.degreeToRadFactor;
    var rotQuat = Transform._tempQuat0;
    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
    this._rotateByQuat(rotQuat, relativeToLocal);
  };
  _proto._onPositionChanged = function _onPositionChanged() {
    this._setDirtyFlagTrue(TransformFlag.LocalMatrix);
    this._updateWorldPositionFlag();
  };
  _proto._onWorldPositionChanged = function _onWorldPositionChanged() {
    var worldPosition = this._worldPosition;
    var parent = this._getParentTransform();
    if (parent) {
      Matrix.invert(parent.worldMatrix, Transform._tempMat41);
      Vector3.transformCoordinate(worldPosition, Transform._tempMat41, this._position);
    } else {
      this._position.copyFrom(worldPosition);
    }
    this._setDirtyFlagFalse(TransformFlag.WorldPosition);
  };
  _proto._onRotationChanged = function _onRotationChanged() {
    this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalQuat);
    this._setDirtyFlagFalse(TransformFlag.LocalEuler);
    this._updateWorldRotationFlag();
  };
  _proto._onWorldRotationChanged = function _onWorldRotationChanged() {
    var worldRotation = this._worldRotation;
    Quaternion.rotationEuler(MathUtil.degreeToRadian(worldRotation.x), MathUtil.degreeToRadian(worldRotation.y), MathUtil.degreeToRadian(worldRotation.z), this._worldRotationQuaternion);
    this._setDirtyFlagFalse(TransformFlag.WorldEuler);
  };
  _proto._onRotationQuaternionChanged = function _onRotationQuaternionChanged() {
    this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalEuler);
    this._setDirtyFlagFalse(TransformFlag.LocalQuat);
    this._updateWorldRotationFlag();
  };
  _proto._onWorldRotationQuaternionChanged = function _onWorldRotationQuaternionChanged() {
    var worldRotationQuaternion = this._worldRotationQuaternion;
    var parent = this._getParentTransform();
    if (parent) {
      var invParentQuaternion = Transform._tempQuat0;
      Quaternion.invert(parent.worldRotationQuaternion, invParentQuaternion);
      Quaternion.multiply(invParentQuaternion, worldRotationQuaternion, this._rotationQuaternion);
    } else {
      this._rotationQuaternion.copyFrom(worldRotationQuaternion);
    }
    this._setDirtyFlagFalse(TransformFlag.WorldQuat);
  };
  _proto._onScaleChanged = function _onScaleChanged() {
    this._setDirtyFlagTrue(TransformFlag.LocalMatrix);
    this._updateWorldScaleFlag();
  };
  _createClass(Transform, [{
    key: "position",
    get:
    /**
     * Local position.
     */
    function get() {
      return this._position;
    },
    set: function set(value) {
      if (this._position !== value) {
        this._position.copyFrom(value);
      }
    }

    /**
     * World position.
     */
  }, {
    key: "worldPosition",
    get: function get() {
      var worldPosition = this._worldPosition;
      if (this._isContainDirtyFlag(TransformFlag.WorldPosition)) {
        //@ts-ignore
        worldPosition._onValueChanged = null;
        if (this._getParentTransform()) {
          this.worldMatrix.getTranslation(worldPosition);
        } else {
          worldPosition.copyFrom(this._position);
        }
        //@ts-ignore
        worldPosition._onValueChanged = this._onWorldPositionChanged;
        this._setDirtyFlagFalse(TransformFlag.WorldPosition);
      }
      return worldPosition;
    },
    set: function set(value) {
      if (this._worldPosition !== value) {
        this._worldPosition.copyFrom(value);
      }
    }

    /**
     * Local rotation, defining the rotation value in degrees.
     * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
     */
  }, {
    key: "rotation",
    get: function get() {
      var rotation = this._rotation;
      if (this._isContainDirtyFlag(TransformFlag.LocalEuler)) {
        //@ts-ignore
        rotation._onValueChanged = null;
        this._rotationQuaternion.toEuler(rotation);
        //@ts-ignore
        rotation._onValueChanged = this._onRotationChanged;
        rotation.scale(MathUtil.radToDegreeFactor); // radians to degrees
        this._setDirtyFlagFalse(TransformFlag.LocalEuler);
      }
      return rotation;
    },
    set: function set(value) {
      if (this._rotation !== value) {
        this._rotation.copyFrom(value);
      }
    }

    /**
     * World rotation, defining the rotation value in degrees.
     * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
     */
  }, {
    key: "worldRotation",
    get: function get() {
      var worldRotation = this._worldRotation;
      if (this._isContainDirtyFlag(TransformFlag.WorldEuler)) {
        //@ts-ignore
        worldRotation._onValueChanged = null;
        this.worldRotationQuaternion.toEuler(worldRotation);
        worldRotation.scale(MathUtil.radToDegreeFactor); // Radian to angle
        //@ts-ignore
        worldRotation._onValueChanged = this._onWorldRotationChanged;
        this._setDirtyFlagFalse(TransformFlag.WorldEuler);
      }
      return worldRotation;
    },
    set: function set(value) {
      if (this._worldRotation !== value) {
        this._worldRotation.copyFrom(value);
      }
    }

    /**
     * Local rotation, defining the rotation by using a unit quaternion.
     */
  }, {
    key: "rotationQuaternion",
    get: function get() {
      var rotationQuaternion = this._rotationQuaternion;
      if (this._isContainDirtyFlag(TransformFlag.LocalQuat)) {
        //@ts-ignore
        rotationQuaternion._onValueChanged = null;
        Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), rotationQuaternion);
        //@ts-ignore
        rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
        this._setDirtyFlagFalse(TransformFlag.LocalQuat);
      }
      return rotationQuaternion;
    },
    set: function set(value) {
      if (this._rotationQuaternion !== value) {
        if (value.normalized) {
          this._rotationQuaternion.copyFrom(value);
        } else {
          Quaternion.normalize(value, this._rotationQuaternion);
        }
      } else {
        value.normalized || value.normalize();
      }
    }

    /**
     * World rotation, defining the rotation by using a unit quaternion.
     */
  }, {
    key: "worldRotationQuaternion",
    get: function get() {
      var worldRotationQuaternion = this._worldRotationQuaternion;
      if (this._isContainDirtyFlag(TransformFlag.WorldQuat)) {
        //@ts-ignore
        worldRotationQuaternion._onValueChanged = null;
        var parent = this._getParentTransform();
        if (parent != null) {
          Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, worldRotationQuaternion);
        } else {
          worldRotationQuaternion.copyFrom(this.rotationQuaternion);
        }
        //@ts-ignore
        worldRotationQuaternion._onValueChanged = this._onWorldRotationQuaternionChanged;
        this._setDirtyFlagFalse(TransformFlag.WorldQuat);
      }
      return worldRotationQuaternion;
    },
    set: function set(value) {
      if (this._worldRotationQuaternion !== value) {
        if (value.normalized) {
          this._worldRotationQuaternion.copyFrom(value);
        } else {
          Quaternion.normalize(value, this._worldRotationQuaternion);
        }
      }
      value.normalized || value.normalize();
    }

    /**
     * Local scaling.
     */
  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    },
    set: function set(value) {
      if (this._scale !== value) {
        this._scale.copyFrom(value);
      }
    }

    /**
     * Local lossy scaling.
     * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has scaling,
     * and the child node has a rotation), the scaling will be tilted. Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3.
     */
  }, {
    key: "lossyWorldScale",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldScale)) {
        if (this._getParentTransform()) {
          var scaleMat = this._getScaleMatrix();
          var e = scaleMat.elements;
          this._lossyWorldScale.set(e[0], e[4], e[8]);
        } else {
          this._lossyWorldScale.copyFrom(this._scale);
        }
        this._setDirtyFlagFalse(TransformFlag.WorldScale);
      }
      return this._lossyWorldScale;
    }

    /**
     * Local matrix.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */
  }, {
    key: "localMatrix",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.LocalMatrix)) {
        Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
        this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
      }
      return this._localMatrix;
    },
    set: function set(value) {
      if (this._localMatrix !== value) {
        this._localMatrix.copyFrom(value);
      }
      this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
      this._setDirtyFlagTrue(TransformFlag.LocalEuler);
      this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
      this._updateAllWorldFlag();
    }

    /**
     * World matrix.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */
  }, {
    key: "worldMatrix",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldMatrix)) {
        var parent = this._getParentTransform();
        if (parent) {
          Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
        } else {
          this._worldMatrix.copyFrom(this.localMatrix);
        }
        this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
      }
      return this._worldMatrix;
    },
    set: function set(value) {
      if (this._worldMatrix !== value) {
        this._worldMatrix.copyFrom(value);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform._tempMat42);
        Matrix.multiply(Transform._tempMat42, value, this._localMatrix);
      } else {
        this._localMatrix.copyFrom(value);
      }
      this.localMatrix = this._localMatrix;
      this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
    }
  }]);
  return Transform;
}(Component), _class2$b._tempQuat0 = new Quaternion(), _class2$b._tempVec30 = new Vector3(), _class2$b._tempVec31 = new Vector3(), _class2$b._tempVec32 = new Vector3(), _class2$b._tempMat30 = new Matrix3x3(), _class2$b._tempMat31 = new Matrix3x3(), _class2$b._tempMat32 = new Matrix3x3(), _class2$b._tempMat41 = new Matrix(), _class2$b._tempMat42 = new Matrix(), _class2$b), (_descriptor$a = _applyDecoratedDescriptor(_class$d.prototype, "_position", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor2$9 = _applyDecoratedDescriptor(_class$d.prototype, "_rotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor3$8 = _applyDecoratedDescriptor(_class$d.prototype, "_rotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Quaternion();
  }
}), _descriptor4$8 = _applyDecoratedDescriptor(_class$d.prototype, "_scale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor5$8 = _applyDecoratedDescriptor(_class$d.prototype, "_worldPosition", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor6$8 = _applyDecoratedDescriptor(_class$d.prototype, "_worldRotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor7$8 = _applyDecoratedDescriptor(_class$d.prototype, "_worldRotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Quaternion();
  }
}), _descriptor8$8 = _applyDecoratedDescriptor(_class$d.prototype, "_lossyWorldScale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor9$7 = _applyDecoratedDescriptor(_class$d.prototype, "_localMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor10$4 = _applyDecoratedDescriptor(_class$d.prototype, "_worldMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor11$4 = _applyDecoratedDescriptor(_class$d.prototype, "_updateFlagManager", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new UpdateFlagManager();
  }
}), _descriptor12$4 = _applyDecoratedDescriptor(_class$d.prototype, "_isParentDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor13$3 = _applyDecoratedDescriptor(_class$d.prototype, "_parentTransformCache", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class$d);
/**
 * Dirty flag of transform.
 */
var TransformFlag;
(function (TransformFlag) {
  TransformFlag[TransformFlag["LocalEuler"] = 1] = "LocalEuler";
  TransformFlag[TransformFlag["LocalQuat"] = 2] = "LocalQuat";
  TransformFlag[TransformFlag["WorldPosition"] = 4] = "WorldPosition";
  TransformFlag[TransformFlag["WorldEuler"] = 8] = "WorldEuler";
  TransformFlag[TransformFlag["WorldQuat"] = 16] = "WorldQuat";
  TransformFlag[TransformFlag["WorldScale"] = 32] = "WorldScale";
  TransformFlag[TransformFlag["LocalMatrix"] = 64] = "LocalMatrix";
  TransformFlag[TransformFlag["WorldMatrix"] = 128] = "WorldMatrix";
  TransformFlag[TransformFlag["WmWp"] = 132] = "WmWp";
  TransformFlag[TransformFlag["WmWeWq"] = 152] = "WmWeWq";
  TransformFlag[TransformFlag["WmWpWeWq"] = 156] = "WmWpWeWq";
  TransformFlag[TransformFlag["WmWs"] = 160] = "WmWs";
  TransformFlag[TransformFlag["WmWpWs"] = 164] = "WmWpWs";
  TransformFlag[TransformFlag["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
})(TransformFlag || (TransformFlag = {}));

/**
 * Entity, be used as components container.
 */
var Entity = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Entity, _EngineObject);
  /**
   * @internal
   */
  Entity._findChildByName = function _findChildByName(root, name) {
    var children = root._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var _child = children[i];
      if (_child.name === name) {
        return _child;
      }
    }
    return null;
  }

  /**
   * @internal
   */;
  Entity._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
    entity._scene = scene;
    var children = entity._children;
    for (var i = entity.childCount - 1; i >= 0; i--) {
      this._traverseSetOwnerScene(children[i], scene);
    }
  }

  /** The name of entity. */;

  /**
   * Create a entity.
   * @param engine - The engine the entity belongs to
   */
  function Entity(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.layer = Layer.Layer0;
    _this.transform = void 0;
    _this._isActiveInHierarchy = false;
    _this._components = [];
    _this._scripts = new DisorderedArray();
    _this._children = [];
    _this._scene = void 0;
    _this._isRoot = false;
    _this._isActive = true;
    _this._siblingIndex = -1;
    _this._parent = null;
    _this._activeChangedComponents = void 0;
    _this._invModelMatrix = new Matrix();
    _this._inverseWorldMatFlag = void 0;
    _this.name = name;
    _this.transform = _this.addComponent(Transform);
    _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
    return _this;
  }

  /**
   * Add component based on the component type.
   * @param type - The type of the component
   * @returns	The component which has been added
   */
  var _proto = Entity.prototype;
  _proto.addComponent = function addComponent(type) {
    ComponentsDependencies._addCheck(this, type);
    var component = new type(this);
    this._components.push(component);
    component._setActive(true);
    return component;
  }

  /**
   * Get component which match the type.
   * @param type - The type of the component
   * @returns	The first component which match type
   */;
  _proto.getComponent = function getComponent(type) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        return component;
      }
    }
  }

  /**
   * Get components which match the type.
   * @param type - The type of the component
   * @param results - The components which match type
   * @returns	The components which match type
   */;
  _proto.getComponents = function getComponents(type, results) {
    results.length = 0;
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    return results;
  }

  /**
   * Get the components which match the type of the entity and it's children.
   * @param type - The component type
   * @param results - The components collection
   * @returns	The components collection which match the type
   */;
  _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
    results.length = 0;
    this._getComponentsInChildren(type, results);
    return results;
  }

  /**
   * Add child entity.
   * @param child - The child entity which want to be added
   */;
  _proto.addChild = function addChild(indexOrChild, child) {
    var index;
    if (typeof indexOrChild === "number") {
      index = indexOrChild;
    } else {
      index = undefined;
      child = indexOrChild;
    }
    if (child._isRoot) {
      child._scene._removeFromEntityList(child);
      child._isRoot = false;
      this._addToChildrenList(index, child);
      child._parent = this;
      var newScene = this._scene;
      if (child._scene !== newScene) {
        Entity._traverseSetOwnerScene(child, newScene);
      }
      if (this._isActiveInHierarchy) {
        !child._isActiveInHierarchy && child._isActive && child._processActive();
      } else {
        child._isActiveInHierarchy && child._processInActive();
      }
      child._setTransformDirty();
    } else {
      child._setParent(this, index);
    }
  }

  /**
   * Remove child entity.
   * @param child - The child entity which want to be removed
   */;
  _proto.removeChild = function removeChild(child) {
    child._setParent(null);
  }

  /**
   * @deprecated Please use `children` property instead.
   * Find child entity by index.
   * @param index - The index of the child entity
   * @returns	The component which be found
   */;
  _proto.getChild = function getChild(index) {
    return this._children[index];
  }

  /**
   * Find child entity by name.
   * @param name - The name of the entity which want to be found
   * @returns The component which be found
   */;
  _proto.findByName = function findByName(name) {
    var children = this._children;
    var child = Entity._findChildByName(this, name);
    if (child) return child;
    for (var i = children.length - 1; i >= 0; i--) {
      var _child2 = children[i];
      var grandson = _child2.findByName(name);
      if (grandson) {
        return grandson;
      }
    }
    return null;
  }

  /**
   * Find the entity by path.
   * @param path - The path fo the entity eg: /entity
   * @returns The component which be found
   */;
  _proto.findByPath = function findByPath(path) {
    var splits = path.split("/");
    var entity = this;
    for (var i = 0, length = splits.length; i < length; ++i) {
      var split = splits[i];
      if (split) {
        entity = Entity._findChildByName(entity, split);
        if (!entity) {
          return null;
        }
      }
    }
    return entity;
  }

  /**
   * Create child entity.
   * @param name - The child entity's name
   * @returns The child entity
   */;
  _proto.createChild = function createChild(name) {
    var child = new Entity(this.engine, name);
    child.layer = this.layer;
    child.parent = this;
    return child;
  }

  /**
   * Clear children entities.
   */;
  _proto.clearChildren = function clearChildren() {
    var children = this._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var _child3 = children[i];
      _child3._parent = null;
      _child3._isActiveInHierarchy && _child3._processInActive();
      Entity._traverseSetOwnerScene(_child3, null); // Must after child._processInActive().
    }

    children.length = 0;
  }

  /**
   * Clone.
   * @returns Cloned entity
   */;
  _proto.clone = function clone() {
    var cloneEntity = new Entity(this._engine, this.name);
    cloneEntity._isActive = this._isActive;
    cloneEntity.transform.localMatrix = this.transform.localMatrix;
    var children = this._children;
    for (var i = 0, len = this._children.length; i < len; i++) {
      var _child4 = children[i];
      cloneEntity.addChild(_child4.clone());
    }
    var components = this._components;
    for (var _i = 0, n = components.length; _i < n; _i++) {
      var sourceComp = components[_i];
      if (!(sourceComp instanceof Transform)) {
        var targetComp = cloneEntity.addComponent(sourceComp.constructor);
        ComponentCloner.cloneComponent(sourceComp, targetComp);
      }
    }
    return cloneEntity;
  }

  /**
   * Destroy self.
   */;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    _EngineObject.prototype.destroy.call(this);
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      components[i].destroy();
    }
    this._components.length = 0;
    var children = this._children;
    for (var _i2 = children.length - 1; _i2 >= 0; _i2--) {
      children[_i2].destroy();
    }
    this._children.length = 0;
    if (this._isRoot) {
      this._scene._removeFromEntityList(this);
      this._isRoot = false;
    } else {
      this._removeFromParent();
    }
  }

  /**
   * @internal
   */;
  _proto._removeComponent = function _removeComponent(component) {
    ComponentsDependencies._removeCheck(this, component.constructor);
    var components = this._components;
    components.splice(components.indexOf(component), 1);
  }

  /**
   * @internal
   */;
  _proto._addScript = function _addScript(script) {
    script._entityScriptsIndex = this._scripts.length;
    this._scripts.add(script);
  }

  /**
   * @internal
   */;
  _proto._removeScript = function _removeScript(script) {
    var replaced = this._scripts.deleteByIndex(script._entityScriptsIndex);
    replaced && (replaced._entityScriptsIndex = script._entityScriptsIndex);
    script._entityScriptsIndex = -1;
  }

  /**
   * @internal
   */;
  _proto._removeFromParent = function _removeFromParent() {
    var oldParent = this._parent;
    if (oldParent != null) {
      var oldSibling = oldParent._children;
      var _index = this._siblingIndex;
      oldSibling.splice(_index, 1);
      for (var n = oldSibling.length; _index < n; _index++) {
        oldSibling[_index]._siblingIndex--;
      }
      this._parent = null;
      this._siblingIndex = -1;
    }
  }

  /**
   * @internal
   */;
  _proto._processActive = function _processActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(true);
  }

  /**
   * @internal
   */;
  _proto._processInActive = function _processInActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setInActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(false);
  };
  _proto._addToChildrenList = function _addToChildrenList(index, child) {
    var children = this._children;
    var childCount = children.length;
    if (index === undefined) {
      child._siblingIndex = childCount;
      children.push(child);
    } else {
      if (index < 0 || index > childCount) {
        throw "The index " + index + " is out of child list bounds " + childCount;
      }
      child._siblingIndex = index;
      children.splice(index, 0, child);
      for (var i = index + 1, n = childCount + 1; i < n; i++) {
        children[i]._siblingIndex++;
      }
    }
  };
  _proto._setParent = function _setParent(parent, siblingIndex) {
    var oldParent = this._parent;
    if (parent !== oldParent) {
      this._removeFromParent();
      this._parent = parent;
      if (parent) {
        parent._addToChildrenList(siblingIndex, this);
        var parentScene = parent._scene;
        if (this._scene !== parentScene) {
          Entity._traverseSetOwnerScene(this, parentScene);
        }
        if (parent._isActiveInHierarchy) {
          !this._isActiveInHierarchy && this._isActive && this._processActive();
        } else {
          this._isActiveInHierarchy && this._processInActive();
        }
      } else {
        this._isActiveInHierarchy && this._processInActive();
        if (oldParent) {
          Entity._traverseSetOwnerScene(this, null);
        }
      }
      this._setTransformDirty();
    }
  };
  _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    for (var _i3 = this._children.length - 1; _i3 >= 0; _i3--) {
      this._children[_i3]._getComponentsInChildren(type, results);
    }
  };
  _proto._setActiveComponents = function _setActiveComponents(isActive) {
    var activeChangedComponents = this._activeChangedComponents;
    for (var i = 0, length = activeChangedComponents.length; i < length; ++i) {
      activeChangedComponents[i]._setActive(isActive);
    }
    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
    this._activeChangedComponents = null;
  };
  _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = true;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      (component.enabled || !component._awoken) && activeChangedComponents.push(component);
    }
    var children = this._children;
    for (var _i4 = children.length - 1; _i4 >= 0; _i4--) {
      var _child5 = children[_i4];
      _child5.isActive && _child5._setActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = false;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      component.enabled && activeChangedComponents.push(component);
    }
    var children = this._children;
    for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
      var _child6 = children[_i5];
      _child6.isActive && _child6._setInActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setTransformDirty = function _setTransformDirty() {
    if (this.transform) {
      this.transform._parentChange();
    } else {
      for (var i = 0, len = this._children.length; i < len; i++) {
        this._children[i]._setTransformDirty();
      }
    }
  };
  _proto._setSiblingIndex = function _setSiblingIndex(sibling, target) {
    target = Math.min(target, sibling.length - 1);
    if (target < 0) {
      throw "Sibling index " + target + " should large than 0";
    }
    if (this._siblingIndex !== target) {
      var oldIndex = this._siblingIndex;
      if (target < oldIndex) {
        for (var i = oldIndex; i >= target; i--) {
          var _child7 = i == target ? this : sibling[i - 1];
          sibling[i] = _child7;
          _child7._siblingIndex = i;
        }
      } else {
        for (var _i6 = oldIndex; _i6 <= target; _i6++) {
          var _child8 = _i6 == target ? this : sibling[_i6 + 1];
          sibling[_i6] = _child8;
          _child8._siblingIndex = _i6;
        }
      }
    }
  }

  //--------------------------------------------------------------deprecated----------------------------------------------------------------
  ;
  /**
   * @deprecated
   */
  _proto.getInvModelMatrix = function getInvModelMatrix() {
    if (this._inverseWorldMatFlag.flag) {
      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
      this._inverseWorldMatFlag.flag = false;
    }
    return this._invModelMatrix;
  };
  _createClass(Entity, [{
    key: "isActive",
    get:
    /**
     * Whether to activate locally.
     */
    function get() {
      return this._isActive;
    },
    set: function set(value) {
      if (value !== this._isActive) {
        this._isActive = value;
        if (value) {
          var parent = this._parent;
          if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
            this._processActive();
          }
        } else {
          if (this._isActiveInHierarchy) {
            this._processInActive();
          }
        }
      }
    }

    /**
     * Whether it is active in the hierarchy.
     */
  }, {
    key: "isActiveInHierarchy",
    get: function get() {
      return this._isActiveInHierarchy;
    }

    /**
     * The parent entity.
     */
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    },
    set: function set(value) {
      this._setParent(value);
    }

    /**
     * The children entities
     */
  }, {
    key: "children",
    get: function get() {
      return this._children;
    }

    /**
     * @deprecated Please use `children.length` property instead.
     * Number of the children entities
     */
  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }

    /**
     * The scene the entity belongs to.
     */
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }

    /**
     * The sibling index.
     */
  }, {
    key: "siblingIndex",
    get: function get() {
      return this._siblingIndex;
    },
    set: function set(value) {
      if (this._siblingIndex === -1) {
        throw "The entity " + this.name + " is not in the hierarchy";
      }
      this._setSiblingIndex(this._isRoot ? this._scene._rootEntities : this._parent._children, value);
    }
  }]);
  return Entity;
}(EngineObject);

/**
 * Manage a set of feature objects.
 */
var FeatureManager = /*#__PURE__*/function () {
  function FeatureManager() {
    this._features = [];
    this._objects = [];
  }
  var _proto = FeatureManager.prototype;
  /**
   * Register a feature.
   * @param {SceneFeature|EngineFeature} IFeature
   */
  _proto.registerFeature = function registerFeature(IFeature) {
    var featureArray = this._features;

    // Search by type, avoid adding
    for (var i = 0, len = featureArray.length; i < len; i++) {
      if (featureArray[i] === IFeature) {
        return;
      }
    }

    // Add to global array
    featureArray.push(IFeature);

    // Add to existing scene
    var objectArray = this._objects;
    for (var _i = 0, _len = objectArray.length; _i < _len; _i++) {
      objectArray[_i].features.push(new IFeature());
    }
  }

  /**
   * Add an feature with functional characteristics.
   * @param {Scene|Engine} obj - Scene or engine
   */;
  _proto.addObject = function addObject(obj) {
    obj.features = [];
    for (var i = 0, len = this._features.length; i < len; i++) {
      var _engine;
      obj.features.push(new this._features[i]((_engine = obj.engine) != null ? _engine : obj));
    }
    this._objects.push(obj);
  }

  /**
   * Call the specified method of the feature.
   * @param obj - Scene or engine
   * @param method - Method name
   * @param args - Function args
   */;
  _proto.callFeatureMethod = function callFeatureMethod(obj, method, args) {
    var features = obj.features;
    var count = features.length;
    for (var i = 0; i < count; i++) {
      var feature = features[i];
      if (feature[method]) {
        feature[method].apply(feature, args);
      }
    }
  }

  /**
   * Find feature.
   * @param obj - Scene or engine
   * @param IFeature - plug-in
   */;
  _proto.findFeature = function findFeature(obj, IFeature) {
    var features = obj.features;
    var count = features.length;
    for (var i = 0; i < count; i++) {
      var feature = features[i];
      if (feature.constructor === IFeature) {
        return feature;
      }
    }
    return undefined;
  };
  return FeatureManager;
}();

/**
 * The keys of the keyboard.
 * Keep up with W3C standards.(https://www.w3.org/TR/2017/CR-uievents-code-20170601/)
 */
var Keys;
(function (Keys) {
  Keys[Keys["Backquote"] = 0] = "Backquote";
  Keys[Keys["Backslash"] = 1] = "Backslash";
  Keys[Keys["Backspace"] = 2] = "Backspace";
  Keys[Keys["BracketLeft"] = 3] = "BracketLeft";
  Keys[Keys["BracketRight"] = 4] = "BracketRight";
  Keys[Keys["Comma"] = 5] = "Comma";
  Keys[Keys["Digit0"] = 6] = "Digit0";
  Keys[Keys["Digit1"] = 7] = "Digit1";
  Keys[Keys["Digit2"] = 8] = "Digit2";
  Keys[Keys["Digit3"] = 9] = "Digit3";
  Keys[Keys["Digit4"] = 10] = "Digit4";
  Keys[Keys["Digit5"] = 11] = "Digit5";
  Keys[Keys["Digit6"] = 12] = "Digit6";
  Keys[Keys["Digit7"] = 13] = "Digit7";
  Keys[Keys["Digit8"] = 14] = "Digit8";
  Keys[Keys["Digit9"] = 15] = "Digit9";
  Keys[Keys["Equal"] = 16] = "Equal";
  Keys[Keys["IntlBackslash"] = 17] = "IntlBackslash";
  Keys[Keys["IntlRo"] = 18] = "IntlRo";
  Keys[Keys["IntlYen"] = 19] = "IntlYen";
  Keys[Keys["KeyA"] = 20] = "KeyA";
  Keys[Keys["KeyB"] = 21] = "KeyB";
  Keys[Keys["KeyC"] = 22] = "KeyC";
  Keys[Keys["KeyD"] = 23] = "KeyD";
  Keys[Keys["KeyE"] = 24] = "KeyE";
  Keys[Keys["KeyF"] = 25] = "KeyF";
  Keys[Keys["KeyG"] = 26] = "KeyG";
  Keys[Keys["KeyH"] = 27] = "KeyH";
  Keys[Keys["KeyI"] = 28] = "KeyI";
  Keys[Keys["KeyJ"] = 29] = "KeyJ";
  Keys[Keys["KeyK"] = 30] = "KeyK";
  Keys[Keys["KeyL"] = 31] = "KeyL";
  Keys[Keys["KeyM"] = 32] = "KeyM";
  Keys[Keys["KeyN"] = 33] = "KeyN";
  Keys[Keys["KeyO"] = 34] = "KeyO";
  Keys[Keys["KeyP"] = 35] = "KeyP";
  Keys[Keys["KeyQ"] = 36] = "KeyQ";
  Keys[Keys["KeyR"] = 37] = "KeyR";
  Keys[Keys["KeyS"] = 38] = "KeyS";
  Keys[Keys["KeyT"] = 39] = "KeyT";
  Keys[Keys["KeyU"] = 40] = "KeyU";
  Keys[Keys["KeyV"] = 41] = "KeyV";
  Keys[Keys["KeyW"] = 42] = "KeyW";
  Keys[Keys["KeyX"] = 43] = "KeyX";
  Keys[Keys["KeyY"] = 44] = "KeyY";
  Keys[Keys["KeyZ"] = 45] = "KeyZ";
  Keys[Keys["Minus"] = 46] = "Minus";
  Keys[Keys["Period"] = 47] = "Period";
  Keys[Keys["Quote"] = 48] = "Quote";
  Keys[Keys["Semicolon"] = 49] = "Semicolon";
  Keys[Keys["Slash"] = 50] = "Slash";
  Keys[Keys["AltLeft"] = 51] = "AltLeft";
  Keys[Keys["AltRight"] = 52] = "AltRight";
  Keys[Keys["CapsLock"] = 53] = "CapsLock";
  Keys[Keys["ContextMenu"] = 54] = "ContextMenu";
  Keys[Keys["ControlLeft"] = 55] = "ControlLeft";
  Keys[Keys["ControlRight"] = 56] = "ControlRight";
  Keys[Keys["Enter"] = 57] = "Enter";
  Keys[Keys["MetaLeft"] = 58] = "MetaLeft";
  Keys[Keys["MetaRight"] = 59] = "MetaRight";
  Keys[Keys["ShiftLeft"] = 60] = "ShiftLeft";
  Keys[Keys["ShiftRight"] = 61] = "ShiftRight";
  Keys[Keys["Space"] = 62] = "Space";
  Keys[Keys["Tab"] = 63] = "Tab";
  Keys[Keys["Convert"] = 64] = "Convert";
  Keys[Keys["KanaMode"] = 65] = "KanaMode";
  Keys[Keys["Lang1"] = 66] = "Lang1";
  Keys[Keys["Lang2"] = 67] = "Lang2";
  Keys[Keys["Lang3"] = 68] = "Lang3";
  Keys[Keys["Lang4"] = 69] = "Lang4";
  Keys[Keys["Lang5"] = 70] = "Lang5";
  Keys[Keys["NonConvert"] = 71] = "NonConvert";
  Keys[Keys["Delete"] = 72] = "Delete";
  Keys[Keys["End"] = 73] = "End";
  Keys[Keys["Help"] = 74] = "Help";
  Keys[Keys["Home"] = 75] = "Home";
  Keys[Keys["Insert"] = 76] = "Insert";
  Keys[Keys["PageDown"] = 77] = "PageDown";
  Keys[Keys["PageUp"] = 78] = "PageUp";
  Keys[Keys["ArrowDown"] = 79] = "ArrowDown";
  Keys[Keys["ArrowLeft"] = 80] = "ArrowLeft";
  Keys[Keys["ArrowRight"] = 81] = "ArrowRight";
  Keys[Keys["ArrowUp"] = 82] = "ArrowUp";
  Keys[Keys["NumLock"] = 83] = "NumLock";
  Keys[Keys["Numpad0"] = 84] = "Numpad0";
  Keys[Keys["Numpad1"] = 85] = "Numpad1";
  Keys[Keys["Numpad2"] = 86] = "Numpad2";
  Keys[Keys["Numpad3"] = 87] = "Numpad3";
  Keys[Keys["Numpad4"] = 88] = "Numpad4";
  Keys[Keys["Numpad5"] = 89] = "Numpad5";
  Keys[Keys["Numpad6"] = 90] = "Numpad6";
  Keys[Keys["Numpad7"] = 91] = "Numpad7";
  Keys[Keys["Numpad8"] = 92] = "Numpad8";
  Keys[Keys["Numpad9"] = 93] = "Numpad9";
  Keys[Keys["NumpadAdd"] = 94] = "NumpadAdd";
  Keys[Keys["NumpadBackspace"] = 95] = "NumpadBackspace";
  Keys[Keys["NumpadClear"] = 96] = "NumpadClear";
  Keys[Keys["NumpadClearEntry"] = 97] = "NumpadClearEntry";
  Keys[Keys["NumpadComma"] = 98] = "NumpadComma";
  Keys[Keys["NumpadDecimal"] = 99] = "NumpadDecimal";
  Keys[Keys["NumpadDivide"] = 100] = "NumpadDivide";
  Keys[Keys["NumpadEnter"] = 101] = "NumpadEnter";
  Keys[Keys["NumpadEqual"] = 102] = "NumpadEqual";
  Keys[Keys["NumpadHash"] = 103] = "NumpadHash";
  Keys[Keys["NumpadMemoryAdd"] = 104] = "NumpadMemoryAdd";
  Keys[Keys["NumpadMemoryClear"] = 105] = "NumpadMemoryClear";
  Keys[Keys["NumpadMemoryRecall"] = 106] = "NumpadMemoryRecall";
  Keys[Keys["NumpadMemoryStore"] = 107] = "NumpadMemoryStore";
  Keys[Keys["NumpadMemorySubtract"] = 108] = "NumpadMemorySubtract";
  Keys[Keys["NumpadMultiply"] = 109] = "NumpadMultiply";
  Keys[Keys["NumpadParenLeft"] = 110] = "NumpadParenLeft";
  Keys[Keys["NumpadParenRight"] = 111] = "NumpadParenRight";
  Keys[Keys["NumpadStar"] = 112] = "NumpadStar";
  Keys[Keys["NumpadSubtract"] = 113] = "NumpadSubtract";
  Keys[Keys["Escape"] = 114] = "Escape";
  Keys[Keys["F1"] = 115] = "F1";
  Keys[Keys["F2"] = 116] = "F2";
  Keys[Keys["F3"] = 117] = "F3";
  Keys[Keys["F4"] = 118] = "F4";
  Keys[Keys["F5"] = 119] = "F5";
  Keys[Keys["F6"] = 120] = "F6";
  Keys[Keys["F7"] = 121] = "F7";
  Keys[Keys["F8"] = 122] = "F8";
  Keys[Keys["F9"] = 123] = "F9";
  Keys[Keys["F10"] = 124] = "F10";
  Keys[Keys["F11"] = 125] = "F11";
  Keys[Keys["F12"] = 126] = "F12";
  Keys[Keys["F13"] = 127] = "F13";
  Keys[Keys["F14"] = 128] = "F14";
  Keys[Keys["F15"] = 129] = "F15";
  Keys[Keys["Fn"] = 130] = "Fn";
  Keys[Keys["FnLock"] = 131] = "FnLock";
  Keys[Keys["PrintScreen"] = 132] = "PrintScreen";
  Keys[Keys["ScrollLock"] = 133] = "ScrollLock";
  Keys[Keys["Pause"] = 134] = "Pause";
  Keys[Keys["BrowserBack"] = 135] = "BrowserBack";
  Keys[Keys["BrowserFavorites"] = 136] = "BrowserFavorites";
  Keys[Keys["BrowserForward"] = 137] = "BrowserForward";
  Keys[Keys["BrowserHome"] = 138] = "BrowserHome";
  Keys[Keys["BrowserRefresh"] = 139] = "BrowserRefresh";
  Keys[Keys["BrowserSearch"] = 140] = "BrowserSearch";
  Keys[Keys["BrowserStop"] = 141] = "BrowserStop";
  Keys[Keys["Eject"] = 142] = "Eject";
  Keys[Keys["LaunchApp1"] = 143] = "LaunchApp1";
  Keys[Keys["LaunchApp2"] = 144] = "LaunchApp2";
  Keys[Keys["LaunchMail"] = 145] = "LaunchMail";
  Keys[Keys["MediaPlayPause"] = 146] = "MediaPlayPause";
  Keys[Keys["MediaSelect"] = 147] = "MediaSelect";
  Keys[Keys["MediaStop"] = 148] = "MediaStop";
  Keys[Keys["MediaTrackNext"] = 149] = "MediaTrackNext";
  Keys[Keys["MediaTrackPrevious"] = 150] = "MediaTrackPrevious";
  Keys[Keys["Power"] = 151] = "Power";
  Keys[Keys["Sleep"] = 152] = "Sleep";
  Keys[Keys["AudioVolumeDown"] = 153] = "AudioVolumeDown";
  Keys[Keys["AudioVolumeMute"] = 154] = "AudioVolumeMute";
  Keys[Keys["AudioVolumeUp"] = 155] = "AudioVolumeUp";
  Keys[Keys["WakeUp"] = 156] = "WakeUp";
  Keys[Keys["Hyper"] = 157] = "Hyper";
  Keys[Keys["Super"] = 158] = "Super";
  Keys[Keys["Turbo"] = 159] = "Turbo";
  Keys[Keys["Abort"] = 160] = "Abort";
  Keys[Keys["Resume"] = 161] = "Resume";
  Keys[Keys["Suspend"] = 162] = "Suspend";
  Keys[Keys["Again"] = 163] = "Again";
  Keys[Keys["Copy"] = 164] = "Copy";
  Keys[Keys["Cut"] = 165] = "Cut";
  Keys[Keys["Find"] = 166] = "Find";
  Keys[Keys["Open"] = 167] = "Open";
  Keys[Keys["Paste"] = 168] = "Paste";
  Keys[Keys["Props"] = 169] = "Props";
  Keys[Keys["Select"] = 170] = "Select";
  Keys[Keys["Undo"] = 171] = "Undo";
  Keys[Keys["Hiragana"] = 172] = "Hiragana";
  Keys[Keys["Katakana"] = 173] = "Katakana";
  Keys[Keys["Unidentified"] = 174] = "Unidentified";
})(Keys || (Keys = {}));

/**
 * Keyboard Manager.
 * @internal
 */
var KeyboardManager = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * Create a KeyboardManager.
   */
  function KeyboardManager(htmlCanvas) {
    this._curHeldDownKeyToIndexMap = [];
    this._upKeyToFrameCountMap = [];
    this._downKeyToFrameCountMap = [];
    this._curFrameHeldDownList = new DisorderedArray();
    this._curFrameDownList = new DisorderedArray();
    this._curFrameUpList = new DisorderedArray();
    this._htmlCanvas = void 0;
    this._nativeEvents = [];
    this._hadListener = false;
    this._htmlCanvas = htmlCanvas;
    // Need to set tabIndex to make the canvas focus.
    htmlCanvas.tabIndex = htmlCanvas.tabIndex;
    this._onKeyEvent = this._onKeyEvent.bind(this);
    htmlCanvas.addEventListener("keydown", this._onKeyEvent);
    htmlCanvas.addEventListener("keyup", this._onKeyEvent);
    this._hadListener = true;
  }

  /**
   * @internal
   */
  var _proto = KeyboardManager.prototype;
  _proto._update = function _update(frameCount) {
    var nativeEvents = this._nativeEvents,
      curFrameDownList = this._curFrameDownList,
      curFrameUpList = this._curFrameUpList;
    curFrameDownList.length = 0;
    curFrameUpList.length = 0;
    if (nativeEvents.length > 0) {
      var curHeldDownKeyToIndexMap = this._curHeldDownKeyToIndexMap,
        curFrameHeldDownList = this._curFrameHeldDownList,
        downKeyToFrameCountMap = this._downKeyToFrameCountMap,
        upKeyToFrameCountMap = this._upKeyToFrameCountMap;
      for (var i = 0, n = nativeEvents.length; i < n; i++) {
        var evt = nativeEvents[i];
        var codeKey = Keys[evt.code];
        switch (evt.type) {
          case "keydown":
            // Filter the repeated triggers of the keyboard.
            if (curHeldDownKeyToIndexMap[codeKey] == null) {
              curFrameDownList.add(codeKey);
              curFrameHeldDownList.add(codeKey);
              curHeldDownKeyToIndexMap[codeKey] = curFrameHeldDownList.length - 1;
              downKeyToFrameCountMap[codeKey] = frameCount;
            }
            break;
          case "keyup":
            var delIndex = curHeldDownKeyToIndexMap[codeKey];
            if (delIndex != null) {
              curHeldDownKeyToIndexMap[codeKey] = null;
              var swapCode = curFrameHeldDownList.deleteByIndex(delIndex);
              swapCode && (curHeldDownKeyToIndexMap[swapCode] = delIndex);
            }
            curFrameUpList.add(codeKey);
            upKeyToFrameCountMap[codeKey] = frameCount;
            break;
        }
      }
      nativeEvents.length = 0;
    }
  }

  /**
   * @internal
   */;
  _proto._onFocus = function _onFocus() {
    if (!this._hadListener) {
      this._htmlCanvas.addEventListener("keydown", this._onKeyEvent);
      this._htmlCanvas.addEventListener("keyup", this._onKeyEvent);
      this._hadListener = true;
    }
  }

  /**
   * @internal
   */;
  _proto._onBlur = function _onBlur() {
    if (this._hadListener) {
      this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
      this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
      this._curHeldDownKeyToIndexMap.length = 0;
      this._curFrameHeldDownList.length = 0;
      this._curFrameDownList.length = 0;
      this._curFrameUpList.length = 0;
      this._nativeEvents.length = 0;
      this._hadListener = false;
    }
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    if (this._hadListener) {
      this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
      this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
      this._hadListener = false;
    }
    this._curHeldDownKeyToIndexMap = null;
    this._upKeyToFrameCountMap = null;
    this._downKeyToFrameCountMap = null;
    this._nativeEvents = null;
    this._curFrameHeldDownList = null;
    this._curFrameDownList = null;
    this._curFrameUpList = null;
  };
  _proto._onKeyEvent = function _onKeyEvent(evt) {
    evt.cancelable && evt.preventDefault();
    this._nativeEvents.push(evt);
  };
  return KeyboardManager;
}();

/**
 * Camera clear flags enumeration.
 */
var CameraClearFlags;
(function (CameraClearFlags) {
  CameraClearFlags[CameraClearFlags["None"] = 0] = "None";
  CameraClearFlags[CameraClearFlags["Color"] = 1] = "Color";
  CameraClearFlags[CameraClearFlags["Depth"] = 2] = "Depth";
  CameraClearFlags[CameraClearFlags["Stencil"] = 4] = "Stencil";
  CameraClearFlags[CameraClearFlags["ColorDepth"] = 3] = "ColorDepth";
  CameraClearFlags[CameraClearFlags["ColorStencil"] = 5] = "ColorStencil";
  CameraClearFlags[CameraClearFlags["DepthStencil"] = 6] = "DepthStencil";
  CameraClearFlags[CameraClearFlags["All"] = 7] = "All";
})(CameraClearFlags || (CameraClearFlags = {}));

/**
 * Structure used to get information back from a raycast or a sweep.
 */
var HitResult = function HitResult() {
  this.entity = null;
  this.distance = 0;
  this.point = new Vector3();
  this.normal = new Vector3();
};

/**
 * A physics manager is a collection of colliders and constraints which can interact.
 */
var PhysicsManager = /*#__PURE__*/function () {
  function PhysicsManager(engine) {
    var _this = this;
    this._initialized = false;
    this._engine = void 0;
    this._restTime = 0;
    this._colliders = new DisorderedArray();
    this._gravity = new Vector3(0, -9.81, 0);
    this._nativePhysicsManager = void 0;
    this._physicalObjectsMap = {};
    this._onContactEnter = function (obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onCollisionEnter(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var _i = 0, _len = scripts.length; _i < _len; _i++) {
        var _script = scripts.get(_i);
        _script._waitHandlingInValid || _script.onCollisionEnter(shape1);
      }
    };
    this._onContactExit = function (obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onCollisionExit(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var _i2 = 0, _len2 = scripts.length; _i2 < _len2; _i2++) {
        var _script2 = scripts.get(_i2);
        _script2._waitHandlingInValid || _script2.onCollisionExit(shape1);
      }
    };
    this._onContactStay = function (obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onCollisionStay(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var _i3 = 0, _len3 = scripts.length; _i3 < _len3; _i3++) {
        var _script3 = scripts.get(_i3);
        _script3._waitHandlingInValid || _script3.onCollisionStay(shape1);
      }
    };
    this._onTriggerEnter = function (obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onTriggerEnter(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var _i4 = 0, _len4 = scripts.length; _i4 < _len4; _i4++) {
        var _script4 = scripts.get(_i4);
        _script4._waitHandlingInValid || _script4.onTriggerEnter(shape1);
      }
    };
    this._onTriggerExit = function (obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, n = scripts.length; i < n; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onTriggerExit(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var _i5 = 0, _n = scripts.length; _i5 < _n; _i5++) {
        var _script5 = scripts.get(_i5);
        _script5._waitHandlingInValid || _script5.onTriggerExit(shape1);
      }
    };
    this._onTriggerStay = function (obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onTriggerStay(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var _i6 = 0, _len5 = scripts.length; _i6 < _len5; _i6++) {
        var _script6 = scripts.get(_i6);
        _script6._waitHandlingInValid || _script6.onTriggerStay(shape1);
      }
    };
    this.fixedTimeStep = 1 / 60;
    this.maxSumTimeStep = 1 / 3;
    this._engine = engine;
  }

  /**
   * initialize PhysicsManager.
   * @param physics - Physics Engine
   */
  var _proto = PhysicsManager.prototype;
  _proto.initialize = function initialize(physics) {
    if (this._initialized) {
      return;
    }
    PhysicsManager._nativePhysics = physics;
    this._nativePhysicsManager = PhysicsManager._nativePhysics.createPhysicsManager(this._onContactEnter, this._onContactExit, this._onContactStay, this._onTriggerEnter, this._onTriggerExit, this._onTriggerStay);
    this._initialized = true;
  }

  /**
   * Casts a ray through the Scene and returns the first hit.
   * @param ray - The ray
   * @returns Returns True if the ray intersects with a collider, otherwise false
   */;
  _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
    var _this2 = this;
    var hitResult;
    var distance = Number.MAX_VALUE;
    if (typeof distanceOrResult === "number") {
      distance = distanceOrResult;
    } else if (distanceOrResult != undefined) {
      hitResult = distanceOrResult;
    }
    var layerMask = Layer.Everything;
    if (typeof layerMaskOrResult === "number") {
      layerMask = layerMaskOrResult;
    } else if (layerMaskOrResult != undefined) {
      hitResult = layerMaskOrResult;
    }
    if (outHitResult) {
      hitResult = outHitResult;
    }
    if (hitResult != undefined) {
      var result = this._nativePhysicsManager.raycast(ray, distance, function (idx, distance, position, normal) {
        hitResult.entity = _this2._physicalObjectsMap[idx]._collider.entity;
        hitResult.distance = distance;
        hitResult.normal.copyFrom(normal);
        hitResult.point.copyFrom(position);
      });
      if (result) {
        if (hitResult.entity.layer & layerMask) {
          return true;
        } else {
          hitResult.entity = null;
          hitResult.distance = 0;
          hitResult.point.set(0, 0, 0);
          hitResult.normal.set(0, 0, 0);
          return false;
        }
      }
      return false;
    } else {
      return this._nativePhysicsManager.raycast(ray, distance);
    }
  }

  /**
   * Call on every frame to update pose of objects.
   * @internal
   */;
  _proto._update = function _update(deltaTime) {
    var fixedTimeStep = this.fixedTimeStep,
      nativePhysicsManager = this._nativePhysicsManager;
    var componentsManager = this._engine._componentsManager;
    var simulateTime = deltaTime + this._restTime;
    var step = Math.floor(Math.min(this.maxSumTimeStep, simulateTime) / fixedTimeStep);
    this._restTime = simulateTime - step * fixedTimeStep;
    for (var i = 0; i < step; i++) {
      componentsManager.callScriptOnPhysicsUpdate();
      this._callColliderOnUpdate();
      nativePhysicsManager.update(fixedTimeStep);
      this._callColliderOnLateUpdate();
    }
  }

  /**
   * Add ColliderShape into the manager.
   * @param colliderShape - The Collider Shape.
   * @internal
   */;
  _proto._addColliderShape = function _addColliderShape(colliderShape) {
    this._physicalObjectsMap[colliderShape.id] = colliderShape;
    this._nativePhysicsManager.addColliderShape(colliderShape._nativeShape);
  }

  /**
   * Remove ColliderShape.
   * @param colliderShape - The Collider Shape.
   * @internal
   */;
  _proto._removeColliderShape = function _removeColliderShape(colliderShape) {
    delete this._physicalObjectsMap[colliderShape.id];
    this._nativePhysicsManager.removeColliderShape(colliderShape._nativeShape);
  }

  /**
   * Add collider into the manager.
   * @param collider - StaticCollider or DynamicCollider.
   * @internal
   */;
  _proto._addCollider = function _addCollider(collider) {
    if (collider._index === -1) {
      collider._index = this._colliders.length;
      this._colliders.add(collider);
    }
    this._nativePhysicsManager.addCollider(collider._nativeCollider);
  }

  /**
   * Add character controller into the manager.
   * @param controller - Character Controller.
   * @internal
   */;
  _proto._addCharacterController = function _addCharacterController(controller) {
    if (controller._index === -1) {
      controller._index = this._colliders.length;
      this._colliders.add(controller);
    }
    this._nativePhysicsManager.addCharacterController(controller._nativeCollider);
  }

  /**
   * Remove collider.
   * @param collider - StaticCollider or DynamicCollider.
   * @internal
   */;
  _proto._removeCollider = function _removeCollider(collider) {
    var replaced = this._colliders.deleteByIndex(collider._index);
    replaced && (replaced._index = collider._index);
    collider._index = -1;
    this._nativePhysicsManager.removeCollider(collider._nativeCollider);
  }

  /**
   * Remove collider.
   * @param controller - Character Controller.
   * @internal
   */;
  _proto._removeCharacterController = function _removeCharacterController(controller) {
    var replaced = this._colliders.deleteByIndex(controller._index);
    replaced && (replaced._index = controller._index);
    controller._index = -1;
    this._nativePhysicsManager.removeCharacterController(controller._nativeCollider);
  }

  /**
   * @internal
   */;
  _proto._callColliderOnUpdate = function _callColliderOnUpdate() {
    var elements = this._colliders._elements;
    for (var i = this._colliders.length - 1; i >= 0; --i) {
      elements[i]._onUpdate();
    }
  }

  /**
   * @internal
   */;
  _proto._callColliderOnLateUpdate = function _callColliderOnLateUpdate() {
    var elements = this._colliders._elements;
    for (var i = this._colliders.length - 1; i >= 0; --i) {
      elements[i]._onLateUpdate();
    }
  };
  _createClass(PhysicsManager, [{
    key: "gravity",
    get: /** @internal */

    /** @internal */

    /** The fixed time step in seconds at which physics are performed. */

    /** The max sum of time step in seconds one frame. */

    /**
     * The gravity of physics scene.
     */
    function get() {
      return this._gravity;
    },
    set: function set(value) {
      var gravity = this._gravity;
      if (gravity !== value) {
        gravity.copyFrom(value);
      }
      this._nativePhysicsManager.setGravity(gravity);
    }
  }]);
  return PhysicsManager;
}();
PhysicsManager._nativePhysics = void 0;

/**
 * Describes how physics materials of the colliding objects are combined.
 */
var PhysicsMaterialCombineMode;
(function (PhysicsMaterialCombineMode) {
  PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Average"] = 0] = "Average";
  PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Minimum"] = 1] = "Minimum";
  PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Multiply"] = 2] = "Multiply";
  PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Maximum"] = 3] = "Maximum";
})(PhysicsMaterialCombineMode || (PhysicsMaterialCombineMode = {}));

/**
 * Material class to represent a set of surface properties.
 */
var PhysicsMaterial = /*#__PURE__*/function () {
  /** @internal */

  function PhysicsMaterial() {
    this._bounciness = 0.1;
    this._dynamicFriction = 0.1;
    this._staticFriction = 0.1;
    this._bounceCombine = PhysicsMaterialCombineMode.Average;
    this._frictionCombine = PhysicsMaterialCombineMode.Average;
    this._nativeMaterial = void 0;
    this._nativeMaterial = PhysicsManager._nativePhysics.createPhysicsMaterial(this._staticFriction, this._dynamicFriction, this._bounciness, this._bounceCombine, this._frictionCombine);
  }

  /**
   * The coefficient of bounciness.
   */
  var _proto = PhysicsMaterial.prototype;
  /**
   * @internal
   */
  _proto._destroy = function _destroy() {
    this._nativeMaterial.destroy();
  };
  _createClass(PhysicsMaterial, [{
    key: "bounciness",
    get: function get() {
      return this._bounciness;
    },
    set: function set(value) {
      this._bounciness = value;
      this._nativeMaterial.setBounciness(value);
    }

    /**
     * The DynamicFriction value.
     */
  }, {
    key: "dynamicFriction",
    get: function get() {
      return this._dynamicFriction;
    },
    set: function set(value) {
      this._dynamicFriction = value;
      this._nativeMaterial.setDynamicFriction(value);
    }

    /**
     * The coefficient of static friction.
     */
  }, {
    key: "staticFriction",
    get: function get() {
      return this._staticFriction;
    },
    set: function set(value) {
      this._staticFriction = value;
      this._nativeMaterial.setStaticFriction(value);
    }

    /**
     * The restitution combine mode.
     */
  }, {
    key: "bounceCombine",
    get: function get() {
      return this._bounceCombine;
    },
    set: function set(value) {
      this._bounceCombine = value;
      this._nativeMaterial.setBounceCombine(value);
    }

    /**
     * The friction combine mode.
     */
  }, {
    key: "frictionCombine",
    get: function get() {
      return this._frictionCombine;
    },
    set: function set(value) {
      this._frictionCombine = value;
      this._nativeMaterial.setFrictionCombine(value);
    }
  }]);
  return PhysicsMaterial;
}();

var _dec$5, _class$c, _class2$a, _descriptor$9;
/**
 * Base class for all colliders.
 * @decorator `@dependentComponents(Transform)`
 */
var Collider = (_dec$5 = dependentComponents(Transform), _dec$5(_class$c = (_class2$a = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Collider, _Component);
  /**
   * @internal
   */
  function Collider(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _initializerDefineProperty(_this, "_index", _descriptor$9, _assertThisInitialized(_this));
    _this._nativeCollider = void 0;
    _this._updateFlag = void 0;
    _this._shapes = [];
    _this._updateFlag = _this.entity.transform.registerWorldChangeFlag();
    return _this;
  }

  /**
   * Add collider shape on this collider.
   * @param shape - Collider shape
   */
  var _proto = Collider.prototype;
  _proto.addShape = function addShape(shape) {
    var oldCollider = shape._collider;
    if (oldCollider !== this) {
      if (oldCollider) {
        oldCollider.removeShape(shape);
      }
      this._shapes.push(shape);
      this.engine.physicsManager._addColliderShape(shape);
      shape._collider = this;
      this._nativeCollider.addShape(shape._nativeShape);
    }
  }

  /**
   * Remove a collider shape.
   * @param shape - The collider shape.
   */;
  _proto.removeShape = function removeShape(shape) {
    var index = this._shapes.indexOf(shape);
    if (index !== -1) {
      this._shapes.splice(index, 1);
      this.engine.physicsManager._removeColliderShape(shape);
      shape._collider = null;
      this._nativeCollider.removeShape(shape._nativeShape);
    }
  }

  /**
   * Remove all shape attached.
   */;
  _proto.clearShapes = function clearShapes() {
    var shapes = this._shapes;
    for (var i = 0, n = shapes.length; i < n; i++) {
      var shape = shapes[i];
      this.engine.physicsManager._removeColliderShape(shape);
      shape._destroy();
      this._nativeCollider.removeShape(shape._nativeShape);
    }
    shapes.length = 0;
  }

  /**
   * @internal
   */;
  _proto._onUpdate = function _onUpdate() {
    if (this._updateFlag.flag) {
      var transform = this.entity.transform;
      this._nativeCollider.setWorldTransform(transform.worldPosition, transform.worldRotationQuaternion);
      var worldScale = transform.lossyWorldScale;
      for (var i = 0, n = this.shapes.length; i < n; i++) {
        this.shapes[i]._nativeShape.setWorldScale(worldScale);
      }
      this._updateFlag.flag = false;
    }
  }

  /**
   * @internal
   */;
  _proto._onLateUpdate = function _onLateUpdate() {}

  /**
   * @override
   * @internal
   */;
  _proto._onEnable = function _onEnable() {
    this.engine.physicsManager._addCollider(this);
  }

  /**
   * @override
   * @internal
   */;
  _proto._onDisable = function _onDisable() {
    this.engine.physicsManager._removeCollider(this);
  }

  /**
   * @override
   * @internal
   */;
  _proto._onDestroy = function _onDestroy() {
    this.clearShapes();
    this._nativeCollider.destroy();
  };
  _createClass(Collider, [{
    key: "shapes",
    get: /** @internal */

    /** @internal */

    /**
     * The shapes of this collider.
     */
    function get() {
      return this._shapes;
    }
  }]);
  return Collider;
}(Component), (_descriptor$9 = _applyDecoratedDescriptor(_class2$a.prototype, "_index", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
})), _class2$a)) || _class$c);

/**
 * The up axis of the collider shape.
 */
var ControllerNonWalkableMode;
(function (ControllerNonWalkableMode) {
  ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbing"] = 0] = "PreventClimbing";
  ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbingAndForceSliding"] = 1] = "PreventClimbingAndForceSliding";
})(ControllerNonWalkableMode || (ControllerNonWalkableMode = {}));

/**
 * The character controllers.
 */
var CharacterController = /*#__PURE__*/function (_Collider) {
  _inheritsLoose(CharacterController, _Collider);
  /**
   * @internal
   */
  function CharacterController(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this._index = -1;
    _this._stepOffset = 0;
    _this._nonWalkableMode = ControllerNonWalkableMode.PreventClimbing;
    _this._upDirection = new Vector3(0, 1, 0);
    _this._slopeLimit = 0;
    _this._nativeCollider = PhysicsManager._nativePhysics.createCharacterController();
    return _this;
  }

  /**
   * Moves the character using a "collide-and-slide" algorithm.
   * @param disp - Displacement vector
   * @param minDist - The minimum travelled distance to consider.
   * @param elapsedTime - Time elapsed since last call
   * @return flags - The ControllerCollisionFlag
   */
  var _proto = CharacterController.prototype;
  _proto.move = function move(disp, minDist, elapsedTime) {
    return this._nativeCollider.move(disp, minDist, elapsedTime);
  }

  /**
   * Add collider shape on this controller.
   * @param shape - Collider shape
   * @override
   */;
  _proto.addShape = function addShape(shape) {
    if (this._shapes.length > 0) {
      throw "only allow single shape on controller!";
    }
    _Collider.prototype.addShape.call(this, shape);
    this._updateFlag.flag = true;
  }

  /**
   * Remove all shape attached.
   * @override
   */;
  _proto.clearShapes = function clearShapes() {
    if (this._shapes.length > 0) {
      _Collider.prototype.removeShape.call(this, this._shapes[0]);
    }
  }

  /**
   * @internal
   * @override
   */;
  _proto._onUpdate = function _onUpdate() {
    if (this._updateFlag.flag) {
      var transform = this.entity.transform;
      var shapes = this.shapes;
      this._nativeCollider.setWorldPosition(transform.worldPosition);
      var worldScale = transform.lossyWorldScale;
      for (var i = 0, n = shapes.length; i < n; i++) {
        shapes[i]._nativeShape.setWorldScale(worldScale);
      }
      this._updateFlag.flag = false;
    }
  }

  /**
   * @internal
   * @override
   */;
  _proto._onLateUpdate = function _onLateUpdate() {
    var position = this.entity.transform.worldPosition;
    this._nativeCollider.getWorldPosition(position);
    this.entity.transform.worldPosition = position;
    this._updateFlag.flag = false;
  }

  /**
   * @override
   * @internal
   */;
  _proto._onEnable = function _onEnable() {
    this.engine.physicsManager._addCharacterController(this);
  }

  /**
   * @override
   * @internal
   */;
  _proto._onDisable = function _onDisable() {
    this.engine.physicsManager._removeCharacterController(this);
  };
  _createClass(CharacterController, [{
    key: "stepOffset",
    get: /** @internal */

    /**
     * The step offset for the controller.
     */
    function get() {
      return this._stepOffset;
    },
    set: function set(value) {
      this._stepOffset = value;
      this._nativeCollider.setStepOffset(value);
    }

    /**
     * The value of the non-walkable mode.
     */
  }, {
    key: "nonWalkableMode",
    get: function get() {
      return this._nonWalkableMode;
    },
    set: function set(value) {
      this._nonWalkableMode = value;
      this._nativeCollider.setNonWalkableMode(value);
    }

    /**
     * The up direction for the controller.
     */
  }, {
    key: "upDirection",
    get: function get() {
      return this._upDirection;
    },
    set: function set(value) {
      if (this._upDirection !== value) {
        this._upDirection.copyFrom(value);
      }
      this._nativeCollider.setUpDirection(this._upDirection);
    }

    /**
     * The slope limit for the controller.
     */
  }, {
    key: "slopeLimit",
    get: function get() {
      return this._slopeLimit;
    },
    set: function set(value) {
      this._slopeLimit = value;
      this._nativeCollider.setSlopeLimit(value);
    }
  }]);
  return CharacterController;
}(Collider);

/**
 * Abstract class for collider shapes.
 */
var ColliderShape = /*#__PURE__*/function () {
  function ColliderShape() {
    this._collider = void 0;
    this._nativeShape = void 0;
    this._id = void 0;
    this._position = new Vector3();
    this._material = void 0;
    this._isTrigger = false;
    this._isSceneQuery = true;
    this._contactOffset = 0;
    this._material = new PhysicsMaterial();
    this._id = ColliderShape._idGenerator++;
  }

  /**
   * Set local position of collider shape
   * @param x - The x component of the vector, default 0
   * @param y - The y component of the vector, default 0
   * @param z - The z component of the vector, default 0
   */
  var _proto = ColliderShape.prototype;
  _proto.setPosition = function setPosition(x, y, z) {
    this._position.set(x, y, z);
    this._nativeShape.setPosition(this._position);
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    this._material._destroy();
    this._nativeShape.destroy();
  };
  _createClass(ColliderShape, [{
    key: "collider",
    get: /** @internal */

    /** @internal */

    /**
     * Collider owner of this shape.
     */
    function get() {
      return this._collider;
    }

    /**
     * Unique id for this shape.
     */
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }

    /**
     * Contact offset for this shape.
     */
  }, {
    key: "contactOffset",
    get: function get() {
      return this._contactOffset;
    },
    set: function set(value) {
      this._contactOffset = value;
      this._nativeShape.setContactOffset(value);
    }

    /**
     * Physical material.
     */
  }, {
    key: "material",
    get: function get() {
      return this._material;
    },
    set: function set(value) {
      this._material = value;
      this._nativeShape.setMaterial(value._nativeMaterial);
    }

    /**
     * The local position of this ColliderShape.
     */
  }, {
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      if (this._position !== value) {
        this._position.copyFrom(value);
      }
      this._nativeShape.setPosition(value);
    }

    /**
     * True for TriggerShape, false for SimulationShape.
     */
  }, {
    key: "isTrigger",
    get: function get() {
      return this._isTrigger;
    },
    set: function set(value) {
      this._isTrigger = value;
      this._nativeShape.setIsTrigger(value);
    }
  }]);
  return ColliderShape;
}();
ColliderShape._idGenerator = 0;

/**
 * Physical collider shape for box.
 */
var BoxColliderShape = /*#__PURE__*/function (_ColliderShape) {
  _inheritsLoose(BoxColliderShape, _ColliderShape);
  function BoxColliderShape() {
    var _this;
    _this = _ColliderShape.call(this) || this;
    _this._size = new Vector3(1, 1, 1);
    _this._nativeShape = PhysicsManager._nativePhysics.createBoxColliderShape(_this._id, _this._size, _this._material._nativeMaterial);
    return _this;
  }

  /**
   * Set size of box.
   * @param x - Size of x-axis
   * @param y - Size of y-axis
   * @param z - Size of z-axis
   */
  var _proto = BoxColliderShape.prototype;
  _proto.setSize = function setSize(x, y, z) {
    this._size.x = x;
    this._size.y = y;
    this._size.z = z;
    this._nativeShape.setSize(this._size);
  };
  _createClass(BoxColliderShape, [{
    key: "size",
    get:
    /**
     * Size of box shape.
     */
    function get() {
      return this._size;
    },
    set: function set(value) {
      if (this._size != value) {
        this._size.copyFrom(value);
      }
      this._nativeShape.setSize(value);
    }
  }]);
  return BoxColliderShape;
}(ColliderShape);

/**
 * Physical collider shape for sphere.
 */
var SphereColliderShape = /*#__PURE__*/function (_ColliderShape) {
  _inheritsLoose(SphereColliderShape, _ColliderShape);
  function SphereColliderShape() {
    var _this;
    _this = _ColliderShape.call(this) || this;
    _this._radius = 1;
    _this._nativeShape = PhysicsManager._nativePhysics.createSphereColliderShape(_this._id, _this._radius, _this._material._nativeMaterial);
    return _this;
  }
  _createClass(SphereColliderShape, [{
    key: "radius",
    get:
    /**
     * Radius of sphere shape.
     */
    function get() {
      return this._radius;
    },
    set: function set(value) {
      this._radius = value;
      this._nativeShape.setRadius(value);
    }
  }]);
  return SphereColliderShape;
}(ColliderShape);

/**
 * Physical collider shape plane.
 */
var PlaneColliderShape = /*#__PURE__*/function (_ColliderShape) {
  _inheritsLoose(PlaneColliderShape, _ColliderShape);
  function PlaneColliderShape() {
    var _this;
    _this = _ColliderShape.call(this) || this;
    _this._rotation = new Vector3();
    _this._nativeShape = PhysicsManager._nativePhysics.createPlaneColliderShape(_this._id, _this._material._nativeMaterial);
    return _this;
  }

  /**
   * Set the local rotation of this plane.
   * @param x - Radian of yaw
   * @param y - Radian of pitch
   * @param z - Radian of roll
   */
  var _proto = PlaneColliderShape.prototype;
  _proto.setRotation = function setRotation(x, y, z) {
    this._rotation.set(x, y, z);
    this._nativeShape.setRotation(this._rotation);
  };
  _createClass(PlaneColliderShape, [{
    key: "rotation",
    get:
    /**
     * The local rotation of this plane.
     */
    function get() {
      return this._rotation;
    },
    set: function set(value) {
      if (this._rotation != value) {
        this._rotation.copyFrom(value);
      }
      this._nativeShape.setRotation(value);
    }
  }]);
  return PlaneColliderShape;
}(ColliderShape);

/**
 * The up axis of the collider shape.
 */
var ColliderShapeUpAxis;
(function (ColliderShapeUpAxis) {
  ColliderShapeUpAxis[ColliderShapeUpAxis["X"] = 0] = "X";
  ColliderShapeUpAxis[ColliderShapeUpAxis["Y"] = 1] = "Y";
  ColliderShapeUpAxis[ColliderShapeUpAxis["Z"] = 2] = "Z";
})(ColliderShapeUpAxis || (ColliderShapeUpAxis = {}));

/**
 * Physical collider shape for capsule.
 */
var CapsuleColliderShape = /*#__PURE__*/function (_ColliderShape) {
  _inheritsLoose(CapsuleColliderShape, _ColliderShape);
  function CapsuleColliderShape() {
    var _this;
    _this = _ColliderShape.call(this) || this;
    _this._radius = 1;
    _this._height = 2;
    _this._upAxis = ColliderShapeUpAxis.Y;
    _this._nativeShape = PhysicsManager._nativePhysics.createCapsuleColliderShape(_this._id, _this._radius, _this._height, _this._material._nativeMaterial);
    _this._nativeShape.setUpAxis(ColliderShapeUpAxis.Y);
    return _this;
  }
  _createClass(CapsuleColliderShape, [{
    key: "radius",
    get:
    /**
     * Radius of capsule.
     */
    function get() {
      return this._radius;
    },
    set: function set(value) {
      this._radius = value;
      this._nativeShape.setRadius(value);
    }

    /**
     * Height of capsule.
     */
  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(value) {
      this._height = value;
      this._nativeShape.setHeight(value);
    }

    /**
     * Up axis of capsule.
     */
  }, {
    key: "upAxis",
    get: function get() {
      return this._upAxis;
    },
    set: function set(value) {
      this._upAxis = value;
      this._nativeShape.setUpAxis(value);
    }
  }]);
  return CapsuleColliderShape;
}(ColliderShape);

var _dec$4, _class$b;
/**
 * A base class providing common functionality for joints.
 * @decorator `@dependentComponents(Collider)`
 */
var Joint = (_dec$4 = dependentComponents(Collider), _dec$4(_class$b = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Joint, _Component);
  function Joint(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._connectedCollider = new JointCollider();
    _this._collider = new JointCollider();
    _this._nativeJoint = void 0;
    _this._force = 0;
    _this._torque = 0;
    _this._connectedCollider.localPosition = new Vector3();
    return _this;
  }
  _createClass(Joint, [{
    key: "connectedCollider",
    get:
    /**
     * The connected collider.
     */
    function get() {
      return this._connectedCollider.collider;
    },
    set: function set(value) {
      if (this._connectedCollider.collider !== value) {
        this._connectedCollider.collider = value;
        this._nativeJoint.setConnectedCollider(value._nativeCollider);
      }
    }

    /**
     * The connected anchor position.
     * @remarks If connectedCollider is set, this anchor is relative offset, or the anchor is world position.
     */
  }, {
    key: "connectedAnchor",
    get: function get() {
      return this._connectedCollider.localPosition;
    },
    set: function set(value) {
      var connectedAnchor = this._connectedCollider.localPosition;
      if (value !== connectedAnchor) {
        connectedAnchor.copyFrom(value);
      }
      this._nativeJoint.setConnectedAnchor(value);
    }

    /**
     *  The scale to apply to the inverse mass of collider 0 for resolving this constraint.
     */
  }, {
    key: "connectedMassScale",
    get: function get() {
      return this._connectedCollider.massScale;
    },
    set: function set(value) {
      if (value !== this._connectedCollider.massScale) {
        this._connectedCollider.massScale = value;
        this._nativeJoint.setConnectedMassScale(value);
      }
    }

    /**
     * The scale to apply to the inverse inertia of collider0 for resolving this constraint.
     */
  }, {
    key: "connectedInertiaScale",
    get: function get() {
      return this._connectedCollider.inertiaScale;
    },
    set: function set(value) {
      if (value !== this._connectedCollider.inertiaScale) {
        this._connectedCollider.inertiaScale = value;
        this._nativeJoint.setConnectedInertiaScale(value);
      }
    }

    /**
     * The scale to apply to the inverse mass of collider 1 for resolving this constraint.
     */
  }, {
    key: "massScale",
    get: function get() {
      return this._collider.massScale;
    },
    set: function set(value) {
      if (value !== this._collider.massScale) {
        this._collider.massScale = value;
        this._nativeJoint.setMassScale(value);
      }
    }

    /**
     * The scale to apply to the inverse inertia of collider1 for resolving this constraint.
     */
  }, {
    key: "inertiaScale",
    get: function get() {
      return this._collider.inertiaScale;
    },
    set: function set(value) {
      if (value !== this._collider.inertiaScale) {
        this._collider.inertiaScale = value;
        this._nativeJoint.setInertiaScale(value);
      }
    }

    /**
     * The maximum force the joint can apply before breaking.
     */
  }, {
    key: "breakForce",
    get: function get() {
      return this._force;
    },
    set: function set(value) {
      if (value !== this._force) {
        this._force = value;
        this._nativeJoint.setBreakForce(value);
      }
    }

    /**
     * The maximum torque the joint can apply before breaking.
     */
  }, {
    key: "breakTorque",
    get: function get() {
      return this._torque;
    },
    set: function set(value) {
      if (value !== this._torque) {
        this._torque = value;
        this._nativeJoint.setBreakTorque(value);
      }
    }
  }]);
  return Joint;
}(Component)) || _class$b);

/**
 * @internal
 */
var JointCollider = function JointCollider() {
  this.collider = null;
  this.localPosition = void 0;
  this.localRotation = void 0;
  this.massScale = 0;
  this.inertiaScale = 0;
};

/*
 * A fixed joint permits no relative movement between two colliders. ie the colliders are glued together.
 */
var FixedJoint = /*#__PURE__*/function (_Joint) {
  _inheritsLoose(FixedJoint, _Joint);
  function FixedJoint() {
    return _Joint.apply(this, arguments) || this;
  }
  var _proto = FixedJoint.prototype;
  /**
   * @override
   * @internal
   */
  _proto._onAwake = function _onAwake() {
    var collider = this._collider;
    collider.collider = this.entity.getComponent(Collider);
    this._nativeJoint = PhysicsManager._nativePhysics.createFixedJoint(collider.collider._nativeCollider);
  };
  return FixedJoint;
}(Joint);

/**
 * Flags specific to the Hinge Joint.
 * @internal
 */
var HingeJointFlag;
(function (HingeJointFlag) {
  HingeJointFlag[HingeJointFlag["LimitEnabled"] = 1] = "LimitEnabled";
  HingeJointFlag[HingeJointFlag["DriveEnabled"] = 2] = "DriveEnabled";
  HingeJointFlag[HingeJointFlag["DriveFreeSpin"] = 4] = "DriveFreeSpin";
})(HingeJointFlag || (HingeJointFlag = {}));

/**
 * A joint which behaves in a similar way to a hinge or axle.
 */
var HingeJoint = /*#__PURE__*/function (_Joint) {
  _inheritsLoose(HingeJoint, _Joint);
  function HingeJoint() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Joint.call.apply(_Joint, [this].concat(args)) || this;
    _this._axis = new Vector3(1, 0, 0);
    _this._hingeFlags = 0;
    _this._useSpring = false;
    _this._jointMonitor = void 0;
    _this._limits = void 0;
    return _this;
  }
  var _proto = HingeJoint.prototype;
  /**
   * @override
   * @internal
   */
  _proto._onAwake = function _onAwake() {
    var collider = this._collider;
    collider.localPosition = new Vector3();
    collider.collider = this.entity.getComponent(Collider);
    this._nativeJoint = PhysicsManager._nativePhysics.createHingeJoint(collider.collider._nativeCollider);
  };
  _createClass(HingeJoint, [{
    key: "axis",
    get:
    /**
     * The anchor rotation.
     */
    function get() {
      return this._axis;
    },
    set: function set(value) {
      var axis = this._axis;
      if (value !== axis) {
        axis.copyFrom(value);
      }
      this._nativeJoint.setAxis(axis);
    }

    /**
     * The swing offset.
     */
  }, {
    key: "swingOffset",
    get: function get() {
      return this._collider.localPosition;
    },
    set: function set(value) {
      var swingOffset = this._collider.localPosition;
      if (value !== swingOffset) {
        swingOffset.copyFrom(value);
      }
      this._nativeJoint.setSwingOffset(swingOffset);
    }

    /**
     * The current angle in degrees of the joint relative to its rest position.
     */
  }, {
    key: "angle",
    get: function get() {
      return this._nativeJoint.getAngle();
    }

    /**
     * The angular velocity of the joint in degrees per second.
     */
  }, {
    key: "velocity",
    get: function get() {
      return this._nativeJoint.getVelocity();
    }

    /**
     * Enables the joint's limits. Disabled by default.
     */
  }, {
    key: "useLimits",
    get: function get() {
      return (this._hingeFlags & HingeJointFlag.LimitEnabled) == HingeJointFlag.LimitEnabled;
    },
    set: function set(value) {
      if (value !== this.useLimits) {
        this._hingeFlags |= HingeJointFlag.LimitEnabled;
      }
      this._nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled, value);
    }

    /**
     * Enables the joint's motor. Disabled by default.
     */
  }, {
    key: "useMotor",
    get: function get() {
      return (this._hingeFlags & HingeJointFlag.DriveEnabled) == HingeJointFlag.DriveEnabled;
    },
    set: function set(value) {
      if (value !== this.useMotor) {
        this._hingeFlags |= HingeJointFlag.DriveEnabled;
      }
      this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled, value);
    }

    /**
     * Enables the joint's spring. Disabled by default.
     */
  }, {
    key: "useSpring",
    get: function get() {
      return this._useSpring;
    },
    set: function set(value) {
      this._useSpring = value;
      this.limits = this._limits;
    }

    /**
     * The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.
     */
  }, {
    key: "motor",
    get: function get() {
      return this._jointMonitor;
    },
    set: function set(value) {
      this._jointMonitor = value;
      this._nativeJoint.setDriveVelocity(value.targetVelocity);
      this._nativeJoint.setDriveForceLimit(value.forceLimit);
      this._nativeJoint.setDriveGearRatio(value.gearRation);
      this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin, value.freeSpin);
    }

    /**
     * Limit of angular rotation (in degrees) on the hinge joint.
     */
  }, {
    key: "limits",
    get: function get() {
      return this._limits;
    },
    set: function set(value) {
      this._limits = value;
      if (this.useSpring) {
        this._nativeJoint.setSoftLimit(value.min, value.max, value.stiffness, value.damping);
      } else {
        this._nativeJoint.setHardLimit(value.min, value.max, value.contactDistance);
      }
    }
  }]);
  return HingeJoint;
}(Joint);

/**
 * A joint that maintains an upper or lower bound (or both) on the distance between two points on different objects.
 */
var SpringJoint = /*#__PURE__*/function (_Joint) {
  _inheritsLoose(SpringJoint, _Joint);
  function SpringJoint() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Joint.call.apply(_Joint, [this].concat(args)) || this;
    _this._minDistance = 0;
    _this._maxDistance = 0;
    _this._tolerance = 0.25;
    _this._stiffness = 0;
    _this._damping = 0;
    return _this;
  }
  var _proto = SpringJoint.prototype;
  /**
   * @override
   * @internal
   */
  _proto._onAwake = function _onAwake() {
    var collider = this._collider;
    collider.localPosition = new Vector3();
    collider.collider = this.entity.getComponent(Collider);
    this._nativeJoint = PhysicsManager._nativePhysics.createSpringJoint(collider.collider._nativeCollider);
  };
  _createClass(SpringJoint, [{
    key: "swingOffset",
    get:
    /**
     * The swing offset.
     */
    function get() {
      return this._collider.localPosition;
    },
    set: function set(value) {
      var swingOffset = this._collider.localPosition;
      if (value !== swingOffset) {
        swingOffset.copyFrom(value);
      }
      this._nativeJoint.setSwingOffset(value);
    }

    /**
     * The minimum distance.
     */
  }, {
    key: "minDistance",
    get: function get() {
      return this._minDistance;
    },
    set: function set(value) {
      this._minDistance = value;
      this._nativeJoint.setMinDistance(value);
    }

    /**
     * The maximum distance.
     */
  }, {
    key: "maxDistance",
    get: function get() {
      return this._maxDistance;
    },
    set: function set(value) {
      this._maxDistance = value;
      this._nativeJoint.setMaxDistance(value);
    }

    /**
     * The distance beyond the allowed range at which the joint becomes active.
     */
  }, {
    key: "tolerance",
    get: function get() {
      return this._tolerance;
    },
    set: function set(value) {
      this._tolerance = value;
      this._nativeJoint.setTolerance(value);
    }

    /**
     * The spring strength of the joint.
     */
  }, {
    key: "stiffness",
    get: function get() {
      return this._stiffness;
    },
    set: function set(value) {
      this._stiffness = value;
      this._nativeJoint.setStiffness(value);
    }

    /**
     * The degree of damping of the joint spring of the joint.
     */
  }, {
    key: "damping",
    get: function get() {
      return this._damping;
    },
    set: function set(value) {
      this._damping = value;
      this._nativeJoint.setDamping(value);
    }
  }]);
  return SpringJoint;
}(Joint);

/**
 * JointLimits is used to limit the joints angle.
 */
var JointLimits = function JointLimits() {
  this.max = 0;
  this.min = 0;
  this.contactDistance = -1;
  this.stiffness = 0;
  this.damping = 0;
};

/**
 * The JointMotor is used to motorize a joint.
 */
var JointMotor = function JointMotor() {
  this.targetVelocity = 0;
  this.forceLimit = Number.MAX_VALUE;
  this.gearRation = 1.0;
  this.freeSpin = false;
};

/**
 * The up axis of the collider shape.
 */
var ControllerCollisionFlag;
(function (ControllerCollisionFlag) {
  ControllerCollisionFlag[ControllerCollisionFlag["Sides"] = 1] = "Sides";
  ControllerCollisionFlag[ControllerCollisionFlag["Up"] = 2] = "Up";
  ControllerCollisionFlag[ControllerCollisionFlag["Down"] = 4] = "Down";
})(ControllerCollisionFlag || (ControllerCollisionFlag = {}));

/**
 * A static collider component that will not move.
 * @remarks Mostly used for object which always stays at the same place and never moves around.
 */
var StaticCollider = /*#__PURE__*/function (_Collider) {
  _inheritsLoose(StaticCollider, _Collider);
  /**
   * @internal
   */
  function StaticCollider(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    var transform = _this.entity.transform;
    _this._nativeCollider = PhysicsManager._nativePhysics.createStaticCollider(transform.worldPosition, transform.worldRotationQuaternion);
    return _this;
  }
  return StaticCollider;
}(Collider);

/**
 * A dynamic collider can act with self-defined movement or physical force.
 */
var DynamicCollider = /*#__PURE__*/function (_Collider) {
  _inheritsLoose(DynamicCollider, _Collider);
  /**
   * @internal
   */
  function DynamicCollider(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this._linearDamping = 0;
    _this._angularDamping = 0;
    _this._linearVelocity = new Vector3();
    _this._angularVelocity = new Vector3();
    _this._mass = 0;
    _this._centerOfMass = new Vector3();
    _this._inertiaTensor = new Vector3();
    _this._maxAngularVelocity = 0;
    _this._maxDepenetrationVelocity = 0;
    _this._sleepThreshold = 0;
    _this._solverIterations = 0;
    _this._isKinematic = false;
    _this._constraints = 0;
    _this._collisionDetectionMode = CollisionDetectionMode.Discrete;
    var transform = _this.entity.transform;
    _this._nativeCollider = PhysicsManager._nativePhysics.createDynamicCollider(transform.worldPosition, transform.worldRotationQuaternion);
    return _this;
  }

  /**
   * Apply a force to the DynamicCollider.
   * @param force - The force make the collider move
   */
  var _proto = DynamicCollider.prototype;
  _proto.applyForce = function applyForce(force) {
    this._nativeCollider.addForce(force);
  }

  /**
   * Apply a torque to the DynamicCollider.
   * @param torque - The force make the collider rotate
   */;
  _proto.applyTorque = function applyTorque(torque) {
    this._nativeCollider.addTorque(torque);
  }

  /**
   * Moves kinematically controlled dynamic actors through the game world.
   * @param position - The desired position for the kinematic actor
   */;
  _proto.move = function move(positionOrRotation, rotation) {
    this._nativeCollider.move(positionOrRotation, rotation);
  }

  /**
   * Forces a collider to sleep at least one frame.
   */;
  _proto.sleep = function sleep() {
    this._nativeCollider.sleep();
  }

  /**
   * Forces a collider to wake up.
   */;
  _proto.wakeUp = function wakeUp() {
    this._nativeCollider.wakeUp();
  }

  /**
   * @override
   * @internal
   */;
  _proto._onLateUpdate = function _onLateUpdate() {
    var transform = this.entity.transform;
    var worldPosition = transform.worldPosition,
      worldRotationQuaternion = transform.worldRotationQuaternion;
    this._nativeCollider.getWorldTransform(worldPosition, worldRotationQuaternion);
    this._updateFlag.flag = false;
  };
  _createClass(DynamicCollider, [{
    key: "linearDamping",
    get:
    /**
     * The linear damping of the dynamic collider.
     */
    function get() {
      return this._linearDamping;
    },
    set: function set(value) {
      this._linearDamping = value;
      this._nativeCollider.setLinearDamping(value);
    }

    /**
     * The angular damping of the dynamic collider.
     */
  }, {
    key: "angularDamping",
    get: function get() {
      return this._angularDamping;
    },
    set: function set(value) {
      this._angularDamping = value;
      this._nativeCollider.setAngularDamping(value);
    }

    /**
     * The linear velocity vector of the dynamic collider measured in world unit per second.
     */
  }, {
    key: "linearVelocity",
    get: function get() {
      return this._linearVelocity;
    },
    set: function set(value) {
      if (this._linearVelocity !== value) {
        this._linearVelocity.copyFrom(value);
      }
      this._nativeCollider.setLinearVelocity(this._linearVelocity);
    }

    /**
     * The angular velocity vector of the dynamic collider measured in radians per second.
     */
  }, {
    key: "angularVelocity",
    get: function get() {
      return this._angularVelocity;
    },
    set: function set(value) {
      if (this._angularVelocity !== value) {
        this._angularVelocity.copyFrom(value);
      }
      this._nativeCollider.setAngularVelocity(this._angularVelocity);
    }

    /**
     * The mass of the dynamic collider.
     */
  }, {
    key: "mass",
    get: function get() {
      return this._mass;
    },
    set: function set(value) {
      this._mass = value;
      this._nativeCollider.setMass(value);
    }

    /**
     * The center of mass relative to the transform's origin.
     */
  }, {
    key: "centerOfMass",
    get: function get() {
      return this._centerOfMass;
    },
    set: function set(value) {
      if (this._centerOfMass !== value) {
        this._centerOfMass.copyFrom(value);
      }
      this._nativeCollider.setCenterOfMass(this._centerOfMass);
    }

    /**
     * The diagonal inertia tensor of mass relative to the center of mass.
     */
  }, {
    key: "inertiaTensor",
    get: function get() {
      return this._inertiaTensor;
    },
    set: function set(value) {
      if (this._inertiaTensor !== value) {
        this._inertiaTensor.copyFrom(value);
      }
      this._nativeCollider.setInertiaTensor(this._inertiaTensor);
    }

    /**
     * The maximum angular velocity of the collider measured in radians per second. (Default 7) range { 0, infinity }.
     */
  }, {
    key: "maxAngularVelocity",
    get: function get() {
      return this._maxAngularVelocity;
    },
    set: function set(value) {
      this._maxAngularVelocity = value;
      this._nativeCollider.setMaxAngularVelocity(value);
    }

    /**
     * Maximum velocity of a collider when moving out of penetrating state.
     */
  }, {
    key: "maxDepenetrationVelocity",
    get: function get() {
      return this._maxDepenetrationVelocity;
    },
    set: function set(value) {
      this._maxDepenetrationVelocity = value;
      this._nativeCollider.setMaxDepenetrationVelocity(value);
    }

    /**
     * The mass-normalized energy threshold, below which objects start going to sleep.
     */
  }, {
    key: "sleepThreshold",
    get: function get() {
      return this._sleepThreshold;
    },
    set: function set(value) {
      this._sleepThreshold = value;
      this._nativeCollider.setSleepThreshold(value);
    }

    /**
     * The solverIterations determines how accurately collider joints and collision contacts are resolved.
     */
  }, {
    key: "solverIterations",
    get: function get() {
      return this._solverIterations;
    },
    set: function set(value) {
      this._solverIterations = value;
      this._nativeCollider.setSolverIterations(value);
    }

    /**
     * Controls whether physics affects the dynamic collider.
     */
  }, {
    key: "isKinematic",
    get: function get() {
      return this._isKinematic;
    },
    set: function set(value) {
      this._isKinematic = value;
      this._nativeCollider.setIsKinematic(value);
    }

    /**
     * The particular rigid dynamic lock flag.
     */
  }, {
    key: "constraints",
    get: function get() {
      return this._constraints;
    },
    set: function set(value) {
      this._constraints = value;
      this._nativeCollider.setConstraints(value);
    }

    /**
     * The colliders' collision detection mode.
     */
  }, {
    key: "collisionDetectionMode",
    get: function get() {
      return this._collisionDetectionMode;
    },
    set: function set(value) {
      this._collisionDetectionMode = value;
      this._nativeCollider.setCollisionDetectionMode(value);
    }
  }]);
  return DynamicCollider;
}(Collider);

/**
 * The collision detection mode constants.
 */
var CollisionDetectionMode;

/**
 * Use these flags to constrain motion of dynamic collider.
 */
(function (CollisionDetectionMode) {
  CollisionDetectionMode[CollisionDetectionMode["Discrete"] = 0] = "Discrete";
  CollisionDetectionMode[CollisionDetectionMode["Continuous"] = 1] = "Continuous";
  CollisionDetectionMode[CollisionDetectionMode["ContinuousDynamic"] = 2] = "ContinuousDynamic";
  CollisionDetectionMode[CollisionDetectionMode["ContinuousSpeculative"] = 3] = "ContinuousSpeculative";
})(CollisionDetectionMode || (CollisionDetectionMode = {}));
var DynamicColliderConstraints;
(function (DynamicColliderConstraints) {
  DynamicColliderConstraints[DynamicColliderConstraints["None"] = 0] = "None";
  DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionX"] = 1] = "FreezePositionX";
  DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionY"] = 2] = "FreezePositionY";
  DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionZ"] = 4] = "FreezePositionZ";
  DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationX"] = 8] = "FreezeRotationX";
  DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationY"] = 16] = "FreezeRotationY";
  DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationZ"] = 32] = "FreezeRotationZ";
})(DynamicColliderConstraints || (DynamicColliderConstraints = {}));

/**
 *  The current phase of the pointer.
 */
var PointerPhase;
(function (PointerPhase) {
  PointerPhase[PointerPhase["Down"] = 0] = "Down";
  PointerPhase[PointerPhase["Move"] = 1] = "Move";
  PointerPhase[PointerPhase["Up"] = 2] = "Up";
  PointerPhase[PointerPhase["Leave"] = 3] = "Leave";
})(PointerPhase || (PointerPhase = {}));

/**
 * Defines values that specify the buttons on a pointer device.
 * Refer to the W3C standards.(https://www.w3.org/TR/uievents/#dom-mouseevent-button)
 * Refer to Microsoft's documentation.(https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mousebutton?view=windowsdesktop-6.0)
 */
var PointerButton;
(function (PointerButton) {
  PointerButton[PointerButton["Primary"] = 0] = "Primary";
  PointerButton[PointerButton["Auxiliary"] = 1] = "Auxiliary";
  PointerButton[PointerButton["Secondary"] = 2] = "Secondary";
  PointerButton[PointerButton["XButton1"] = 3] = "XButton1";
  PointerButton[PointerButton["XButton2"] = 4] = "XButton2";
  PointerButton[PointerButton["XButton3"] = 5] = "XButton3";
  PointerButton[PointerButton["XButton4"] = 6] = "XButton4";
  PointerButton[PointerButton["XButton5"] = 7] = "XButton5";
  PointerButton[PointerButton["XButton6"] = 8] = "XButton6";
  PointerButton[PointerButton["XButton7"] = 9] = "XButton7";
  PointerButton[PointerButton["XButton8"] = 10] = "XButton8";
})(PointerButton || (PointerButton = {}));

/**
 * Pointer.
 */
var Pointer =
/**
 * Unique id.
 * @remarks Start from 0.
 */

/** The phase of pointer. */

/** The position of the pointer in screen space pixel coordinates. */

/** @internal */

/**
 * @internal
 */
function Pointer(id) {
  this.id = void 0;
  this.phase = PointerPhase.Leave;
  this.position = new Vector2();
  this._uniqueID = void 0;
  this.id = id;
};

/**
 * Pointer Manager.
 * @internal
 */
var PointerManager = /*#__PURE__*/function () {
  /** Refer to the W3C standards.(https://www.w3.org/TR/uievents/#dom-mouseevent-buttons) */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * Create a PointerManager.
   * @param engine - The current engine instance
   * @param htmlCanvas - HTMLCanvasElement
   */
  function PointerManager(engine, htmlCanvas) {
    this._pointers = [];
    this._movingDelta = new Vector2();
    this._multiPointerEnabled = true;
    this._buttons = 0x0;
    this._upMap = [];
    this._downMap = [];
    this._downList = new DisorderedArray();
    this._upList = new DisorderedArray();
    this._currentPosition = new Vector2();
    this._currentPressedEntity = void 0;
    this._currentEnteredEntity = void 0;
    this._engine = void 0;
    this._canvas = void 0;
    this._htmlCanvas = void 0;
    this._nativeEvents = [];
    this._pointerPool = void 0;
    this._keyEventList = [];
    this._keyEventCount = 0;
    this._needOverallPointers = false;
    this._hadListener = false;
    this._lastPositionFrameCount = 0;
    this._engine = engine;
    this._canvas = engine.canvas;
    this._htmlCanvas = htmlCanvas;
    htmlCanvas.oncontextmenu = function (event) {
      return false;
    };
    var onPointerEvent = this._onPointerEvent = this._onPointerEvent.bind(this);
    htmlCanvas.addEventListener("pointerdown", onPointerEvent);
    htmlCanvas.addEventListener("pointerup", onPointerEvent);
    htmlCanvas.addEventListener("pointerout", onPointerEvent);
    htmlCanvas.addEventListener("pointermove", onPointerEvent);
    this._hadListener = true;
    // If there are no compatibility issues, navigator.maxTouchPoints should be used here.
    this._pointerPool = new Array(11);
  }

  /**
   * @internal
   */
  var _proto = PointerManager.prototype;
  _proto._update = function _update(frameCount) {
    this._needOverallPointers && this._overallPointers();
    this._downList.length = 0;
    this._upList.length = 0;
    this._movingDelta.set(0, 0);
    this._nativeEvents.length > 0 && this._handlePointerEvent(this._nativeEvents, frameCount);
    this._pointers.length > 0 && (this._lastPositionFrameCount = frameCount);
    if (this._engine.physicsManager._initialized) {
      var rayCastEntity = this._pointerRayCast();
      var keyEventCount = this._keyEventCount;
      if (keyEventCount > 0) {
        var keyEventList = this._keyEventList;
        for (var i = 0; i < keyEventCount; i++) {
          switch (keyEventList[i]) {
            case PointerKeyEvent.Down:
              this._firePointerDown(rayCastEntity);
              break;
            case PointerKeyEvent.Up:
              this._firePointerUpAndClick(rayCastEntity);
              break;
          }
        }
        this._firePointerExitAndEnter(rayCastEntity);
        keyEventList[keyEventCount - 1] === PointerKeyEvent.Leave && (this._currentPressedEntity = null);
        this._keyEventCount = 0;
      } else {
        this._firePointerDrag();
        this._firePointerExitAndEnter(rayCastEntity);
      }
    }
  }

  /**
   * @internal
   */;
  _proto._onFocus = function _onFocus() {
    if (!this._hadListener) {
      var htmlCanvas = this._htmlCanvas,
        onPointerEvent = this._onPointerEvent;
      htmlCanvas.addEventListener("pointerdown", onPointerEvent);
      htmlCanvas.addEventListener("pointerup", onPointerEvent);
      htmlCanvas.addEventListener("pointerout", onPointerEvent);
      htmlCanvas.addEventListener("pointermove", onPointerEvent);
      this._hadListener = true;
    }
  }

  /**
   * @internal
   */;
  _proto._onBlur = function _onBlur() {
    if (this._hadListener) {
      var htmlCanvas = this._htmlCanvas,
        onPointerEvent = this._onPointerEvent;
      htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
      htmlCanvas.removeEventListener("pointerup", onPointerEvent);
      htmlCanvas.removeEventListener("pointerout", onPointerEvent);
      htmlCanvas.removeEventListener("pointermove", onPointerEvent);
      this._nativeEvents.length = 0;
      this._pointerPool.length = 0;
      this._currentEnteredEntity = null;
      this._currentPressedEntity = null;
      this._downList.length = 0;
      this._upList.length = 0;
      this._hadListener = false;
    }
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    // @ts-ignore
    if (this._hadListener) {
      var htmlCanvas = this._htmlCanvas,
        onPointerEvent = this._onPointerEvent;
      htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
      htmlCanvas.removeEventListener("pointerup", onPointerEvent);
      htmlCanvas.removeEventListener("pointerout", onPointerEvent);
      htmlCanvas.removeEventListener("pointermove", onPointerEvent);
      this._hadListener = false;
    }
    this._nativeEvents.length = 0;
    this._pointerPool.length = 0;
    this._pointers.length = 0;
    this._currentPosition = null;
    this._currentEnteredEntity = null;
    this._currentPressedEntity = null;
    this._engine = null;
    this._canvas = null;
  };
  _proto._onPointerEvent = function _onPointerEvent(evt) {
    evt.cancelable && evt.preventDefault();
    evt.type === "pointerdown" && this._htmlCanvas.focus();
    this._nativeEvents.push(evt);
  };
  _proto._overallPointers = function _overallPointers() {
    var pointers = this._pointers;
    var deleteCount = 0;
    var totalCount = pointers.length;
    for (var i = 0; i < totalCount; i++) {
      if (pointers[i].phase === PointerPhase.Leave) {
        deleteCount++;
      } else {
        if (deleteCount > 0) {
          pointers[i - deleteCount] = pointers[i];
        }
      }
    }
    pointers.length = totalCount - deleteCount;
    this._needOverallPointers = false;
  };
  _proto._getIndexByPointerID = function _getIndexByPointerID(pointerId) {
    var pointers = this._pointers;
    for (var i = pointers.length - 1; i >= 0; i--) {
      if (pointers[i]._uniqueID === pointerId) {
        return i;
      }
    }
    return -1;
  };
  _proto._addPointer = function _addPointer(pointerId, x, y, phase) {
    var pointers = this._pointers;
    var lastCount = pointers.length;
    if (lastCount === 0 || this._multiPointerEnabled) {
      var pointerPool = this._pointerPool;
      // Get Pointer smallest index.
      var i = 0;
      for (; i < lastCount; i++) {
        if (pointers[i].id > i) {
          break;
        }
      }
      var pointer = pointerPool[i];
      if (!pointer) {
        pointer = pointerPool[i] = new Pointer(i);
      }
      pointer._uniqueID = pointerId;
      pointer.position.set(x, y);
      pointer.phase = phase;
      pointers.splice(i, 0, pointer);
    }
  };
  _proto._removePointer = function _removePointer(pointerIndex) {
    var leavePointer = this._pointers[pointerIndex];
    leavePointer.phase = PointerPhase.Leave;
  };
  _proto._updatePointer = function _updatePointer(pointerIndex, x, y, phase) {
    var updatedPointer = this._pointers[pointerIndex];
    updatedPointer.position.set(x, y);
    updatedPointer.phase = phase;
  };
  _proto._handlePointerEvent = function _handlePointerEvent(nativeEvents, frameCount) {
    var pointers = this._pointers,
      keyEventList = this._keyEventList,
      upMap = this._upMap,
      downMap = this._downMap,
      upList = this._upList,
      downList = this._downList;
    var activePointerCount = pointers.length;
    var pixelRatioW = this._canvas.width / this._htmlCanvas.clientWidth;
    var pixelRatioH = this._canvas.height / this._htmlCanvas.clientHeight;
    var nativeEventsLen = nativeEvents.length;
    for (var i = 0; i < nativeEventsLen; i++) {
      var evt = nativeEvents[i];
      var pointerButton = evt.button | PointerButton.Primary;
      var pointerIndex = this._getIndexByPointerID(evt.pointerId);
      switch (evt.type) {
        case "pointerdown":
          if (pointerIndex === -1) {
            this._addPointer(evt.pointerId, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, PointerPhase.Down);
            activePointerCount++;
          } else {
            this._updatePointer(pointerIndex, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, PointerPhase.Down);
          }
          activePointerCount === 1 && (keyEventList[this._keyEventCount++] = PointerKeyEvent.Down);
          downList.add(pointerButton);
          downMap[pointerButton] = frameCount;
          break;
        case "pointerup":
          if (pointerIndex >= 0) {
            this._updatePointer(pointerIndex, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, PointerPhase.Up);
            activePointerCount === 1 && (keyEventList[this._keyEventCount++] = PointerKeyEvent.Up);
          }
          upList.add(pointerButton);
          upMap[pointerButton] = frameCount;
          break;
        case "pointermove":
          if (pointerIndex === -1) {
            this._addPointer(evt.pointerId, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, PointerPhase.Move);
            activePointerCount++;
          } else {
            this._updatePointer(pointerIndex, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, PointerPhase.Move);
          }
          break;
        case "pointerout":
          if (pointerIndex >= 0) {
            this._removePointer(pointerIndex);
            --activePointerCount === 0 && (keyEventList[this._keyEventCount++] = PointerKeyEvent.Leave);
            this._needOverallPointers = true;
          }
          break;
      }
    }
    this._buttons = nativeEvents[nativeEventsLen - 1].buttons;
    var pointerCount = pointers.length;
    if (pointerCount > 0) {
      var currentPosition = this._currentPosition;
      var lastX = currentPosition.x,
        lastY = currentPosition.y;
      if (activePointerCount === 0) {
        // Get the pointer coordinates when leaving, and use it to correctly dispatch the click event.
        var lastNativeEvent = nativeEvents[nativeEventsLen - 1];
        currentPosition.set(lastNativeEvent.offsetX * pixelRatioW, lastNativeEvent.offsetY * pixelRatioH);
      } else {
        currentPosition.set(0, 0);
        for (var _i = 0; _i < pointerCount; _i++) {
          currentPosition.add(pointers[_i].position);
        }
        currentPosition.scale(1 / pointerCount);
      }
      // Update pointer moving delta.
      if (this._lastPositionFrameCount === frameCount - 1) {
        this._movingDelta.set(currentPosition.x - lastX, currentPosition.y - lastY);
      }
    }
    nativeEvents.length = 0;
  };
  _proto._pointerRayCast = function _pointerRayCast() {
    if (this._pointers.length > 0) {
      var point = PointerManager._tempPoint,
        ray = PointerManager._tempRay,
        hitResult = PointerManager._tempHitResult;
      var cameras = this._engine.sceneManager.activeScene._activeCameras;
      var x = this._currentPosition.x / this._canvas.width;
      var y = this._currentPosition.y / this._canvas.height;
      for (var i = cameras.length - 1; i >= 0; i--) {
        var camera = cameras[i];
        if (!camera.enabled || camera.renderTarget) {
          continue;
        }
        var _camera$viewport = camera.viewport,
          vpX = _camera$viewport.x,
          vpY = _camera$viewport.y,
          vpW = _camera$viewport.z,
          vpH = _camera$viewport.w;
        if (x >= vpX && y >= vpY && x - vpX <= vpW && y - vpY <= vpH) {
          point.set((x - vpX) / vpW, (y - vpY) / vpH);
          // TODO: Only check which colliders have listened to the input.
          if (this._engine.physicsManager.raycast(camera.viewportPointToRay(point, ray), Number.MAX_VALUE, camera.cullingMask, hitResult)) {
            return hitResult.entity;
          } else if (camera.clearFlags & CameraClearFlags.Color) {
            return null;
          }
        }
      }
    }
    return null;
  };
  _proto._firePointerDrag = function _firePointerDrag() {
    if (this._currentPressedEntity) {
      var scripts = this._currentPressedEntity._scripts;
      for (var i = scripts.length - 1; i >= 0; i--) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onPointerDrag();
      }
    }
  };
  _proto._firePointerExitAndEnter = function _firePointerExitAndEnter(rayCastEntity) {
    if (this._currentEnteredEntity !== rayCastEntity) {
      if (this._currentEnteredEntity) {
        var scripts = this._currentEnteredEntity._scripts;
        for (var i = scripts.length - 1; i >= 0; i--) {
          var script = scripts.get(i);
          script._waitHandlingInValid || script.onPointerExit();
        }
      }
      if (rayCastEntity) {
        var _scripts = rayCastEntity._scripts;
        for (var _i2 = _scripts.length - 1; _i2 >= 0; _i2--) {
          var _script = _scripts.get(_i2);
          _script._waitHandlingInValid || _script.onPointerEnter();
        }
      }
      this._currentEnteredEntity = rayCastEntity;
    }
  };
  _proto._firePointerDown = function _firePointerDown(rayCastEntity) {
    if (rayCastEntity) {
      var scripts = rayCastEntity._scripts;
      for (var i = scripts.length - 1; i >= 0; i--) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onPointerDown();
      }
    }
    this._currentPressedEntity = rayCastEntity;
  };
  _proto._firePointerUpAndClick = function _firePointerUpAndClick(rayCastEntity) {
    var pressedEntity = this._currentPressedEntity;
    if (pressedEntity) {
      var sameTarget = pressedEntity === rayCastEntity;
      var scripts = pressedEntity._scripts;
      for (var i = scripts.length - 1; i >= 0; i--) {
        var script = scripts.get(i);
        if (!script._waitHandlingInValid) {
          sameTarget && script.onPointerClick();
          script.onPointerUp();
        }
      }
      this._currentPressedEntity = null;
    }
  };
  return PointerManager;
}();

/**
 * @internal
 */
PointerManager.Buttons = [0x1, 0x4, 0x2, 0x8, 0x10, 0x20, 0x40, 0x80, 0x100, 0x200, 0x400];
PointerManager._tempRay = new Ray();
PointerManager._tempPoint = new Vector2();
PointerManager._tempHitResult = new HitResult();
var PointerKeyEvent;
(function (PointerKeyEvent) {
  PointerKeyEvent[PointerKeyEvent["Down"] = 0] = "Down";
  PointerKeyEvent[PointerKeyEvent["Up"] = 1] = "Up";
  PointerKeyEvent[PointerKeyEvent["Leave"] = 2] = "Leave";
})(PointerKeyEvent || (PointerKeyEvent = {}));

/**
 * Wheel Manager.
 * @internal
 */
var WheelManager = /*#__PURE__*/function () {
  /** @internal */

  /**
   * Create a KeyboardManager.
   */
  function WheelManager(htmlCanvas) {
    this._delta = new Vector3();
    this._nativeEvents = [];
    this._canvas = void 0;
    this._hadListener = void 0;
    this._onWheelEvent = this._onWheelEvent.bind(this);
    htmlCanvas.addEventListener("wheel", this._onWheelEvent);
    this._canvas = htmlCanvas;
    this._hadListener = true;
  }

  /**
   * @internal
   */
  var _proto = WheelManager.prototype;
  _proto._update = function _update() {
    var delta = this._delta;
    delta.set(0, 0, 0);
    var nativeEvents = this._nativeEvents;
    if (nativeEvents.length > 0) {
      for (var i = nativeEvents.length - 1; i >= 0; i--) {
        var evt = nativeEvents[i];
        delta.x += evt.deltaX;
        delta.y += evt.deltaY;
        delta.z += evt.deltaZ;
      }
      nativeEvents.length = 0;
    }
  }

  /**
   * @internal
   */;
  _proto._onFocus = function _onFocus() {
    if (!this._hadListener) {
      this._canvas.addEventListener("wheel", this._onWheelEvent);
      this._hadListener = true;
    }
  }

  /**
   * @internal
   */;
  _proto._onBlur = function _onBlur() {
    if (this._hadListener) {
      this._canvas.removeEventListener("wheel", this._onWheelEvent);
      this._nativeEvents.length = 0;
      this._delta.set(0, 0, 0);
      this._hadListener = false;
    }
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    if (this._hadListener) {
      this._canvas.removeEventListener("wheel", this._onWheelEvent);
      this._hadListener = false;
    }
    this._nativeEvents = null;
  };
  _proto._onWheelEvent = function _onWheelEvent(evt) {
    evt.cancelable && evt.preventDefault();
    this._nativeEvents.push(evt);
  };
  return WheelManager;
}();

/**
 * InputManager manages device input such as mouse, touch, keyboard, etc.
 */
var InputManager = /*#__PURE__*/function () {
  var _proto = InputManager.prototype;
  /**
   * Whether the key is being held down, if there is no parameter, return whether any key is being held down.
   * @param key - The keys of the keyboard
   * @returns Whether the key is being held down
   */
  _proto.isKeyHeldDown = function isKeyHeldDown(key) {
    if (this._initialized) {
      if (key === undefined) {
        return this._keyboardManager._curFrameHeldDownList.length > 0;
      } else {
        return this._keyboardManager._curHeldDownKeyToIndexMap[key] != null;
      }
    } else {
      return false;
    }
  }

  /**
   * Whether the key starts to be pressed down during the current frame, if there is no parameter, return whether any key starts to be pressed down during the current frame.
   * @param key - The keys of the keyboard
   * @returns Whether the key starts to be pressed down during the current frame
   */;
  _proto.isKeyDown = function isKeyDown(key) {
    if (this._initialized) {
      if (key === undefined) {
        return this._keyboardManager._curFrameDownList.length > 0;
      } else {
        return this._keyboardManager._downKeyToFrameCountMap[key] === this._curFrameCount;
      }
    } else {
      return false;
    }
  }

  /**
   * Whether the key is released during the current frame, if there is no parameter, return whether any key released during the current frame.
   * @param key - The keys of the keyboard
   * @returns Whether the key is released during the current frame
   */;
  _proto.isKeyUp = function isKeyUp(key) {
    if (this._initialized) {
      if (key === undefined) {
        return this._keyboardManager._curFrameUpList.length > 0;
      } else {
        return this._keyboardManager._upKeyToFrameCountMap[key] === this._curFrameCount;
      }
    } else {
      return false;
    }
  }

  /**
   * Whether the pointer is being held down, if there is no parameter, return whether any pointer is being held down.
   * @param pointerButton - The pointerButton on a pointer device
   * @returns Whether the pointer is being held down
   */;
  _proto.isPointerHeldDown = function isPointerHeldDown(pointerButton) {
    if (this._initialized) {
      if (pointerButton === undefined) {
        return this._pointerManager._buttons !== 0;
      } else {
        return (this._pointerManager._buttons & PointerManager.Buttons[pointerButton]) !== 0;
      }
    } else {
      return false;
    }
  }

  /**
   * Whether the pointer starts to be pressed down during the current frame, if there is no parameter, return whether any pointer starts to be pressed down during the current frame.
   * @param pointerButton - The pointerButton on a pointer device
   * @returns Whether the pointer starts to be pressed down during the current frame
   */;
  _proto.isPointerDown = function isPointerDown(pointerButton) {
    if (this._initialized) {
      if (pointerButton === undefined) {
        return this._pointerManager._downList.length > 0;
      } else {
        return this._pointerManager._downMap[pointerButton] === this._curFrameCount;
      }
    } else {
      return false;
    }
  }

  /**
   * Whether the pointer is released during the current frame, if there is no parameter, return whether any pointer released during the current frame.
   * @param pointerButton - The pointerButtons on a mouse device
   * @returns Whether the pointer is released during the current frame
   */;
  _proto.isPointerUp = function isPointerUp(pointerButton) {
    if (this._initialized) {
      if (pointerButton === undefined) {
        return this._pointerManager._upList.length > 0;
      } else {
        return this._pointerManager._upMap[pointerButton] === this._curFrameCount;
      }
    } else {
      return false;
    }
  }

  /**
   * @internal
   */;
  function InputManager(engine) {
    this._initialized = false;
    this._curFrameCount = 0;
    this._wheelManager = void 0;
    this._pointerManager = void 0;
    this._keyboardManager = void 0;
    // @ts-ignore
    var canvas = engine._canvas._webCanvas;
    if (typeof OffscreenCanvas === "undefined" || !(canvas instanceof OffscreenCanvas)) {
      this._wheelManager = new WheelManager(canvas);
      this._pointerManager = new PointerManager(engine, canvas);
      this._keyboardManager = new KeyboardManager(canvas);
      this._onBlur = this._onBlur.bind(this);
      window.addEventListener("blur", this._onBlur);
      this._onFocus = this._onFocus.bind(this);
      window.addEventListener("focus", this._onFocus);
      this._initialized = true;
    }
  }

  /**
   * @internal
   */
  _proto._update = function _update() {
    if (this._initialized) {
      ++this._curFrameCount;
      this._wheelManager._update();
      this._pointerManager._update(this._curFrameCount);
      this._keyboardManager._update(this._curFrameCount);
    }
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    if (this._initialized) {
      window.removeEventListener("blur", this._onBlur);
      window.removeEventListener("focus", this._onFocus);
      this._wheelManager._destroy();
      this._pointerManager._destroy();
      this._keyboardManager._destroy();
    }
  };
  _proto._onBlur = function _onBlur() {
    this._wheelManager._onBlur();
    this._pointerManager._onBlur();
    this._keyboardManager._onBlur();
  };
  _proto._onFocus = function _onFocus() {
    this._wheelManager._onFocus();
    this._pointerManager._onFocus();
    this._keyboardManager._onFocus();
  };
  _createClass(InputManager, [{
    key: "pointers",
    get: /** Sometimes the input module will not be initialized, such as off-screen rendering. */

    /**
     * Pointer List.
     */
    function get() {
      return this._initialized ? this._pointerManager._pointers : null;
    }

    /**
     *  Whether to handle multi-pointer.
     */
  }, {
    key: "multiPointerEnabled",
    get: function get() {
      return this._initialized ? this._pointerManager._multiPointerEnabled : false;
    },
    set: function set(enabled) {
      this._initialized && (this._pointerManager._multiPointerEnabled = enabled);
    }

    /**
     * Get the change of the scroll wheel on the x-axis.
     * @returns Change value
     */
  }, {
    key: "wheelDelta",
    get: function get() {
      return this._initialized ? this._wheelManager._delta : null;
    }

    /**
     * Get the change of the pointer.
     * @returns Change value
     */
  }, {
    key: "pointerMovingDelta",
    get: function get() {
      return this._initialized ? this._pointerManager._movingDelta : null;
    }

    /**
     * Get the position of the pointer.
     * @returns The position of the pointer
     */
  }, {
    key: "pointerPosition",
    get: function get() {
      return this._initialized && this._pointerManager._pointers.length > 0 ? this._pointerManager._currentPosition : null;
    }
  }]);
  return InputManager;
}();

/**
 * Render queue type.
 */
var RenderQueueType;
(function (RenderQueueType) {
  RenderQueueType[RenderQueueType["Opaque"] = 0] = "Opaque";
  RenderQueueType[RenderQueueType["AlphaTest"] = 1] = "AlphaTest";
  RenderQueueType[RenderQueueType["Transparent"] = 2] = "Transparent";
})(RenderQueueType || (RenderQueueType = {}));

/**
 * The base class of assets, with reference counting capability.
 */
var RefObject = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(RefObject, _EngineObject);
  function RefObject(engine) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.isGCIgnored = false;
    _this._refCount = 0;
    engine.resourceManager._addRefObject(_this.instanceId, _assertThisInitialized(_this));
    return _this;
  }

  /**
   * Destroy self.
   * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
   * @returns Whether the release was successful.
   */
  var _proto = RefObject.prototype;
  _proto.destroy = function destroy(force) {
    if (force === void 0) {
      force = false;
    }
    if (this._destroyed) return true;
    if (!force && this._refCount !== 0) return false;
    var resourceManager = this._engine.resourceManager;
    // resourceManager maybe null,because engine has destroyed.
    // TODO:the right way to fix this is to ensure destroy all when call engine.destroy,thus don't need to add this project.
    if (resourceManager) {
      _EngineObject.prototype.destroy.call(this);
      resourceManager._deleteRefObject(this.instanceId);
    }
    var refCount = this._getRefCount();
    if (refCount > 0) {
      this._addRefCount(-refCount);
    }
    this._engine = null;
    this._onDestroy();
    return true;
  }

  /**
   * @internal
   */;
  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  }

  /**
   * @internal
   */;
  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
  }

  /**
   * @internal
   */;
  _proto._addToResourceManager = function _addToResourceManager(path) {
    this._engine.resourceManager._addAsset(path, this);
  }

  /**
   * Called when the resource is destroyed.
   * Subclasses can override this function.
   */;
  _createClass(RefObject, [{
    key: "refCount",
    get: /** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */

    /**
     * Counted by valid references.
     */
    function get() {
      return this._refCount;
    }
  }]);
  return RefObject;
}(EngineObject);

/**
 * Shader data grouping.
 */
var ShaderDataGroup;
(function (ShaderDataGroup) {
  ShaderDataGroup[ShaderDataGroup["Scene"] = 0] = "Scene";
  ShaderDataGroup[ShaderDataGroup["Camera"] = 1] = "Camera";
  ShaderDataGroup[ShaderDataGroup["Renderer"] = 2] = "Renderer";
  ShaderDataGroup[ShaderDataGroup["Material"] = 3] = "Material";
})(ShaderDataGroup || (ShaderDataGroup = {}));

/**
 * The base class of texture, contains some common functions of texture-related classes.
 */
var Texture = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Texture, _RefObject);
  function Texture() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RefObject.call.apply(_RefObject, [this].concat(args)) || this;
    _this.name = void 0;
    _this._platformTexture = void 0;
    _this._mipmap = void 0;
    _this._format = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._mipmapCount = void 0;
    _this._wrapModeU = void 0;
    _this._wrapModeV = void 0;
    _this._filterMode = void 0;
    _this._anisoLevel = 1;
    return _this;
  }
  var _proto = Texture.prototype;
  /**
   * Generate multi-level textures based on the 0th level data.
   */
  _proto.generateMipmaps = function generateMipmaps() {
    if (!this._mipmap) return;
    this._platformTexture.generateMipmaps();
  }

  /**
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {
    this._platformTexture.destroy();
    this._platformTexture = null;
  }

  /**
   * Get the maximum mip level of the corresponding size:rounding down.
   * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
   */;
  _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
    return Math.floor(Math.log2(size));
  };
  _proto._getMipmapCount = function _getMipmapCount() {
    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
  };
  _createClass(Texture, [{
    key: "format",
    get:
    /**
     * Texture format.
     */
    function get() {
      return this._format;
    }

    /**
     * The width of the texture.
     */
  }, {
    key: "width",
    get: function get() {
      return this._width;
    }

    /**
     * The height of the texture.
     */
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }

    /**
     * Wrapping mode for texture coordinate S.
     */
  }, {
    key: "wrapModeU",
    get: function get() {
      return this._wrapModeU;
    },
    set: function set(value) {
      if (value === this._wrapModeU) return;
      this._wrapModeU = value;
      this._platformTexture.wrapModeU = value;
    }

    /**
     * Wrapping mode for texture coordinate T.
     */
  }, {
    key: "wrapModeV",
    get: function get() {
      return this._wrapModeV;
    },
    set: function set(value) {
      if (value === this._wrapModeV) return;
      this._wrapModeV = value;
      this._platformTexture.wrapModeV = value;
    }

    /**
     * Texture mipmapping count.
     */
  }, {
    key: "mipmapCount",
    get: function get() {
      return this._mipmapCount;
    }

    /**
     * Filter mode for texture.
     */
  }, {
    key: "filterMode",
    get: function get() {
      return this._filterMode;
    },
    set: function set(value) {
      if (value === this._filterMode) return;
      this._filterMode = value;
      this._platformTexture.filterMode = value;
    }

    /**
     * Anisotropic level for texture.
     */
  }, {
    key: "anisoLevel",
    get: function get() {
      return this._anisoLevel;
    },
    set: function set(value) {
      var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;
      if (value > max) {
        Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
        value = max;
      }
      if (value < 1) {
        Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
        value = 1;
      }
      if (value === this._anisoLevel) return;
      this._anisoLevel = value;
      this._platformTexture.anisoLevel = value;
    }
  }]);
  return Texture;
}(RefObject);

/**
 * Shader Property type.
 */
var ShaderPropertyType;
(function (ShaderPropertyType) {
  ShaderPropertyType[ShaderPropertyType["Float"] = 0] = "Float";
  ShaderPropertyType[ShaderPropertyType["Int"] = 1] = "Int";
  ShaderPropertyType[ShaderPropertyType["Vector2"] = 2] = "Vector2";
  ShaderPropertyType[ShaderPropertyType["Vector3"] = 3] = "Vector3";
  ShaderPropertyType[ShaderPropertyType["Vector4"] = 4] = "Vector4";
  ShaderPropertyType[ShaderPropertyType["Matrix"] = 5] = "Matrix";
  ShaderPropertyType[ShaderPropertyType["Color"] = 6] = "Color";
  ShaderPropertyType[ShaderPropertyType["Texture"] = 7] = "Texture";
  ShaderPropertyType[ShaderPropertyType["FloatArray"] = 8] = "FloatArray";
  ShaderPropertyType[ShaderPropertyType["IntArray"] = 9] = "IntArray";
  ShaderPropertyType[ShaderPropertyType["TextureArray"] = 10] = "TextureArray";
})(ShaderPropertyType || (ShaderPropertyType = {}));

var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2(float x){return x*x;}vec4 RGBMToLinear(vec4 value,float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 gammaToLinear(vec4 srgbIn){return vec4(pow(srgbIn.rgb,vec3(2.2)),srgbIn.a);}vec4 linearToGamma(vec4 linearIn){return vec4(pow(linearIn.rgb,vec3(1.0/2.2)),linearIn.a);}"; // eslint-disable-line

var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_UV1\nattribute vec2 TEXCOORD_1;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;uniform vec4 u_tilingOffset;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n"; // eslint-disable-line

var common_frag = "#define GLSLIFY 1\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;"; // eslint-disable-line

var color_share = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n"; // eslint-disable-line

var normal_share = "#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nvarying vec3 v_normal;\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvarying mat3 v_TBN;\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;\n#ifdef O3_HAS_UV1\nvarying vec2 v_uv1;\n#endif\n"; // eslint-disable-line

var worldpos_share = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvarying vec3 v_pos;\n#endif\n"; // eslint-disable-line

var shadow_share = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n"; // eslint-disable-line

var fog_share = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform float u_fogDensity;\n#else\nuniform float u_fogNear;uniform float u_fogFar;\n#endif\n#endif\n"; // eslint-disable-line

var begin_normal_vert = "#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#endif\n#ifdef O3_HAS_TANGENT\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n"; // eslint-disable-line

var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);"; // eslint-disable-line

var position_vert = "#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n"; // eslint-disable-line

var color_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n"; // eslint-disable-line

var normal_vert = "#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nv_normal=normalize(mat3(u_normalMat)*normal);\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var skinning_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var blendShape_input = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nuniform mediump sampler2DArray u_blendShapeTexture;uniform ivec3 u_blendShapeTextureInfo;uniform float u_blendShapeWeights[OASIS_BLENDSHAPE_COUNT];\n#else\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;attribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#if defined( OASIS_BLENDSHAPE_NORMAL ) || defined( OASIS_BLENDSHAPE_TANGENT )\n#ifdef OASIS_BLENDSHAPE_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef OASIS_BLENDSHAPE_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\nuniform float u_blendShapeWeights[4];\n#else\nattribute vec3 POSITION_BS4;attribute vec3 POSITION_BS5;attribute vec3 POSITION_BS6;attribute vec3 POSITION_BS7;uniform float u_blendShapeWeights[8];\n#endif\n#endif\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nvec3 getBlendShapeVertexElement(int blendShapeIndex,int vertexElementIndex){int y=vertexElementIndex/u_blendShapeTextureInfo.y;int x=vertexElementIndex-y*u_blendShapeTextureInfo.y;ivec3 uv=ivec3(x,y,blendShapeIndex);return texelFetch(u_blendShapeTexture,uv,0).xyz;}\n#endif\n#endif\n"; // eslint-disable-line

var blendShape_vert = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nint vertexOffset=gl_VertexID*u_blendShapeTextureInfo.x;for(int i=0;i<OASIS_BLENDSHAPE_COUNT;i++){int vertexElementOffset=vertexOffset;float weight=u_blendShapeWeights[i];position.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#ifndef OMIT_NORMAL\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nvertexElementOffset+=1;normal+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#if defined( O3_HAS_TANGENT ) && defined(OASIS_BLENDSHAPE_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvertexElementOffset+=1;tangent.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#endif\n}\n#else\nposition.xyz+=POSITION_BS0*u_blendShapeWeights[0];position.xyz+=POSITION_BS1*u_blendShapeWeights[1];position.xyz+=POSITION_BS2*u_blendShapeWeights[2];position.xyz+=POSITION_BS3*u_blendShapeWeights[3];\n#if defined( OASIS_BLENDSHAPE_NORMAL ) || defined( OASIS_BLENDSHAPE_TANGENT )\n#ifndef OMIT_NORMAL\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nnormal+=NORMAL_BS0*u_blendShapeWeights[0];normal+=NORMAL_BS1*u_blendShapeWeights[1];normal+=NORMAL_BS2*u_blendShapeWeights[2];normal+=NORMAL_BS3*u_blendShapeWeights[3];\n#endif\n#if defined( O3_HAS_TANGENT ) && defined(OASIS_BLENDSHAPE_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\ntangent.xyz+=TANGENT_BS0*u_blendShapeWeights[0];tangent.xyz+=TANGENT_BS1*u_blendShapeWeights[1];tangent.xyz+=TANGENT_BS2*u_blendShapeWeights[2];tangent.xyz+=TANGENT_BS3*u_blendShapeWeights[3];\n#endif\n#endif\n#else\nposition.xyz+=POSITION_BS4*u_blendShapeWeights[4];position.xyz+=POSITION_BS5*u_blendShapeWeights[5];position.xyz+=POSITION_BS6*u_blendShapeWeights[6];position.xyz+=POSITION_BS7*u_blendShapeWeights[7];\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var uv_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef O3_HAS_UV1\nv_uv1=TEXCOORD_1;\n#endif\n#ifdef O3_NEED_TILINGOFFSET\nv_uv=v_uv*u_tilingOffset.xy+u_tilingOffset.zw;\n#endif\n"; // eslint-disable-line

var worldpos_vert = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n"; // eslint-disable-line

var shadow_vert = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n"; // eslint-disable-line

var fog_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n"; // eslint-disable-line

var light_frag_define = "#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngleCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];\n#endif\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_SH\nuniform vec3 u_env_sh[9];\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n"; // eslint-disable-line

var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_baseColor;uniform vec4 u_specularColor;uniform float u_shininess;uniform float u_normalIntensity;uniform float u_alphaCutoff;\n#ifdef EMISSIVETEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n#ifdef NORMALTEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n"; // eslint-disable-line

var fog_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n"; // eslint-disable-line

var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_baseColor;vec4 specular=u_specularColor;\n#ifdef EMISSIVETEXTURE\nvec4 emissiveTextureColor=texture2D(u_emissiveTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nemissiveTextureColor=gammaToLinear(emissiveTextureColor);\n#endif\nemission*=emissiveTextureColor;\n#endif\n#ifdef BASETEXTURE\nvec4 diffuseTextureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\ndiffuseTextureColor=gammaToLinear(diffuseTextureColor);\n#endif\ndiffuse*=diffuseTextureColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nvec4 specularTextureColor=texture2D(u_specularTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nspecularTextureColor=gammaToLinear(specularTextureColor);\n#endif\nspecular*=specularTextureColor;\n#endif\nambient=vec4(u_envMapLight.diffuse*u_envMapLight.diffuseIntensity,1.0)*diffuse;"; // eslint-disable-line

var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n"; // eslint-disable-line

var mobile_blinnphong_frag = "#define GLSLIFY 1\n#ifdef NORMALTEXTURE\nmat3 tbn=getTBN();vec3 N=getNormalByNormalTexture(tbn,u_normalTexture,u_normalIntensity,v_uv);\n#else\nvec3 N=getNormal();\n#endif\nvec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef ALPHA_CUTOFF\nif(diffuse.a<u_alphaCutoff){discard;}\n#endif\n"; // eslint-disable-line

var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n"; // eslint-disable-line

var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}"; // eslint-disable-line

var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}"; // eslint-disable-line

var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}"; // eslint-disable-line

var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}"; // eslint-disable-line

var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n"; // eslint-disable-line

var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}"; // eslint-disable-line

var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}"; // eslint-disable-line

var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}"; // eslint-disable-line

var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n"; // eslint-disable-line

var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}"; // eslint-disable-line

var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}"; // eslint-disable-line

var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}"; // eslint-disable-line

var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}"; // eslint-disable-line

var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}"; // eslint-disable-line

var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n"; // eslint-disable-line

var pbr_frag_define = "#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_PBRSpecularColor;uniform float u_glossiness;uniform vec3 u_emissiveColor;\n#ifdef CLEARCOAT\nuniform float u_clearCoat;uniform float u_clearCoatRoughness;\n#endif\nuniform float u_normalIntensity;uniform float u_occlusionIntensity;uniform float u_occlusionTextureCoord;\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\n#ifdef NORMALTEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef EMISSIVETEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef ROUGHNESSMETALLICTEXTURE\nuniform sampler2D u_roughnessMetallicTexture;\n#endif\n#ifdef SPECULARGLOSSINESSTEXTURE\nuniform sampler2D u_specularGlossinessTexture;\n#endif\n#ifdef OCCLUSIONTEXTURE\nuniform sampler2D u_occlusionTexture;\n#endif\n#ifdef HAS_CLEARCOATTEXTURE\nuniform sampler2D u_clearCoatTexture;\n#endif\n#ifdef HAS_CLEARCOATROUGHNESSTEXTURE\nuniform sampler2D u_clearCoatRoughnessTexture;\n#endif\n#ifdef HAS_CLEARCOATNORMALTEXTURE\nuniform sampler2D u_clearCoatNormalTexture;\n#endif\nstruct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct Geometry{vec3 position;vec3 normal;vec3 viewDir;float dotNV;\n#ifdef CLEARCOAT\nvec3 clearCoatNormal;float clearCoatDotNV;\n#endif\n};struct Material{vec3 diffuseColor;float roughness;vec3 specularColor;float opacity;\n#ifdef CLEARCOAT\nfloat clearCoat;float clearCoatRoughness;\n#endif\n};"; // eslint-disable-line

var pbr_helper = "#define GLSLIFY 1\n#include <normal_get>\nfloat computeSpecularOcclusion(float ambientOcclusion,float roughness,float dotNV){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}float getAARoughnessFactor(vec3 normal){\n#ifdef HAS_DERIVATIVES\nvec3 dxy=max(abs(dFdx(normal)),abs(dFdy(normal)));return 0.04+max(max(dxy.x,dxy.y),dxy.z);\n#else\nreturn 0.04;\n#endif\n}void initGeometry(out Geometry geometry){geometry.position=v_pos;geometry.viewDir=normalize(u_cameraPos-v_pos);\n#if defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE)\nmat3 tbn=getTBN();\n#endif\n#ifdef NORMALTEXTURE\ngeometry.normal=getNormalByNormalTexture(tbn,u_normalTexture,u_normalIntensity,v_uv);\n#else\ngeometry.normal=getNormal();\n#endif\ngeometry.dotNV=saturate(dot(geometry.normal,geometry.viewDir));\n#ifdef CLEARCOAT\n#ifdef HAS_CLEARCOATNORMALTEXTURE\ngeometry.clearCoatNormal=getNormalByNormalTexture(tbn,u_clearCoatNormalTexture,u_normalIntensity,v_uv);\n#else\ngeometry.clearCoatNormal=getNormal();\n#endif\ngeometry.clearCoatDotNV=saturate(dot(geometry.clearCoatNormal,geometry.viewDir));\n#endif\n}void initMaterial(out Material material,const in Geometry geometry){vec4 baseColor=u_baseColor;float metal=u_metal;float roughness=u_roughness;vec3 specularColor=u_PBRSpecularColor;float glossiness=u_glossiness;float alphaCutoff=u_alphaCutoff;\n#ifdef BASETEXTURE\nvec4 baseTextureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nbaseTextureColor=gammaToLinear(baseTextureColor);\n#endif\nbaseColor*=baseTextureColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nbaseColor*=v_color;\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<alphaCutoff){discard;}\n#endif\n#ifdef ROUGHNESSMETALLICTEXTURE\nvec4 metalRoughMapColor=texture2D(u_roughnessMetallicTexture,v_uv);roughness*=metalRoughMapColor.g;metal*=metalRoughMapColor.b;\n#endif\n#ifdef SPECULARGLOSSINESSTEXTURE\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nspecularGlossinessColor=gammaToLinear(specularGlossinessColor);\n#endif\nspecularColor*=specularGlossinessColor.rgb;glossiness*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=baseColor.rgb*(1.0-metal);material.specularColor=mix(vec3(0.04),baseColor.rgb,metal);material.roughness=roughness;\n#else\nfloat specularStrength=max(max(specularColor.r,specularColor.g),specularColor.b);material.diffuseColor=baseColor.rgb*(1.0-specularStrength);material.specularColor=specularColor;material.roughness=1.0-glossiness;\n#endif\nmaterial.roughness=max(material.roughness,getAARoughnessFactor(geometry.normal));\n#ifdef CLEARCOAT\nmaterial.clearCoat=u_clearCoat;material.clearCoatRoughness=u_clearCoatRoughness;\n#ifdef HAS_CLEARCOATTEXTURE\nmaterial.clearCoat*=texture2D(u_clearCoatTexture,v_uv).r;\n#endif\n#ifdef HAS_CLEARCOATROUGHNESSTEXTURE\nmaterial.clearCoatRoughness*=texture2D(u_clearCoatRoughnessTexture,v_uv).g;\n#endif\nmaterial.clearCoat=saturate(material.clearCoat);material.clearCoatRoughness=max(material.clearCoatRoughness,getAARoughnessFactor(geometry.clearCoatNormal));\n#endif\nmaterial.opacity=baseColor.a;}\n#include <brdf>\n#include <direct_irradiance_frag_define>\n#include <ibl_frag_define>\n"; // eslint-disable-line

var brdf = "#define GLSLIFY 1\nfloat F_Schlick(float dotLH){return 0.04+0.96*(pow(1.0-dotLH,5.0));}vec3 F_Schlick(vec3 specularColor,float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(float alpha,float dotNL,float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(float alpha,float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(vec3 incidentDirection,vec3 viewDir,vec3 normal,vec3 specularColor,float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentDirection+viewDir);float dotNL=saturate(dot(normal,incidentDirection));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotLH=saturate(dot(incidentDirection,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}vec3 BRDF_Diffuse_Lambert(vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}"; // eslint-disable-line

var direct_irradiance_frag_define = "#define GLSLIFY 1\nvoid addDirectRadiance(vec3 incidentDirection,vec3 color,Geometry geometry,Material material,inout ReflectedLight reflectedLight){float attenuation=1.0;\n#ifdef CLEARCOAT\nfloat clearCoatDotNL=saturate(dot(geometry.clearCoatNormal,incidentDirection));vec3 clearCoatIrradiance=clearCoatDotNL*color;reflectedLight.directSpecular+=material.clearCoat*clearCoatIrradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.clearCoatNormal,vec3(0.04),material.clearCoatRoughness);attenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nfloat dotNL=saturate(dot(geometry.normal,incidentDirection));vec3 irradiance=dotNL*color*PI;reflectedLight.directSpecular+=attenuation*irradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.normal,material.specularColor,material.roughness);reflectedLight.directDiffuse+=attenuation*irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid addDirectionalDirectLightRadiance(DirectLight directionalLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 color=directionalLight.color;vec3 direction=-directionalLight.direction;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid addPointDirectLightRadiance(PointLight pointLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=pointLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);vec3 color=pointLight.color;color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid addSpotDirectLightRadiance(SpotLight spotLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=spotLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);vec3 color=spotLight.color;color*=spotEffect*decayEffect;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\nvoid addTotalDirectRadiance(Geometry geometry,Material material,inout ReflectedLight reflectedLight){\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];addDirectionalDirectLightRadiance(directionalLight,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];addPointDirectLightRadiance(pointLight,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];addSpotDirectLightRadiance(spotLight,geometry,material,reflectedLight);}\n#endif\n}"; // eslint-disable-line

var ibl_frag_define = "#define GLSLIFY 1\nvec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){normal.x=-normal.x;vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}vec3 envBRDFApprox(vec3 specularColor,float roughness,float dotNV){const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(float roughness,int maxMIPLevel){return roughness*float(maxMIPLevel);}vec3 getLightProbeRadiance(vec3 viewDir,vec3 normal,float roughness,int maxMIPLevel,float specularIntensity){\n#ifndef O3_USE_SPECULAR_ENV\nreturn vec3(0);\n#else\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec.x=-reflectVec.x;float specularMIPLevel=getSpecularMIPLevel(roughness,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\n#ifdef O3_DECODE_ENV_RGBM\nenvMapColor.rgb=RGBMToLinear(envMapColor,5.0).rgb;\n#ifdef OASIS_COLORSPACE_GAMMA\nenvMapColor=linearToGamma(envMapColor);\n#endif\n#else\n#ifndef OASIS_COLORSPACE_GAMMA\nenvMapColor=gammaToLinear(envMapColor);\n#endif\n#endif\nreturn envMapColor.rgb*specularIntensity;\n#endif\n}"; // eslint-disable-line

var pbr_frag = "#define GLSLIFY 1\nGeometry geometry;Material material;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));initGeometry(geometry);initMaterial(material,geometry);addTotalDirectRadiance(geometry,material,reflectedLight);\n#ifdef O3_USE_SH\nvec3 irradiance=getLightProbeIrradiance(u_env_sh,geometry.normal);\n#ifdef OASIS_COLORSPACE_GAMMA\nirradiance=linearToGamma(vec4(irradiance,1.0)).rgb;\n#endif\nirradiance*=u_envMapLight.diffuseIntensity;\n#else\nvec3 irradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;irradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);vec3 radiance=getLightProbeRadiance(geometry.viewDir,geometry.normal,material.roughness,int(u_envMapLight.mipMapLevel),u_envMapLight.specularIntensity);float radianceAttenuation=1.0;\n#ifdef CLEARCOAT\nvec3 clearCoatRadiance=getLightProbeRadiance(geometry.viewDir,geometry.clearCoatNormal,material.clearCoatRoughness,int(u_envMapLight.mipMapLevel),u_envMapLight.specularIntensity);reflectedLight.indirectSpecular+=clearCoatRadiance*material.clearCoat*envBRDFApprox(vec3(0.04),material.clearCoatRoughness,geometry.clearCoatDotNV);radianceAttenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nreflectedLight.indirectSpecular+=radianceAttenuation*radiance*envBRDFApprox(material.specularColor,material.roughness,geometry.dotNV);\n#ifdef OCCLUSIONTEXTURE\nvec2 aoUV=v_uv;\n#ifdef O3_HAS_UV1\nif(u_occlusionTextureCoord==1.0){aoUV=v_uv1;}\n#endif\nfloat ambientOcclusion=(texture2D(u_occlusionTexture,aoUV).r-1.0)*u_occlusionIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#ifdef O3_USE_SPECULAR_ENV\nreflectedLight.indirectSpecular*=computeSpecularOcclusion(ambientOcclusion,material.roughness,geometry.dotNV);\n#endif\n#endif\nvec3 emissiveRadiance=u_emissiveColor;\n#ifdef EMISSIVETEXTURE\nvec4 emissiveColor=texture2D(u_emissiveTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nemissiveColor=gammaToLinear(emissiveColor);\n#endif\nemissiveRadiance*=emissiveColor.rgb;\n#endif\nvec3 totalRadiance=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+emissiveRadiance;vec4 targetColor=vec4(totalRadiance,material.opacity);\n#ifndef OASIS_COLORSPACE_GAMMA\ntargetColor=linearToGamma(targetColor);\n#endif\ngl_FragColor=targetColor;"; // eslint-disable-line

var PBRShaderLib = {
  pbr_frag_define: pbr_frag_define,
  pbr_helper: pbr_helper,
  brdf: brdf,
  direct_irradiance_frag_define: direct_irradiance_frag_define,
  ibl_frag_define: ibl_frag_define,
  pbr_frag: pbr_frag
};

var normal_get = "#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_HAS_NORMAL\nvec3 normal=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 normal=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 normal=vec3(0,0,1);\n#endif\nnormal*=float(gl_FrontFacing)*2.0-1.0;return normal;}vec3 getNormalByNormalTexture(mat3 tbn,sampler2D normalTexture,float normalIntensity,vec2 uv){vec3 normal=texture2D(normalTexture,uv).rgb;normal=normalize(tbn*((2.0*normal-1.0)*vec3(normalIntensity,normalIntensity,1.0)));normal*=float(gl_FrontFacing)*2.0-1.0;return normal;}mat3 getTBN(){\n#if defined(O3_HAS_NORMAL) && defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nmat3 tbn=v_TBN;\n#else\nvec3 normal=getNormal();vec3 position=v_pos;vec2 uv=gl_FrontFacing? v_uv:-v_uv;\n#ifdef HAS_DERIVATIVES\nvec3 dp1=dFdx(position);vec3 dp2=dFdy(position);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));mat3 tbn=mat3(tangent*invmax,binormal*invmax,normal);\n#else\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),normal);\n#endif\n#endif\nreturn tbn;}"; // eslint-disable-line

var ShaderLib = _objectSpread2(_objectSpread2({
  common: common,
  common_vert: common_vert,
  common_frag: common_frag,
  color_share: color_share,
  normal_share: normal_share,
  uv_share: uv_share,
  worldpos_share: worldpos_share,
  shadow_share: shadow_share,
  fog_share: fog_share,
  begin_normal_vert: begin_normal_vert,
  begin_position_vert: begin_position_vert,
  position_vert: position_vert,
  color_vert: color_vert,
  normal_vert: normal_vert,
  skinning_vert: skinning_vert,
  blendShape_input: blendShape_input,
  blendShape_vert: blendShape_vert,
  uv_vert: uv_vert,
  worldpos_vert: worldpos_vert,
  shadow_vert: shadow_vert,
  fog_vert: fog_vert,
  light_frag_define: light_frag_define,
  mobile_material_frag: mobile_material_frag,
  fog_frag: fog_frag,
  begin_mobile_frag: begin_mobile_frag,
  begin_viewdir_frag: begin_viewdir_frag,
  mobile_blinnphong_frag: mobile_blinnphong_frag,
  noise_common: noise_common,
  noise_cellular_2D: noise_cellular_2D,
  noise_cellular_2x2: noise_cellular_2x2,
  noise_cellular_2x2x2: noise_cellular_2x2x2,
  noise_cellular_3D: noise_cellular_3D,
  noise_cellular: noise_cellular,
  noise_perlin_2D: noise_perlin_2D,
  noise_perlin_3D: noise_perlin_3D,
  noise_perlin_4D: noise_perlin_4D,
  noise_perlin: noise_perlin,
  noise_psrd_2D: noise_psrd_2D,
  noise_simplex_2D: noise_simplex_2D,
  noise_simplex_3D_grad: noise_simplex_3D_grad,
  noise_simplex_3D: noise_simplex_3D,
  noise_simplex_4D: noise_simplex_4D,
  noise_simplex: noise_simplex
}, PBRShaderLib), {}, {
  normal_get: normal_get
});

var ShaderFactory = /*#__PURE__*/function () {
  function ShaderFactory() {}
  ShaderFactory.parseCustomMacros = function parseCustomMacros(macros) {
    return macros.map(function (m) {
      return "#define " + m + "\n";
    }).join("");
  };
  ShaderFactory.parseIncludes = function parseIncludes(src) {
    var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
    function replace(match, slice) {
      var replace = ShaderLib[slice];
      if (replace === undefined) {
        Logger.error("Shader slice \"" + match.trim() + "\" not founded.");
        return "";
      }
      return ShaderFactory.parseIncludes(replace);
    }
    return src.replace(regex, replace);
  }

  /**
   * GLSL extension.
   * @param extensions - such as ["GL_EXT_shader_texture_lod"]
   * */;
  ShaderFactory.parseExtension = function parseExtension(extensions) {
    return extensions.map(function (e) {
      return "#extension " + e + " : enable\n";
    }).join("");
  }

  /**
   * Convert lower GLSL version to GLSL 300 es.
   * @param shader - code
   * @param isFrag - Whether it is a fragment shader.
   * */;
  ShaderFactory.convertTo300 = function convertTo300(shader, isFrag) {
    /** replace attribute and in */
    shader = shader.replace(/\battribute\b/g, "in");
    shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");

    /** replace api */
    shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
    shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
    if (isFrag) {
      var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
      if (isMRT) {
        shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        var result = shader.match(/\bgl_FragData\[.+?\]/g);
        shader = this._replaceMRTShader(shader, result);
      } else {
        shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
        shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
      }
    }
    return shader;
  };
  ShaderFactory._replaceMRTShader = function _replaceMRTShader(shader, result) {
    var declaration = "";
    var mrtIndexSet = new Set();
    for (var i = 0; i < result.length; i++) {
      var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    mrtIndexSet.forEach(function (index) {
      declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
    });
    declaration += "void main(";
    shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
    shader = shader.replace(/void\s+?main\s*\(/g, declaration);
    return shader;
  };
  return ShaderFactory;
}();

/**
 * Shader macro。
 */
var ShaderMacro = /** @internal */

/** Name. */

/** Value. */

/** @internal */

/** @internal */

/** @internal */

/**
 * @internal
 */
function ShaderMacro(name, value, maskIndex, maskValue) {
  this.name = void 0;
  this.value = void 0;
  this._nameId = void 0;
  this._maskIndex = void 0;
  this._maskValue = void 0;
  this.name = name;
  this._maskIndex = maskIndex;
  this._maskValue = maskValue;
  this.value = value;
  var macroNameIDMap = ShaderMacro._macroNameIdMap;
  var nameID = macroNameIDMap[name];
  if (macroNameIDMap[name] === undefined) {
    macroNameIDMap[name] = nameID = ShaderMacro._macroNameCounter++;
  }
  this._nameId = nameID;
};
ShaderMacro._macroNameIdMap = Object.create(null);
ShaderMacro._macroNameCounter = 0;

/**
 * Color Space.
 */
var ColorSpace;
(function (ColorSpace) {
  ColorSpace[ColorSpace["Linear"] = 0] = "Linear";
  ColorSpace[ColorSpace["Gamma"] = 1] = "Gamma";
})(ColorSpace || (ColorSpace = {}));

/**
 * Shader uniform。
 * @internal
 */
var ShaderUniform = /*#__PURE__*/function () {
  function ShaderUniform(engine) {
    this.name = void 0;
    this.propertyId = void 0;
    this.location = void 0;
    this.applyFunc = void 0;
    this.cacheValue = void 0;
    this.textureIndex = void 0;
    this.textureDefault = void 0;
    this._rhi = void 0;
    this._gl = void 0;
    this._colorSpace = void 0;
    var rhi = engine._hardwareRenderer;
    this._rhi = rhi;
    this._gl = rhi.gl;
    this._colorSpace = engine.settings.colorSpace;
  }
  var _proto = ShaderUniform.prototype;
  _proto.upload1f = function upload1f(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1f(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1fv = function upload1fv(shaderUniform, value) {
    this._gl.uniform1fv(shaderUniform.location, value);
  };
  _proto.upload2f = function upload2f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        if (this._colorSpace === ColorSpace.Linear) {
          this._gl.uniform2f(shaderUniform.location, Color.gammaToLinearSpace(value.r), Color.gammaToLinearSpace(value.g));
        } else {
          this._gl.uniform2f(shaderUniform.location, value.r, value.g);
        }
        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2f(shaderUniform.location, value.x, value.y);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };
  _proto.upload2fv = function upload2fv(shaderUniform, value) {
    this._gl.uniform2fv(shaderUniform.location, value);
  };
  _proto.upload3f = function upload3f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        if (this._colorSpace === ColorSpace.Linear) {
          this._gl.uniform3f(shaderUniform.location, Color.gammaToLinearSpace(value.r), Color.gammaToLinearSpace(value.g), Color.gammaToLinearSpace(value.b));
        } else {
          this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
        }
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };
  _proto.upload3fv = function upload3fv(shaderUniform, value) {
    this._gl.uniform3fv(shaderUniform.location, value);
  };
  _proto.upload4f = function upload4f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        if (this._colorSpace === ColorSpace.Linear) {
          this._gl.uniform4f(shaderUniform.location, Color.gammaToLinearSpace(value.r), Color.gammaToLinearSpace(value.g), Color.gammaToLinearSpace(value.b), value.a);
        } else {
          this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
        }
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };
  _proto.upload4fv = function upload4fv(shaderUniform, value) {
    this._gl.uniform4fv(shaderUniform.location, value);
  };
  _proto.upload1i = function upload1i(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1i(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1iv = function upload1iv(shaderUniform, value) {
    this._gl.uniform1iv(shaderUniform.location, value);
  };
  _proto.upload2i = function upload2i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        this._gl.uniform2i(shaderUniform.location, value.r, value.g);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2i(shaderUniform.location, value.x, value.y);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };
  _proto.upload2iv = function upload2iv(shaderUniform, value) {
    this._gl.uniform2iv(shaderUniform.location, value);
  };
  _proto.upload3i = function upload3i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };
  _proto.upload3iv = function upload3iv(shaderUniform, value) {
    this._gl.uniform3iv(shaderUniform.location, value);
  };
  _proto.upload4i = function upload4i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };
  _proto.upload4iv = function upload4iv(shaderUniform, value) {
    this._gl.uniform4iv(shaderUniform.location, value);
  };
  _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
  };
  _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
  };
  _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
    var rhi = this._rhi;
    rhi.activeTexture(shaderUniform.textureIndex);
    rhi.bindTexture(value._platformTexture);
  };
  _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
    var rhi = this._rhi;
    var textureIndices = shaderUniform.textureIndex;
    for (var i = 0; i < value.length; i++) {
      var texture = value[i];
      rhi.activeTexture(textureIndices[i]);
      rhi.bindTexture(texture._platformTexture);
    }
  };
  return ShaderUniform;
}();

/**
 * Shader uniform block.
 * @internal
 */
var ShaderUniformBlock = function ShaderUniformBlock() {
  this.constUniforms = [];
  this.textureUniforms = [];
};

/**
 * Shader program, corresponding to the GPU shader program.
 * @internal
 */
var ShaderProgram = /*#__PURE__*/function () {
  ShaderProgram._addLineNum = function _addLineNum(str) {
    var lines = str.split("\n");
    var limitLength = (lines.length + 1).toString().length + 6;
    var prefix;
    return lines.map(function (line, index) {
      prefix = "0:" + (index + 1);
      if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;
      for (var i = 0; i < limitLength - prefix.length; i++) {
        prefix += " ";
      }
      return prefix + line;
    }).join("\n");
  };
  function ShaderProgram(engine, vertexSource, fragmentSource) {
    this.id = void 0;
    this.sceneUniformBlock = new ShaderUniformBlock();
    this.cameraUniformBlock = new ShaderUniformBlock();
    this.rendererUniformBlock = new ShaderUniformBlock();
    this.materialUniformBlock = new ShaderUniformBlock();
    this.otherUniformBlock = new ShaderUniformBlock();
    this._uploadRenderCount = -1;
    this._uploadCamera = void 0;
    this._uploadRenderer = void 0;
    this._uploadMaterial = void 0;
    this.attributeLocation = Object.create(null);
    this._isValid = void 0;
    this._engine = void 0;
    this._gl = void 0;
    this._vertexShader = void 0;
    this._fragmentShader = void 0;
    this._glProgram = void 0;
    this._activeTextureUint = 0;
    this._engine = engine;
    this._gl = engine._hardwareRenderer.gl;
    this._glProgram = this._createProgram(vertexSource, fragmentSource);
    if (this._glProgram) {
      this._isValid = true;
      this._recordLocation();
    } else {
      this._isValid = false;
    }
    this.id = ShaderProgram._counter++;
  }

  /**
   * Upload all shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */
  var _proto = ShaderProgram.prototype;
  _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
    this.uploadUniforms(uniformBlock, shaderData);
    this.uploadTextures(uniformBlock, shaderData);
  }

  /**
   * Upload constant shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */;
  _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
    var propertyValueMap = shaderData._propertyValueMap;
    var constUniforms = uniformBlock.constUniforms;
    for (var i = 0, n = constUniforms.length; i < n; i++) {
      var uniform = constUniforms[i];
      var data = propertyValueMap[uniform.propertyId];
      data != null && uniform.applyFunc(uniform, data);
    }
  }

  /**
   * Upload texture shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */;
  _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
    var propertyValueMap = shaderData._propertyValueMap;
    var textureUniforms = uniformBlock.textureUniforms;
    // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        var texture = propertyValueMap[uniform.propertyId];
        if (texture && !texture.destroyed) {
          uniform.applyFunc(uniform, texture);
        } else {
          uniform.applyFunc(uniform, uniform.textureDefault);
        }
      }
    }
  }

  /**
   * Upload ungroup texture shader data in shader uniform block.
   */;
  _proto.uploadUnGroupTextures = function uploadUnGroupTextures() {
    var textureUniforms = this.otherUniformBlock.textureUniforms;
    // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        uniform.applyFunc(uniform, uniform.textureDefault);
      }
    }
  }

  /**
   * Grouping other data.
   */;
  _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
    var _this$otherUniformBlo = this.otherUniformBlock,
      constUniforms = _this$otherUniformBlo.constUniforms,
      textureUniforms = _this$otherUniformBlo.textureUniforms;
    constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
    textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
  }

  /**
   * Bind this shader program.
   * @returns Whether the shader program is switched.
   */;
  _proto.bind = function bind() {
    var rhi = this._engine._hardwareRenderer;
    if (rhi._currentBind !== this) {
      this._gl.useProgram(this._glProgram);
      rhi._currentBind = this;
      return true;
    } else {
      return false;
    }
  }

  /**
   * Destroy this shader program.
   */;
  _proto.destroy = function destroy() {
    var gl = this._gl;
    this._vertexShader && gl.deleteShader(this._vertexShader);
    this._fragmentShader && gl.deleteShader(this._fragmentShader);
    this._glProgram && gl.deleteProgram(this._glProgram);
  };
  _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
    for (var i = uniforms.length - 1; i >= 0; i--) {
      var uniform = uniforms[i];
      var group = Shader._getShaderPropertyGroup(uniform.name);
      if (group !== undefined) {
        uniforms.splice(uniforms.indexOf(uniform), 1);
        this._groupingUniform(uniform, group, isTexture);
      }
    }
  };
  _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
    switch (group) {
      case ShaderDataGroup.Scene:
        if (isTexture) {
          this.sceneUniformBlock.textureUniforms.push(uniform);
        } else {
          this.sceneUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Camera:
        if (isTexture) {
          this.cameraUniformBlock.textureUniforms.push(uniform);
        } else {
          this.cameraUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Renderer:
        if (isTexture) {
          this.rendererUniformBlock.textureUniforms.push(uniform);
        } else {
          this.rendererUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Material:
        if (isTexture) {
          this.materialUniformBlock.textureUniforms.push(uniform);
        } else {
          this.materialUniformBlock.constUniforms.push(uniform);
        }
        break;
      default:
        if (isTexture) {
          this.otherUniformBlock.textureUniforms.push(uniform);
        } else {
          this.otherUniformBlock.constUniforms.push(uniform);
        }
    }
  }

  /**
   * init and link program with shader.
   */;
  _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
    var gl = this._gl;

    // create and compile shader
    var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
    if (!vertexShader) {
      return null;
    }
    var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (!fragmentShader) {
      return null;
    }

    // link program and shader
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (gl.isContextLost()) {
      Logger.error("Context lost while linking program.");
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }
    if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS)) {
      Logger.error("Could not link WebGL program. \n" + gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    this._vertexShader = vertexShader;
    this._fragmentShader = fragmentShader;
    return program;
  };
  _proto._createShader = function _createShader(shaderType, shaderSource) {
    var gl = this._gl;
    var shader = gl.createShader(shaderType);
    if (!shader) {
      Logger.error("Context lost while create shader.");
      return null;
    }
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (gl.isContextLost()) {
      Logger.error("Context lost while compiling shader.");
      gl.deleteShader(shader);
      return null;
    }
    if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      Logger.error("Could not compile WebGL shader.\n" + gl.getShaderInfoLog(shader), ShaderProgram._addLineNum(shaderSource));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  /**
   * record the location of uniform/attribute.
   */;
  _proto._recordLocation = function _recordLocation() {
    var _this = this;
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = this._getUniformInfos();
    var attributeInfos = this._getAttributeInfos();
    uniformInfos.forEach(function (_ref) {
      var name = _ref.name,
        size = _ref.size,
        type = _ref.type;
      var shaderUniform = new ShaderUniform(_this._engine);
      var isArray = false;
      var isTexture = false;
      if (name.indexOf("[0]") > 0) {
        name = name.substr(0, name.length - 3);
        isArray = true;
      }
      var location = gl.getUniformLocation(program, name);
      shaderUniform.name = name;
      shaderUniform.propertyId = Shader.getPropertyByName(name)._uniqueId;
      shaderUniform.location = location;
      switch (type) {
        case gl.FLOAT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1f;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.FLOAT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2f;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.FLOAT_VEC3:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload3fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload3f;
            shaderUniform.cacheValue = new Vector3(0, 0, 0);
          }
          break;
        case gl.FLOAT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4f;
            shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
          }
          break;
        case gl.BOOL:
        case gl.INT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1i;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.BOOL_VEC2:
        case gl.INT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2i;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.BOOL_VEC3:
        case gl.INT_VEC3:
          shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
          shaderUniform.cacheValue = new Vector3(0, 0, 0);
          break;
        case gl.BOOL_VEC4:
        case gl.INT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4i;
            shaderUniform.cacheValue = new Vector4(0, 0, 0);
          }
          break;
        case gl.FLOAT_MAT4:
          shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
          break;
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
        case gl.SAMPLER_2D_ARRAY:
          var defaultTexture;
          switch (type) {
            case gl.SAMPLER_2D:
              defaultTexture = _this._engine._magentaTexture2D;
              break;
            case gl.SAMPLER_CUBE:
              defaultTexture = _this._engine._magentaTextureCube;
              break;
            case gl.SAMPLER_2D_ARRAY:
              defaultTexture = _this._engine._magentaTexture2DArray;
              break;
            default:
              throw new Error("Unsupported texture type.");
          }
          isTexture = true;
          if (isArray) {
            var defaultTextures = new Array(size);
            var textureIndices = new Int32Array(size);
            var glTextureIndices = new Array(size);
            for (var i = 0; i < size; i++) {
              defaultTextures[i] = defaultTexture;
              textureIndices[i] = _this._activeTextureUint;
              glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
            }
            shaderUniform.textureDefault = defaultTextures;
            shaderUniform.textureIndex = glTextureIndices;
            shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
            _this.bind();
            gl.uniform1iv(location, textureIndices);
            shaderUniform.uploadTextureArray(shaderUniform, defaultTextures);
          } else {
            var textureIndex = gl.TEXTURE0 + _this._activeTextureUint;
            shaderUniform.textureDefault = defaultTexture;
            shaderUniform.textureIndex = textureIndex;
            shaderUniform.applyFunc = shaderUniform.uploadTexture;
            _this.bind();
            gl.uniform1i(location, _this._activeTextureUint++);
            shaderUniform.uploadTexture(shaderUniform, defaultTexture);
          }
          break;
      }
      var group = Shader._getShaderPropertyGroup(name);
      _this._groupingUniform(shaderUniform, group, isTexture);
    });
    attributeInfos.forEach(function (_ref2) {
      var name = _ref2.name;
      _this.attributeLocation[name] = gl.getAttribLocation(program, name);
    });
  };
  _proto._getUniformInfos = function _getUniformInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = new Array();
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < uniformCount; ++i) {
      var info = gl.getActiveUniform(program, i);
      uniformInfos[i] = info;
    }
    return uniformInfos;
  };
  _proto._getAttributeInfos = function _getAttributeInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var attributeInfos = new Array();
    var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < attributeCount; ++i) {
      var info = gl.getActiveAttrib(program, i);
      attributeInfos[i] = info;
    }
    return attributeInfos;
  };
  _createClass(ShaderProgram, [{
    key: "isValid",
    get:
    /**
     * Whether this shader program is valid.
     */
    function get() {
      return this._isValid;
    }
  }]);
  return ShaderProgram;
}();
ShaderProgram._counter = 0;

/**
 * Shader property.
 */
var ShaderProperty = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function ShaderProperty(name) {
    this._uniqueId = void 0;
    this._group = void 0;
    this._type = void 0;
    this.name = void 0;
    this.name = name;
    this._uniqueId = ShaderProperty._propertyNameCounter++;
  }
  _createClass(ShaderProperty, [{
    key: "type",
    get: /** @internal */

    /** @internal */

    /** @internal */

    /** Shader property name. */

    /**
     * Shader property type.
     */
    function get() {
      return this._type;
    }
  }]);
  return ShaderProperty;
}();
ShaderProperty._propertyNameCounter = 0;

/**
 * Shader containing vertex and fragment source.
 */
var Shader = /*#__PURE__*/function () {
  /** @internal */
  /** @internal */
  /**
   * Create a shader.
   * @param name - Name of the shader
   * @param vertexSource - Vertex source code
   * @param fragmentSource - Fragment source code
   */
  Shader.create = function create(name, vertexSource, fragmentSource) {
    var shaderMap = Shader._shaderMap;
    if (shaderMap[name]) {
      throw "Shader named \"" + name + "\" already exists.";
    }
    return shaderMap[name] = new Shader(name, vertexSource, fragmentSource);
  }

  /**
   * Find a shader by name.
   * @param name - Name of the shader
   */;
  Shader.find = function find(name) {
    return Shader._shaderMap[name];
  }

  /**
   * Get shader macro by name.
   * @param name - Name of the shader macro
   * @returns Shader macro
   */;
  Shader.getMacroByName = function getMacroByName(name, value) {
    var key = value ? name + " " + value : name;
    var macro = Shader._macroMap[key];
    if (!macro) {
      var maskMap = Shader._macroMaskMap;
      var counter = Shader._macroCounter;
      var index = Math.floor(counter / 32);
      var bit = counter % 32;
      macro = new ShaderMacro(name, value, index, 1 << bit);
      Shader._macroMap[key] = macro;
      if (index == maskMap.length) {
        maskMap.length++;
        maskMap[index] = new Array(32);
      }
      maskMap[index][bit] = key;
      Shader._macroCounter++;
    }
    return macro;
  }

  /**
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */;
  Shader.getPropertyByName = function getPropertyByName(name) {
    var propertyNameMap = Shader._propertyNameMap;
    if (propertyNameMap[name] != null) {
      return propertyNameMap[name];
    } else {
      var property = new ShaderProperty(name);
      propertyNameMap[name] = property;
      Shader._propertyIdMap[property._uniqueId] = property;
      return property;
    }
  }

  /**
   * @internal
   */;
  Shader._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
    var shaderProperty = Shader._propertyNameMap[propertyName];
    return shaderProperty === null || shaderProperty === void 0 ? void 0 : shaderProperty._group;
  };
  Shader._getNamesByMacros = function _getNamesByMacros(macros, out) {
    var maskMap = Shader._macroMaskMap;
    var mask = macros._mask;
    out.length = 0;
    for (var i = 0, n = macros._length; i < n; i++) {
      var subMaskMap = maskMap[i];
      var subMask = mask[i];
      var _n = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1; // if is negative must contain 1 << 31.
      for (var j = 0; j < _n; j++) {
        if (subMask & 1 << j) {
          out.push(subMaskMap[j]);
        }
      }
    }
  }

  /** The name of shader. */;

  function Shader(name, vertexSource, fragmentSource) {
    this.name = void 0;
    this._shaderId = 0;
    this._vertexSource = void 0;
    this._fragmentSource = void 0;
    this._shaderId = Shader._shaderCounter++;
    this.name = name;
    this._vertexSource = vertexSource;
    this._fragmentSource = fragmentSource;
  }

  /**
   * Compile shader variant by macro name list.
   *
   * @remarks
   * Usually a shader contains some macros,any combination of macros is called shader variant.
   *
   * @param engine - Engine to which the shader variant belongs
   * @param macros - Macro name list
   * @returns Is the compiled shader variant valid
   */
  var _proto = Shader.prototype;
  _proto.compileVariant = function compileVariant(engine, macros) {
    var compileMacros = Shader._compileMacros;
    compileMacros.clear();
    for (var i = 0, n = macros.length; i < n; i++) {
      compileMacros.enable(Shader.getMacroByName(macros[i]));
    }
    return this._getShaderProgram(engine, compileMacros).isValid;
  }

  /**
   * @internal
   */;
  _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
    var shaderProgramPool = engine._getShaderProgramPool(this);
    var shaderProgram = shaderProgramPool.get(macroCollection);
    if (shaderProgram) {
      return shaderProgram;
    }
    var isWebGL2 = engine._hardwareRenderer.isWebGL2;
    var macroNameList = [];
    Shader._getNamesByMacros(macroCollection, macroNameList);
    var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
    var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
    var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n    #else\n      precision mediump float;\n      precision mediump int;\n    #endif\n    ";
    if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
      precisionStr += "#define HAS_TEX_LOD\n";
    }
    if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
      precisionStr += "#define HAS_DERIVATIVES\n";
    }
    var vertexSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + precisionStr + "\n        " + macroNameStr + "\n        " + this._vertexSource);
    var fragmentSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + this._fragmentSource);
    if (isWebGL2) {
      vertexSource = ShaderFactory.convertTo300(vertexSource);
      fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
    }
    shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
    shaderProgramPool.cache(shaderProgram);
    return shaderProgram;
  };
  return Shader;
}();
Shader._compileMacros = new ShaderMacroCollection();
Shader._propertyIdMap = Object.create(null);
Shader._shaderCounter = 0;
Shader._shaderMap = Object.create(null);
Shader._propertyNameMap = Object.create(null);
Shader._macroMaskMap = [];
Shader._macroCounter = 0;
Shader._macroMap = Object.create(null);
Shader._shaderExtension = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];

/**
 * Shader data collection,Correspondence includes shader properties data and macros data.
 */
var ShaderData = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * @internal
   */
  function ShaderData(group) {
    this._group = void 0;
    this._propertyValueMap = Object.create(null);
    this._macroCollection = new ShaderMacroCollection();
    this._macroMap = Object.create(null);
    this._refCount = 0;
    this._group = group;
  }

  /**
   * Get float by shader property name.
   * @param propertyName - Shader property name
   * @returns Float
   */
  var _proto = ShaderData.prototype;
  _proto.getFloat = function getFloat(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set float by shader property name.
   * @remarks Corresponding float shader property type.
   * @param propertyName - Shader property name
   * @param value - Float
   */;
  _proto.setFloat = function setFloat(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Float, value);
  }

  /**
   * Get int by shader property name.
   * @param propertyName - Shader property name
   * @returns Int
   */;
  _proto.getInt = function getInt(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set int by shader property name.
   * @remarks Correspondence includes int and bool shader property type.
   * @param propertyName - Shader property name
   * @param value - Int
   */;
  _proto.setInt = function setInt(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Int, value);
  }

  /**
   * Get float array by shader property name.
   * @param propertyName - Shader property name
   * @returns Float array
   */;
  _proto.getFloatArray = function getFloatArray(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set float array by shader property name.
   * @remarks Correspondence includes float array、vec2 array、vec3 array、vec4 array and matrix array shader property type.
   * @param propertyName - Shader property name
   * @param value - Float array
   */;
  _proto.setFloatArray = function setFloatArray(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.FloatArray, value);
  }

  /**
   * Get int array by shader property name.
   * @param propertyName - Shader property name
   * @returns Int Array
   */;
  _proto.getIntArray = function getIntArray(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set int array by shader property name.
   * @remarks Correspondence includes bool array、int array、bvec2 array、bvec3 array、bvec4 array、ivec2 array、ivec3 array and ivec4 array shader property type.
   * @param propertyName - Shader property name
   * @param value - Int Array
   */;
  _proto.setIntArray = function setIntArray(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.IntArray, value);
  }

  /**
   * Get two-dimensional from shader property name.
   * @param propertyName - Shader property name
   * @returns Two-dimensional vector
   */;
  _proto.getVector2 = function getVector2(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set two-dimensional vector from shader property name.
   * @remarks Correspondence includes vec2、ivec2 and bvec2 shader property type.
   * @param property - Shader property name
   * @param value - Two-dimensional vector
   */;
  _proto.setVector2 = function setVector2(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Vector2, value);
  }

  /**
   * Get vector3 by shader property name.
   * @param propertyName - Shader property name
   * @returns Three-dimensional vector
   */;
  _proto.getVector3 = function getVector3(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set three dimensional vector by shader property name.
   * @remarks Correspondence includes vec3、ivec3 and bvec3 shader property type.
   * @param property - Shader property name
   * @param value - Three-dimensional vector
   */;
  _proto.setVector3 = function setVector3(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Vector3, value);
  }

  /**
   * Get vector4 by shader property name.
   * @param propertyName - Shader property name
   * @returns Four-dimensional vector
   */;
  _proto.getVector4 = function getVector4(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set four-dimensional vector by shader property name.
   * @remarks Correspondence includes vec4、ivec4 and bvec4 shader property type.
   * @param property - Shader property name
   * @param value - Four-dimensional vector
   */;
  _proto.setVector4 = function setVector4(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Vector4, value);
  }

  /**
   * Get matrix by shader property name.
   * @param propertyName - Shader property name
   * @returns Matrix
   */;
  _proto.getMatrix = function getMatrix(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set matrix by shader property name.
   * @remarks Correspondence includes matrix shader property type.
   * @param propertyName - Shader property name
   * @param value - Matrix
   */;
  _proto.setMatrix = function setMatrix(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Matrix, value);
  }

  /**
   * Get color by shader property name.
   * @param propertyName - Shader property name
   * @returns Color
   */;
  _proto.getColor = function getColor(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set color by shader property name.
   * @remarks Correspondence includes vec4 shader property type.
   * @param propertyName - Shader property name
   * @param value - Color
   */;
  _proto.setColor = function setColor(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Color, value);
  }

  /**
   * Get texture by shader property name.
   * @param propertyName - Shader property name
   * @returns Texture
   */;
  _proto.getTexture = function getTexture(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set texture by shader property name.
   * @param propertyName - Shader property name
   * @param value - Texture
   */;
  _proto.setTexture = function setTexture(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this.getPropertyValue(property);
      lastValue && lastValue._addRefCount(-1);
      value && value._addRefCount(1);
    }
    this._setPropertyValue(property, ShaderPropertyType.Texture, value);
  }

  /**
   * Get texture array by shader property name.
   * @param propertyName - Shader property name
   * @returns Texture array
   */;
  _proto.getTextureArray = function getTextureArray(property) {
    return this.getPropertyValue(property);
  }

  /**
   * Set texture array by shader property name.
   * @param propertyName - Shader property name
   * @param value - Texture array
   */;
  _proto.setTextureArray = function setTextureArray(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this.getPropertyValue(property);
      if (lastValue) {
        for (var i = 0, n = lastValue.length; i < n; i++) {
          lastValue[i]._addRefCount(-1);
        }
      }
      if (value) {
        for (var _i = 0, _n = value.length; _i < _n; _i++) {
          value[_i]._addRefCount(1);
        }
      }
    }
    this._setPropertyValue(property, ShaderPropertyType.TextureArray, value);
  }

  /**
   * Get shader property value set on this shaderData.
   * @param property - Shader property
   * @returns Property value
   */;
  _proto.getPropertyValue = function getPropertyValue(property) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }
    return this._propertyValueMap[property._uniqueId];
  }

  /**
   * Enable macro with name.
   * @param macroName - Macro name
   */;
  _proto.enableMacro = function enableMacro(macro, value) {
    if (typeof macro === "string") {
      macro = Shader.getMacroByName(macro, value);
    }
    var nameID = macro._nameId;
    var lastMacro = this._macroMap[nameID];
    if (lastMacro !== macro) {
      var macroCollection = this._macroCollection;
      lastMacro && macroCollection.disable(lastMacro);
      macroCollection.enable(macro);
      this._macroMap[nameID] = macro;
    }
  }

  /**
   * Disable macro.
   * @param macroName - Macro name
   */;
  _proto.disableMacro = function disableMacro(macro) {
    var nameID;
    if (typeof macro === "string") {
      nameID = ShaderMacro._macroNameIdMap[macro];
      if (nameID === undefined) {
        return;
      }
    } else {
      nameID = macro._nameId;
    }
    var currentMacro = this._macroMap[nameID];
    if (currentMacro) {
      this._macroCollection.disable(currentMacro);
      delete this._macroMap[nameID];
    }
  }

  /**
   * Get shader macro array that are currently enabled for ShaderData.
   */;
  _proto.getMacros = function getMacros(out) {
    if (out) {
      var macroMap = this._macroMap;
      out.length = 0;
      for (var key in macroMap) {
        out.push(macroMap[key]);
      }
    } else {
      return Object.values(this._macroMap);
    }
  }

  /**
   * Get all shader properties that have been set on this shaderData
   * @returns  All shader properties
   */;
  _proto.getProperties = function getProperties(out) {
    var properties;
    if (out) {
      out.length = 0;
      properties = out;
    } else {
      properties = [];
    }
    var propertyValueMap = this._propertyValueMap;
    var propertyIdMap = Shader._propertyIdMap;
    for (var key in propertyValueMap) {
      properties.push(propertyIdMap[key]);
    }
    if (!out) {
      return properties;
    }
  };
  _proto.clone = function clone() {
    var shaderData = new ShaderData(this._group);
    this.cloneTo(shaderData);
    return shaderData;
  };
  _proto.cloneTo = function cloneTo(target) {
    CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);
    _extends(target._macroMap, this._macroMap);
    var propertyValueMap = this._propertyValueMap;
    var targetPropertyValueMap = target._propertyValueMap;
    var keys = Object.keys(propertyValueMap);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var _property = propertyValueMap[k];
      if (_property != null) {
        if (typeof _property === "number") {
          targetPropertyValueMap[k] = _property;
        } else if (_property instanceof Texture) {
          targetPropertyValueMap[k] = _property;
        } else if (_property instanceof Array || _property instanceof Float32Array || _property instanceof Int32Array) {
          targetPropertyValueMap[k] = _property.slice();
        } else {
          var targetProperty = targetPropertyValueMap[k];
          if (targetProperty) {
            targetProperty.copyFrom(_property);
          } else {
            targetPropertyValueMap[k] = _property.clone();
          }
        }
      } else {
        targetPropertyValueMap[k] = _property;
      }
    }
  }

  /**
   * @internal
   */;
  _proto._setPropertyValue = function _setPropertyValue(property, type, value) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }
    if (property._group !== this._group) {
      if (property._group === undefined) {
        property._group = this._group;
      } else {
        throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " group.";
      }
    }
    if (property._type !== type) {
      if (property._type === undefined) {
        property._type = type;
      } else {
        throw "Shader property " + property.name + " has been used as " + ShaderPropertyType[property._type] + " type.";
      }
    }
    this._propertyValueMap[property._uniqueId] = value;
  }

  /**
   * @internal
   */;
  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  }

  /**
   * @internal
   */;
  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
    var properties = this._propertyValueMap;
    for (var k in properties) {
      var _property2 = properties[k];
      // @todo: Separate array to speed performance.
      if (_property2 && _property2 instanceof Texture) {
        _property2._addRefCount(value);
      }
    }
  };
  return ShaderData;
}();

/**
 * Blend factor.
 * @remarks defines which function is used for blending pixel arithmetic
 */
var BlendFactor;
(function (BlendFactor) {
  BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
  BlendFactor[BlendFactor["One"] = 1] = "One";
  BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
  BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
  BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
  BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
  BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
  BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
  BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
  BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
  BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
  BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
  BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
})(BlendFactor || (BlendFactor = {}));

/**
 * Blend operation function.
 * @remarks defines how a new pixel is combined with a pixel.
 */
var BlendOperation;
(function (BlendOperation) {
  BlendOperation[BlendOperation["Add"] = 0] = "Add";
  BlendOperation[BlendOperation["Subtract"] = 1] = "Subtract";
  BlendOperation[BlendOperation["ReverseSubtract"] = 2] = "ReverseSubtract";
  BlendOperation[BlendOperation["Min"] = 3] = "Min";
  BlendOperation[BlendOperation["Max"] = 4] = "Max";
})(BlendOperation || (BlendOperation = {}));

/**
 * Set which color channels can be rendered to frame buffer.
 * @remarks enumeration can be combined using bit operations.
 */
var ColorWriteMask;
(function (ColorWriteMask) {
  ColorWriteMask[ColorWriteMask["None"] = 0] = "None";
  ColorWriteMask[ColorWriteMask["Red"] = 1] = "Red";
  ColorWriteMask[ColorWriteMask["Green"] = 2] = "Green";
  ColorWriteMask[ColorWriteMask["Blue"] = 4] = "Blue";
  ColorWriteMask[ColorWriteMask["Alpha"] = 8] = "Alpha";
  ColorWriteMask[ColorWriteMask["All"] = 15] = "All";
})(ColorWriteMask || (ColorWriteMask = {}));

/**
 * The blend state of the render target.
 */
var RenderTargetBlendState = function RenderTargetBlendState() {
  this.enabled = false;
  this.colorBlendOperation = BlendOperation.Add;
  this.alphaBlendOperation = BlendOperation.Add;
  this.sourceColorBlendFactor = BlendFactor.One;
  this.sourceAlphaBlendFactor = BlendFactor.One;
  this.destinationColorBlendFactor = BlendFactor.Zero;
  this.destinationAlphaBlendFactor = BlendFactor.Zero;
  this.colorWriteMask = ColorWriteMask.All;
};

/**
 * Blend state.
 */
var BlendState = /*#__PURE__*/function () {
  function BlendState() {
    this.targetBlendState = new RenderTargetBlendState();
    this.blendColor = new Color(0, 0, 0, 0);
    this.alphaToCoverage = false;
  }
  BlendState._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
    var gl = rhi.gl;
    switch (blendFactor) {
      case BlendFactor.Zero:
        return gl.ZERO;
      case BlendFactor.One:
        return gl.ONE;
      case BlendFactor.SourceColor:
        return gl.SRC_COLOR;
      case BlendFactor.OneMinusSourceColor:
        return gl.ONE_MINUS_SRC_COLOR;
      case BlendFactor.DestinationColor:
        return gl.DST_COLOR;
      case BlendFactor.OneMinusDestinationColor:
        return gl.ONE_MINUS_DST_COLOR;
      case BlendFactor.SourceAlpha:
        return gl.SRC_ALPHA;
      case BlendFactor.OneMinusSourceAlpha:
        return gl.ONE_MINUS_SRC_ALPHA;
      case BlendFactor.DestinationAlpha:
        return gl.DST_ALPHA;
      case BlendFactor.OneMinusDestinationAlpha:
        return gl.ONE_MINUS_DST_ALPHA;
      case BlendFactor.SourceAlphaSaturate:
        return gl.SRC_ALPHA_SATURATE;
      case BlendFactor.BlendColor:
        return gl.CONSTANT_COLOR;
      case BlendFactor.OneMinusBlendColor:
        return gl.ONE_MINUS_CONSTANT_COLOR;
    }
  };
  BlendState._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
    var gl = rhi.gl;
    switch (blendOperation) {
      case BlendOperation.Add:
        return gl.FUNC_ADD;
      case BlendOperation.Subtract:
        return gl.FUNC_SUBTRACT;
      case BlendOperation.ReverseSubtract:
        return gl.FUNC_REVERSE_SUBTRACT;
      case BlendOperation.Min:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Min is not supported in this context");
        }
        return gl.MIN;
      // in webgl1.0 is an extension
      case BlendOperation.Max:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Max is not supported in this context");
        }
        return gl.MAX;
      // in webgl1.0 is an extension
    }
  }

  /** The blend state of the render target. */;
  var _proto = BlendState.prototype;
  /**
   * @internal
   * Apply the current blend state by comparing with the last blend state.
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.blendState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var lastTargetBlendState = lastState.targetBlendState;
    var _this$targetBlendStat = this.targetBlendState,
      enabled = _this$targetBlendStat.enabled,
      colorBlendOperation = _this$targetBlendStat.colorBlendOperation,
      alphaBlendOperation = _this$targetBlendStat.alphaBlendOperation,
      sourceColorBlendFactor = _this$targetBlendStat.sourceColorBlendFactor,
      destinationColorBlendFactor = _this$targetBlendStat.destinationColorBlendFactor,
      sourceAlphaBlendFactor = _this$targetBlendStat.sourceAlphaBlendFactor,
      destinationAlphaBlendFactor = _this$targetBlendStat.destinationAlphaBlendFactor,
      colorWriteMask = _this$targetBlendStat.colorWriteMask;
    if (enabled !== lastTargetBlendState.enabled) {
      if (enabled) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      lastTargetBlendState.enabled = enabled;
    }
    if (enabled) {
      // apply blend factor.
      if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
        gl.blendFuncSeparate(BlendState._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
        lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
        lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
        lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
        lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
      }

      // apply blend operation.
      if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
        gl.blendEquationSeparate(BlendState._getGLBlendOperation(rhi, colorBlendOperation), BlendState._getGLBlendOperation(rhi, alphaBlendOperation));
        lastTargetBlendState.colorBlendOperation = colorBlendOperation;
        lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
      }

      // apply blend color.
      var blendColor = this.blendColor;
      if (!Color.equals(lastState.blendColor, blendColor)) {
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
        lastState.blendColor.copyFrom(blendColor);
      }
    }

    // apply color mask.
    if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
      gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
      lastTargetBlendState.colorWriteMask = colorWriteMask;
    }

    // apply alpha to coverage.
    var alphaToCoverage = this.alphaToCoverage;
    if (alphaToCoverage !== lastState.alphaToCoverage) {
      if (alphaToCoverage) {
        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      } else {
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      }
      lastState.alphaToCoverage = alphaToCoverage;
    }
  };
  return BlendState;
}();

/**
 * Depth/Stencil comparison function.
 * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.
 */
var CompareFunction;
(function (CompareFunction) {
  CompareFunction[CompareFunction["Never"] = 0] = "Never";
  CompareFunction[CompareFunction["Less"] = 1] = "Less";
  CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
  CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
  CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
  CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
  CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
  CompareFunction[CompareFunction["Always"] = 7] = "Always";
})(CompareFunction || (CompareFunction = {}));

/**
 * Depth state.
 */
var DepthState = /*#__PURE__*/function () {
  function DepthState() {
    this.enabled = true;
    this.writeEnabled = true;
    this.compareFunction = CompareFunction.Less;
  }
  DepthState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;
      case CompareFunction.Less:
        return gl.LESS;
      case CompareFunction.Equal:
        return gl.EQUAL;
      case CompareFunction.LessEqual:
        return gl.LEQUAL;
      case CompareFunction.Greater:
        return gl.GREATER;
      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;
      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  }

  /** Whether to enable the depth test. */;
  var _proto = DepthState.prototype;
  /**
   * @internal
   * Apply the current depth state by comparing with the last depth state.
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.depthState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled,
      compareFunction = this.compareFunction,
      writeEnabled = this.writeEnabled;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      // apply compare func.
      if (compareFunction != lastState.compareFunction) {
        gl.depthFunc(DepthState._getGLCompareFunction(rhi, compareFunction));
        lastState.compareFunction = compareFunction;
      }

      // apply write enabled.
      if (writeEnabled != lastState.writeEnabled) {
        gl.depthMask(writeEnabled);
        lastState.writeEnabled = writeEnabled;
      }
    }
  };
  return DepthState;
}();

/**
 * Culling mode.
 * @remarks specifies whether or not front- and/or back-facing polygons can be culled.
 */
var CullMode;
(function (CullMode) {
  CullMode[CullMode["Off"] = 0] = "Off";
  CullMode[CullMode["Front"] = 1] = "Front";
  CullMode[CullMode["Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));

/**
 * Raster state.
 */
var RasterState = /*#__PURE__*/function () {
  function RasterState() {
    this.cullMode = CullMode.Back;
    this.depthBias = 0;
    this.slopeScaledDepthBias = 0;
    this._cullFaceEnable = true;
    this._frontFaceInvert = false;
  }
  var _proto = RasterState.prototype;
  /**
   * @internal
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState, frontFaceInvert) {
    this._platformApply(hardwareRenderer, lastRenderState.rasterState, frontFaceInvert);
  };
  _proto._platformApply = function _platformApply(rhi, lastState, frontFaceInvert) {
    var gl = rhi.gl;
    var cullMode = this.cullMode,
      depthBias = this.depthBias,
      slopeScaledDepthBias = this.slopeScaledDepthBias;
    var cullFaceEnable = cullMode !== CullMode.Off;
    if (cullFaceEnable !== lastState._cullFaceEnable) {
      if (cullFaceEnable) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      lastState._cullFaceEnable = cullFaceEnable;
    }

    // apply front face.
    if (cullFaceEnable) {
      if (cullMode !== lastState.cullMode) {
        if (cullMode == CullMode.Back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }
        lastState.cullMode = cullMode;
      }
    }
    if (frontFaceInvert !== lastState._frontFaceInvert) {
      if (frontFaceInvert) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      lastState._frontFaceInvert = frontFaceInvert;
    }

    // apply polygonOffset.
    if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
      if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(slopeScaledDepthBias, depthBias);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      lastState.depthBias = depthBias;
      lastState.slopeScaledDepthBias = slopeScaledDepthBias;
    }
  };
  return RasterState;
}();

/**
 * Stencil operation mode.
 * @remarks sets the front and/or back-facing stencil test actions.
 */
var StencilOperation;
(function (StencilOperation) {
  StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
  StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
  StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
  StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
  StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
  StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
  StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
  StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOperation || (StencilOperation = {}));

/**
 * Stencil state.
 */
var StencilState = /*#__PURE__*/function () {
  function StencilState() {
    this.enabled = false;
    this.referenceValue = 0;
    this.mask = 0xff;
    this.writeMask = 0xff;
    this.compareFunctionFront = CompareFunction.Always;
    this.compareFunctionBack = CompareFunction.Always;
    this.passOperationFront = StencilOperation.Keep;
    this.passOperationBack = StencilOperation.Keep;
    this.failOperationFront = StencilOperation.Keep;
    this.failOperationBack = StencilOperation.Keep;
    this.zFailOperationFront = StencilOperation.Keep;
    this.zFailOperationBack = StencilOperation.Keep;
  }
  StencilState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;
      case CompareFunction.Less:
        return gl.LESS;
      case CompareFunction.Equal:
        return gl.EQUAL;
      case CompareFunction.LessEqual:
        return gl.LEQUAL;
      case CompareFunction.Greater:
        return gl.GREATER;
      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;
      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  };
  StencilState._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case StencilOperation.Keep:
        return gl.KEEP;
      case StencilOperation.Zero:
        return gl.ZERO;
      case StencilOperation.Replace:
        return gl.REPLACE;
      case StencilOperation.IncrementSaturate:
        return gl.INCR;
      case StencilOperation.DecrementSaturate:
        return gl.DECR;
      case StencilOperation.Invert:
        return gl.INVERT;
      case StencilOperation.IncrementWrap:
        return gl.INCR_WRAP;
      case StencilOperation.DecrementWrap:
        return gl.DECR_WRAP;
    }
  }

  /** Whether to enable stencil test. */;
  var _proto = StencilState.prototype;
  /**
   * @internal
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.stencilState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled,
      referenceValue = this.referenceValue,
      mask = this.mask,
      compareFunctionFront = this.compareFunctionFront,
      compareFunctionBack = this.compareFunctionBack,
      failOperationFront = this.failOperationFront,
      zFailOperationFront = this.zFailOperationFront,
      passOperationFront = this.passOperationFront,
      failOperationBack = this.failOperationBack,
      zFailOperationBack = this.zFailOperationBack,
      passOperationBack = this.passOperationBack,
      writeMask = this.writeMask;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      // apply stencil func.
      var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
      if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
        gl.stencilFuncSeparate(gl.FRONT, StencilState._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
        lastState.compareFunctionFront = compareFunctionFront;
      }
      if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
        gl.stencilFuncSeparate(gl.BACK, StencilState._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
        lastState.compareFunctionBack = this.compareFunctionBack;
      }
      if (referenceOrMaskChange) {
        lastState.referenceValue = this.referenceValue;
        lastState.mask = this.mask;
      }

      // apply stencil operation.
      if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
        gl.stencilOpSeparate(gl.FRONT, StencilState._getGLStencilOperation(rhi, failOperationFront), StencilState._getGLStencilOperation(rhi, zFailOperationFront), StencilState._getGLStencilOperation(rhi, passOperationFront));
        lastState.failOperationFront = failOperationFront;
        lastState.zFailOperationFront = zFailOperationFront;
        lastState.passOperationFront = passOperationFront;
      }
      if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
        gl.stencilOpSeparate(gl.BACK, StencilState._getGLStencilOperation(rhi, failOperationBack), StencilState._getGLStencilOperation(rhi, zFailOperationBack), StencilState._getGLStencilOperation(rhi, passOperationBack));
        lastState.failOperationBack = failOperationBack;
        lastState.zFailOperationBack = zFailOperationBack;
        lastState.passOperationBack = passOperationBack;
      }

      // apply write mask.
      if (writeMask !== lastState.writeMask) {
        gl.stencilMask(writeMask);
        lastState.writeMask = writeMask;
      }
    }
  };
  return StencilState;
}();

/**
 * Render state.
 */
var RenderState = /*#__PURE__*/function () {
  function RenderState() {
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.stencilState = new StencilState();
    this.rasterState = new RasterState();
  }
  var _proto = RenderState.prototype;
  /**
   * @internal
   */
  _proto._apply = function _apply(engine, frontFaceInvert) {
    var hardwareRenderer = engine._hardwareRenderer;
    var lastRenderState = engine._lastRenderState;
    this.blendState._apply(hardwareRenderer, lastRenderState);
    this.depthState._apply(hardwareRenderer, lastRenderState);
    this.stencilState._apply(hardwareRenderer, lastRenderState);
    this.rasterState._apply(hardwareRenderer, lastRenderState, frontFaceInvert);
  };
  return RenderState;
}();

/**
 * Material.
 */
var Material = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Material, _RefObject);
  /** Name. */

  /** Shader used by the material. */

  /** Render queue type. */

  /** Shader data. */

  /** Render state. */
  // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.

  /**
   * Create a material instance.
   * @param engine - Engine to which the material belongs
   * @param shader - Shader used by the material
   */
  function Material(engine, shader) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.shader = void 0;
    _this.renderQueueType = RenderQueueType.Opaque;
    _this.shaderData = new ShaderData(ShaderDataGroup.Material);
    _this.renderState = new RenderState();
    _this.shader = shader;
    return _this;
  }

  /**
   * Clone and return the instance.
   */
  var _proto = Material.prototype;
  _proto.clone = function clone() {
    var dest = new Material(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  }

  /**
   * Clone to the target material.
   * @param target - target material
   */;
  _proto.cloneTo = function cloneTo(target) {
    target.shader = this.shader;
    target.renderQueueType = this.renderQueueType;
    this.shaderData.cloneTo(target.shaderData);
    CloneManager.deepCloneObject(this.renderState, target.renderState);
  }

  /**
   * @override
   */;
  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);
    this.shaderData._addRefCount(value);
  }

  /**
   * @internal
   * @todo:temporary solution
   */;
  _proto._preRender = function _preRender(renderElement) {}

  /**
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {};
  return Material;
}(RefObject);

/**
 * Class pool utils.
 */
var ClassPool = /*#__PURE__*/function () {
  function ClassPool(type) {
    this._elementPoolIndex = 0;
    this._elementPool = [];
    this._type = void 0;
    this._type = type;
  }

  /**
   * Get element from pool.
   */
  var _proto = ClassPool.prototype;
  _proto.getFromPool = function getFromPool() {
    var index = this._elementPoolIndex,
      pool = this._elementPool;
    this._elementPoolIndex++;
    if (pool.length === index) {
      var element = new this._type();
      pool.push(element);
      return element;
    } else {
      return pool[index];
    }
  }

  /**
   * Reset pool.
   */;
  _proto.resetPool = function resetPool() {
    this._elementPoolIndex = 0;
  };
  return ClassPool;
}();

var RenderElement = function RenderElement() {
  this.component = void 0;
  this.material = void 0;
  this.multiRenderData = void 0;
};

/**
 * Render element.
 */
var MeshRenderElement = /*#__PURE__*/function (_RenderElement) {
  _inheritsLoose(MeshRenderElement, _RenderElement);
  function MeshRenderElement() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RenderElement.call.apply(_RenderElement, [this].concat(args)) || this;
    _this.mesh = void 0;
    _this.subMesh = void 0;
    return _this;
  }
  var _proto = MeshRenderElement.prototype;
  _proto.setValue = function setValue(component, mesh, subMesh, material) {
    this.component = component;
    this.mesh = mesh;
    this.subMesh = subMesh;
    this.material = material;
  };
  return MeshRenderElement;
}(RenderElement);

/**
 * Rendering context.
 */
var RenderContext = /*#__PURE__*/function () {
  function RenderContext() {
    this._camera = void 0;
    this._viewProjectMatrix = new Matrix();
  }
  var _proto = RenderContext.prototype;
  /**
   * @internal
   */
  _proto._setContext = function _setContext(camera) {
    this._camera = camera;
    Matrix.multiply(camera.projectionMatrix, camera.viewMatrix, this._viewProjectMatrix);
  };
  return RenderContext;
}();

var SpriteElement = /*#__PURE__*/function (_RenderElement) {
  _inheritsLoose(SpriteElement, _RenderElement);
  function SpriteElement() {
    var _this;
    _this = _RenderElement.call(this) || this;
    _this.renderData = void 0;
    _this.texture = void 0;
    _this.multiRenderData = false;
    return _this;
  }
  var _proto = SpriteElement.prototype;
  _proto.setValue = function setValue(component, renderDate, material, texture) {
    this.component = component;
    this.renderData = renderDate;
    this.material = material;
    this.texture = texture;
  };
  return SpriteElement;
}(RenderElement);

var SpriteMaskElement = /*#__PURE__*/function (_RenderElement) {
  _inheritsLoose(SpriteMaskElement, _RenderElement);
  function SpriteMaskElement() {
    var _this;
    _this = _RenderElement.call(this) || this;
    _this.renderData = void 0;
    _this.isAdd = true;
    _this.multiRenderData = false;
    return _this;
  }
  var _proto = SpriteMaskElement.prototype;
  _proto.setValue = function setValue(component, renderData, material) {
    this.component = component;
    this.renderData = renderData;
    this.material = material;
  };
  return SpriteMaskElement;
}(RenderElement);

/**
 * Sprite mask interaction.
 */
var SpriteMaskInteraction;
(function (SpriteMaskInteraction) {
  SpriteMaskInteraction[SpriteMaskInteraction["None"] = 0] = "None";
  SpriteMaskInteraction[SpriteMaskInteraction["VisibleInsideMask"] = 1] = "VisibleInsideMask";
  SpriteMaskInteraction[SpriteMaskInteraction["VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
})(SpriteMaskInteraction || (SpriteMaskInteraction = {}));

var _dec$3, _class$a, _class2$9, _descriptor$8, _descriptor2$8, _descriptor3$7, _descriptor4$7, _descriptor5$7, _descriptor6$7, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$3, _descriptor11$3, _descriptor12$3, _descriptor13$2, _descriptor14$1, _descriptor15$1, _descriptor16$1, _class3$1;

/**
 * Basis for all renderers.
 * @decorator `@dependentComponents(Transform)`
 */
var Renderer = (_dec$3 = dependentComponents(Transform), _dec$3(_class$a = (_class2$9 = (_class3$1 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Renderer, _Component);
  /**
   * @internal
   */
  function Renderer(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _initializerDefineProperty(_this, "shaderData", _descriptor$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "isCulled", _descriptor2$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_distanceForSort", _descriptor3$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor4$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rendererIndex", _descriptor5$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_globalShaderMacro", _descriptor6$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_transformChangeFlag", _descriptor7$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_bounds", _descriptor8$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_overrideUpdate", _descriptor9$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_materials", _descriptor10$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvMatrix", _descriptor11$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvpMatrix", _descriptor12$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvInvMatrix", _descriptor13$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_normalMatrix", _descriptor14$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_materialsInstanced", _descriptor15$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_priority", _descriptor16$1, _assertThisInitialized(_this));
    var prototype = Renderer.prototype;
    _this._overrideUpdate = _this.update !== prototype.update;
    _this._transformChangeFlag = _this.entity.transform.registerWorldChangeFlag();
    _this.shaderData._addRefCount(1);
    return _this;
  }

  /**
   * Get the first instance material.
   * @returns The first instance material
   */
  var _proto = Renderer.prototype;
  _proto.getInstanceMaterial = function getInstanceMaterial(index) {
    if (index === void 0) {
      index = 0;
    }
    var materials = this._materials;
    if (materials.length > index) {
      var _material = materials[index];
      if (_material) {
        if (this._materialsInstanced[index]) {
          return _material;
        } else {
          return this._createInstanceMaterial(_material, index);
        }
      }
    }
    return null;
  }

  /**
   * Get the first material.
   * @returns The first material
   */;
  _proto.getMaterial = function getMaterial(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._materials[index] || null;
  }

  /**
   * Set the first material.
   * @param material - The first material
   */;
  _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
    if (material === void 0) {
      material = null;
    }
    if (typeof indexOrMaterial === "number") {
      this._setMaterial(indexOrMaterial, material);
    } else {
      this._setMaterial(0, indexOrMaterial);
    }
  }

  /**
   * Get all instance materials.
   * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.
   * @returns All instance materials
   */;
  _proto.getInstanceMaterials = function getInstanceMaterials() {
    var materials = this._materials;
    var materialsInstance = this._materialsInstanced;
    for (var i = 0, n = materials.length; i < n; i++) {
      if (!materialsInstance[i]) {
        this._createInstanceMaterial(this._materials[i], i);
      }
    }
    return materials;
  }

  /**
   * Get all materials.
   * @returns All materials
   */;
  _proto.getMaterials = function getMaterials() {
    return this._materials;
  }

  /**
   * Set all materials.
   * @param materials - All materials
   */;
  _proto.setMaterials = function setMaterials(materials) {
    var count = materials.length;
    var internalMaterials = this._materials;
    var materialsInstanced = this._materialsInstanced;
    for (var i = count, n = internalMaterials.length; i < n; i++) {
      var internalMaterial = internalMaterials[i];
      internalMaterial && internalMaterial._addRefCount(-1);
    }
    internalMaterials.length !== count && (internalMaterials.length = count);
    materialsInstanced.length !== 0 && (materialsInstanced.length = 0);
    for (var _i = 0; _i < count; _i++) {
      var _internalMaterial = internalMaterials[_i];
      var _material2 = materials[_i];
      if (_internalMaterial !== _material2) {
        internalMaterials[_i] = _material2;
        _internalMaterial && _internalMaterial._addRefCount(-1);
        _material2 && _material2._addRefCount(1);
      }
    }
  };
  _proto.update = function update(deltaTime) {}

  /**
   * @internal
   */;
  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    var worldMatrix = this.entity.transform.worldMatrix;
    var mvMatrix = this._mvMatrix;
    var mvpMatrix = this._mvpMatrix;
    var mvInvMatrix = this._mvInvMatrix;
    var normalMatrix = this._normalMatrix;
    Matrix.multiply(context._camera.viewMatrix, worldMatrix, mvMatrix);
    Matrix.multiply(context._viewProjectMatrix, worldMatrix, mvpMatrix);
    Matrix.invert(mvMatrix, mvInvMatrix);
    Matrix.invert(worldMatrix, normalMatrix);
    normalMatrix.transpose();
    shaderData.setMatrix(Renderer._localMatrixProperty, this.entity.transform.localMatrix);
    shaderData.setMatrix(Renderer._worldMatrixProperty, worldMatrix);
    shaderData.setMatrix(Renderer._mvMatrixProperty, mvMatrix);
    shaderData.setMatrix(Renderer._mvpMatrixProperty, mvpMatrix);
    shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);
    shaderData.setMatrix(Renderer._normalMatrixProperty, normalMatrix);
  };
  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.addOnUpdateRenderers(this);
    }
    componentsManager.addRenderer(this);
  };
  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.removeOnUpdateRenderers(this);
    }
    componentsManager.removeRenderer(this);
  }

  /**
   * @internal
   */;
  _proto._render = function _render(camera) {
    throw "not implement";
  }

  /**
   * @internal
   */;
  _proto._onDestroy = function _onDestroy() {
    var flag = this._transformChangeFlag;
    if (flag) {
      flag.destroy();
      this._transformChangeFlag = null;
    }
    this.shaderData._addRefCount(-1);
    var materials = this._materials;
    for (var i = 0, n = materials.length; i < n; i++) {
      var _materials$i;
      (_materials$i = materials[i]) === null || _materials$i === void 0 ? void 0 : _materials$i._addRefCount(-1);
    }
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {};
  _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
    var insMaterial = material.clone();
    insMaterial.name = insMaterial.name + "(Instance)";
    material._addRefCount(-1);
    insMaterial._addRefCount(1);
    this._materialsInstanced[index] = true;
    this._materials[index] = insMaterial;
    return insMaterial;
  };
  _proto._setMaterial = function _setMaterial(index, material) {
    var materials = this._materials;
    if (index >= materials.length) {
      materials.length = index + 1;
    }
    var internalMaterial = materials[index];
    if (internalMaterial !== material) {
      var materialsInstance = this._materialsInstanced;
      index < materialsInstance.length && (materialsInstance[index] = false);
      internalMaterial && internalMaterial._addRefCount(-1);
      material && material._addRefCount(1);
      materials[index] = material;
    }
  };
  _createClass(Renderer, [{
    key: "materialCount",
    get: /** ShaderData related to renderer. */

    /** Whether it is clipped by the frustum, needs to be turned on camera.enableFrustumCulling. */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Material count.
     */
    function get() {
      return this._materials.length;
    },
    set: function set(value) {
      var materials = this._materials;
      var materialsInstanced = this._materialsInstanced;
      materials.length !== value && (materials.length = value);
      materialsInstanced.length > value && (materialsInstanced.length = value);
    }

    /**
     * The bounding volume of the renderer.
     */
  }, {
    key: "bounds",
    get: function get() {
      var changeFlag = this._transformChangeFlag;
      if (changeFlag.flag) {
        this._updateBounds(this._bounds);
        changeFlag.flag = false;
      }
      return this._bounds;
    }

    /**
     * The render priority of the renderer, lower values are rendered first and higher values are rendered last.
     */
  }, {
    key: "priority",
    get: function get() {
      return this._priority;
    },
    set: function set(value) {
      this._priority = value;
    }
  }]);
  return Renderer;
}(Component), _class3$1._localMatrixProperty = Shader.getPropertyByName("u_localMat"), _class3$1._worldMatrixProperty = Shader.getPropertyByName("u_modelMat"), _class3$1._mvMatrixProperty = Shader.getPropertyByName("u_MVMat"), _class3$1._mvpMatrixProperty = Shader.getPropertyByName("u_MVPMat"), _class3$1._mvInvMatrixProperty = Shader.getPropertyByName("u_MVInvMat"), _class3$1._normalMatrixProperty = Shader.getPropertyByName("u_normalMat"), _class3$1), (_descriptor$8 = _applyDecoratedDescriptor(_class2$9.prototype, "shaderData", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ShaderData(ShaderDataGroup.Renderer);
  }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class2$9.prototype, "isCulled", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor3$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_distanceForSort", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor5$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_rendererIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor6$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_globalShaderMacro", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ShaderMacroCollection();
  }
}), _descriptor7$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_transformChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_bounds", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new BoundingBox();
  }
}), _descriptor9$6 = _applyDecoratedDescriptor(_class2$9.prototype, "_overrideUpdate", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor10$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_materials", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor11$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_mvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor12$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_mvpMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor13$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_mvInvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor14$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_normalMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor15$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_materialsInstanced", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor16$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_priority", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
})), _class2$9)) || _class$a);

/**
 *  Static interface implement decorator.
 *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
 */
function StaticInterfaceImplement() {
  return function (constructor) {
  };
}

var _dec$2, _class$9, _class2$8;

/**
 * @internal
 */
var SimpleSpriteAssembler = (_dec$2 = StaticInterfaceImplement(), _dec$2(_class$9 = (_class2$8 = /*#__PURE__*/function () {
  function SimpleSpriteAssembler() {}
  SimpleSpriteAssembler.resetData = function resetData(renderer) {
    var renderData = renderer._renderData;
    var vertexCount = renderData.vertexCount = 4;
    var positions = renderData.positions,
      uvs = renderData.uvs;
    if (positions.length < vertexCount) {
      for (var i = positions.length; i < vertexCount; i++) {
        positions.push(new Vector3());
        uvs.push(new Vector2());
      }
    }
    renderData.triangles = SimpleSpriteAssembler._rectangleTriangles;
  };
  SimpleSpriteAssembler.updatePositions = function updatePositions(renderer) {
    var width = renderer.width,
      height = renderer.height,
      sprite = renderer.sprite;
    var _sprite$pivot = sprite.pivot,
      pivotX = _sprite$pivot.x,
      pivotY = _sprite$pivot.y;
    // Renderer's worldMatrix;
    var worldMatrix = SimpleSpriteAssembler._worldMatrix;
    var wE = worldMatrix.elements;
    // Parent's worldMatrix.
    var pWE = renderer.entity.transform.worldMatrix.elements;
    var sx = renderer.flipX ? -width : width;
    var sy = renderer.flipY ? -height : height;
    wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
    wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
    wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
    wE[12] = pWE[12] - pivotX * wE[0] - pivotY * wE[4];
    wE[13] = pWE[13] - pivotX * wE[1] - pivotY * wE[5];
    wE[14] = pWE[14] - pivotX * wE[2] - pivotY * wE[6];

    // ---------------
    //  2 - 3
    //  |   |
    //  0 - 1
    // ---------------
    // Update positions.
    var spritePositions = sprite._getPositions();
    var positions = renderer._renderData.positions;
    for (var i = 0; i < 4; i++) {
      var _spritePositions$i = spritePositions[i],
        x = _spritePositions$i.x,
        y = _spritePositions$i.y;
      positions[i].set(wE[0] * x + wE[4] * y + wE[12], wE[1] * x + wE[5] * y + wE[13], wE[2] * x + wE[6] * y + wE[14]);
    }
    BoundingBox.transform(sprite._getBounds(), worldMatrix, renderer._bounds);
  };
  SimpleSpriteAssembler.updateUVs = function updateUVs(renderer) {
    var spriteUVs = renderer.sprite._getUVs();
    var renderUVs = renderer._renderData.uvs;
    var _spriteUVs$ = spriteUVs[0],
      left = _spriteUVs$.x,
      bottom = _spriteUVs$.y;
    var _spriteUVs$2 = spriteUVs[3],
      right = _spriteUVs$2.x,
      top = _spriteUVs$2.y;
    renderUVs[0].set(left, bottom);
    renderUVs[1].set(right, bottom);
    renderUVs[2].set(left, top);
    renderUVs[3].set(right, top);
  };
  return SimpleSpriteAssembler;
}(), _class2$8._rectangleTriangles = [0, 1, 2, 2, 1, 3], _class2$8._worldMatrix = new Matrix(), _class2$8)) || _class$9);

/**
 * @internal
 */
var RenderData2D = function RenderData2D(vertexCount, positions, uvs, triangles, color) {
  if (triangles === void 0) {
    triangles = null;
  }
  if (color === void 0) {
    color = null;
  }
  this.vertexCount = vertexCount;
  this.positions = positions;
  this.uvs = uvs;
  this.triangles = triangles;
  this.color = color;
};

/**
 * Sprite Property Dirty Flag.
 */
var SpritePropertyDirtyFlag;
(function (SpritePropertyDirtyFlag) {
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["texture"] = 1] = "texture";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["size"] = 2] = "size";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["atlasRotate"] = 4] = "atlasRotate";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["atlasRegion"] = 8] = "atlasRegion";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["atlasRegionOffset"] = 16] = "atlasRegionOffset";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["region"] = 32] = "region";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["pivot"] = 64] = "pivot";
  SpritePropertyDirtyFlag[SpritePropertyDirtyFlag["border"] = 128] = "border";
})(SpritePropertyDirtyFlag || (SpritePropertyDirtyFlag = {}));

/**
 * Sprite mask layer.
 */
var SpriteMaskLayer;
(function (SpriteMaskLayer) {
  SpriteMaskLayer[SpriteMaskLayer["Layer0"] = 1] = "Layer0";
  SpriteMaskLayer[SpriteMaskLayer["Layer1"] = 2] = "Layer1";
  SpriteMaskLayer[SpriteMaskLayer["Layer2"] = 4] = "Layer2";
  SpriteMaskLayer[SpriteMaskLayer["Layer3"] = 8] = "Layer3";
  SpriteMaskLayer[SpriteMaskLayer["Layer4"] = 16] = "Layer4";
  SpriteMaskLayer[SpriteMaskLayer["Layer5"] = 32] = "Layer5";
  SpriteMaskLayer[SpriteMaskLayer["Layer6"] = 64] = "Layer6";
  SpriteMaskLayer[SpriteMaskLayer["Layer7"] = 128] = "Layer7";
  SpriteMaskLayer[SpriteMaskLayer["Layer8"] = 256] = "Layer8";
  SpriteMaskLayer[SpriteMaskLayer["Layer9"] = 512] = "Layer9";
  SpriteMaskLayer[SpriteMaskLayer["Layer10"] = 1024] = "Layer10";
  SpriteMaskLayer[SpriteMaskLayer["Layer11"] = 2048] = "Layer11";
  SpriteMaskLayer[SpriteMaskLayer["Layer12"] = 4096] = "Layer12";
  SpriteMaskLayer[SpriteMaskLayer["Layer13"] = 8192] = "Layer13";
  SpriteMaskLayer[SpriteMaskLayer["Layer14"] = 16384] = "Layer14";
  SpriteMaskLayer[SpriteMaskLayer["Layer15"] = 32768] = "Layer15";
  SpriteMaskLayer[SpriteMaskLayer["Layer16"] = 65536] = "Layer16";
  SpriteMaskLayer[SpriteMaskLayer["Layer17"] = 131072] = "Layer17";
  SpriteMaskLayer[SpriteMaskLayer["Layer18"] = 262144] = "Layer18";
  SpriteMaskLayer[SpriteMaskLayer["Layer19"] = 524288] = "Layer19";
  SpriteMaskLayer[SpriteMaskLayer["Layer20"] = 1048576] = "Layer20";
  SpriteMaskLayer[SpriteMaskLayer["Layer21"] = 2097152] = "Layer21";
  SpriteMaskLayer[SpriteMaskLayer["Layer22"] = 4194304] = "Layer22";
  SpriteMaskLayer[SpriteMaskLayer["Layer23"] = 8388608] = "Layer23";
  SpriteMaskLayer[SpriteMaskLayer["Layer24"] = 16777216] = "Layer24";
  SpriteMaskLayer[SpriteMaskLayer["Layer25"] = 33554432] = "Layer25";
  SpriteMaskLayer[SpriteMaskLayer["Layer26"] = 67108864] = "Layer26";
  SpriteMaskLayer[SpriteMaskLayer["Layer27"] = 134217728] = "Layer27";
  SpriteMaskLayer[SpriteMaskLayer["Layer28"] = 268435456] = "Layer28";
  SpriteMaskLayer[SpriteMaskLayer["Layer29"] = 536870912] = "Layer29";
  SpriteMaskLayer[SpriteMaskLayer["Layer30"] = 1073741824] = "Layer30";
  SpriteMaskLayer[SpriteMaskLayer["Layer31"] = 2147483648] = "Layer31";
  SpriteMaskLayer[SpriteMaskLayer["Everything"] = 4294967295] = "Everything";
})(SpriteMaskLayer || (SpriteMaskLayer = {}));

var _class$8, _descriptor$7, _descriptor2$7, _descriptor3$6, _descriptor4$6, _descriptor5$6, _descriptor6$6, _descriptor7$6, _descriptor8$6, _descriptor9$5, _class2$7;
/**
 * A component for masking Sprites.
 */
var SpriteMask = (_class$8 = (_class2$7 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(SpriteMask, _Renderer);
  /**
   * @internal
   */
  function SpriteMask(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "influenceLayers", _descriptor$7, _assertThisInitialized(_this));
    _this._maskElement = void 0;
    _this._renderData = void 0;
    _initializerDefineProperty(_this, "_sprite", _descriptor2$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_width", _descriptor3$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_height", _descriptor4$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_flipX", _descriptor5$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_flipY", _descriptor6$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_alphaCutoff", _descriptor7$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_dirtyFlag", _descriptor8$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_spriteChangeFlag", _descriptor9$5, _assertThisInitialized(_this));
    _this._renderData = new RenderData2D(4, [], []);
    SimpleSpriteAssembler.resetData(_assertThisInitialized(_this));
    _this.setMaterial(_this._engine._spriteMaskDefaultMaterial);
    _this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, _this._alphaCutoff);
    _this._onSpriteChange = _this._onSpriteChange.bind(_assertThisInitialized(_this));
    return _this;
  }

  /**
   * @override
   * @inheritdoc
   */
  var _proto = SpriteMask.prototype;
  _proto._onDestroy = function _onDestroy() {
    this._sprite = null;
    this._renderData = null;
    if (this._spriteChangeFlag) {
      this._spriteChangeFlag.destroy();
      this._spriteChangeFlag = null;
    }
    _Renderer.prototype._onDestroy.call(this);
  }

  /**
   * @override
   * @inheritdoc
   */;
  _proto._render = function _render(camera) {
    var _this$sprite;
    if (!((_this$sprite = this.sprite) !== null && _this$sprite !== void 0 && _this$sprite.texture) || !this.width || !this.height) {
      return;
    }
    // Update position.
    if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$3.Position) {
      SimpleSpriteAssembler.updatePositions(this);
      this._dirtyFlag &= ~DirtyFlag$3.Position;
      this._transformChangeFlag.flag = false;
    }

    // Update uv.
    if (this._dirtyFlag & DirtyFlag$3.UV) {
      SimpleSpriteAssembler.updateUVs(this);
      this._dirtyFlag &= ~DirtyFlag$3.UV;
    }
    var spriteMaskElementPool = this._engine._spriteMaskElementPool;
    var maskElement = spriteMaskElementPool.getFromPool();
    maskElement.setValue(this, this._renderData, this.getMaterial());
    camera._renderPipeline._allSpriteMasks.add(this);
    this._maskElement = maskElement;
  }

  /**
   * @internal
   */;
  _proto._cloneTo = function _cloneTo(target) {
    target.sprite = this._sprite;
  };
  _proto._onSpriteChange = function _onSpriteChange(dirtyFlag) {
    switch (dirtyFlag) {
      case SpritePropertyDirtyFlag.texture:
        this.shaderData.setTexture(SpriteMask._textureProperty, this.sprite.texture);
        break;
      case SpritePropertyDirtyFlag.region:
      case SpritePropertyDirtyFlag.atlasRegionOffset:
        this._dirtyFlag |= DirtyFlag$3.All;
        break;
      case SpritePropertyDirtyFlag.atlasRegion:
        this._dirtyFlag |= DirtyFlag$3.UV;
        break;
    }
  };
  _createClass(SpriteMask, [{
    key: "width",
    get: /** @internal */

    /** @internal */

    /** The mask layers the sprite mask influence to. */

    /** @internal */

    /** @internal */

    /**
     * Render width.
     */
    function get() {
      if (this._width === undefined && this._sprite) {
        this.width = this._sprite.width;
      }
      return this._width;
    },
    set: function set(value) {
      if (this._width !== value) {
        this._width = value;
        this._dirtyFlag |= DirtyFlag$3.Position;
      }
    }

    /**
     * Render height.
     */
  }, {
    key: "height",
    get: function get() {
      if (this._height === undefined && this._sprite) {
        this.height = this._sprite.height;
      }
      return this._height;
    },
    set: function set(value) {
      if (this._height !== value) {
        this._height = value;
        this._dirtyFlag |= DirtyFlag$3.Position;
      }
    }

    /**
     * Flips the sprite on the X axis.
     */
  }, {
    key: "flipX",
    get: function get() {
      return this._flipX;
    },
    set: function set(value) {
      if (this._flipX !== value) {
        this._flipX = value;
        this._dirtyFlag |= DirtyFlag$3.Position;
      }
    }

    /**
     * Flips the sprite on the Y axis.
     */
  }, {
    key: "flipY",
    get: function get() {
      return this._flipY;
    },
    set: function set(value) {
      if (this._flipY !== value) {
        this._flipY = value;
        this._dirtyFlag |= DirtyFlag$3.Position;
      }
    }

    /**
     * The Sprite to render.
     */
  }, {
    key: "sprite",
    get: function get() {
      return this._sprite;
    },
    set: function set(value) {
      if (this._sprite !== value) {
        this._sprite = value;
        this._spriteChangeFlag && this._spriteChangeFlag.destroy();
        if (value) {
          this._spriteChangeFlag = value._registerUpdateFlag();
          this._spriteChangeFlag.listener = this._onSpriteChange;
          this._dirtyFlag |= DirtyFlag$3.All;
          this.shaderData.setTexture(SpriteMask._textureProperty, value.texture);
        } else {
          this._spriteChangeFlag = null;
          this.shaderData.setTexture(SpriteMask._textureProperty, null);
        }
      }
    }

    /**
     * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.
     */
  }, {
    key: "alphaCutoff",
    get: function get() {
      return this._alphaCutoff;
    },
    set: function set(value) {
      if (this._alphaCutoff !== value) {
        this._alphaCutoff = value;
        this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, value);
      }
    }

    /**
     * The bounding volume of the spriteRenderer.
     */
  }, {
    key: "bounds",
    get: function get() {
      var _this$sprite2;
      if (!((_this$sprite2 = this.sprite) !== null && _this$sprite2 !== void 0 && _this$sprite2.texture) || !this.width || !this.height) {
        return Engine._defaultBoundingBox;
      } else if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$3.Position) {
        SimpleSpriteAssembler.updatePositions(this);
        this._dirtyFlag &= ~DirtyFlag$3.Position;
        this._transformChangeFlag.flag = false;
      }
      return this._bounds;
    }
  }]);
  return SpriteMask;
}(Renderer), _class2$7._textureProperty = Shader.getPropertyByName("u_maskTexture"), _class2$7._alphaCutoffProperty = Shader.getPropertyByName("u_maskAlphaCutoff"), _class2$7), (_descriptor$7 = _applyDecoratedDescriptor(_class$8.prototype, "influenceLayers", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskLayer.Everything;
  }
}), _descriptor2$7 = _applyDecoratedDescriptor(_class$8.prototype, "_sprite", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class$8.prototype, "_width", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return undefined;
  }
}), _descriptor4$6 = _applyDecoratedDescriptor(_class$8.prototype, "_height", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return undefined;
  }
}), _descriptor5$6 = _applyDecoratedDescriptor(_class$8.prototype, "_flipX", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor6$6 = _applyDecoratedDescriptor(_class$8.prototype, "_flipY", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor7$6 = _applyDecoratedDescriptor(_class$8.prototype, "_alphaCutoff", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.5;
  }
}), _descriptor8$6 = _applyDecoratedDescriptor(_class$8.prototype, "_dirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor9$5 = _applyDecoratedDescriptor(_class$8.prototype, "_spriteChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class$8);
var DirtyFlag$3;
(function (DirtyFlag) {
  DirtyFlag[DirtyFlag["Position"] = 1] = "Position";
  DirtyFlag[DirtyFlag["UV"] = 2] = "UV";
  DirtyFlag[DirtyFlag["All"] = 3] = "All";
})(DirtyFlag$3 || (DirtyFlag$3 = {}));

/**
 * Vertex element format.
 */
var VertexElementFormat;
(function (VertexElementFormat) {
  VertexElementFormat[VertexElementFormat["Float"] = 0] = "Float";
  VertexElementFormat[VertexElementFormat["Vector2"] = 1] = "Vector2";
  VertexElementFormat[VertexElementFormat["Vector3"] = 2] = "Vector3";
  VertexElementFormat[VertexElementFormat["Vector4"] = 3] = "Vector4";
  VertexElementFormat[VertexElementFormat["Byte4"] = 4] = "Byte4";
  VertexElementFormat[VertexElementFormat["UByte4"] = 5] = "UByte4";
  VertexElementFormat[VertexElementFormat["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat[VertexElementFormat["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat[VertexElementFormat["Short2"] = 8] = "Short2";
  VertexElementFormat[VertexElementFormat["UShort2"] = 9] = "UShort2";
  VertexElementFormat[VertexElementFormat["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat[VertexElementFormat["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat[VertexElementFormat["Short4"] = 12] = "Short4";
  VertexElementFormat[VertexElementFormat["UShort4"] = 13] = "UShort4";
  VertexElementFormat[VertexElementFormat["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat[VertexElementFormat["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));

/**
 * Buffer usage.
 */
var BufferUsage;
(function (BufferUsage) {
  BufferUsage[BufferUsage["Static"] = 0] = "Static";
  BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
  BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));

/**
 * Index format.
 */
var IndexFormat;
(function (IndexFormat) {
  IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
  IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
  IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));

var BufferUtil = /*#__PURE__*/function () {
  function BufferUtil() {}
  /**
   * @internal
   */
  BufferUtil._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
    switch (bufferUsage) {
      case BufferUsage.Static:
        return gl.STATIC_DRAW;
      case BufferUsage.Dynamic:
        return gl.DYNAMIC_DRAW;
      case BufferUsage.Stream:
        return gl.STREAM_DRAW;
    }
  };
  BufferUtil._getGLIndexType = function _getGLIndexType(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return DataType.UNSIGNED_BYTE;
      case IndexFormat.UInt16:
        return DataType.UNSIGNED_SHORT;
      case IndexFormat.UInt32:
        return DataType.UNSIGNED_INT;
    }
  };
  BufferUtil._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return 1;
      case IndexFormat.UInt16:
        return 2;
      case IndexFormat.UInt32:
        return 4;
    }
  }

  /**
   * @internal
   */;
  BufferUtil._getElementInfo = function _getElementInfo(format) {
    var size;
    var type;
    var normalized = false;
    switch (format) {
      case VertexElementFormat.Float:
        size = 1;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector2:
        size = 2;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector3:
        size = 3;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector4:
        size = 4;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Byte4:
        size = 4;
        type = DataType.BYTE;
        break;
      case VertexElementFormat.UByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        break;
      case VertexElementFormat.NormalizedByte4:
        size = 4;
        type = DataType.BYTE;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        normalized = true;
        break;
      case VertexElementFormat.Short2:
        size = 2;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.NormalizedShort2:
        size = 2;
        type = DataType.SHORT;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
      case VertexElementFormat.Short4:
        size = 4;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.NormalizedShort4:
        size = 4;
        type = DataType.SHORT;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
    }
    return {
      size: size,
      type: type,
      normalized: normalized
    };
  };
  return BufferUtil;
}();

/**
 * Vertex element.
 */
var VertexElement = /*#__PURE__*/function () {
  /**
   * Create vertex element.
   * @param semantic - Input vertex semantic
   * @param offset - Vertex data byte offset
   * @param format - Vertex data format
   * @param bindingIndex - Vertex buffer binding index
   * @param instanceStepRate - Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
   */
  function VertexElement(semantic, offset, format, bindingIndex, instanceStepRate) {
    if (instanceStepRate === void 0) {
      instanceStepRate = 0;
    }
    this._glElementInfo = void 0;
    this._semantic = void 0;
    this._offset = void 0;
    this._format = void 0;
    this._bindingIndex = void 0;
    this._instanceStepRate = void 0;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }
  _createClass(VertexElement, [{
    key: "semantic",
    get:
    /**
     * Vertex semantic.
     */
    function get() {
      return this._semantic;
    }

    /**
     * Vertex data byte offset.
     */
  }, {
    key: "offset",
    get: function get() {
      return this._offset;
    },
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Vertex data format.
     */
  }, {
    key: "format",
    get: function get() {
      return this._format;
    }

    /**
     * Vertex buffer binding index.
     */
  }, {
    key: "bindingIndex",
    get: function get() {
      return this._bindingIndex;
    },
    set: function set(value) {
      this._bindingIndex = value;
    }

    /**
     * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
     */
  }, {
    key: "instanceStepRate",
    get: function get() {
      return this._instanceStepRate;
    }
  }]);
  return VertexElement;
}();

/**
 * Buffer binding flag.
 */
var BufferBindFlag;
(function (BufferBindFlag) {
  BufferBindFlag[BufferBindFlag["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag[BufferBindFlag["IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));

/**
 * Define update strategy when call bufferData/bufferSubData func.
 */
var SetDataOptions;
(function (SetDataOptions) {
  SetDataOptions[SetDataOptions["None"] = 0] = "None";
  SetDataOptions[SetDataOptions["Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));

/**
 * Buffer.
 */
var Buffer = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Buffer, _RefObject);
  function Buffer(engine, type, byteLengthOrData, bufferUsage) {
    var _this;
    if (bufferUsage === void 0) {
      bufferUsage = BufferUsage.Static;
    }
    _this = _RefObject.call(this, engine) || this;
    _this._glBindTarget = void 0;
    _this._glBufferUsage = void 0;
    _this._nativeBuffer = void 0;
    _this._hardwareRenderer = void 0;
    _this._type = void 0;
    _this._byteLength = void 0;
    _this._bufferUsage = void 0;
    _this._engine = engine;
    _this._type = type;
    _this._bufferUsage = bufferUsage;
    var hardwareRenderer = engine._hardwareRenderer;
    var gl = hardwareRenderer.gl;
    var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);
    var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    _this._nativeBuffer = gl.createBuffer();
    _this._hardwareRenderer = hardwareRenderer;
    _this._glBufferUsage = glBufferUsage;
    _this._glBindTarget = glBindTarget;
    _this.bind();
    if (typeof byteLengthOrData === "number") {
      _this._byteLength = byteLengthOrData;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    } else {
      _this._byteLength = byteLengthOrData.byteLength;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    }
    gl.bindBuffer(glBindTarget, null);
    return _this;
  }

  /**
   * Bind buffer.
   */
  var _proto = Buffer.prototype;
  _proto.bind = function bind() {
    var gl = this._hardwareRenderer.gl;
    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
  }

  /**
   * Set buffer data.
   * @param data - Input buffer data
   */;
  _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }
    if (dataOffset === void 0) {
      dataOffset = 0;
    }
    if (options === void 0) {
      options = SetDataOptions.None;
    }
    var gl = this._hardwareRenderer.gl;
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    var glBindTarget = this._glBindTarget;
    this.bind();
    if (options === SetDataOptions.Discard) {
      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
    }

    // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1
    var byteSize = data.BYTES_PER_ELEMENT || 1;
    var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
    if (dataOffset !== 0 || dataByteLength < data.byteLength) {
      var isArrayBufferView = data.byteOffset !== undefined;
      if (isWebGL2 && isArrayBufferView) {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
      } else {
        var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
      }
    } else {
      gl.bufferSubData(glBindTarget, bufferByteOffset, data);
    }
    gl.bindBuffer(glBindTarget, null);
  }

  /**
   * Get buffer data.
   * @param data - Output buffer data
   */;
  _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }
    if (dataOffset === void 0) {
      dataOffset = 0;
    }
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    if (isWebGL2) {
      var gl = this._hardwareRenderer.gl;
      this.bind();
      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
    } else {
      throw "Buffer is write-only on WebGL1.0 platforms.";
    }
  }

  /**
   * @override
   * Destroy.
   */;
  _proto._onDestroy = function _onDestroy() {
    var gl = this._hardwareRenderer.gl;
    gl.deleteBuffer(this._nativeBuffer);
    this._nativeBuffer = null;
    this._hardwareRenderer = null;
  }

  /**
   * @deprecated
   */;
  _proto.resize = function resize(dataLength) {
    this.bind();
    var gl = this._hardwareRenderer.gl;
    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
    this._byteLength = dataLength;
  };
  _createClass(Buffer, [{
    key: "type",
    get:
    /**
     * Buffer binding flag.
     */
    function get() {
      return this._type;
    }

    /**
     * Byte length.
     */
  }, {
    key: "byteLength",
    get: function get() {
      return this._byteLength;
    }

    /**
     * Buffer usage.
     */
  }, {
    key: "bufferUsage",
    get: function get() {
      return this._bufferUsage;
    }

    /**
     * Create Buffer.
     * @param engine - Engine
     * @param type - Buffer binding flag
     * @param byteLength - Byte length
     * @param bufferUsage - Buffer usage
     */
  }]);
  return Buffer;
}(RefObject);

/**
 * Mesh topology.
 */
var MeshTopology;
(function (MeshTopology) {
  MeshTopology[MeshTopology["Points"] = 0] = "Points";
  MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
  MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
  MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
  MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
  MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
  MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
})(MeshTopology || (MeshTopology = {}));

/**
 * Index buffer binding.
 */
var IndexBufferBinding = /*#__PURE__*/function () {
  /**
   * Create index buffer binding.
   * @param buffer - Index buffer
   * @param format - Index buffer format
   */
  function IndexBufferBinding(buffer, format) {
    this._buffer = void 0;
    this._format = void 0;
    this._buffer = buffer;
    this._format = format;
  }
  _createClass(IndexBufferBinding, [{
    key: "buffer",
    get: /** @internal */

    /** @internal */

    /**
     * Index buffer.
     */
    function get() {
      return this._buffer;
    }

    /**
     * Index buffer format.
     */
  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
  }]);
  return IndexBufferBinding;
}();

/**
 * Sub-mesh, mainly contains drawing information.
 */
var SubMesh = /** Start drawing offset. */

/** Drawing count. */

/** Drawing topology. */

/**
 * Create a sub-mesh.
 * @param start - Start drawing offset
 * @param count - Drawing count
 * @param topology - Drawing topology
 */
function SubMesh(start, count, topology) {
  if (start === void 0) {
    start = 0;
  }
  if (count === void 0) {
    count = 0;
  }
  if (topology === void 0) {
    topology = MeshTopology.Triangles;
  }
  this.start = void 0;
  this.count = void 0;
  this.topology = void 0;
  this.start = start;
  this.count = count;
  this.topology = topology;
};

/**
 * Mesh.
 */
var Mesh = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Mesh, _RefObject);
  /**
   * Create mesh.
   * @param engine - Engine
   * @param name - Mesh name
   */
  function Mesh(engine, name) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.bounds = new BoundingBox();
    _this._vertexElementMap = {};
    _this._glIndexType = void 0;
    _this._glIndexByteCount = void 0;
    _this._platformPrimitive = void 0;
    _this._instanceCount = 0;
    _this._vertexBufferBindings = [];
    _this._indexBufferBinding = null;
    _this._vertexElements = [];
    _this._enableVAO = true;
    _this._subMeshes = [];
    _this._updateFlagManager = new UpdateFlagManager();
    _this.name = name;
    _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));
    return _this;
  }

  /**
   * Add sub-mesh, each sub-mesh can correspond to an independent material.
   * @param subMesh - Start drawing offset, if the index buffer is set, it means the offset in the index buffer, if not set, it means the offset in the vertex buffer
   * @returns Sub-mesh
   */
  var _proto = Mesh.prototype;
  _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
    if (topology === void 0) {
      topology = MeshTopology.Triangles;
    }
    if (typeof startOrSubMesh === "number") {
      startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
    }
    this._subMeshes.push(startOrSubMesh);
    return startOrSubMesh;
  }

  /**
   * Remove sub-mesh.
   * @param subMesh - Sub-mesh needs to be removed
   */;
  _proto.removeSubMesh = function removeSubMesh(subMesh) {
    var subMeshes = this._subMeshes;
    var index = subMeshes.indexOf(subMesh);
    if (index !== -1) {
      subMeshes.splice(index, 1);
    }
  }

  /**
   * Clear all sub-mesh.
   */;
  _proto.clearSubMesh = function clearSubMesh() {
    this._subMeshes.length = 0;
  }

  /**
   * Register update flag, update flag will be true if the vertex element changes.
   * @returns Update flag
   */;
  _proto.registerUpdateFlag = function registerUpdateFlag() {
    return this._updateFlagManager.createFlag(BoolUpdateFlag);
  }

  /**
   * @internal
   */;
  _proto._clearVertexElements = function _clearVertexElements() {
    this._vertexElements.length = 0;
    var vertexElementMap = this._vertexElementMap;
    for (var k in vertexElementMap) {
      delete vertexElementMap[k];
    }
  }

  /**
   * @internal
   */;
  _proto._addVertexElement = function _addVertexElement(element) {
    var semantic = element.semantic;
    this._vertexElementMap[semantic] = element;
    this._vertexElements.push(element);
    this._updateFlagManager.dispatch();
  }

  /**
   * @internal
   */;
  _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
    if (this._getRefCount() > 0) {
      var lastBinding = this._vertexBufferBindings[index];
      lastBinding && lastBinding._buffer._addRefCount(-1);
      binding._buffer._addRefCount(1);
    }
    this._vertexBufferBindings[index] = binding;
  }

  /**
   * @internal
   */;
  _proto._draw = function _draw(shaderProgram, subMesh) {
    this._platformPrimitive.draw(shaderProgram, subMesh);
  }

  /**
   * @override
   */;
  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);
    var vertexBufferBindings = this._vertexBufferBindings;
    for (var i = 0, n = vertexBufferBindings.length; i < n; i++) {
      vertexBufferBindings[i]._buffer._addRefCount(value);
    }
  }

  /**
   * @override
   * Destroy.
   */;
  _proto._onDestroy = function _onDestroy() {
    this._vertexBufferBindings = null;
    this._indexBufferBinding = null;
    this._vertexElements = null;
    this._vertexElementMap = null;
    this._platformPrimitive.destroy();
  };
  _proto._setVertexElements = function _setVertexElements(elements) {
    this._clearVertexElements();
    for (var i = 0, n = elements.length; i < n; i++) {
      this._addVertexElement(elements[i]);
    }
  };
  _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
    if (binding) {
      this._indexBufferBinding = binding;
      this._glIndexType = BufferUtil._getGLIndexType(binding.format);
      this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
    } else {
      this._indexBufferBinding = null;
      this._glIndexType = undefined;
    }
  };
  _createClass(Mesh, [{
    key: "subMesh",
    get: /** Name. */

    /** The bounding volume of the mesh. */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * First sub-mesh. Rendered using the first material.
     */
    function get() {
      return this._subMeshes[0] || null;
    }

    /**
     * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.
     */
  }, {
    key: "subMeshes",
    get: function get() {
      return this._subMeshes;
    }
  }]);
  return Mesh;
}(RefObject);

/**
 * Vertex buffer binding.
 */
var VertexBufferBinding = /*#__PURE__*/function () {
  /**
   * Create vertex buffer.
   * @param buffer - Vertex buffer
   * @param stride - Vertex buffer stride
   */
  function VertexBufferBinding(buffer, stride) {
    this._buffer = void 0;
    this._stride = void 0;
    this._buffer = buffer;
    this._stride = stride;
  }
  _createClass(VertexBufferBinding, [{
    key: "buffer",
    get: /** @internal */

    /** @internal */

    /**
     * Vertex buffer.
     */
    function get() {
      return this._buffer;
    }

    /**
     * Vertex buffer stride.
     */
  }, {
    key: "stride",
    get: function get() {
      return this._stride;
    }
  }]);
  return VertexBufferBinding;
}();

/**
 * Render buffer depth format enumeration.
 */
var RenderBufferDepthFormat;
(function (RenderBufferDepthFormat) {
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));

/**
 * Define the face of the cube texture.
 */
var TextureCubeFace;
(function (TextureCubeFace) {
  TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));

/**
 * The filter mode of the texture.
 */
var TextureFilterMode;
(function (TextureFilterMode) {
  TextureFilterMode[TextureFilterMode["Point"] = 0] = "Point";
  TextureFilterMode[TextureFilterMode["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode[TextureFilterMode["Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));

/**
 * Texture format enumeration.
 */
var TextureFormat;
(function (TextureFormat) {
  TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat[TextureFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat[TextureFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat[TextureFormat["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat[TextureFormat["Alpha8"] = 5] = "Alpha8";
  TextureFormat[TextureFormat["LuminanceAlpha"] = 6] = "LuminanceAlpha";
  TextureFormat[TextureFormat["R16G16B16A16"] = 7] = "R16G16B16A16";
  TextureFormat[TextureFormat["R32G32B32A32"] = 8] = "R32G32B32A32";
  TextureFormat[TextureFormat["DXT1"] = 9] = "DXT1";
  TextureFormat[TextureFormat["DXT5"] = 10] = "DXT5";
  TextureFormat[TextureFormat["ETC1_RGB"] = 11] = "ETC1_RGB";
  TextureFormat[TextureFormat["ETC2_RGB"] = 12] = "ETC2_RGB";
  TextureFormat[TextureFormat["ETC2_RGBA5"] = 13] = "ETC2_RGBA5";
  TextureFormat[TextureFormat["ETC2_RGBA8"] = 14] = "ETC2_RGBA8";
  TextureFormat[TextureFormat["PVRTC_RGB2"] = 15] = "PVRTC_RGB2";
  TextureFormat[TextureFormat["PVRTC_RGBA2"] = 16] = "PVRTC_RGBA2";
  TextureFormat[TextureFormat["PVRTC_RGB4"] = 17] = "PVRTC_RGB4";
  TextureFormat[TextureFormat["PVRTC_RGBA4"] = 18] = "PVRTC_RGBA4";
  TextureFormat[TextureFormat["ASTC_4x4"] = 19] = "ASTC_4x4";
  TextureFormat[TextureFormat["ASTC_5x5"] = 20] = "ASTC_5x5";
  TextureFormat[TextureFormat["ASTC_6x6"] = 21] = "ASTC_6x6";
  TextureFormat[TextureFormat["ASTC_8x8"] = 22] = "ASTC_8x8";
  TextureFormat[TextureFormat["ASTC_10x10"] = 23] = "ASTC_10x10";
  TextureFormat[TextureFormat["ASTC_12x12"] = 24] = "ASTC_12x12";
  TextureFormat[TextureFormat["Depth"] = 25] = "Depth";
  TextureFormat[TextureFormat["DepthStencil"] = 26] = "DepthStencil";
  TextureFormat[TextureFormat["Stencil"] = 27] = "Stencil";
  TextureFormat[TextureFormat["Depth16"] = 28] = "Depth16";
  TextureFormat[TextureFormat["Depth24"] = 29] = "Depth24";
  TextureFormat[TextureFormat["Depth32"] = 30] = "Depth32";
  TextureFormat[TextureFormat["Depth24Stencil8"] = 31] = "Depth24Stencil8";
  TextureFormat[TextureFormat["Depth32Stencil8"] = 32] = "Depth32Stencil8";
})(TextureFormat || (TextureFormat = {}));

/**
 * Wrapping mode of the texture.
 */
var TextureWrapMode;
(function (TextureWrapMode) {
  TextureWrapMode[TextureWrapMode["Clamp"] = 0] = "Clamp";
  TextureWrapMode[TextureWrapMode["Repeat"] = 1] = "Repeat";
  TextureWrapMode[TextureWrapMode["Mirror"] = 2] = "Mirror";
})(TextureWrapMode || (TextureWrapMode = {}));

/**
 * The render target used for off-screen rendering.
 */
var RenderTarget = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(RenderTarget, _EngineObject);
  /**
   * @internal
   */
  function RenderTarget(engine, width, height, renderTexture, depth, antiAliasing) {
    var _this;
    if (depth === void 0) {
      depth = RenderBufferDepthFormat.Depth;
    }
    if (antiAliasing === void 0) {
      antiAliasing = 1;
    }
    _this = _EngineObject.call(this, engine) || this;
    _this._platformRenderTarget = void 0;
    _this._depth = void 0;
    _this._antiAliasing = void 0;
    _this._autoGenerateMipmaps = true;
    _this._width = void 0;
    _this._height = void 0;
    _this._colorTextures = void 0;
    _this._depthTexture = void 0;
    _this._width = width;
    _this._height = height;
    _this._antiAliasing = antiAliasing;
    _this._depth = depth;
    if (renderTexture) {
      _this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
    } else {
      _this._colorTextures = [];
    }
    if (depth instanceof Texture) {
      _this._depthTexture = depth;
    }
    _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_assertThisInitialized(_this));
    return _this;
  }

  /**
   *
   * Get the render color texture by index.
   * @param index
   */
  var _proto = RenderTarget.prototype;
  _proto.getColorTexture = function getColorTexture(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._colorTextures[index];
  }

  /**
   * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
   */;
  _proto.generateMipmaps = function generateMipmaps() {
    if (this._autoGenerateMipmaps) {
      var _colorTextures = this._colorTextures;
      for (var i = 0, n = _colorTextures.length; i < n; i++) {
        var _colorTexture = _colorTextures[i];
        _colorTexture.generateMipmaps();
      }
      this._depthTexture && this._depthTexture.generateMipmaps();
    }
  }

  /**
   * Destroy render target.
   */;
  _proto.destroy = function destroy() {
    this._platformRenderTarget.destroy();
    this._colorTextures.length = 0;
    this._depthTexture = null;
    this._depth = null;
  }

  /**
   * @internal
   */;
  _proto._setRenderTargetInfo = function _setRenderTargetInfo(faceIndex, mipLevel) {
    this._platformRenderTarget.setRenderTargetInfo(faceIndex, mipLevel);
  }

  /**
   * @internal
   */;
  _proto._blitRenderTarget = function _blitRenderTarget() {
    this._platformRenderTarget.blitRenderTarget();
  };
  _createClass(RenderTarget, [{
    key: "autoGenerateMipmaps",
    get: /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Whether to automatically generate multi-level textures.
     */
    function get() {
      return this._autoGenerateMipmaps;
    },
    set: function set(value) {
      this._autoGenerateMipmaps = value;
    }

    /**
     * Render target width.
     */
  }, {
    key: "width",
    get: function get() {
      return this._width;
    }

    /**
     * Render target height.
     */
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }

    /**
     * Render color texture count.
     */
  }, {
    key: "colorTextureCount",
    get: function get() {
      return this._colorTextures.length;
    }

    /**
     * Depth texture.
     */
  }, {
    key: "depthTexture",
    get: function get() {
      return this._depthTexture;
    }

    /**
     * Anti-aliasing level.
     * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
     */
  }, {
    key: "antiAliasing",
    get: function get() {
      return this._antiAliasing;
    }

    /**
     * Create a render target through color texture and depth format.
     * @param engine - Define the engine to use for this off-screen rendering
     * @param width - Render target width
     * @param height - Render target height
     * @param colorTexture - Render color texture
     * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
     * @param antiAliasing - Anti-aliasing level, default is 1
     */
  }]);
  return RenderTarget;
}(EngineObject);

/**
 * Two-dimensional texture.
 */
var Texture2D = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(Texture2D, _Texture);
  /**
   * Create Texture2D.
   * @param engine - Define the engine to use to render this texture
   * @param width - Texture width
   * @param height - Texture height
   * @param format - Texture format. default  `TextureFormat.R8G8B8A8`
   * @param mipmap - Whether to use multi-level texture
   */
  function Texture2D(engine, width, height, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Repeat;
    return _this;
  }

  /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */
  var _proto = Texture2D.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
  }

  /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */;
  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  }

  /**
   * Get pixel color buffer.
   * @param out - Color buffer
   */;
  _proto.getPixelBuffer = function getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
    var argsLength = arguments.length;
    if (argsLength === 1) {
      this._platformTexture.getPixelBuffer(0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
    } else if (argsLength === 2) {
      this._platformTexture.getPixelBuffer(0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
    } else if (argsLength === 5) {
      this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
    } else if (argsLength === 6) {
      this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
    }
  };
  return Texture2D;
}(Texture);

/**
 * Two-dimensional texture array.
 */
var Texture2DArray = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(Texture2DArray, _Texture);
  /**
   * Create Texture2D Array.
   * @param engine - Define the engine to use to render this texture
   * @param width - Texture width
   * @param height - Texture height
   * @param length - Texture length
   * @param format - Texture format. default `TextureFormat.R8G8B8A8`
   * @param mipmap - Whether to use multi-level texture
   */
  function Texture2DArray(engine, width, height, length, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._length = void 0;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._length = length;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2DArray(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Repeat;
    return _this;
  }

  /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param offsetIndex - The texture array element offset index
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   * @param length - Data length. if it's empty, length is the length of Texture2DArray.length
   */
  var _proto = Texture2DArray.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._platformTexture.setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length);
  }

  /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param elementIndex - The texture array element index
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */;
  _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._platformTexture.setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  }

  /**
   * Get pixel color buffer.
   * @param elementIndex - The texture array element index
   * @param out - Color buffer
   */;
  _proto.getPixelBuffer = function getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
    var argsLength = arguments.length;
    if (argsLength === 1) {
      this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
    } else if (argsLength === 2) {
      this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
    } else if (argsLength === 5) {
      this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
    } else if (argsLength === 6) {
      this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
    }
  };
  _createClass(Texture2DArray, [{
    key: "length",
    get:
    /**
     * The length of the texture.
     */
    function get() {
      return this._length;
    }
  }]);
  return Texture2DArray;
}(Texture);

/**
 * Cube texture.
 */
var TextureCube = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(TextureCube, _Texture);
  /**
   * Create TextureCube.
   * @param engine - Define the engine to use to render this texture
   * @param size - Texture size. texture width must be equal to height in cube texture
   * @param format - Texture format,default TextureFormat.R8G8B8A8
   * @param mipmap - Whether to use multi-level texture
   */
  function TextureCube(engine, size, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._mipmap = mipmap;
    _this._width = size;
    _this._height = size;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCube(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }

  /**
   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
   * @param face - Cube face
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y -  Y coordinate of area start
   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */
  var _proto = TextureCube.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
  }

  /**
   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
   * @param face - Cube face
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */;
  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  }

  /**
   * Get pixel color buffer.
   * @param out - Color buffer
   */;
  _proto.getPixelBuffer = function getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
    var argsLength = arguments.length;
    if (argsLength === 2) {
      this._platformTexture.getPixelBuffer(face, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
    } else if (argsLength === 3) {
      this._platformTexture.getPixelBuffer(face, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
    } else if (argsLength === 6) {
      this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
    } else if (argsLength === 7) {
      this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
    }
  };
  return TextureCube;
}(Texture);

/**
 * @internal
 */
var BlendShapeManager = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  function BlendShapeManager(engine, modelMesh) {
    this._blendShapeCount = 0;
    this._blendShapes = [];
    this._blendShapeNames = void 0;
    this._layoutDirtyListener = new ListenerUpdateFlag();
    this._subDataDirtyFlags = [];
    this._vertexTexture = void 0;
    this._vertexBuffers = [];
    this._vertices = void 0;
    this._useBlendNormal = false;
    this._useBlendTangent = false;
    this._vertexElementCount = 0;
    this._vertexElementOffset = void 0;
    this._storeInVertexBufferInfo = [];
    this._maxCountSingleVertexBuffer = 0;
    this._engine = void 0;
    this._modelMesh = void 0;
    this._lastCreateHostInfo = new Vector3(0, 0, 0);
    this._canUseTextureStoreData = true;
    this._dataTextureInfo = new Vector3();
    this._engine = engine;
    this._modelMesh = modelMesh;
    this._canUseTextureStoreData = this._engine._hardwareRenderer.capability.canUseFloatTextureBlendShape;
    this._layoutDirtyListener.listener = this._updateLayoutChange.bind(this);
  }

  /**
   * @internal
   */
  var _proto = BlendShapeManager.prototype;
  _proto._addBlendShape = function _addBlendShape(blendShape) {
    this._blendShapes.push(blendShape);
    this._blendShapeCount++;
    blendShape._addLayoutChangeFlag(this._layoutDirtyListener);
    this._updateLayoutChange(blendShape);
    this._subDataDirtyFlags.push(blendShape._createSubDataDirtyFlag());
  }

  /**
   * @internal
   */;
  _proto._clearBlendShapes = function _clearBlendShapes() {
    this._useBlendNormal = false;
    this._useBlendTangent = false;
    this._vertexElementCount = 0;
    this._blendShapes.length = 0;
    this._blendShapeCount = 0;
    this._layoutDirtyListener.clearFromManagers();
    var subDataDirtyFlags = this._subDataDirtyFlags;
    for (var i = 0, n = subDataDirtyFlags.length; i < n; i++) {
      subDataDirtyFlags[i].destroy();
    }
    subDataDirtyFlags.length = 0;
  }

  /**
   * @internal
   */;
  _proto._updateShaderData = function _updateShaderData(shaderData, skinnedMeshRenderer) {
    var blendShapeCount = this._blendShapeCount;
    if (blendShapeCount > 0) {
      shaderData.enableMacro(BlendShapeManager._blendShapeMacro);
      if (this._useTextureMode()) {
        shaderData.enableMacro(BlendShapeManager._blendShapeTextureMacro);
        shaderData.setTexture(BlendShapeManager._blendShapeTextureProperty, this._vertexTexture);
        shaderData.setVector3(BlendShapeManager._blendShapeTextureInfoProperty, this._dataTextureInfo);
        shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
      } else {
        var maxBlendCount = this._getVertexBufferModeSupportCount();
        if (blendShapeCount > maxBlendCount) {
          var condensedBlendShapeWeights = skinnedMeshRenderer._condensedBlendShapeWeights;
          if (!condensedBlendShapeWeights) {
            condensedBlendShapeWeights = new Float32Array(maxBlendCount);
            skinnedMeshRenderer._condensedBlendShapeWeights = condensedBlendShapeWeights;
          }
          this._filterCondensedBlendShapeWeights(skinnedMeshRenderer.blendShapeWeights, condensedBlendShapeWeights);
          shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, condensedBlendShapeWeights);
          this._modelMesh._enableVAO = false;
          blendShapeCount = maxBlendCount;
        } else {
          shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
          this._modelMesh._enableVAO = true;
        }
        shaderData.disableMacro(BlendShapeManager._blendShapeTextureMacro);
      }
      shaderData.enableMacro("OASIS_BLENDSHAPE_COUNT", blendShapeCount.toString());
      if (this._useBlendNormal) {
        shaderData.enableMacro(BlendShapeManager._blendShapeNormalMacro);
      } else {
        shaderData.disableMacro(BlendShapeManager._blendShapeNormalMacro);
      }
      if (this._useBlendTangent) {
        shaderData.enableMacro(BlendShapeManager._blendShapeTangentMacro);
      } else {
        shaderData.disableMacro(BlendShapeManager._blendShapeTangentMacro);
      }
    } else {
      shaderData.disableMacro(BlendShapeManager._blendShapeMacro);
      shaderData.disableMacro("OASIS_BLENDSHAPE_COUNT");
    }
  }

  /**
   * @internal
   */;
  _proto._useTextureMode = function _useTextureMode() {
    if (!this._canUseTextureStoreData) {
      return false;
    }
    return this._blendShapeCount > this._getVertexBufferModeSupportCount();
  }

  /**
   * @internal
   */;
  _proto._layoutOrCountChange = function _layoutOrCountChange() {
    var last = this._lastCreateHostInfo;
    return last.x !== this._blendShapeCount || !!last.y !== this._useBlendNormal || !!last.z !== this._useBlendTangent;
  }

  /**
   * @internal
   */;
  _proto._vertexElementsNeedUpdate = function _vertexElementsNeedUpdate() {
    var maxSupportCount = this._getVertexBufferModeSupportCount();
    var info = this._lastCreateHostInfo;
    return Math.min(info.x, maxSupportCount) !== Math.min(this._blendShapeCount, maxSupportCount) || !!info.y !== this._useBlendNormal || !!info.z !== this._useBlendTangent;
  }

  /**
   * @internal
   */;
  _proto._needUpdateData = function _needUpdateData() {
    var subDataDirtyFlags = this._subDataDirtyFlags;
    for (var i = 0, n = subDataDirtyFlags.length; i < n; i++) {
      if (subDataDirtyFlags[i].flag) {
        return true;
      }
    }
    return false;
  }

  /**
   * @internal
   */;
  _proto._addVertexElements = function _addVertexElements(modelMesh) {
    var offset = 0;
    this._vertexElementOffset = modelMesh._vertexElements.length;
    for (var i = 0, n = Math.min(this._blendShapeCount, this._getVertexBufferModeSupportCount()); i < n; i++) {
      modelMesh._addVertexElement(new VertexElement("POSITION_BS" + i, offset, VertexElementFormat.Vector3, 1));
      offset += 12;
      if (this._useBlendNormal) {
        modelMesh._addVertexElement(new VertexElement("NORMAL_BS" + i, offset, VertexElementFormat.Vector3, 1));
        offset += 12;
      }
      if (this._useBlendTangent) {
        modelMesh._addVertexElement(new VertexElement("TANGENT_BS" + i, offset, VertexElementFormat.Vector3, 1));
        offset += 12;
      }
    }
  }

  /**
   * @internal
   */;
  _proto._update = function _update(vertexCountChange, noLongerAccessible) {
    var vertexCount = this._modelMesh.vertexCount;
    var useTexture = this._useTextureMode();
    var createHost = this._layoutOrCountChange() || vertexCountChange;
    if (createHost) {
      if (useTexture) {
        this._createTextureArray(vertexCount);
      } else {
        this._createVertexBuffers(vertexCount, noLongerAccessible);
      }
      this._lastCreateHostInfo.set(this._blendShapeCount, +this._useBlendNormal, +this._useBlendTangent);
    }
    if (this._needUpdateData()) {
      if (useTexture) {
        this._updateTextureArray(vertexCount, createHost);
      } else {
        this._updateVertexBuffers(vertexCount, createHost);
      }
    }
  }

  /**
   * @internal
   */;
  _proto._releaseMemoryCache = function _releaseMemoryCache() {
    var blendShapes = this._blendShapes;
    var blendShapeCount = blendShapes.length;
    var blendShapeNamesMap = new Array(blendShapeCount);
    for (var i = 0; i < blendShapeCount; i++) {
      blendShapeNamesMap[i] = blendShapes[i].name;
    }
    this._blendShapeNames = blendShapeNamesMap;
    this._layoutDirtyListener.destroy();
    var dataChangedFlags = this._subDataDirtyFlags;
    for (var _i = 0, n = dataChangedFlags.length; _i < n; _i++) {
      dataChangedFlags[_i].destroy();
    }
    this._layoutDirtyListener = null;
    this._subDataDirtyFlags = null;
    this._blendShapes = null;
    this._vertices = null;
  };
  _proto._createVertexBuffers = function _createVertexBuffers(vertexCount, noLongerAccessible) {
    var engine = this._engine,
      modelMesh = this._modelMesh,
      blendShapeCount = this._blendShapeCount,
      vertexBuffers = this._vertexBuffers;
    var vertexFloatCount = this._vertexElementCount * 3;
    var vertexByteCount = vertexFloatCount * 4;
    var maxCountSingleBuffer = Math.floor(255 / vertexByteCount); // 255: Attribute MaxStride
    var bufferCount = Math.ceil(blendShapeCount / maxCountSingleBuffer);
    var floatCount = vertexFloatCount * vertexCount * Math.min(maxCountSingleBuffer, blendShapeCount);
    vertexBuffers.length = bufferCount;
    this._vertices = new Float32Array(floatCount);
    this._maxCountSingleVertexBuffer = maxCountSingleBuffer;
    this._storeInVertexBufferInfo.length = blendShapeCount;
    for (var i = 0; i < bufferCount; i++) {
      var lastIndex = bufferCount - 1;
      var containCount = i === lastIndex ? blendShapeCount - lastIndex * maxCountSingleBuffer : maxCountSingleBuffer;
      var stride = containCount * vertexByteCount;
      var byteLength = stride * vertexCount;
      var usage = noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic;
      var blendShapeBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, byteLength, usage);
      modelMesh._setVertexBufferBinding(i + 1, new VertexBufferBinding(blendShapeBuffer, stride));
      vertexBuffers[i] = blendShapeBuffer;
    }
  };
  _proto._createTextureArray = function _createTextureArray(vertexCount) {
    var maxTextureSize = this._engine._hardwareRenderer.capability.maxTextureSize;
    var vertexPixelStride = this._vertexElementCount;
    var textureWidth = vertexPixelStride * vertexCount;
    var textureHeight = 1;
    if (textureWidth > maxTextureSize) {
      textureHeight = Math.ceil(textureWidth / maxTextureSize);
      textureWidth = maxTextureSize;
    }
    var blendShapeDataTexture = this._vertexTexture;
    var blendShapeCount = this._blendShapes.length;
    blendShapeDataTexture && blendShapeDataTexture.destroy();
    blendShapeDataTexture = new Texture2DArray(this._engine, textureWidth, textureHeight, blendShapeCount, TextureFormat.R32G32B32A32, false);
    blendShapeDataTexture.filterMode = TextureFilterMode.Point;
    this._vertices = new Float32Array(blendShapeCount * textureWidth * textureHeight * 4);
    this._vertexTexture = blendShapeDataTexture;
    this._dataTextureInfo.set(vertexPixelStride, textureWidth, textureHeight);
  }

  /**
   * @internal
   */;
  _proto._updateVertexBuffers = function _updateVertexBuffers(vertexCount, force) {
    var blendShapes = this._blendShapes,
      maxCountSingleBuffer = this._maxCountSingleVertexBuffer;
    var vertices = this._vertices,
      vertexBuffers = this._vertexBuffers,
      storeInfos = this._storeInVertexBufferInfo;
    var subDataDirtyFlags = this._subDataDirtyFlags;
    var blendShapeFloatStride = this._vertexElementCount * 3;
    var blendShapeByteStride = blendShapeFloatStride * 4;

    // @todo: should fix bug when dataChangedFlag is true
    for (var i = 0, n = blendShapes.length; i < n; i++) {
      var dataChangedFlag = subDataDirtyFlags[i];
      if (force || dataChangedFlag.flag) {
        var frames = blendShapes[i].frames;
        var frameCount = frames.length;
        var endFrame = frames[frameCount - 1];
        if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
          throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
        }
        var bufferIndex = Math.floor(i / maxCountSingleBuffer);
        var indexInBuffer = i % maxCountSingleBuffer;
        var buffer = vertexBuffers[bufferIndex];
        var bufferFloatStride = buffer.byteLength / (vertexCount * 4);
        var offset = indexInBuffer * blendShapeFloatStride;
        var storeInfo = storeInfos[i];
        storeInfo || (storeInfos[i] = storeInfo = new Vector2());
        storeInfo.set(bufferIndex + 1, indexInBuffer * blendShapeByteStride); // BlendShape buffer is start from 1

        var _endFrame = endFrame,
          deltaPositions = _endFrame.deltaPositions;
        for (var j = 0; j < vertexCount; j++) {
          var start = offset + bufferFloatStride * j;
          var deltaPosition = deltaPositions[j];
          if (deltaPosition) {
            vertices[start] = deltaPosition.x;
            vertices[start + 1] = deltaPosition.y;
            vertices[start + 2] = deltaPosition.z;
          }
        }
        offset += 3;
        if (this._useBlendNormal) {
          var _endFrame2 = endFrame,
            deltaNormals = _endFrame2.deltaNormals;
          if (deltaNormals) {
            for (var _j = 0; _j < vertexCount; _j++) {
              var _start = offset + bufferFloatStride * _j;
              var deltaNormal = deltaNormals[_j];
              if (deltaNormal) {
                vertices[_start] = deltaNormal.x;
                vertices[_start + 1] = deltaNormal.y;
                vertices[_start + 2] = deltaNormal.z;
              }
            }
          }
          offset += 3;
        }
        if (this._useBlendTangent) {
          var _endFrame3 = endFrame,
            deltaTangents = _endFrame3.deltaTangents;
          if (deltaTangents) {
            for (var _j2 = 0; _j2 < vertexCount; _j2++) {
              var _start2 = offset + bufferFloatStride * _j2;
              var deltaTangent = deltaTangents[_j2];
              if (deltaTangent) {
                vertices[_start2] = deltaTangent.x;
                vertices[_start2 + 1] = deltaTangent.y;
                vertices[_start2 + 2] = deltaTangent.z;
              }
            }
          }
          offset += 3;
        }
        if (indexInBuffer === maxCountSingleBuffer - 1 || i === n - 1) {
          // @todo: can optimize in setData
          buffer.setData(vertices, 0, 0, buffer.byteLength / 4);
        }
        dataChangedFlag.flag = false;
      }
    }
  };
  _proto._updateTextureArray = function _updateTextureArray(vertexCount, force) {
    var blendShapes = this._blendShapes,
      vertexTexture = this._vertexTexture,
      vertices = this._vertices,
      subDataDirtyFlags = this._subDataDirtyFlags;
    for (var i = 0, n = blendShapes.length; i < n; i++) {
      var subDirtyFlag = subDataDirtyFlags[i];
      var subBlendShapeDataStride = vertexTexture.width * vertexTexture.height * 4;
      if (force || subDirtyFlag.flag) {
        var frames = blendShapes[i].frames;
        var frameCount = frames.length;
        var endFrame = frames[frameCount - 1];
        if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
          throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
        }
        var _endFrame4 = endFrame,
          deltaPositions = _endFrame4.deltaPositions,
          deltaNormals = _endFrame4.deltaNormals,
          deltaTangents = _endFrame4.deltaTangents;
        var offset = i * subBlendShapeDataStride;
        for (var j = 0; j < vertexCount; j++) {
          var position = deltaPositions[j];
          vertices[offset] = position.x;
          vertices[offset + 1] = position.y;
          vertices[offset + 2] = position.z;
          offset += 4;
          if (deltaNormals) {
            var normal = deltaNormals[j];
            vertices[offset] = normal.x;
            vertices[offset + 1] = normal.y;
            vertices[offset + 2] = normal.z;
            offset += 4;
          }
          if (deltaTangents) {
            var tangent = deltaTangents[j];
            vertices[offset] = tangent.x;
            vertices[offset + 1] = tangent.y;
            vertices[offset + 2] = tangent.z;
            offset += 4;
          }
        }
        subDirtyFlag.flag = false;
      }
    }
    vertexTexture.setPixelBuffer(0, vertices);
  };
  _proto._updateLayoutChange = function _updateLayoutChange(blendShape) {
    var notFirst = this._blendShapeCount > 1;
    var vertexElementCount = 1;
    var useBlendNormal = blendShape._useBlendShapeNormal;
    var useBlendTangent = blendShape._useBlendShapeTangent;
    if (notFirst) {
      useBlendNormal && (useBlendNormal = this._useBlendNormal);
      useBlendTangent && (useBlendTangent = this._useBlendTangent);
    }
    useBlendNormal && vertexElementCount++;
    useBlendTangent && vertexElementCount++;
    this._useBlendNormal = useBlendNormal;
    this._useBlendTangent = useBlendTangent;
    this._vertexElementCount = vertexElementCount;
  };
  _proto._attributeModeUpdateVertexElement = function _attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, index, condensedIndex) {
    var elementOffset = this._vertexElementOffset + this._vertexElementCount * condensedIndex;
    var _vertexBufferStoreInf = vertexBufferStoreInfo[index],
      bufferIndex = _vertexBufferStoreInf.x,
      offset = _vertexBufferStoreInf.y;
    var vertexElement = vertexElements[elementOffset];
    vertexElement.bindingIndex = bufferIndex;
    vertexElement.offset = offset;
    if (this._useBlendNormal) {
      var _vertexElement = vertexElements[++elementOffset];
      offset += 12;
      _vertexElement.bindingIndex = bufferIndex;
      _vertexElement.offset = offset;
    }
    if (this._useBlendTangent) {
      var _vertexElement2 = vertexElements[++elementOffset];
      offset += 12;
      _vertexElement2.bindingIndex = bufferIndex;
      _vertexElement2.offset = offset;
    }
  };
  _proto._getVertexBufferModeSupportCount = function _getVertexBufferModeSupportCount() {
    if (this._useBlendNormal || this._useBlendTangent) {
      return 4;
    } else {
      return 8;
    }
  };
  _proto._filterCondensedBlendShapeWeights = function _filterCondensedBlendShapeWeights(blendShapeWeights, condensedBlendShapeWeights) {
    var condensedWeightsCount = condensedBlendShapeWeights.length;
    var vertexElements = this._modelMesh._vertexElements;
    var vertexBufferStoreInfo = this._storeInVertexBufferInfo;
    var thresholdWeight = Number.POSITIVE_INFINITY;
    var thresholdIndex;
    for (var i = 0, n = Math.min(blendShapeWeights.length, this._blendShapeCount); i < n; i++) {
      var weight = blendShapeWeights[i];
      if (i < condensedWeightsCount) {
        this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, i);
        condensedBlendShapeWeights[i] = weight;
        if (weight < thresholdWeight) {
          thresholdWeight = weight;
          thresholdIndex = i;
        }
      } else if (weight > thresholdWeight) {
        this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, thresholdIndex);
        condensedBlendShapeWeights[thresholdIndex] = weight;
        thresholdWeight = Number.POSITIVE_INFINITY;
        for (var j = 0; j < condensedWeightsCount; j++) {
          var condensedWeight = condensedBlendShapeWeights[j];
          if (condensedWeight < thresholdWeight) {
            thresholdWeight = condensedWeight;
            thresholdIndex = j;
          }
        }
      }
    }
  };
  return BlendShapeManager;
}();
BlendShapeManager._blendShapeMacro = Shader.getMacroByName("OASIS_BLENDSHAPE");
BlendShapeManager._blendShapeTextureMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_TEXTURE");
BlendShapeManager._blendShapeNormalMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_NORMAL");
BlendShapeManager._blendShapeTangentMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_TANGENT");
BlendShapeManager._blendShapeWeightsProperty = Shader.getPropertyByName("u_blendShapeWeights");
BlendShapeManager._blendShapeTextureProperty = Shader.getPropertyByName("u_blendShapeTexture");
BlendShapeManager._blendShapeTextureInfoProperty = Shader.getPropertyByName("u_blendShapeTextureInfo");

/**
 * Mesh containing common vertex elements of the model.
 */
var ModelMesh = /*#__PURE__*/function (_Mesh) {
  _inheritsLoose(ModelMesh, _Mesh);
  /**
   * Create a model mesh.
   * @param engine - Engine to which the mesh belongs
   * @param name - Mesh name
   */
  function ModelMesh(engine, name) {
    var _this;
    _this = _Mesh.call(this, engine) || this;
    _this._blendShapeManager = void 0;
    _this._vertexCount = 0;
    _this._accessible = true;
    _this._verticesFloat32 = null;
    _this._verticesUint8 = null;
    _this._indices = null;
    _this._indicesFormat = null;
    _this._vertexSlotChanged = true;
    _this._vertexChangeFlag = 0;
    _this._indicesChangeFlag = false;
    _this._vertexStrideFloat = 0;
    _this._lastUploadVertexCount = -1;
    _this._positions = [];
    _this._normals = null;
    _this._colors = null;
    _this._tangents = null;
    _this._uv = null;
    _this._uv1 = null;
    _this._uv2 = null;
    _this._uv3 = null;
    _this._uv4 = null;
    _this._uv5 = null;
    _this._uv6 = null;
    _this._uv7 = null;
    _this._boneWeights = null;
    _this._boneIndices = null;
    _this.name = name;
    _this._blendShapeManager = new BlendShapeManager(engine, _assertThisInitialized(_this));
    return _this;
  }

  /**
   * Set positions for the mesh.
   * @param positions - The positions for the mesh.
   */
  var _proto = ModelMesh.prototype;
  _proto.setPositions = function setPositions(positions) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    this._positions = positions;
    this._vertexCount = positions.length;
    this._vertexChangeFlag |= ValueChanged.Position;
  }

  /**
   * Get positions for the mesh.
   * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.
   */;
  _proto.getPositions = function getPositions() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._positions;
  }

  /**
   * Set per-vertex normals for the mesh.
   * @param normals - The normals for the mesh.
   */;
  _proto.setNormals = function setNormals(normals) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (normals.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._normals !== !!normals;
    this._vertexChangeFlag |= ValueChanged.Normal;
    this._normals = normals;
  }

  /**
   * Get normals for the mesh.
   * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.
   */;
  _proto.getNormals = function getNormals() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._normals;
  }

  /**
   * Set per-vertex colors for the mesh.
   * @param colors - The colors for the mesh.
   */;
  _proto.setColors = function setColors(colors) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (colors.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._colors !== !!colors;
    this._vertexChangeFlag |= ValueChanged.Color;
    this._colors = colors;
  }

  /**
   * Get colors for the mesh.
   * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.
   */;
  _proto.getColors = function getColors() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._colors;
  }

  /**
   * Set per-vertex bone weights for the mesh.
   * @param boneWeights - The bone weights for the mesh.
   */;
  _proto.setBoneWeights = function setBoneWeights(boneWeights) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (boneWeights.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = boneWeights != null;
    this._vertexChangeFlag |= ValueChanged.BoneWeight;
    this._boneWeights = boneWeights;
  }

  /**
   * Get weights for the mesh.
   * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.
   */;
  _proto.getBoneWeights = function getBoneWeights() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._boneWeights;
  }

  /**
   * Set per-vertex bone indices for the mesh.
   * @param boneIndices - The bone indices for the mesh.
   */;
  _proto.setBoneIndices = function setBoneIndices(boneIndices) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (boneIndices.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._boneIndices !== !!boneIndices;
    this._vertexChangeFlag |= ValueChanged.BoneIndex;
    this._boneIndices = boneIndices;
  }

  /**
   * Get joints for the mesh.
   * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.
   */;
  _proto.getBoneIndices = function getBoneIndices() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._boneIndices;
  }

  /**
   * Set per-vertex tangents for the mesh.
   * @param tangents - The tangents for the mesh.
   */;
  _proto.setTangents = function setTangents(tangents) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (tangents.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._tangents !== !!tangents;
    this._vertexChangeFlag |= ValueChanged.Tangent;
    this._tangents = tangents;
  }

  /**
   * Get tangents for the mesh.
   * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.
   */;
  _proto.getTangents = function getTangents() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._tangents;
  }

  /**
   * Set per-vertex uv for the mesh.
   * @param uv - The uv for the mesh.
   */;
  _proto.setUVs = function setUVs(uv, channelIndex) {
    var _channelIndex;
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (uv.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    channelIndex = (_channelIndex = channelIndex) != null ? _channelIndex : 0;
    switch (channelIndex) {
      case 0:
        this._vertexSlotChanged = !!this._uv !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV;
        this._uv = uv;
        break;
      case 1:
        this._vertexSlotChanged = !!this._uv1 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV1;
        this._uv1 = uv;
        break;
      case 2:
        this._vertexSlotChanged = !!this._uv2 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV2;
        this._uv2 = uv;
        break;
      case 3:
        this._vertexSlotChanged = !!this._uv3 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV3;
        this._uv3 = uv;
        break;
      case 4:
        this._vertexSlotChanged = !!this._uv4 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV4;
        this._uv4 = uv;
        break;
      case 5:
        this._vertexSlotChanged = !!this._uv5 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV5;
        this._uv5 = uv;
        break;
      case 6:
        this._vertexSlotChanged = !!this._uv6 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV6;
        this._uv6 = uv;
        break;
      case 7:
        this._vertexSlotChanged = !!this._uv7 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV7;
        this._uv7 = uv;
        break;
      default:
        throw "The index of channel needs to be in range [0 - 7].";
    }
  }

  /**
   * Get uv for the mesh.
   * @remarks Please call the setUV() method after modification to ensure that the modification takes effect.
   */;
  _proto.getUVs = function getUVs(channelIndex) {
    var _channelIndex2;
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    channelIndex = (_channelIndex2 = channelIndex) != null ? _channelIndex2 : 0;
    switch (channelIndex) {
      case 0:
        return this._uv;
      case 1:
        return this._uv1;
      case 2:
        return this._uv2;
      case 3:
        return this._uv3;
      case 4:
        return this._uv4;
      case 5:
        return this._uv5;
      case 6:
        return this._uv6;
      case 7:
        return this._uv7;
    }
    throw "The index of channel needs to be in range [0 - 7].";
  }

  /**
   * Set indices for the mesh.
   * @param indices - The indices for the mesh.
   */;
  _proto.setIndices = function setIndices(indices) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (this._indices !== indices) {
      this._indices = indices;
      if (indices instanceof Uint8Array) {
        this._indicesFormat = IndexFormat.UInt8;
      } else if (indices instanceof Uint16Array) {
        this._indicesFormat = IndexFormat.UInt16;
      } else if (indices instanceof Uint32Array) {
        this._indicesFormat = IndexFormat.UInt32;
      }
    }
    this._indicesChangeFlag = true;
  }

  /**
   * Get indices for the mesh.
   */;
  _proto.getIndices = function getIndices() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._indices;
  }

  /**
   * Add a BlendShape for this ModelMesh.
   * @param blendShape - The BlendShape
   */;
  _proto.addBlendShape = function addBlendShape(blendShape) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    this._blendShapeManager._addBlendShape(blendShape);
  }

  /**
   * Clear all BlendShapes.
   */;
  _proto.clearBlendShapes = function clearBlendShapes() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    this._blendShapeManager._clearBlendShapes();
  }

  /**
   * Get name of BlendShape by given index.
   * @param index - The index of BlendShape
   * @returns The name of BlendShape
   */;
  _proto.getBlendShapeName = function getBlendShapeName(index) {
    if (this._accessible) {
      var blendShapes = this._blendShapeManager._blendShapes;
      return blendShapes[index].name;
    } else {
      return this._blendShapeManager._blendShapeNames[index];
    }
  }

  /**
   * Upload Mesh Data to GPU.
   * @param noLongerAccessible - Whether to access data later. If true, you'll never access data anymore (free memory cache)
   */;
  _proto.uploadData = function uploadData(noLongerAccessible) {
    var _this$_vertexBufferBi, _this$_indexBufferBin;
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    var vertexCount = this._vertexCount;
    var vertexElementChanged = this._updateVertexElements();
    var vertexCountChange = this._lastUploadVertexCount !== vertexCount;

    // Vertex count change
    var vertexBuffer = (_this$_vertexBufferBi = this._vertexBufferBindings[0]) === null || _this$_vertexBufferBi === void 0 ? void 0 : _this$_vertexBufferBi._buffer;
    if (vertexCountChange) {
      vertexBuffer === null || vertexBuffer === void 0 ? void 0 : vertexBuffer.destroy();
      var elementCount = this._vertexStrideFloat;
      var vertexFloatCount = elementCount * vertexCount;
      var vertices = new Float32Array(vertexFloatCount);
      this._verticesFloat32 = vertices;
      this._verticesUint8 = new Uint8Array(vertices.buffer);
      this._updateVertices(vertices, true);
      var newVertexBuffer = new Buffer(this._engine, BufferBindFlag.VertexBuffer, vertices, noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic);
      this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));
      this._lastUploadVertexCount = vertexCount;
    } else {
      if (this._vertexChangeFlag & ValueChanged.All) {
        var _vertices = this._verticesFloat32;
        this._updateVertices(_vertices, vertexElementChanged);
        vertexBuffer.setData(_vertices);
      }
    }
    var indices = this._indices;
    var indexBuffer = (_this$_indexBufferBin = this._indexBufferBinding) === null || _this$_indexBufferBin === void 0 ? void 0 : _this$_indexBufferBin._buffer;
    if (indices) {
      if (!indexBuffer || indices.byteLength != indexBuffer.byteLength) {
        indexBuffer === null || indexBuffer === void 0 ? void 0 : indexBuffer.destroy();
        var newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, indices);
        this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
        this._indicesChangeFlag = false;
      } else if (this._indicesChangeFlag) {
        indexBuffer.setData(indices);
        if (this._indexBufferBinding._format !== this._indicesFormat) {
          this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
        }
        this._indicesChangeFlag = false;
      }
    } else if (indexBuffer) {
      indexBuffer.destroy();
      this._setIndexBufferBinding(null);
    }
    var blendShapeManager = this._blendShapeManager;
    blendShapeManager._blendShapeCount > 0 && blendShapeManager._update(vertexCountChange, noLongerAccessible);
    if (noLongerAccessible) {
      this._accessible = false;
      this._releaseCache();
    }
  }

  /**
   * @override
   * @internal
   */;
  _proto._onDestroy = function _onDestroy() {
    _Mesh.prototype._onDestroy.call(this);
    this._accessible && this._releaseCache();
  };
  _proto._updateVertexElements = function _updateVertexElements() {
    var blendShapeManager = this._blendShapeManager;
    var attributeMode = !blendShapeManager._useTextureMode();
    if (this._vertexSlotChanged || attributeMode && blendShapeManager._vertexElementsNeedUpdate()) {
      var offset = 12;
      var elementCount = 3;
      this._clearVertexElements();
      this._addVertexElement(POSITION_VERTEX_ELEMENT);
      if (this._normals) {
        this._addVertexElement(new VertexElement("NORMAL", offset, VertexElementFormat.Vector3, 0));
        offset += 12;
        elementCount += 3;
      }
      if (this._colors) {
        this._addVertexElement(new VertexElement("COLOR_0", offset, VertexElementFormat.Vector4, 0));
        offset += 16;
        elementCount += 4;
      }
      if (this._boneWeights) {
        this._addVertexElement(new VertexElement("WEIGHTS_0", offset, VertexElementFormat.Vector4, 0));
        offset += 16;
        elementCount += 4;
      }
      if (this._boneIndices) {
        this._addVertexElement(new VertexElement("JOINTS_0", offset, VertexElementFormat.UByte4, 0));
        offset += 4;
        elementCount += 1;
      }
      if (this._tangents) {
        this._addVertexElement(new VertexElement("TANGENT", offset, VertexElementFormat.Vector4, 0));
        offset += 16;
        elementCount += 4;
      }
      if (this._uv) {
        this._addVertexElement(new VertexElement("TEXCOORD_0", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv1) {
        this._addVertexElement(new VertexElement("TEXCOORD_1", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv2) {
        this._addVertexElement(new VertexElement("TEXCOORD_2", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv3) {
        this._addVertexElement(new VertexElement("TEXCOORD_3", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv4) {
        this._addVertexElement(new VertexElement("TEXCOORD_4", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv5) {
        this._addVertexElement(new VertexElement("TEXCOORD_5", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv6) {
        this._addVertexElement(new VertexElement("TEXCOORD_6", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (this._uv7) {
        this._addVertexElement(new VertexElement("TEXCOORD_7", offset, VertexElementFormat.Vector2, 0));
        offset += 8;
        elementCount += 2;
      }
      if (attributeMode) {
        blendShapeManager._blendShapeCount > 0 && blendShapeManager._addVertexElements(this);
      }
      this._vertexSlotChanged = false;
      this._vertexStrideFloat = elementCount;
      return true;
    }
    return false;
  };
  _proto._updateVertices = function _updateVertices(vertices, force) {
    // prettier-ignore
    var _vertexStrideFloat = this._vertexStrideFloat,
      _vertexCount = this._vertexCount,
      _positions = this._positions,
      _normals = this._normals,
      _colors = this._colors,
      _vertexChangeFlag = this._vertexChangeFlag,
      _boneWeights = this._boneWeights,
      _boneIndices = this._boneIndices,
      _tangents = this._tangents,
      _uv = this._uv,
      _uv1 = this._uv1,
      _uv2 = this._uv2,
      _uv3 = this._uv3,
      _uv4 = this._uv4,
      _uv5 = this._uv5,
      _uv6 = this._uv6,
      _uv7 = this._uv7;
    force && (this._vertexChangeFlag = ValueChanged.All);
    if (_vertexChangeFlag & ValueChanged.Position) {
      for (var i = 0; i < _vertexCount; i++) {
        var start = _vertexStrideFloat * i;
        var position = _positions[i];
        vertices[start] = position.x;
        vertices[start + 1] = position.y;
        vertices[start + 2] = position.z;
      }
    }
    var offset = 3;
    if (_normals) {
      if (_vertexChangeFlag & ValueChanged.Normal) {
        for (var _i = 0; _i < _vertexCount; _i++) {
          var _start = _vertexStrideFloat * _i + offset;
          var normal = _normals[_i];
          if (normal) {
            vertices[_start] = normal.x;
            vertices[_start + 1] = normal.y;
            vertices[_start + 2] = normal.z;
          }
        }
      }
      offset += 3;
    }
    if (_colors) {
      if (_vertexChangeFlag & ValueChanged.Color) {
        for (var _i2 = 0; _i2 < _vertexCount; _i2++) {
          var _start2 = _vertexStrideFloat * _i2 + offset;
          var color = _colors[_i2];
          if (color) {
            vertices[_start2] = color.r;
            vertices[_start2 + 1] = color.g;
            vertices[_start2 + 2] = color.b;
            vertices[_start2 + 3] = color.a;
          }
        }
      }
      offset += 4;
    }
    if (_boneWeights) {
      if (_vertexChangeFlag & ValueChanged.BoneWeight) {
        for (var _i3 = 0; _i3 < _vertexCount; _i3++) {
          var _start3 = _vertexStrideFloat * _i3 + offset;
          var weight = _boneWeights[_i3];
          if (weight) {
            vertices[_start3] = weight.x;
            vertices[_start3 + 1] = weight.y;
            vertices[_start3 + 2] = weight.z;
            vertices[_start3 + 3] = weight.w;
          }
        }
      }
      offset += 4;
    }
    if (_boneIndices) {
      if (_vertexChangeFlag & ValueChanged.BoneIndex) {
        var _verticesUint8 = this._verticesUint8;
        for (var _i4 = 0; _i4 < _vertexCount; _i4++) {
          var _start4 = _vertexStrideFloat * _i4 + offset;
          var joint = _boneIndices[_i4];
          if (joint) {
            var internalStart = _start4 * 4;
            _verticesUint8[internalStart] = joint.x;
            _verticesUint8[internalStart + 1] = joint.y;
            _verticesUint8[internalStart + 2] = joint.z;
            _verticesUint8[internalStart + 3] = joint.w;
          }
        }
      }
      offset += 1;
    }
    if (_tangents) {
      if (_vertexChangeFlag & ValueChanged.Tangent) {
        for (var _i5 = 0; _i5 < _vertexCount; _i5++) {
          var _start5 = _vertexStrideFloat * _i5 + offset;
          var tangent = _tangents[_i5];
          if (tangent) {
            vertices[_start5] = tangent.x;
            vertices[_start5 + 1] = tangent.y;
            vertices[_start5 + 2] = tangent.z;
            vertices[_start5 + 3] = tangent.w;
          }
        }
      }
      offset += 4;
    }
    if (_uv) {
      if (_vertexChangeFlag & ValueChanged.UV) {
        for (var _i6 = 0; _i6 < _vertexCount; _i6++) {
          var _start6 = _vertexStrideFloat * _i6 + offset;
          var _uv8 = _uv[_i6];
          if (_uv8) {
            vertices[_start6] = _uv8.x;
            vertices[_start6 + 1] = _uv8.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv1) {
      if (_vertexChangeFlag & ValueChanged.UV1) {
        for (var _i7 = 0; _i7 < _vertexCount; _i7++) {
          var _start7 = _vertexStrideFloat * _i7 + offset;
          var _uv9 = _uv1[_i7];
          if (_uv9) {
            vertices[_start7] = _uv9.x;
            vertices[_start7 + 1] = _uv9.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv2) {
      if (_vertexChangeFlag & ValueChanged.UV2) {
        for (var _i8 = 0; _i8 < _vertexCount; _i8++) {
          var _start8 = _vertexStrideFloat * _i8 + offset;
          var _uv10 = _uv2[_i8];
          if (_uv10) {
            vertices[_start8] = _uv10.x;
            vertices[_start8 + 1] = _uv10.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv3) {
      if (_vertexChangeFlag & ValueChanged.UV3) {
        for (var _i9 = 0; _i9 < _vertexCount; _i9++) {
          var _start9 = _vertexStrideFloat * _i9 + offset;
          var _uv11 = _uv3[_i9];
          if (_uv11) {
            vertices[_start9] = _uv11.x;
            vertices[_start9 + 1] = _uv11.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv4) {
      if (_vertexChangeFlag & ValueChanged.UV4) {
        for (var _i10 = 0; _i10 < _vertexCount; _i10++) {
          var _start10 = _vertexStrideFloat * _i10 + offset;
          var _uv12 = _uv4[_i10];
          if (_uv12) {
            vertices[_start10] = _uv12.x;
            vertices[_start10 + 1] = _uv12.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv5) {
      if (_vertexChangeFlag & ValueChanged.UV5) {
        for (var _i11 = 0; _i11 < _vertexCount; _i11++) {
          var _start11 = _vertexStrideFloat * _i11 + offset;
          var _uv13 = _uv5[_i11];
          if (_uv13) {
            vertices[_start11] = _uv13.x;
            vertices[_start11 + 1] = _uv13.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv6) {
      if (_vertexChangeFlag & ValueChanged.UV6) {
        for (var _i12 = 0; _i12 < _vertexCount; _i12++) {
          var _start12 = _vertexStrideFloat * _i12 + offset;
          var _uv14 = _uv6[_i12];
          if (_uv14) {
            vertices[_start12] = _uv14.x;
            vertices[_start12 + 1] = _uv14.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv7) {
      if (_vertexChangeFlag & ValueChanged.UV7) {
        for (var _i13 = 0; _i13 < _vertexCount; _i13++) {
          var _start13 = _vertexStrideFloat * _i13 + offset;
          var _uv15 = _uv7[_i13];
          if (_uv15) {
            vertices[_start13] = _uv15.x;
            vertices[_start13 + 1] = _uv15.y;
          }
        }
      }
      offset += 2;
    }
    this._vertexChangeFlag = 0;
  };
  _proto._releaseCache = function _releaseCache() {
    this._verticesUint8 = null;
    this._indices = null;
    this._verticesFloat32 = null;
    this._positions.length = 0;
    this._tangents = null;
    this._normals = null;
    this._colors = null;
    this._uv = null;
    this._uv1 = null;
    this._uv2 = null;
    this._uv3 = null;
    this._uv4 = null;
    this._uv5 = null;
    this._uv6 = null;
    this._uv7 = null;
    this._blendShapeManager._releaseMemoryCache();
  };
  _createClass(ModelMesh, [{
    key: "accessible",
    get: /** @internal */

    /**
     * Whether to access data of the mesh.
     */
    function get() {
      return this._accessible;
    }

    /**
     * Vertex count of current mesh.
     */
  }, {
    key: "vertexCount",
    get: function get() {
      return this._vertexCount;
    }

    /**
     * BlendShapes of this ModelMesh.
     */
  }, {
    key: "blendShapes",
    get: function get() {
      if (!this._accessible) {
        throw "Not allowed to access data while accessible is false.";
      }
      return this._blendShapeManager._blendShapes;
    }

    /**
     * BlendShape count of this ModelMesh.
     */
  }, {
    key: "blendShapeCount",
    get: function get() {
      return this._blendShapeManager._blendShapeCount;
    }
  }]);
  return ModelMesh;
}(Mesh);
var POSITION_VERTEX_ELEMENT = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
var ValueChanged;
(function (ValueChanged) {
  ValueChanged[ValueChanged["Position"] = 1] = "Position";
  ValueChanged[ValueChanged["Normal"] = 2] = "Normal";
  ValueChanged[ValueChanged["Color"] = 4] = "Color";
  ValueChanged[ValueChanged["Tangent"] = 8] = "Tangent";
  ValueChanged[ValueChanged["BoneWeight"] = 16] = "BoneWeight";
  ValueChanged[ValueChanged["BoneIndex"] = 32] = "BoneIndex";
  ValueChanged[ValueChanged["UV"] = 64] = "UV";
  ValueChanged[ValueChanged["UV1"] = 128] = "UV1";
  ValueChanged[ValueChanged["UV2"] = 256] = "UV2";
  ValueChanged[ValueChanged["UV3"] = 512] = "UV3";
  ValueChanged[ValueChanged["UV4"] = 1024] = "UV4";
  ValueChanged[ValueChanged["UV5"] = 2048] = "UV5";
  ValueChanged[ValueChanged["UV6"] = 4096] = "UV6";
  ValueChanged[ValueChanged["UV7"] = 8192] = "UV7";
  ValueChanged[ValueChanged["All"] = 65535] = "All";
})(ValueChanged || (ValueChanged = {}));

/**
 * Mesh skin data, equal glTF skins define
 */
var Skin = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Skin, _EngineObject);
  /**
   * Constructor of skin
   * @param name - name
   */
  function Skin(name) {
    var _this;
    _this = _EngineObject.call(this, null) || this;
    _this.name = name;
    _this.inverseBindMatrices = void 0;
    _this.joints = void 0;
    _this.skeleton = void 0;
    _this.inverseBindMatrices = []; // inverse bind matrix array
    _this.joints = []; // joints name array, element type: string
    _this.skeleton = "none"; // root bone name
    return _this;
  }
  return Skin;
}(EngineObject);

var _class$7, _descriptor$6, _descriptor2$6, _class2$6;

/**
 * MeshRenderer Component.
 */
var MeshRenderer = (_class$7 = (_class2$6 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(MeshRenderer, _Renderer);
  /** @internal */

  /**
   * @internal
   */
  function MeshRenderer(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "_mesh", _descriptor$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_meshUpdateFlag", _descriptor2$6, _assertThisInitialized(_this));
    return _this;
  }

  /**
   * Mesh assigned to the renderer.
   */
  var _proto = MeshRenderer.prototype;
  /**
   * @internal
   */
  _proto._render = function _render(camera) {
    var mesh = this._mesh;
    if (mesh) {
      if (this._meshUpdateFlag.flag) {
        var shaderData = this.shaderData;
        var vertexElements = mesh._vertexElements;
        shaderData.disableMacro(MeshRenderer._uvMacro);
        shaderData.disableMacro(MeshRenderer._uv1Macro);
        shaderData.disableMacro(MeshRenderer._normalMacro);
        shaderData.disableMacro(MeshRenderer._tangentMacro);
        shaderData.disableMacro(MeshRenderer._vertexColorMacro);
        for (var i = 0, n = vertexElements.length; i < n; i++) {
          var semantic = vertexElements[i].semantic;
          switch (semantic) {
            case "TEXCOORD_0":
              shaderData.enableMacro(MeshRenderer._uvMacro);
              break;
            case "TEXCOORD_1":
              shaderData.enableMacro(MeshRenderer._uv1Macro);
              break;
            case "NORMAL":
              shaderData.enableMacro(MeshRenderer._normalMacro);
              break;
            case "TANGENT":
              shaderData.enableMacro(MeshRenderer._tangentMacro);
              break;
            case "COLOR_0":
              shaderData.enableMacro(MeshRenderer._vertexColorMacro);
              break;
          }
        }
        this._meshUpdateFlag.flag = false;
      }
      var subMeshes = mesh.subMeshes;
      var renderPipeline = camera._renderPipeline;
      var renderElementPool = this._engine._renderElementPool;
      for (var _i = 0, _n = subMeshes.length; _i < _n; _i++) {
        var material = this._materials[_i];
        if (material) {
          var element = renderElementPool.getFromPool();
          element.setValue(this, mesh, subMeshes[_i], material);
          renderPipeline.pushPrimitive(element);
        }
      }
    } else {
      Logger.error("mesh is null.");
    }
  }

  /**
   * @internal
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {
    _Renderer.prototype._onDestroy.call(this);
    var mesh = this._mesh;
    if (mesh && !mesh.destroyed) {
      mesh._addRefCount(-1);
      this._mesh = null;
    }
  }

  /**
   * @internal
   */;
  _proto._cloneTo = function _cloneTo(target) {
    target.mesh = this._mesh;
  }

  /**
   * @override
   */;
  _proto._updateBounds = function _updateBounds(worldBounds) {
    var mesh = this._mesh;
    if (mesh) {
      var localBounds = mesh.bounds;
      var worldMatrix = this._entity.transform.worldMatrix;
      BoundingBox.transform(localBounds, worldMatrix, worldBounds);
    } else {
      worldBounds.min.set(0, 0, 0);
      worldBounds.max.set(0, 0, 0);
    }
  };
  _proto._setMesh = function _setMesh(mesh) {
    var lastMesh = this._mesh;
    if (lastMesh) {
      lastMesh._addRefCount(-1);
      this._meshUpdateFlag.destroy();
    }
    if (mesh) {
      mesh._addRefCount(1);
      this._meshUpdateFlag = mesh.registerUpdateFlag();
    }
    this._mesh = mesh;
  };
  _createClass(MeshRenderer, [{
    key: "mesh",
    get: function get() {
      return this._mesh;
    },
    set: function set(mesh) {
      if (this._mesh !== mesh) {
        this._setMesh(mesh);
      }
    }
  }]);
  return MeshRenderer;
}(Renderer), _class2$6._uvMacro = Shader.getMacroByName("O3_HAS_UV"), _class2$6._uv1Macro = Shader.getMacroByName("O3_HAS_UV1"), _class2$6._normalMacro = Shader.getMacroByName("O3_HAS_NORMAL"), _class2$6._tangentMacro = Shader.getMacroByName("O3_HAS_TANGENT"), _class2$6._vertexColorMacro = Shader.getMacroByName("O3_HAS_VERTEXCOLOR"), _class2$6), (_descriptor$6 = _applyDecoratedDescriptor(_class$7.prototype, "_mesh", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$6 = _applyDecoratedDescriptor(_class$7.prototype, "_meshUpdateFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class$7);

var _class$6, _descriptor$5, _descriptor2$5, _descriptor3$5, _descriptor4$5, _descriptor5$5, _descriptor6$5, _descriptor7$5, _descriptor8$5, _class2$5;
/**
 * SkinnedMeshRenderer.
 */
var SkinnedMeshRenderer = (_class$6 = (_class2$5 = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(SkinnedMeshRenderer, _MeshRenderer);
  /**
   * Constructor of SkinnedMeshRenderer
   * @param entity - Entity
   */
  function SkinnedMeshRenderer(entity) {
    var _this;
    _this = _MeshRenderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "matrixPalette", _descriptor$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "jointNodes", _descriptor2$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "jointTexture", _descriptor3$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_hasInitJoints", _descriptor4$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mat", _descriptor5$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_useJointTexture", _descriptor6$5, _assertThisInitialized(_this));
    _this._skin = void 0;
    _initializerDefineProperty(_this, "_blendShapeWeights", _descriptor7$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_condensedBlendShapeWeights", _descriptor8$5, _assertThisInitialized(_this));
    _this._mat = new Matrix();
    _this._skin = null;
    return _this;
  }

  /**
   * @internal
   */
  var _proto = SkinnedMeshRenderer.prototype;
  _proto._updateShaderData = function _updateShaderData(context) {
    _MeshRenderer.prototype._updateShaderData.call(this, context);
    var shaderData = this.shaderData;
    if (!this._useJointTexture && this.matrixPalette) {
      shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty, this.matrixPalette);
    }
    var mesh = this.mesh;
    mesh._blendShapeManager._updateShaderData(shaderData, this);
  }

  /**
   * Skin Object.
   */;
  _proto._initJoints = function _initJoints() {
    if (!this._skin) return;
    var skin = this._skin;
    var joints = skin.joints;
    var jointNodes = [];
    for (var i = joints.length - 1; i >= 0; i--) {
      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
    } // end of for
    this.matrixPalette = new Float32Array(jointNodes.length * 16);
    this.jointNodes = jointNodes;

    /** Whether to use a skeleton texture */
    var rhi = this.entity.engine._hardwareRenderer;
    if (!rhi) return;
    var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
    var maxJoints = Math.floor((maxAttribUniformVec4 - 30) / 4);
    var shaderData = this.shaderData;
    var jointCount = jointNodes.length;
    if (jointCount) {
      shaderData.enableMacro("O3_HAS_SKIN");
      shaderData.setInt(SkinnedMeshRenderer._jointCountProperty, jointCount);
      if (jointCount > maxJoints) {
        if (rhi.canIUseMoreJoints) {
          this._useJointTexture = true;
        } else {
          Logger.error("component's joints count(" + jointCount + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + maxAttribUniformVec4 + ", and don't support jointTexture in this device. suggest joint count less than " + maxJoints + ".", this);
        }
      } else {
        var _maxJoints = Math.max(SkinnedMeshRenderer._maxJoints, jointCount);
        SkinnedMeshRenderer._maxJoints = _maxJoints;
        shaderData.disableMacro("O3_USE_JOINT_TEXTURE");
        shaderData.enableMacro("O3_JOINTS_NUM", _maxJoints.toString());
      }
    } else {
      shaderData.disableMacro("O3_HAS_SKIN");
    }
  };
  _proto.findByNodeName = function findByNodeName(entity, nodeName) {
    if (!entity) return null;
    var n = entity.findByName(nodeName);
    if (n) return n;
    return this.findByNodeName(entity.parent, nodeName);
  }

  /**
   * @internal
   */;
  _proto.update = function update() {
    if (!this._hasInitJoints) {
      this._initJoints();
      this._hasInitJoints = true;
    }
    if (this._skin) {
      var joints = this.jointNodes;
      var ibms = this._skin.inverseBindMatrices;
      var matrixPalette = this.matrixPalette;
      var worldToLocal = this.entity.getInvModelMatrix();
      var mat = this._mat;
      for (var i = joints.length - 1; i >= 0; i--) {
        mat.identity();
        if (joints[i]) {
          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
        } else {
          mat.copyFrom(ibms[i]);
        }
        Matrix.multiply(worldToLocal, mat, mat);
        matrixPalette.set(mat.elements, i * 16);
      }
      if (this._useJointTexture) {
        this.createJointTexture();
      }
    }
  }

  /**
   * Generate joint texture.
   * Format: (4 * RGBA) * jointCont
   */;
  _proto.createJointTexture = function createJointTexture() {
    if (!this.jointTexture) {
      var engine = this.engine;
      var rhi = engine._hardwareRenderer;
      if (!rhi) return;
      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);
      this.jointTexture.filterMode = TextureFilterMode.Point;
      this.shaderData.enableMacro("O3_USE_JOINT_TEXTURE");
      this.shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty, this.jointTexture);
    }
    this.jointTexture.setPixelBuffer(this.matrixPalette);
  }

  /**
   * @internal
   */;
  _proto._cloneTo = function _cloneTo(target) {
    _MeshRenderer.prototype._cloneTo.call(this, target);
    this._blendShapeWeights && (target._blendShapeWeights = this._blendShapeWeights.slice());
  };
  _proto._checkBlendShapeWeightLength = function _checkBlendShapeWeightLength() {
    var mesh = this._mesh;
    var newBlendShapeCount = mesh ? mesh.blendShapeCount : 0;
    var lastBlendShapeWeights = this._blendShapeWeights;
    if (lastBlendShapeWeights) {
      if (lastBlendShapeWeights.length !== newBlendShapeCount) {
        var newBlendShapeWeights = new Float32Array(newBlendShapeCount);
        if (newBlendShapeCount > lastBlendShapeWeights.length) {
          newBlendShapeWeights.set(lastBlendShapeWeights);
        } else {
          for (var i = 0, n = lastBlendShapeWeights.length; i < n; i++) {
            lastBlendShapeWeights[i] = newBlendShapeWeights[i];
          }
        }
        this._blendShapeWeights = newBlendShapeWeights;
      }
    } else {
      this._blendShapeWeights = new Float32Array(newBlendShapeCount);
    }
  };
  _createClass(SkinnedMeshRenderer, [{
    key: "blendShapeWeights",
    get: /** @internal */

    /**
     * The weights of the BlendShapes.
     * @remarks Array index is BlendShape index.
     */
    function get() {
      this._checkBlendShapeWeightLength();
      return this._blendShapeWeights;
    },
    set: function set(value) {
      this._checkBlendShapeWeightLength();
      var blendShapeWeights = this._blendShapeWeights;
      if (value.length <= blendShapeWeights.length) {
        blendShapeWeights.set(value);
      } else {
        for (var i = 0, n = blendShapeWeights.length; i < n; i++) {
          blendShapeWeights[i] = value[i];
        }
      }
    }
  }, {
    key: "skin",
    get: function get() {
      return this._skin;
    },
    set: function set(skin) {
      this._skin = skin;
    }
  }]);
  return SkinnedMeshRenderer;
}(MeshRenderer), _class2$5._jointCountProperty = Shader.getPropertyByName("u_jointCount"), _class2$5._jointSamplerProperty = Shader.getPropertyByName("u_jointSampler"), _class2$5._jointMatrixProperty = Shader.getPropertyByName("u_jointMatrix"), _class2$5._maxJoints = 0, _class2$5), (_descriptor$5 = _applyDecoratedDescriptor(_class$6.prototype, "matrixPalette", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$5 = _applyDecoratedDescriptor(_class$6.prototype, "jointNodes", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$5 = _applyDecoratedDescriptor(_class$6.prototype, "jointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$5 = _applyDecoratedDescriptor(_class$6.prototype, "_hasInitJoints", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class$6.prototype, "_mat", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$5 = _applyDecoratedDescriptor(_class$6.prototype, "_useJointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor7$5 = _applyDecoratedDescriptor(_class$6.prototype, "_blendShapeWeights", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$5 = _applyDecoratedDescriptor(_class$6.prototype, "_condensedBlendShapeWeights", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class$6);

/**
 * Used to generate common primitive meshes.
 */
var PrimitiveMesh = /*#__PURE__*/function () {
  function PrimitiveMesh() {}
  /**
   * Create a sphere mesh.
   * @param engine - Engine
   * @param radius - Sphere radius
   * @param segments - Number of segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Sphere model mesh
   */
  PrimitiveMesh.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (segments === void 0) {
      segments = 18;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    segments = Math.max(2, Math.floor(segments));
    var count = segments + 1;
    var vertexCount = count * count;
    var rectangleCount = segments * segments;
    var indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);
    var thetaRange = Math.PI;
    var alphaRange = thetaRange * 2;
    var countReciprocal = 1.0 / count;
    var segmentsReciprocal = 1.0 / segments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    for (var i = 0; i < vertexCount; ++i) {
      var x = i % count;
      var y = i * countReciprocal | 0;
      var u = x * segmentsReciprocal;
      var v = y * segmentsReciprocal;
      var alphaDelta = u * alphaRange;
      var thetaDelta = v * thetaRange;
      var sinTheta = Math.sin(thetaDelta);
      var posX = -radius * Math.cos(alphaDelta) * sinTheta;
      var posY = radius * Math.cos(thetaDelta);
      var posZ = radius * Math.sin(alphaDelta) * sinTheta;

      // Position
      positions[i] = new Vector3(posX, posY, posZ);
      // Normal
      normals[i] = new Vector3(posX, posY, posZ);
      // Texcoord
      uvs[i] = new Vector2(u, v);
    }
    var offset = 0;
    for (var _i = 0; _i < rectangleCount; ++_i) {
      var _x = _i % segments;
      var _y = _i * segmentsReciprocal | 0;
      var a = _y * count + _x;
      var b = a + 1;
      var c = a + count;
      var d = c + 1;
      indices[offset++] = b;
      indices[offset++] = a;
      indices[offset++] = d;
      indices[offset++] = a;
      indices[offset++] = c;
      indices[offset++] = d;
    }
    var bounds = mesh.bounds;
    bounds.min.set(-radius, -radius, -radius);
    bounds.max.set(radius, radius, radius);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  }

  /**
   * Create a cuboid mesh.
   * @param engine - Engine
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cuboid model mesh
   */;
  PrimitiveMesh.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (depth === void 0) {
      depth = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2;
    var positions = new Array(24);
    var normals = new Array(24);
    var uvs = new Array(24);

    // Up
    positions[0] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[1] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[2] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[3] = new Vector3(-halfWidth, halfHeight, halfDepth);
    normals[0] = new Vector3(0, 1, 0);
    normals[1] = new Vector3(0, 1, 0);
    normals[2] = new Vector3(0, 1, 0);
    normals[3] = new Vector3(0, 1, 0);
    uvs[0] = new Vector2(0, 0);
    uvs[1] = new Vector2(1, 0);
    uvs[2] = new Vector2(1, 1);
    uvs[3] = new Vector2(0, 1);
    // Down
    positions[4] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    positions[5] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[6] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[7] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[4] = new Vector3(0, -1, 0);
    normals[5] = new Vector3(0, -1, 0);
    normals[6] = new Vector3(0, -1, 0);
    normals[7] = new Vector3(0, -1, 0);
    uvs[4] = new Vector2(0, 1);
    uvs[5] = new Vector2(1, 1);
    uvs[6] = new Vector2(1, 0);
    uvs[7] = new Vector2(0, 0);
    // Left
    positions[8] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[9] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[10] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    positions[11] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[8] = new Vector3(-1, 0, 0);
    normals[9] = new Vector3(-1, 0, 0);
    normals[10] = new Vector3(-1, 0, 0);
    normals[11] = new Vector3(-1, 0, 0);
    uvs[8] = new Vector2(0, 0);
    uvs[9] = new Vector2(1, 0);
    uvs[10] = new Vector2(1, 1);
    uvs[11] = new Vector2(0, 1);
    // Right
    positions[12] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[13] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[14] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[15] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    normals[12] = new Vector3(1, 0, 0);
    normals[13] = new Vector3(1, 0, 0);
    normals[14] = new Vector3(1, 0, 0);
    normals[15] = new Vector3(1, 0, 0);
    uvs[12] = new Vector2(1, 0);
    uvs[13] = new Vector2(0, 0);
    uvs[14] = new Vector2(0, 1);
    uvs[15] = new Vector2(1, 1);
    // Front
    positions[16] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[17] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[18] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[19] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[16] = new Vector3(0, 0, 1);
    normals[17] = new Vector3(0, 0, 1);
    normals[18] = new Vector3(0, 0, 1);
    normals[19] = new Vector3(0, 0, 1);
    uvs[16] = new Vector2(0, 0);
    uvs[17] = new Vector2(1, 0);
    uvs[18] = new Vector2(1, 1);
    uvs[19] = new Vector2(0, 1);
    // Back
    positions[20] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[21] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[22] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[23] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[20] = new Vector3(0, 0, -1);
    normals[21] = new Vector3(0, 0, -1);
    normals[22] = new Vector3(0, 0, -1);
    normals[23] = new Vector3(0, 0, -1);
    uvs[20] = new Vector2(1, 0);
    uvs[21] = new Vector2(0, 0);
    uvs[22] = new Vector2(0, 1);
    uvs[23] = new Vector2(1, 1);
    var indices = new Uint16Array(36);

    // prettier-ignore
    // Up
    indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3,
    // Down
    indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5,
    // Left
    indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11,
    // Right
    indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13,
    // Front
    indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19,
    // Back
    indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
    var bounds = mesh.bounds;
    bounds.min.set(-halfWidth, -halfHeight, -halfDepth);
    bounds.max.set(halfWidth, halfHeight, halfDepth);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  }

  /**
   * Create a plane mesh.
   * @param engine - Engine
   * @param width - Plane width
   * @param height - Plane height
   * @param horizontalSegments - Plane horizontal segments
   * @param verticalSegments - Plane vertical segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Plane model mesh
   */;
  PrimitiveMesh.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (horizontalSegments === void 0) {
      horizontalSegments = 1;
    }
    if (verticalSegments === void 0) {
      verticalSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
    verticalSegments = Math.max(1, Math.floor(verticalSegments));
    var horizontalCount = horizontalSegments + 1;
    var verticalCount = verticalSegments + 1;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var gridWidth = width / horizontalSegments;
    var gridHeight = height / verticalSegments;
    var vertexCount = horizontalCount * verticalCount;
    var rectangleCount = verticalSegments * horizontalSegments;
    var indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);
    var horizontalCountReciprocal = 1.0 / horizontalCount;
    var horizontalSegmentsReciprocal = 1.0 / horizontalSegments;
    var verticalSegmentsReciprocal = 1.0 / verticalSegments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    for (var i = 0; i < vertexCount; ++i) {
      var x = i % horizontalCount;
      var z = i * horizontalCountReciprocal | 0;

      // Position
      positions[i] = new Vector3(x * gridWidth - halfWidth, 0, z * gridHeight - halfHeight);
      // Normal
      normals[i] = new Vector3(0, 1, 0);
      // Texcoord
      uvs[i] = new Vector2(x * horizontalSegmentsReciprocal, z * verticalSegmentsReciprocal);
    }
    var offset = 0;
    for (var _i2 = 0; _i2 < rectangleCount; ++_i2) {
      var _x2 = _i2 % horizontalSegments;
      var y = _i2 * horizontalSegmentsReciprocal | 0;
      var a = y * horizontalCount + _x2;
      var b = a + 1;
      var c = a + horizontalCount;
      var d = c + 1;
      indices[offset++] = a;
      indices[offset++] = c;
      indices[offset++] = b;
      indices[offset++] = c;
      indices[offset++] = d;
      indices[offset++] = b;
    }
    var bounds = mesh.bounds;
    bounds.min.set(-halfWidth, 0, -halfHeight);
    bounds.max.set(halfWidth, 0, halfHeight);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  }

  /**
   * Create a cylinder mesh.
   * @param engine - Engine
   * @param radiusTop - The radius of top cap
   * @param radiusBottom - The radius of bottom cap
   * @param height - The height of torso
   * @param radialSegments - Cylinder radial segments
   * @param heightSegments - Cylinder height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cylinder model mesh
   */;
  PrimitiveMesh.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radiusTop === void 0) {
      radiusTop = 0.5;
    }
    if (radiusBottom === void 0) {
      radiusBottom = 0.5;
    }
    if (height === void 0) {
      height = 2;
    }
    if (radialSegments === void 0) {
      radialSegments = 20;
    }
    if (heightSegments === void 0) {
      heightSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var capTriangleCount = radialSegments * 2;
    var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;
    var indices = PrimitiveMesh._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);
    var radialCountReciprocal = 1.0 / radialCount;
    var radialSegmentsReciprocal = 1.0 / radialSegments;
    var heightSegmentsReciprocal = 1.0 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;

    // Create torso
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var radiusDiff = radiusBottom - radiusTop;
    var slope = radiusDiff / height;
    var radiusSlope = radiusDiff / heightSegments;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var radius = radiusBottom - y * radiusSlope;
      var posX = radius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = radius * cosTheta;

      // Position
      positions[i] = new Vector3(posX, posY, posZ);
      // Normal
      normals[i] = new Vector3(sinTheta, slope, cosTheta);
      // Texcoord
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var _i3 = 0; _i3 < torsoRectangleCount; ++_i3) {
      var _x3 = _i3 % radialSegments;
      var _y2 = _i3 * radialSegmentsReciprocal | 0;
      var a = _y2 * radialCount + _x3;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }

    // Bottom position
    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
    // Bottom normal
    normals[torsoVertexCount] = new Vector3(0, -1, 0);
    // Bottom texcoord
    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);

    // Top position
    positions[torsoVertexCount + 1] = new Vector3(0, halfHeight, 0);
    // Top normal
    normals[torsoVertexCount + 1] = new Vector3(0, 1, 0);
    // Top texcoord
    uvs[torsoVertexCount + 1] = new Vector2(0.5, 0.5);

    // Add cap vertices
    var offset = torsoVertexCount + 2;
    var diameterTopReciprocal = 1.0 / (radiusTop * 2);
    var diameterBottomReciprocal = 1.0 / (radiusBottom * 2);
    var positionStride = radialCount * heightSegments;
    for (var _i4 = 0; _i4 < radialSegments; ++_i4) {
      var curPosBottom = positions[_i4];
      var curPosX = curPosBottom.x;
      var curPosZ = curPosBottom.z;

      // Bottom position
      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
      // Bottom normal
      normals[offset] = new Vector3(0, -1, 0);
      // Bottom texcoord
      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
      var curPosTop = positions[_i4 + positionStride];
      curPosX = curPosTop.x;
      curPosZ = curPosTop.z;

      // Top position
      positions[offset] = new Vector3(curPosX, halfHeight, curPosZ);
      // Top normal
      normals[offset] = new Vector3(0, 1, 0);
      // Top texcoord
      uvs[offset++] = new Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);
    }

    // Add cap indices
    var topCapIndex = torsoVertexCount + 1;
    var bottomIndiceIndex = torsoVertexCount + 2;
    var topIndiceIndex = bottomIndiceIndex + 1;
    for (var _i5 = 0; _i5 < radialSegments; ++_i5) {
      var firstStride = _i5 * 2;
      var secondStride = _i5 === radialSegments - 1 ? 0 : firstStride + 2;

      // Bottom
      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;

      // Top
      indices[indicesOffset++] = topCapIndex;
      indices[indicesOffset++] = topIndiceIndex + firstStride;
      indices[indicesOffset++] = topIndiceIndex + secondStride;
    }
    var bounds = mesh.bounds;
    var radiusMax = Math.max(radiusTop, radiusBottom);
    bounds.min.set(-radiusMax, -halfHeight, -radiusMax);
    bounds.max.set(radiusMax, halfHeight, radiusMax);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  }

  /**
   * Create a torus mesh.
   * @param engine - Engine
   * @param radius - Torus radius
   * @param tubeRadius - Torus tube
   * @param radialSegments - Torus radial segments
   * @param tubularSegments - Torus tubular segments
   * @param arc - Central angle
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Torus model mesh
   */;
  PrimitiveMesh.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (tubeRadius === void 0) {
      tubeRadius = 0.1;
    }
    if (radialSegments === void 0) {
      radialSegments = 30;
    }
    if (tubularSegments === void 0) {
      tubularSegments = 30;
    }
    if (arc === void 0) {
      arc = 360;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
    var rectangleCount = radialSegments * tubularSegments;
    var indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    arc = arc / 180 * Math.PI;
    var offset = 0;
    for (var i = 0; i <= radialSegments; i++) {
      for (var j = 0; j <= tubularSegments; j++) {
        var u = j / tubularSegments * arc;
        var v = i / radialSegments * Math.PI * 2;
        var cosV = Math.cos(v);
        var sinV = Math.sin(v);
        var cosU = Math.cos(u);
        var sinU = Math.sin(u);
        var position = new Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
        positions[offset] = position;
        var centerX = radius * cosU;
        var centerY = radius * sinU;
        normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
        uvs[offset++] = new Vector2(j / tubularSegments, i / radialSegments);
      }
    }
    offset = 0;
    for (var _i6 = 1; _i6 <= radialSegments; _i6++) {
      for (var _j = 1; _j <= tubularSegments; _j++) {
        var a = (tubularSegments + 1) * _i6 + _j - 1;
        var b = (tubularSegments + 1) * (_i6 - 1) + _j - 1;
        var c = (tubularSegments + 1) * (_i6 - 1) + _j;
        var d = (tubularSegments + 1) * _i6 + _j;
        indices[offset++] = a;
        indices[offset++] = b;
        indices[offset++] = d;
        indices[offset++] = b;
        indices[offset++] = c;
        indices[offset++] = d;
      }
    }
    var bounds = mesh.bounds;
    var outerRadius = radius + tubeRadius;
    bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
    bounds.max.set(outerRadius, outerRadius, tubeRadius);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  }

  /**
   * Create a cone mesh.
   * @param engine - Engine
   * @param radius - The radius of cap
   * @param height - The height of torso
   * @param radialSegments - Cylinder radial segments
   * @param heightSegments - Cylinder height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cone model mesh
   */;
  PrimitiveMesh.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (height === void 0) {
      height = 2;
    }
    if (radialSegments === void 0) {
      radialSegments = 20;
    }
    if (heightSegments === void 0) {
      heightSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var totalVertexCount = torsoVertexCount + 1 + radialSegments;
    var indices = PrimitiveMesh._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);
    var radialCountReciprocal = 1.0 / radialCount;
    var radialSegmentsReciprocal = 1.0 / radialSegments;
    var heightSegmentsReciprocal = 1.0 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;

    // Create torso
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var slope = radius / height;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var curRadius = radius - y * radius;
      var posX = curRadius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = curRadius * cosTheta;

      // Position
      positions[i] = new Vector3(posX, posY, posZ);
      // Normal
      normals[i] = new Vector3(sinTheta, slope, cosTheta);
      // Texcoord
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var _i7 = 0; _i7 < torsoRectangleCount; ++_i7) {
      var _x4 = _i7 % radialSegments;
      var _y3 = _i7 * radialSegmentsReciprocal | 0;
      var a = _y3 * radialCount + _x4;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }

    // Bottom position
    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
    // Bottom normal
    normals[torsoVertexCount] = new Vector3(0, -1, 0);
    // Bottom texcoord
    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);

    // Add bottom cap vertices
    var offset = torsoVertexCount + 1;
    var diameterBottomReciprocal = 1.0 / (radius * 2);
    for (var _i8 = 0; _i8 < radialSegments; ++_i8) {
      var curPos = positions[_i8];
      var curPosX = curPos.x;
      var curPosZ = curPos.z;

      // Bottom position
      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
      // Bottom normal
      normals[offset] = new Vector3(0, -1, 0);
      // Bottom texcoord
      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
    }
    var bottomIndiceIndex = torsoVertexCount + 1;
    for (var _i9 = 0; _i9 < radialSegments; ++_i9) {
      var firstStride = _i9;
      var secondStride = _i9 === radialSegments - 1 ? 0 : firstStride + 1;

      // Bottom
      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;
    }
    var bounds = mesh.bounds;
    bounds.min.set(-radius, -halfHeight, -radius);
    bounds.max.set(radius, halfHeight, radius);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  }

  /**
   * Create a capsule mesh.
   * @param engine - Engine
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param radialSegments - Hemispherical end radial segments
   * @param heightSegments - Cylindrical part height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Capsule model mesh
   */;
  PrimitiveMesh.createCapsule = function createCapsule(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (height === void 0) {
      height = 2;
    }
    if (radialSegments === void 0) {
      radialSegments = 6;
    }
    if (heightSegments === void 0) {
      heightSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.max(2, Math.floor(radialSegments));
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var capVertexCount = radialCount * radialCount;
    var capRectangleCount = radialSegments * radialSegments;
    var totalVertexCount = torsoVertexCount + 2 * capVertexCount;
    var indices = PrimitiveMesh._generateIndices(engine, totalVertexCount, (torsoRectangleCount + 2 * capRectangleCount) * 6);
    var radialCountReciprocal = 1.0 / radialCount;
    var radialSegmentsReciprocal = 1.0 / radialSegments;
    var heightSegmentsReciprocal = 1.0 / heightSegments;
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;

    // create torso
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      positions[i] = new Vector3(radius * sinTheta, y * unitHeight - halfHeight, radius * cosTheta);
      normals[i] = new Vector3(sinTheta, 0, cosTheta);
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var _i10 = 0; _i10 < torsoRectangleCount; ++_i10) {
      var _x5 = _i10 % radialSegments;
      var _y4 = _i10 * radialSegmentsReciprocal | 0;
      var a = _y4 * radialCount + _x5;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }
    PrimitiveMesh._createCapsuleCap(radius, height, radialSegments, thetaRange, torsoVertexCount, 1, positions, normals, uvs, indices, indicesOffset);
    PrimitiveMesh._createCapsuleCap(radius, height, radialSegments, -thetaRange, torsoVertexCount + capVertexCount, -1, positions, normals, uvs, indices, indicesOffset + 6 * capRectangleCount);
    var bounds = mesh.bounds;
    bounds.min.set(-radius, -radius - halfHeight, -radius);
    bounds.max.set(radius, radius + halfHeight, radius);
    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh._initialize = function _initialize(mesh, positions, normals, uvs, indices, noLongerAccessible) {
    mesh.setPositions(positions);
    mesh.setNormals(normals);
    mesh.setUVs(uvs);
    mesh.setIndices(indices);
    mesh.uploadData(noLongerAccessible);
    mesh.addSubMesh(0, indices.length);
  };
  PrimitiveMesh._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
    var indices = null;
    if (vertexCount > 65535) {
      if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        indices = new Uint32Array(indexCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(indexCount);
    }
    return indices;
  };
  PrimitiveMesh._createCapsuleCap = function _createCapsuleCap(radius, height, radialSegments, capAlphaRange, offset, posIndex, positions, normals, uvs, indices, indicesOffset) {
    var radialCount = radialSegments + 1;
    var halfHeight = height * 0.5 * posIndex;
    var capVertexCount = radialCount * radialCount;
    var capRectangleCount = radialSegments * radialSegments;
    var radialCountReciprocal = 1.0 / radialCount;
    var radialSegmentsReciprocal = 1.0 / radialSegments;
    for (var i = 0; i < capVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * radialSegmentsReciprocal;
      var alphaDelta = u * capAlphaRange;
      var thetaDelta = v * Math.PI / 2;
      var sinTheta = Math.sin(thetaDelta);
      var posX = -radius * Math.cos(alphaDelta) * sinTheta;
      var posY = radius * Math.cos(thetaDelta) * posIndex + halfHeight;
      var posZ = radius * Math.sin(alphaDelta) * sinTheta;
      var index = i + offset;
      positions[index] = new Vector3(posX, posY, posZ);
      normals[index] = new Vector3(posX, posY - halfHeight, posZ);
      uvs[index] = new Vector2(u, v);
    }
    for (var _i11 = 0; _i11 < capRectangleCount; ++_i11) {
      var _x6 = _i11 % radialSegments;
      var _y5 = _i11 * radialSegmentsReciprocal | 0;
      var a = _y5 * radialCount + _x6 + offset;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = d;
    }
  };
  return PrimitiveMesh;
}();

/**
 * BufferMesh.
 */
var BufferMesh = /*#__PURE__*/function (_Mesh) {
  _inheritsLoose(BufferMesh, _Mesh);
  function BufferMesh() {
    return _Mesh.apply(this, arguments) || this;
  }
  var _proto = BufferMesh.prototype;
  /**
   * Set vertex elements.
   * @param elements - Vertex element collection
   */
  _proto.setVertexElements = function setVertexElements(elements) {
    this._setVertexElements(elements);
  }

  /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param index - Vertex buffer index, the default value is 0
   */;
  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
    if (strideOrFirstIndex === void 0) {
      strideOrFirstIndex = 0;
    }
    if (index === void 0) {
      index = 0;
    }
    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== undefined;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    var bindings = this._vertexBufferBindings;
    bindings.length <= index && (bindings.length = index + 1);
    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
  }

  /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */;
  _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
    if (firstIndex === void 0) {
      firstIndex = 0;
    }
    var bindings = this._vertexBufferBindings;
    var count = vertexBufferBindings.length;
    var needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);
    for (var i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
    }
  }

  /**
   * Set index buffer binding.
   * @param buffer - Index buffer
   * @param format - Index buffer format
   */;
  _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
    var binding = bufferOrBinding;
    if (binding) {
      var isBinding = binding.buffer !== undefined;
      isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
    }
    this._setIndexBufferBinding(binding);
  };
  _createClass(BufferMesh, [{
    key: "instanceCount",
    get:
    /**
     * Instanced count, disable instanced drawing when set zero.
     */
    function get() {
      return this._instanceCount;
    },
    set: function set(value) {
      this._instanceCount = value;
    }

    /**
     * Vertex buffer binding collection.
     */
  }, {
    key: "vertexBufferBindings",
    get: function get() {
      return this._vertexBufferBindings;
    }

    /**
     * Index buffer binding.
     */
  }, {
    key: "indexBufferBinding",
    get: function get() {
      return this._indexBufferBinding;
    }

    /**
     * Vertex element collection.
     */
  }, {
    key: "vertexElements",
    get: function get() {
      return this._vertexElements;
    }
  }]);
  return BufferMesh;
}(Mesh);

/**
 * BlendShapeFrame.
 */
var BlendShapeFrame = /** Weight of BlendShapeFrame. */

/** Delta positions for the frame being added. */

/** Delta normals for the frame being added. */

/** Delta tangents for the frame being added. */

/**
 * Create a BlendShapeFrame.
 * @param weight - Weight of BlendShapeFrame
 * @param deltaPositions - Delta positions for the frame being added
 * @param deltaNormals - Delta normals for the frame being added
 * @param deltaTangents - Delta tangents for the frame being added
 */
function BlendShapeFrame(weight, deltaPositions, deltaNormals, deltaTangents) {
  if (deltaNormals === void 0) {
    deltaNormals = null;
  }
  if (deltaTangents === void 0) {
    deltaTangents = null;
  }
  this.weight = void 0;
  this.deltaPositions = void 0;
  this.deltaNormals = void 0;
  this.deltaTangents = void 0;
  if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
    throw "deltaNormals length must same with deltaPositions length.";
  }
  if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
    throw "deltaTangents length must same with deltaPositions length.";
  }
  this.weight = weight;
  this.deltaPositions = deltaPositions;
  this.deltaNormals = deltaNormals;
  this.deltaTangents = deltaTangents;
};

/**
 * BlendShape.
 */
var BlendShape = /*#__PURE__*/function () {
  /**
   * Create a BlendShape.
   * @param name - BlendShape name.
   */
  function BlendShape(name) {
    this.name = void 0;
    this._useBlendShapeNormal = true;
    this._useBlendShapeTangent = true;
    this._layoutChangeManager = new UpdateFlagManager();
    this._dataChangeManager = new UpdateFlagManager();
    this._frames = [];
    this.name = name;
  }

  /**
   * Add a BlendShapeFrame by weight, deltaPositions, deltaNormals and deltaTangents.
   * @param weight - Weight of BlendShapeFrame
   * @param deltaPositions - Delta positions for the frame being added
   * @param deltaNormals - Delta normals for the frame being added
   * @param deltaTangents - Delta tangents for the frame being added
   */
  var _proto = BlendShape.prototype;
  _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
    if (typeof frameOrWeight === "number") {
      var _frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);
      this._addFrame(_frame);
      return _frame;
    } else {
      this._addFrame(frameOrWeight);
    }
  }

  /**
   * Clear all frames.
   */;
  _proto.clearFrames = function clearFrames() {
    this._frames.length = 0;
    this._updateUseNormalAndTangent(true, true);
    this._dataChangeManager.dispatch();
  }

  /**
   * @internal
   */;
  _proto._addLayoutChangeFlag = function _addLayoutChangeFlag(flag) {
    this._layoutChangeManager.addFlag(flag);
  }

  /**
   * @internal
   */;
  _proto._addDataDirtyFlag = function _addDataDirtyFlag(flag) {
    this._dataChangeManager.addFlag(flag);
  }

  /**
   * @internal
   */;
  _proto._createSubDataDirtyFlag = function _createSubDataDirtyFlag() {
    return this._dataChangeManager.createFlag(BoolUpdateFlag);
  };
  _proto._addFrame = function _addFrame(frame) {
    var frames = this._frames;
    var frameCount = frames.length;
    if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
      throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
    }
    this._frames.push(frame);
    this._updateUseNormalAndTangent(!!frame.deltaNormals, !!frame.deltaTangents);
    this._dataChangeManager.dispatch();
  };
  _proto._updateUseNormalAndTangent = function _updateUseNormalAndTangent(useNormal, useTangent) {
    var useBlendShapeNormal = this._useBlendShapeNormal && useNormal;
    var useBlendShapeTangent = this._useBlendShapeTangent && useTangent;
    if (this._useBlendShapeNormal !== useBlendShapeNormal || this._useBlendShapeTangent !== useBlendShapeTangent) {
      this._useBlendShapeNormal = useBlendShapeNormal;
      this._useBlendShapeTangent = useBlendShapeTangent;
      this._layoutChangeManager.dispatch(this);
    }
  };
  _createClass(BlendShape, [{
    key: "frames",
    get: /** Name of BlendShape. */

    /** @internal */

    /** @internal */

    /**
     * Frames of BlendShape.
     */
    function get() {
      return this._frames;
    }
  }]);
  return BlendShape;
}();

var Basic2DBatcher = /*#__PURE__*/function () {
  /** The maximum number of vertex. */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  function Basic2DBatcher(engine) {
    this._engine = void 0;
    this._subMeshPool = new ClassPool(SubMesh);
    this._batchedQueue = [];
    this._meshes = [];
    this._meshCount = 1;
    this._vertexBuffers = [];
    this._indiceBuffers = [];
    this._vertices = void 0;
    this._indices = void 0;
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    this._engine = engine;
    var MAX_VERTEX_COUNT = Basic2DBatcher.MAX_VERTEX_COUNT;
    this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);
    this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);
    var _meshes = this._meshes,
      _meshCount = this._meshCount;
    for (var i = 0; i < _meshCount; i++) {
      _meshes[i] = this._createMesh(engine, i);
    }
  }
  var _proto = Basic2DBatcher.prototype;
  _proto.drawElement = function drawElement(element, camera, replaceMaterial) {
    if (element.multiRenderData) {
      var elements = element.charElements;
      for (var i = 0, n = elements.length; i < n; ++i) {
        this._drawSubElement(elements[i], camera, replaceMaterial);
      }
    } else {
      this._drawSubElement(element, camera, replaceMaterial);
    }
  };
  _proto._drawSubElement = function _drawSubElement(element, camera, replaceMaterial) {
    var len = element.renderData.vertexCount;
    if (this._vertexCount + len > Basic2DBatcher.MAX_VERTEX_COUNT) {
      this.flush(camera, replaceMaterial);
    }
    this._vertexCount += len;
    this._batchedQueue[this._elementCount++] = element;
  };
  _proto.flush = function flush(camera, replaceMaterial) {
    var batchedQueue = this._batchedQueue;
    if (batchedQueue.length === 0) {
      return;
    }
    this._updateData(this._engine);
    this.drawBatches(camera, replaceMaterial);
    if (!Basic2DBatcher._canUploadSameBuffer) {
      this._flushId++;
    }
    batchedQueue.length = 0;
    this._subMeshPool.resetPool();
    this._vertexCount = 0;
    this._elementCount = 0;
  };
  _proto.clear = function clear() {
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    this._batchedQueue.length = 0;
  };
  _proto.destroy = function destroy() {
    this._batchedQueue = null;
    var meshes = this._meshes,
      vertexBuffers = this._vertexBuffers,
      indiceBuffers = this._indiceBuffers;
    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }
    this._meshes = null;
    for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
      vertexBuffers[_i].destroy();
    }
    this._vertexBuffers = null;
    for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
      indiceBuffers[_i2].destroy();
    }
    this._indiceBuffers = null;
  };
  _proto._createMesh = function _createMesh(engine, index) {
    var MAX_VERTEX_COUNT = Basic2DBatcher.MAX_VERTEX_COUNT;
    var mesh = new BufferMesh(engine, "BufferMesh" + index);
    var vertexElements = [];
    var vertexStride = this.createVertexElements(vertexElements);

    // vertices
    this._vertexBuffers[index] = new Buffer(engine, BufferBindFlag.VertexBuffer, MAX_VERTEX_COUNT * 4 * vertexStride, BufferUsage.Dynamic);
    // indices
    this._indiceBuffers[index] = new Buffer(engine, BufferBindFlag.IndexBuffer, MAX_VERTEX_COUNT * 3, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(this._vertexBuffers[index], vertexStride);
    mesh.setIndexBufferBinding(this._indiceBuffers[index], IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    return mesh;
  };
  _proto._updateData = function _updateData(engine) {
    var _meshes = this._meshes,
      _flushId = this._flushId;
    if (!Basic2DBatcher._canUploadSameBuffer && this._meshCount <= _flushId) {
      this._meshCount++;
      _meshes[_flushId] = this._createMesh(engine, _flushId);
    }
    var batchedQueue = this._batchedQueue,
      vertices = this._vertices,
      indices = this._indices;
    var mesh = _meshes[_flushId];
    mesh.clearSubMesh();
    var vertexIndex = 0;
    var indiceIndex = 0;
    var vertexStartIndex = 0;
    var vertexCount = 0;
    var curIndiceStartIndex = 0;
    var curMeshIndex = 0;
    var preElement = null;
    for (var i = 0, len = batchedQueue.length; i < len; i++) {
      var _curElement = batchedQueue[i];

      // Batch vertex
      vertexIndex = this.updateVertices(_curElement, vertices, vertexIndex);

      // Batch indice
      var triangles = _curElement.renderData.triangles;
      var triangleNum = triangles.length;
      for (var j = 0; j < triangleNum; j++) {
        indices[indiceIndex++] = triangles[j] + curIndiceStartIndex;
      }
      curIndiceStartIndex += _curElement.renderData.vertexCount;
      if (preElement === null) {
        vertexCount += triangleNum;
      } else {
        if (this.canBatch(preElement, _curElement)) {
          vertexCount += triangleNum;
        } else {
          mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
          vertexStartIndex += vertexCount;
          vertexCount = triangleNum;
          batchedQueue[curMeshIndex++] = preElement;
        }
      }
      preElement = _curElement;
    }
    mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
    batchedQueue[curMeshIndex] = preElement;
    this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);
    this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);
  };
  _proto._getSubMeshFromPool = function _getSubMeshFromPool(start, count) {
    var subMesh = this._subMeshPool.getFromPool();
    subMesh.start = start;
    subMesh.count = count;
    subMesh.topology = MeshTopology.Triangles;
    return subMesh;
  }

  /**
   * @internal
   */;
  return Basic2DBatcher;
}();
Basic2DBatcher.MAX_VERTEX_COUNT = 4096;
Basic2DBatcher._canUploadSameBuffer = true;

var SpriteMaskBatcher = /*#__PURE__*/function (_Basic2DBatcher) {
  _inheritsLoose(SpriteMaskBatcher, _Basic2DBatcher);
  function SpriteMaskBatcher() {
    return _Basic2DBatcher.apply(this, arguments) || this;
  }
  var _proto = SpriteMaskBatcher.prototype;
  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    return 20;
  };
  _proto.canBatch = function canBatch(preElement, curElement) {
    if (preElement.isAdd !== curElement.isAdd) {
      return false;
    }

    // Compare renderer property
    var preShaderData = preElement.component.shaderData;
    var curShaderData = curElement.component.shaderData;
    var textureProperty = SpriteMask._textureProperty;
    var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
    return preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) && preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty);
  };
  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var _element$renderData = element.renderData,
      positions = _element$renderData.positions,
      uvs = _element$renderData.uvs,
      vertexCount = _element$renderData.vertexCount;
    for (var i = 0; i < vertexCount; i++) {
      var curPos = positions[i];
      var curUV = uvs[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
    }
    return vertexIndex;
  };
  _proto.drawBatches = function drawBatches(camera) {
    var engine = this._engine,
      batchedQueue = this._batchedQueue;
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var sceneData = camera.scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteMaskElement = batchedQueue[i];
      if (!subMesh || !spriteMaskElement) {
        return;
      }
      var renderer = spriteMaskElement.component;
      var material = spriteMaskElement.material;
      var compileMacros = Shader._compileMacros;
      // union render global macro and material self macro.
      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);

      // Update stencil state
      var stencilState = material.renderState.stencilState;
      var op = spriteMaskElement.isAdd ? StencilOperation.IncrementSaturate : StencilOperation.DecrementSaturate;
      stencilState.passOperationFront = op;
      stencilState.passOperationBack = op;
      var program = material.shader._getShaderProgram(engine, compileMacros);
      if (!program.isValid) {
        return;
      }
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, sceneData);
      program.uploadAll(program.cameraUniformBlock, cameraData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);
      material.renderState._apply(engine, false);
      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
    }
  };
  return SpriteMaskBatcher;
}(Basic2DBatcher);

/**
 * @internal
 */
var SpriteMaskManager = /*#__PURE__*/function () {
  function SpriteMaskManager(engine) {
    this._batcher = void 0;
    this._preMaskLayer = 0;
    this._batcher = new SpriteMaskBatcher(engine);
  }
  var _proto = SpriteMaskManager.prototype;
  _proto.clear = function clear() {
    this._preMaskLayer = 0;
    this._batcher.clear();
  };
  _proto.preRender = function preRender(camera, renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }
    this._batcher.clear();
    this._processMasksDiff(camera, renderer);
    this._batcher.flush(camera, null);
  };
  _proto.postRender = function postRender(renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }
    this._preMaskLayer = renderer.maskLayer;
  };
  _proto.destroy = function destroy() {
    this._batcher.destroy();
    this._batcher = null;
  };
  _proto._processMasksDiff = function _processMasksDiff(camera, renderer) {
    var preMaskLayer = this._preMaskLayer;
    var curMaskLayer = renderer.maskLayer;
    if (preMaskLayer !== curMaskLayer) {
      var allMasks = camera._renderPipeline._allSpriteMasks;
      var commonLayer = preMaskLayer & curMaskLayer;
      var addLayer = curMaskLayer & ~preMaskLayer;
      var reduceLayer = preMaskLayer & ~curMaskLayer;
      var allMaskElements = allMasks._elements;
      for (var i = 0, n = allMasks.length; i < n; i++) {
        var mask = allMaskElements[i];
        var influenceLayers = mask.influenceLayers;
        if (influenceLayers & commonLayer) {
          continue;
        }
        if (influenceLayers & addLayer) {
          var maskRenderElement = mask._maskElement;
          maskRenderElement.isAdd = true;
          this._batcher.drawElement(maskRenderElement, camera, null);
          continue;
        }
        if (influenceLayers & reduceLayer) {
          var _maskRenderElement = mask._maskElement;
          _maskRenderElement.isAdd = false;
          this._batcher.drawElement(_maskRenderElement, camera, null);
        }
      }
    }
  };
  return SpriteMaskManager;
}();

var TextRenderElement = /*#__PURE__*/function (_RenderElement) {
  _inheritsLoose(TextRenderElement, _RenderElement);
  function TextRenderElement() {
    var _this;
    _this = _RenderElement.call(this) || this;
    _this.charElements = [];
    _this.multiRenderData = true;
    return _this;
  }
  return TextRenderElement;
}(RenderElement);

/**
 * The Background mode enumeration.
 */
var BackgroundMode;
(function (BackgroundMode) {
  BackgroundMode[BackgroundMode["SolidColor"] = 0] = "SolidColor";
  BackgroundMode[BackgroundMode["Sky"] = 1] = "Sky";
  BackgroundMode[BackgroundMode["Texture"] = 2] = "Texture";
})(BackgroundMode || (BackgroundMode = {}));

/**
 * Filling mode of background texture.
 */
var BackgroundTextureFillMode;
(function (BackgroundTextureFillMode) {
  BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitWidth"] = 0] = "AspectFitWidth";
  BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitHeight"] = 1] = "AspectFitHeight";
  BackgroundTextureFillMode[BackgroundTextureFillMode["Fill"] = 2] = "Fill";
})(BackgroundTextureFillMode || (BackgroundTextureFillMode = {}));

/**
 * Sky.
 */
var Sky = function Sky() {
  this.material = void 0;
  this.mesh = void 0;
  this._matrix = new Matrix();
};

/**
 * Background of scene.
 */
var Background = /*#__PURE__*/function () {
  /**
   * Constructor of Background.
   * @param _engine Engine Which the background belongs to.
   */
  function Background(_engine) {
    this._engine = _engine;
    this.mode = BackgroundMode.SolidColor;
    this.solidColor = new Color(0.25, 0.25, 0.25, 1.0);
    this.sky = new Sky();
    this._textureFillMode = BackgroundTextureFillMode.AspectFitHeight;
    this._mesh = void 0;
    this._texture = null;
    this._mesh = this._createPlane(_engine);
  }

  /**
   * @internal
   */
  var _proto = Background.prototype;
  _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
    if (!this._texture) {
      return;
    }
    var canvas = this._engine.canvas;
    var width = canvas.width,
      height = canvas.height;
    var _backgroundTextureMesh = this._mesh;
    var positions = _backgroundTextureMesh.getPositions();
    switch (this._textureFillMode) {
      case BackgroundTextureFillMode.Fill:
        positions[0].set(-1, -1, 1);
        positions[1].set(1, -1, 1);
        positions[2].set(-1, 1, 1);
        positions[3].set(1, 1, 1);
        break;
      case BackgroundTextureFillMode.AspectFitWidth:
        var fitWidthScale = this._texture.height * width / this.texture.width / height;
        positions[0].set(-1, -fitWidthScale, 1);
        positions[1].set(1, -fitWidthScale, 1);
        positions[2].set(-1, fitWidthScale, 1);
        positions[3].set(1, fitWidthScale, 1);
        break;
      case BackgroundTextureFillMode.AspectFitHeight:
        var fitHeightScale = this._texture.width * height / this.texture.height / width;
        positions[0].set(-fitHeightScale, -1, 1);
        positions[1].set(fitHeightScale, -1, 1);
        positions[2].set(-fitHeightScale, 1, 1);
        positions[3].set(fitHeightScale, 1, 1);
        break;
    }
    _backgroundTextureMesh.setPositions(positions);
    _backgroundTextureMesh.uploadData(false);
  };
  _proto._createPlane = function _createPlane(engine) {
    var mesh = new ModelMesh(engine);
    mesh.isGCIgnored = true;
    var indices = new Uint8Array([1, 2, 0, 1, 3, 2]);
    var positions = new Array(4);
    var uvs = new Array(4);
    for (var i = 0; i < 4; ++i) {
      positions[i] = new Vector3();
      uvs[i] = new Vector2(i % 2, 1 - (i * 0.5 | 0));
    }
    mesh.setPositions(positions);
    mesh.setUVs(uvs);
    mesh.setIndices(indices);
    mesh.uploadData(false);
    mesh.addSubMesh(0, indices.length);
    return mesh;
  };
  _createClass(Background, [{
    key: "texture",
    get:
    /**
     * Background mode.
     * @defaultValue `BackgroundMode.SolidColor`
     * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.
     */

    /**
     * Background solid color.
     * @defaultValue `new Color(0.25, 0.25, 0.25, 1.0)`
     * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.
     */

    /**
     * Background sky.
     * @remarks When `mode` is `BackgroundMode.Sky`, the property will take effects.
     */

    /** @internal */

    /** @internal */

    /**
     * Background texture.
     * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
     */
    function get() {
      return this._texture;
    },
    set: function set(value) {
      if (this._texture !== value) {
        this._texture = value;
        this._engine._backgroundTextureMaterial.shaderData.setTexture("u_baseTexture", value);
      }
    }

    /**
     * @internal
     * Background texture fill mode.
     * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
     * @defaultValue `BackgroundTextureFillMode.FitHeight`
     */
  }, {
    key: "textureFillMode",
    get: function get() {
      return this._textureFillMode;
    },
    set: function set(value) {
      if (value !== this._textureFillMode) {
        this._textureFillMode = value;
        this._resizeBackgroundTexture();
      }
    }
  }]);
  return Background;
}();

/**
 * Diffuse mode.
 */
var DiffuseMode;
(function (DiffuseMode) {
  DiffuseMode[DiffuseMode["SolidColor"] = 0] = "SolidColor";
  DiffuseMode[DiffuseMode["SphericalHarmonics"] = 1] = "SphericalHarmonics";
})(DiffuseMode || (DiffuseMode = {}));

/**
 * Ambient light.
 */
var AmbientLight = /*#__PURE__*/function () {
  function AmbientLight() {
    this._diffuseSphericalHarmonics = void 0;
    this._diffuseSolidColor = new Color(0.212, 0.227, 0.259);
    this._diffuseIntensity = 1.0;
    this._specularTexture = void 0;
    this._specularIntensity = 1.0;
    this._diffuseMode = DiffuseMode.SolidColor;
    this._shArray = new Float32Array(27);
    this._scenes = [];
    this._specularTextureDecodeRGBM = false;
  }
  var _proto = AmbientLight.prototype;
  /**
   * @internal
   */
  _proto._addToScene = function _addToScene(scene) {
    this._scenes.push(scene);
    var shaderData = scene.shaderData;
    shaderData.setColor(AmbientLight._diffuseColorProperty, this._diffuseSolidColor);
    shaderData.setFloat(AmbientLight._diffuseIntensityProperty, this._diffuseIntensity);
    shaderData.setFloat(AmbientLight._specularIntensityProperty, this._specularIntensity);
    shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._shArray);
    this._setDiffuseMode(shaderData);
    this._setSpecularTextureDecodeRGBM(shaderData);
    this._setSpecularTexture(shaderData);
  }

  /**
   * @internal
   */;
  _proto._removeFromScene = function _removeFromScene(scene) {
    var scenes = this._scenes;
    var index = scenes.indexOf(scene);
    scenes.splice(index, 1);
  };
  _proto._setDiffuseMode = function _setDiffuseMode(sceneShaderData) {
    if (this._diffuseMode === DiffuseMode.SphericalHarmonics) {
      sceneShaderData.enableMacro(AmbientLight._shMacro);
    } else {
      sceneShaderData.disableMacro(AmbientLight._shMacro);
    }
  };
  _proto._setSpecularTexture = function _setSpecularTexture(sceneShaderData) {
    if (this._specularTexture) {
      sceneShaderData.setTexture(AmbientLight._specularTextureProperty, this._specularTexture);
      sceneShaderData.setFloat(AmbientLight._mipLevelProperty, this._specularTexture.mipmapCount - 1);
      sceneShaderData.enableMacro(AmbientLight._specularMacro);
    } else {
      sceneShaderData.disableMacro(AmbientLight._specularMacro);
    }
  };
  _proto._setSpecularTextureDecodeRGBM = function _setSpecularTextureDecodeRGBM(sceneShaderData) {
    if (this._specularTextureDecodeRGBM) {
      sceneShaderData.enableMacro(AmbientLight._decodeRGBMMacro);
    } else {
      sceneShaderData.disableMacro(AmbientLight._decodeRGBMMacro);
    }
  };
  _proto._preComputeSH = function _preComputeSH(sh, out) {
    /**
     * Basis constants
     *
     * 0: 1/2 * Math.sqrt(1 / Math.PI)
     *
     * 1: -1/2 * Math.sqrt(3 / Math.PI)
     * 2: 1/2 * Math.sqrt(3 / Math.PI)
     * 3: -1/2 * Math.sqrt(3 / Math.PI)
     *
     * 4: 1/2 * Math.sqrt(15 / Math.PI)
     * 5: -1/2 * Math.sqrt(15 / Math.PI)
     * 6: 1/4 * Math.sqrt(5 / Math.PI)
     * 7: -1/2 * Math.sqrt(15 / Math.PI)
     * 8: 1/4 * Math.sqrt(15 / Math.PI)
     */

    /**
     * Convolution kernel
     *
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */

    var src = sh.coefficients;

    // l0
    out[0] = src[0] * 0.886227; // kernel0 * basis0 = 0.886227
    out[1] = src[1] * 0.886227;
    out[2] = src[2] * 0.886227;

    // l1
    out[3] = src[3] * -1.023327; // kernel1 * basis1 = -1.023327;
    out[4] = src[4] * -1.023327;
    out[5] = src[5] * -1.023327;
    out[6] = src[6] * 1.023327; // kernel1 * basis2 = 1.023327
    out[7] = src[7] * 1.023327;
    out[8] = src[8] * 1.023327;
    out[9] = src[9] * -1.023327; // kernel1 * basis3 = -1.023327
    out[10] = src[10] * -1.023327;
    out[11] = src[11] * -1.023327;

    // l2
    out[12] = src[12] * 0.858086; // kernel2 * basis4 = 0.858086
    out[13] = src[13] * 0.858086;
    out[14] = src[14] * 0.858086;
    out[15] = src[15] * -0.858086; // kernel2 * basis5 = -0.858086
    out[16] = src[16] * -0.858086;
    out[17] = src[17] * -0.858086;
    out[18] = src[18] * 0.247708; // kernel2 * basis6 = 0.247708
    out[19] = src[19] * 0.247708;
    out[20] = src[20] * 0.247708;
    out[21] = src[21] * -0.858086; // kernel2 * basis7 = -0.858086
    out[22] = src[22] * -0.858086;
    out[23] = src[23] * -0.858086;
    out[24] = src[24] * 0.429042; // kernel2 * basis8 = 0.429042
    out[25] = src[25] * 0.429042;
    out[26] = src[26] * 0.429042;
  };
  _createClass(AmbientLight, [{
    key: "specularTextureDecodeRGBM",
    get:
    /**
     * Whether to decode from specularTexture with RGBM format.
     */
    function get() {
      return this._specularTextureDecodeRGBM;
    },
    set: function set(value) {
      this._specularTextureDecodeRGBM = value;
      var scenes = this._scenes;
      for (var i = 0, n = scenes.length; i < n; i++) {
        this._setSpecularTextureDecodeRGBM(scenes[i].shaderData);
      }
    }

    /**
     * Diffuse mode of ambient light.
     */
  }, {
    key: "diffuseMode",
    get: function get() {
      return this._diffuseMode;
    },
    set: function set(value) {
      this._diffuseMode = value;
      var scenes = this._scenes;
      for (var i = 0, n = scenes.length; i < n; i++) {
        this._setDiffuseMode(scenes[i].shaderData);
      }
    }

    /**
     * Diffuse reflection solid color.
     * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.
     */
  }, {
    key: "diffuseSolidColor",
    get: function get() {
      return this._diffuseSolidColor;
    },
    set: function set(value) {
      if (value !== this._diffuseSolidColor) {
        this._diffuseSolidColor.copyFrom(value);
      }
    }

    /**
     * Diffuse reflection spherical harmonics 3.
     * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.
     */
  }, {
    key: "diffuseSphericalHarmonics",
    get: function get() {
      return this._diffuseSphericalHarmonics;
    },
    set: function set(value) {
      this._diffuseSphericalHarmonics = value;
      if (value) {
        this._preComputeSH(value, this._shArray);
        var scenes = this._scenes;
        for (var i = 0, n = scenes.length; i < n; i++) {
          scenes[i].shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._shArray);
        }
      }
    }

    /**
     * Diffuse reflection intensity.
     */
  }, {
    key: "diffuseIntensity",
    get: function get() {
      return this._diffuseIntensity;
    },
    set: function set(value) {
      this._diffuseIntensity = value;
      var scenes = this._scenes;
      for (var i = 0, n = scenes.length; i < n; i++) {
        scenes[i].shaderData.setFloat(AmbientLight._diffuseIntensityProperty, value);
      }
    }

    /**
     * Specular reflection texture.
     * @remarks This texture must be baked from @oasis-engine/baker
     */
  }, {
    key: "specularTexture",
    get: function get() {
      return this._specularTexture;
    },
    set: function set(value) {
      this._specularTexture = value;
      var scenes = this._scenes;
      for (var i = 0, n = scenes.length; i < n; i++) {
        this._setSpecularTexture(scenes[i].shaderData);
      }
    }

    /**
     * Specular reflection intensity.
     */
  }, {
    key: "specularIntensity",
    get: function get() {
      return this._specularIntensity;
    },
    set: function set(value) {
      this._specularIntensity = value;
      for (var i = 0, n = this._scenes.length; i < n; i++) {
        this._scenes[i].shaderData.setFloat(AmbientLight._specularIntensityProperty, value);
      }
    }
  }]);
  return AmbientLight;
}();
AmbientLight._shMacro = Shader.getMacroByName("O3_USE_SH");
AmbientLight._specularMacro = Shader.getMacroByName("O3_USE_SPECULAR_ENV");
AmbientLight._decodeRGBMMacro = Shader.getMacroByName("O3_DECODE_ENV_RGBM");
AmbientLight._diffuseColorProperty = Shader.getPropertyByName("u_envMapLight.diffuse");
AmbientLight._diffuseSHProperty = Shader.getPropertyByName("u_env_sh");
AmbientLight._diffuseIntensityProperty = Shader.getPropertyByName("u_envMapLight.diffuseIntensity");
AmbientLight._specularTextureProperty = Shader.getPropertyByName("u_env_specularSampler");
AmbientLight._specularIntensityProperty = Shader.getPropertyByName("u_envMapLight.specularIntensity");
AmbientLight._mipLevelProperty = Shader.getPropertyByName("u_envMapLight.mipMapLevel");

/**
 * Scene feature plug-in.
 * @deprecated
 */
var SceneFeature = /*#__PURE__*/function () {
  function SceneFeature() {}
  var _proto = SceneFeature.prototype;
  /**
   * Callback before every scene update.
   * @param scene - Scene
   */
  _proto.preUpdate = function preUpdate(scene) {}

  /**
   * Callback after every scene update.
   * @param scene - Scene
   */;
  _proto.postUpdate = function postUpdate(scene) {}

  /**
   * Callback before scene rendering.
   * @param scene - Scene
   * @param camera - Camera
   */;
  _proto.preRender = function preRender(scene, camera) {}

  /**
   * Callback after scene rendering.
   * @param scene - Scene
   * @param camera - Camera
   */;
  _proto.postRender = function postRender(scene, camera) {}

  /**
   * Callback after the scene is destroyed.
   * @param scene - Scene
   */;
  _proto.destroy = function destroy(scene) {};
  return SceneFeature;
}();

/**
 * Light base class.
 */
var Light = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Light, _Component);
  function Light() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this._viewMat = void 0;
    _this._inverseViewMat = void 0;
    return _this;
  }
  var _proto = Light.prototype;
  /**
   * Mount to the current Scene.
   * @internal
   * @override
   */
  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(LightFeature).attachRenderLight(this);
  }

  /**
   * Unmount from the current Scene.
   * @internal
   * @override
   */;
  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(LightFeature).detachRenderLight(this);
  }

  /**
   * View matrix.
   */;
  _createClass(Light, [{
    key: "viewMatrix",
    get: function get() {
      if (!this._viewMat) this._viewMat = new Matrix();
      Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
      return this._viewMat;
    }

    /**
     * Inverse view matrix.
     */
  }, {
    key: "inverseViewMatrix",
    get: function get() {
      if (!this._inverseViewMat) this._inverseViewMat = new Matrix();
      Matrix.invert(this.viewMatrix, this._inverseViewMat);
      return this._inverseViewMat;
    }
  }]);
  return Light;
}(Component);
Light._maxLight = 10;

/**
 * Directional light.
 */
var DirectLight = /*#__PURE__*/function (_Light) {
  _inheritsLoose(DirectLight, _Light);
  function DirectLight() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._reverseDirection = new Vector3();
    return _this;
  }
  /**
   * @internal
   */
  DirectLight._updateShaderData = function _updateShaderData(shaderData) {
    var data = DirectLight._combinedData;
    shaderData.setFloatArray(DirectLight._colorProperty, data.color);
    shaderData.setFloatArray(DirectLight._directionProperty, data.direction);
  };
  var _proto = DirectLight.prototype;
  /**
   * @internal
   */
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var lightColor = this.lightColor;
    var direction = this.direction;
    var data = DirectLight._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
  };
  _createClass(DirectLight, [{
    key: "direction",
    get:
    /**
     * Get direction.
     */
    function get() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }

    /**
     * Get the final light color.
     */
  }, {
    key: "lightColor",
    get: function get() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }

    /**
     * Get the opposite direction of the directional light direction.
     */
  }, {
    key: "reverseDirection",
    get: function get() {
      Vector3.scale(this.direction, -1, this._reverseDirection);
      return this._reverseDirection;
    }
  }]);
  return DirectLight;
}(Light);
DirectLight._colorProperty = Shader.getPropertyByName("u_directLightColor");
DirectLight._directionProperty = Shader.getPropertyByName("u_directLightDirection");
DirectLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight)
};

/**
 * Point light.
 */
var PointLight = /*#__PURE__*/function (_Light) {
  _inheritsLoose(PointLight, _Light);
  function PointLight() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1.0;
    _this.distance = 100;
    _this._lightColor = new Color(1, 1, 1, 1);
    return _this;
  }
  /**
   * @internal
   */
  PointLight._updateShaderData = function _updateShaderData(shaderData) {
    var data = PointLight._combinedData;
    shaderData.setFloatArray(PointLight._colorProperty, data.color);
    shaderData.setFloatArray(PointLight._positionProperty, data.position);
    shaderData.setFloatArray(PointLight._distanceProperty, data.distance);
  }
  /** Light color. */;
  var _proto = PointLight.prototype;
  /**
   * @internal
   */
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var lightColor = this.lightColor;
    var lightPosition = this.position;
    var data = PointLight._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.position[positionStart] = lightPosition.x;
    data.position[positionStart + 1] = lightPosition.y;
    data.position[positionStart + 2] = lightPosition.z;
    data.distance[distanceStart] = this.distance;
  };
  _createClass(PointLight, [{
    key: "position",
    get:
    /**
     * Get light position.
     */
    function get() {
      return this.entity.transform.worldPosition;
    }

    /**
     * Get the final light color.
     */
  }, {
    key: "lightColor",
    get: function get() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);
  return PointLight;
}(Light);
PointLight._colorProperty = Shader.getPropertyByName("u_pointLightColor");
PointLight._positionProperty = Shader.getPropertyByName("u_pointLightPosition");
PointLight._distanceProperty = Shader.getPropertyByName("u_pointLightDistance");
PointLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight)
};

/**
 * Spot light.
 */
var SpotLight = /*#__PURE__*/function (_Light) {
  _inheritsLoose(SpotLight, _Light);
  function SpotLight() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1.0;
    _this.distance = 100;
    _this.angle = Math.PI / 6;
    _this.penumbra = Math.PI / 12;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._inverseDirection = new Vector3();
    return _this;
  }
  /**
   * @internal
   */
  SpotLight._updateShaderData = function _updateShaderData(shaderData) {
    var data = SpotLight._combinedData;
    shaderData.setFloatArray(SpotLight._colorProperty, data.color);
    shaderData.setFloatArray(SpotLight._positionProperty, data.position);
    shaderData.setFloatArray(SpotLight._directionProperty, data.direction);
    shaderData.setFloatArray(SpotLight._distanceProperty, data.distance);
    shaderData.setFloatArray(SpotLight._angleCosProperty, data.angleCos);
    shaderData.setFloatArray(SpotLight._penumbraCosProperty, data.penumbraCos);
  }

  /** Light color. */;
  var _proto = SpotLight.prototype;
  /**
   * @internal
   */
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var penumbraCosStart = lightIndex;
    var angleCosStart = lightIndex;
    var color = this.lightColor;
    var position = this.position;
    var direction = this.direction;
    var data = SpotLight._combinedData;
    data.color[colorStart] = color.r;
    data.color[colorStart + 1] = color.g;
    data.color[colorStart + 2] = color.b;
    data.position[positionStart] = position.x;
    data.position[positionStart + 1] = position.y;
    data.position[positionStart + 2] = position.z;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
    data.distance[distanceStart] = this.distance;
    data.angleCos[angleCosStart] = Math.cos(this.angle);
    data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
  };
  _createClass(SpotLight, [{
    key: "position",
    get:
    /**
     * Get light position.
     */
    function get() {
      return this.entity.transform.worldPosition;
    }

    /**
     * Get light direction.
     */
  }, {
    key: "direction",
    get: function get() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }

    /**
     * Get the opposite direction of the spotlight.
     */
  }, {
    key: "reverseDirection",
    get: function get() {
      Vector3.scale(this.direction, -1, this._inverseDirection);
      return this._inverseDirection;
    }

    /**
     * Get the final light color.
     */
  }, {
    key: "lightColor",
    get: function get() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);
  return SpotLight;
}(Light);
SpotLight._colorProperty = Shader.getPropertyByName("u_spotLightColor");
SpotLight._positionProperty = Shader.getPropertyByName("u_spotLightPosition");
SpotLight._directionProperty = Shader.getPropertyByName("u_spotLightDirection");
SpotLight._distanceProperty = Shader.getPropertyByName("u_spotLightDistance");
SpotLight._angleCosProperty = Shader.getPropertyByName("u_spotLightAngleCos");
SpotLight._penumbraCosProperty = Shader.getPropertyByName("u_spotLightPenumbraCos");
SpotLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight),
  angleCos: new Float32Array(Light._maxLight),
  penumbraCos: new Float32Array(Light._maxLight)
};

/**
 * Determine whether there are lights in the scene.
 * @returns Has light
 */
function hasLight() {
  return this.findFeature(LightFeature).visibleLights.length > 0;
}

/**
 * Light plug-in.
 */
var LightFeature = /*#__PURE__*/function (_SceneFeature) {
  _inheritsLoose(LightFeature, _SceneFeature);
  function LightFeature() {
    var _this;
    _this = _SceneFeature.call(this) || this;
    _this.visibleLights = void 0;
    _this.visibleLights = [];
    return _this;
  }

  /**
   * Register a light object to the current scene.
   * @param light
   */
  var _proto = LightFeature.prototype;
  _proto.attachRenderLight = function attachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);
    if (index == -1) {
      this.visibleLights.push(light);
    } else {
      Logger.warn("Light already attached.");
    }
  }

  /**
   * Remove a light object from the current scene.
   * @param light
   */;
  _proto.detachRenderLight = function detachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);
    if (index != -1) {
      this.visibleLights.splice(index, 1);
    }
  }

  /**
   * @internal
   */;
  _proto._updateShaderData = function _updateShaderData(shaderData) {
    /**
     * ambientLight and envMapLight only use the last one in the scene
     * */
    var directLightCount = 0;
    var pointLightCount = 0;
    var spotLightCount = 0;
    var lights = this.visibleLights;
    for (var i = 0, len = lights.length; i < len; i++) {
      var light = lights[i];
      if (light instanceof DirectLight) {
        light._appendData(directLightCount++);
      } else if (light instanceof PointLight) {
        light._appendData(pointLightCount++);
      } else if (light instanceof SpotLight) {
        light._appendData(spotLightCount++);
      }
    }
    if (directLightCount) {
      DirectLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT", directLightCount.toString());
    } else {
      shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");
    }
    if (pointLightCount) {
      PointLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_POINT_LIGHT_COUNT", pointLightCount.toString());
    } else {
      shaderData.disableMacro("O3_POINT_LIGHT_COUNT");
    }
    if (spotLightCount) {
      SpotLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_SPOT_LIGHT_COUNT", spotLightCount.toString());
    } else {
      shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");
    }
  };
  return LightFeature;
}(SceneFeature);

/**
 * Scene.
 */
var Scene = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Scene, _EngineObject);
  /**
   * Create scene.
   * @param engine - Engine
   * @param name - Name
   */
  function Scene(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.background = new Background(_this._engine);
    _this.shaderData = new ShaderData(ShaderDataGroup.Scene);
    _this._activeCameras = [];
    _this._isActiveInEngine = false;
    _this._globalShaderMacro = new ShaderMacroCollection();
    _this._rootEntities = [];
    _this._ambientLight = void 0;
    _this.features = [];
    _this.name = name || "";
    var shaderData = _this.shaderData;
    Scene.sceneFeatureManager.addObject(_assertThisInitialized(_this));
    shaderData._addRefCount(1);
    _this.ambientLight = new AmbientLight();
    engine.sceneManager._allScenes.push(_assertThisInitialized(_this));
    return _this;
  }

  /**
   * Create root entity.
   * @param name - Entity name
   * @returns Entity
   */
  var _proto = Scene.prototype;
  _proto.createRootEntity = function createRootEntity(name) {
    var entity = new Entity(this._engine, name);
    this.addRootEntity(entity);
    return entity;
  }

  /**
   * Append an entity.
   * @param entity - The root entity to add
   */;
  _proto.addRootEntity = function addRootEntity(indexOrChild, entity) {
    var index;
    if (typeof indexOrChild === "number") {
      index = indexOrChild;
    } else {
      index = undefined;
      entity = indexOrChild;
    }
    var isRoot = entity._isRoot;
    // let entity become root
    if (!isRoot) {
      entity._isRoot = true;
      entity._removeFromParent();
    }

    // add or remove from scene's rootEntities
    var oldScene = entity._scene;
    if (oldScene !== this) {
      if (oldScene && isRoot) {
        oldScene._removeFromEntityList(entity);
      }
      this._addToRootEntityList(index, entity);
      Entity._traverseSetOwnerScene(entity, this);
    } else if (!isRoot) {
      this._addToRootEntityList(index, entity);
    }

    // process entity active/inActive
    if (this._isActiveInEngine) {
      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
    } else {
      entity._isActiveInHierarchy && entity._processInActive();
    }
  }

  /**
   * Remove an entity.
   * @param entity - The root entity to remove
   */;
  _proto.removeRootEntity = function removeRootEntity(entity) {
    if (entity._isRoot && entity._scene == this) {
      this._removeFromEntityList(entity);
      entity._isRoot = false;
      this._isActiveInEngine && entity._isActiveInHierarchy && entity._processInActive();
      Entity._traverseSetOwnerScene(entity, null);
    }
  }

  /**
   * Get root entity from index.
   * @param index - Index
   * @returns Entity
   */;
  _proto.getRootEntity = function getRootEntity(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._rootEntities[index];
  }

  /**
   * Find entity globally by name.
   * @param name - Entity name
   * @returns Entity
   */;
  _proto.findEntityByName = function findEntityByName(name) {
    var children = this._rootEntities;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    for (var _i = children.length - 1; _i >= 0; _i--) {
      var _child = children[_i];
      var _entity = _child.findByName(name);
      if (_entity) {
        return _entity;
      }
    }
    return null;
  }

  /**
   * Find entity globally by name,use ‘/’ symbol as a path separator.
   * @param path - Entity's path
   * @returns Entity
   */;
  _proto.findEntityByPath = function findEntityByPath(path) {
    var splits = path.split("/").filter(Boolean);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      var findEntity = this.getRootEntity(i);
      if (findEntity.name != splits[0]) continue;
      for (var j = 1, m = splits.length; j < m; ++j) {
        findEntity = Entity._findChildByName(findEntity, splits[j]);
        if (!findEntity) break;
      }
      return findEntity;
    }
    return null;
  }

  /**
   * Destroy this scene.
   */;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._destroy();
    var allScenes = this.engine.sceneManager._allScenes;
    allScenes.splice(allScenes.indexOf(this), 1);
  }

  /**
   * @internal
   */;
  _proto._attachRenderCamera = function _attachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index === -1) {
      this._activeCameras.push(camera);
    } else {
      Logger.warn("Camera already attached.");
    }
  }

  /**
   * @internal
   */;
  _proto._detachRenderCamera = function _detachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index !== -1) {
      this._activeCameras.splice(index, 1);
    }
  }

  /**
   * @internal
   */;
  _proto._processActive = function _processActive(active) {
    this._isActiveInEngine = active;
    var rootEntities = this._rootEntities;
    for (var i = rootEntities.length - 1; i >= 0; i--) {
      var _entity2 = rootEntities[i];
      if (_entity2._isActive) {
        active ? _entity2._processActive() : _entity2._processInActive();
      }
    }
  }

  /**
   * @internal
   */;
  _proto._updateShaderData = function _updateShaderData() {
    this.findFeature(LightFeature)._updateShaderData(this.shaderData);
    // union scene and camera macro.
    ShaderMacroCollection.unionCollection(this.engine._macroCollection, this.shaderData._macroCollection, this._globalShaderMacro);
  }

  /**
   * @internal
   */;
  _proto._removeFromEntityList = function _removeFromEntityList(entity) {
    var rootEntities = this._rootEntities;
    var index = entity._siblingIndex;
    rootEntities.splice(index, 1);
    for (var n = rootEntities.length; index < n; index++) {
      rootEntities[index]._siblingIndex--;
    }
    entity._siblingIndex = -1;
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
    Scene.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      this._rootEntities[i].destroy();
    }
    this._rootEntities.length = 0;
    this._activeCameras.length = 0;
    Scene.sceneFeatureManager._objects = [];
    this.shaderData._addRefCount(-1);
  };
  _proto._addToRootEntityList = function _addToRootEntityList(index, rootEntity) {
    var rootEntities = this._rootEntities;
    var rootEntityCount = rootEntities.length;
    if (index === undefined) {
      rootEntity._siblingIndex = rootEntityCount;
      rootEntities.push(rootEntity);
    } else {
      if (index < 0 || index > rootEntityCount) {
        throw "The index " + index + " is out of child list bounds " + rootEntityCount;
      }
      rootEntity._siblingIndex = index;
      rootEntities.splice(index, 0, rootEntity);
      for (var i = index + 1, n = rootEntityCount + 1; i < n; i++) {
        rootEntities[i]._siblingIndex++;
      }
    }
  }

  //-----------------------------------------@deprecated-----------------------------------
  ;
  Scene.registerFeature = function registerFeature(Feature) {
    Scene.sceneFeatureManager.registerFeature(Feature);
  };
  _proto.findFeature = function findFeature(Feature) {
    return Scene.sceneFeatureManager.findFeature(this, Feature);
  };
  _createClass(Scene, [{
    key: "ambientLight",
    get: /** Scene name. */

    /** The background of the scene. */

    /** Scene-related shader data. */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Ambient light.
     */
    function get() {
      return this._ambientLight;
    },
    set: function set(value) {
      if (!value) {
        Logger.warn("The scene must have one ambient light");
        return;
      }
      var lastAmbientLight = this._ambientLight;
      if (lastAmbientLight !== value) {
        lastAmbientLight && lastAmbientLight._removeFromScene(this);
        value._addToScene(this);
        this._ambientLight = value;
      }
    }

    /**
     * Count of root entities.
     */
  }, {
    key: "rootEntitiesCount",
    get: function get() {
      return this._rootEntities.length;
    }

    /**
     * Root entity collection.
     */
  }, {
    key: "rootEntities",
    get: function get() {
      return this._rootEntities;
    }
  }]);
  return Scene;
}(EngineObject);
Scene.sceneFeatureManager = new FeatureManager();

/**
 * Scene manager.
 */
var SceneManager = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SceneManager(engine) {
    this.engine = engine;
    this._allScenes = [];
    this._activeScene = void 0;
  }

  /**
   * Load and activate scene.
   * @param url - the path of the scene
   * @param destroyOldScene - whether to destroy old scene information
   * @returns scene promise
   */
  var _proto = SceneManager.prototype;
  _proto.loadScene = function loadScene(url, destroyOldScene) {
    var _this = this;
    if (destroyOldScene === void 0) {
      destroyOldScene = true;
    }
    var scenePromise = this.engine.resourceManager.load(url);
    scenePromise.then(function (scene) {
      var oldScene = _this._activeScene;
      _this.activeScene = scene;
      if (oldScene && destroyOldScene) {
        oldScene.destroy();
      }
    });
    return scenePromise;
  }

  /**
   * Merge the source scene into the target scene.
   * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.
   * @param sourceScene - source scene
   * @param destScene - target scene
   */;
  _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
    var oldRootEntities = sourceScene.rootEntities;
    for (var i = 0, n = oldRootEntities.length; i < n; i++) {
      destScene.addRootEntity(oldRootEntities[i]);
    }
  }

  /**
   * @internal
   */;
  _proto._destroyAllScene = function _destroyAllScene() {
    var allScenes = this._allScenes;
    for (var i = 0, n = allScenes.length; i < n; i++) {
      allScenes[i]._destroy();
    }
    allScenes.length = 0;
  };
  _createClass(SceneManager, [{
    key: "activeScene",
    get: /** @internal */

    /** @internal */

    /**
     * Get the activated scene.
     */
    function get() {
      return this._activeScene;
    },
    set: function set(scene) {
      var oldScene = this._activeScene;
      if (oldScene !== scene) {
        oldScene && oldScene._processActive(false);
        scene && scene._processActive(true);
        this._activeScene = scene;
      }
    }
  }]);
  return SceneManager;
}();

var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <mobile_material_frag>\n#include <fog_share>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#ifndef OASIS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n#include <fog_frag>\n}"; // eslint-disable-line

var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}"; // eslint-disable-line

var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}"; // eslint-disable-line

var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}"; // eslint-disable-line

var pbrFs = "#define GLSLIFY 1\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <common_frag>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <fog_frag>\n}"; // eslint-disable-line

var pbrSpecularFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <fog_frag>\n}"; // eslint-disable-line

var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}"; // eslint-disable-line

var shadowMapFs = "#define GLSLIFY 1\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}"; // eslint-disable-line

var shadowMapVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}"; // eslint-disable-line

var shadowFs = "#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}"; // eslint-disable-line

var skyboxFs = "#define GLSLIFY 1\n#include <common>\nuniform samplerCube u_cube;varying vec3 v_cubeUV;uniform vec4 u_cubeDecodeParam;void main(){vec4 textureColor=textureCube(u_cube,v_cubeUV);if(u_cubeDecodeParam.x>0.0){textureColor=RGBMToLinear(textureColor,u_cubeDecodeParam.y);textureColor=linearToGamma(textureColor);}gl_FragColor=textureColor;}"; // eslint-disable-line

var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=vec3(-POSITION.x,POSITION.yz);gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}"; // eslint-disable-line

var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D u_maskTexture;uniform float u_maskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(u_maskTexture,v_uv);if(color.a<u_maskAlphaCutoff){discard;}gl_FragColor=color;}"; // eslint-disable-line

var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 u_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=u_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

var spriteFs = "#define GLSLIFY 1\n#ifdef USE_CUSTOM_TEXTURE\nuniform sampler2D u_cusTomTexture;\n#else\nuniform sampler2D u_spriteTexture;\n#endif\nvarying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_CUSTOM_TEXTURE\nvec4 baseColor=texture2D(u_cusTomTexture,v_uv);\n#else\nvec4 baseColor=texture2D(u_spriteTexture,v_uv);\n#endif\ngl_FragColor=baseColor*v_color;}"; // eslint-disable-line

var spriteVs = "#define GLSLIFY 1\n#ifdef USE_MODEL_MATRIX\nuniform mat4 u_MVPMat;\n#else\nuniform mat4 u_VPMat;\n#endif\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_MODEL_MATRIX\ngl_Position=u_MVPMat*vec4(POSITION,1.0);\n#else\ngl_Position=u_VPMat*vec4(POSITION,1.0);\n#endif\nv_uv=TEXCOORD_0;v_color=COLOR_0;}"; // eslint-disable-line

var unlitFs = "#define GLSLIFY 1\n#include <common>\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;uniform float u_alphaCutoff;\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef BASETEXTURE\nvec4 textureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\ntextureColor=gammaToLinear(textureColor);\n#endif\nbaseColor*=textureColor;\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<u_alphaCutoff){discard;}\n#endif\n#ifndef OASIS_COLORSPACE_GAMMA\nbaseColor=linearToGamma(baseColor);\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}"; // eslint-disable-line

var unlitVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}"; // eslint-disable-line

var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

var backgroundTextureFs = "#define GLSLIFY 1\nuniform sampler2D u_baseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_baseTexture,v_uv);}"; // eslint-disable-line

/**
 * Internal shader pool.
 * @internal
 */
var ShaderPool = /*#__PURE__*/function () {
  function ShaderPool() {}
  ShaderPool.init = function init() {
    Shader.create("blinn-phong", blinnPhongVs, blinnPhongFs);
    Shader.create("pbr", pbrVs, pbrFs);
    Shader.create("pbr-specular", pbrVs, pbrSpecularFs);
    Shader.create("unlit", unlitVs, unlitFs);
    Shader.create("shadow-map", shadowMapVs, shadowMapFs);
    Shader.create("shadow", shadowMapVs, shadowFs);
    Shader.create("skybox", skyboxVs, skyboxFs);
    Shader.create("particle-shader", particleVs, particleFs);
    Shader.create("SpriteMask", spriteMaskVs, spriteMaskFs);
    Shader.create("Sprite", spriteVs, spriteFs);
    Shader.create("background-texture", backgroundTextureVs, backgroundTextureFs);
  };
  return ShaderPool;
}();

/**
 * Shader program pool.
 * @internal
 */
var ShaderProgramPool = /*#__PURE__*/function () {
  function ShaderProgramPool() {
    this._cacheHierarchy = 1;
    this._cacheMap = Object.create(null);
    this._lastQueryMap = void 0;
    this._lastQueryKey = void 0;
  }
  var _proto = ShaderProgramPool.prototype;
  /**
   * Get shader program by macro collection.
   * @param macros - macro collection
   * @returns shader program
   */
  _proto.get = function get(macros) {
    var cacheMap = this._cacheMap;
    var maskLength = macros._length;
    if (maskLength > this._cacheHierarchy) {
      this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
    }
    var mask = macros._mask;
    var endIndex = macros._length - 1;
    var maxEndIndex = this._cacheHierarchy - 1;
    for (var i = 0; i < maxEndIndex; i++) {
      var subMask = endIndex < i ? 0 : mask[i];
      var subCacheShaders = cacheMap[subMask];
      subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));
      cacheMap = subCacheShaders;
    }
    var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
    var shader = cacheMap[cacheKey];
    if (!shader) {
      this._lastQueryKey = cacheKey;
      this._lastQueryMap = cacheMap;
    }
    return shader;
  }

  /**
   * Cache the shader program.
   *
   * @remarks
   * The method must return an empty value after calling get() to run normally.
   *
   * @param shaderProgram - shader program
   */;
  _proto.cache = function cache(shaderProgram) {
    this._lastQueryMap[this._lastQueryKey] = shaderProgram;
  };
  _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
    // only expand but not shrink.
    var end = this._cacheHierarchy - 1;
    if (hierarchy == end) {
      for (var k in cacheMap) {
        var shader = cacheMap[k];
        for (var i = 0, n = resizeLength - end; i < n; i++) {
          if (i == n - 1) {
            cacheMap[0] = shader;
          } else {
            cacheMap = cacheMap[i == 0 ? k : 0] = Object.create(null);
          }
        }
      }
      this._cacheHierarchy = resizeLength;
    } else {
      for (var _k in cacheMap) {
        this._resizeCacheMapHierarchy(cacheMap[_k], ++hierarchy, resizeLength);
      }
    }
  };
  return ShaderProgramPool;
}();

/** TODO: delete */
var engineFeatureManager = new FeatureManager();
ShaderPool.init();

/**
 * Engine.
 */
var Engine = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(Engine, _EventDispatcher);
  /**
   * Create engine.
   * @param canvas - The canvas to use for rendering
   * @param hardwareRenderer - Graphics API renderer
   */
  function Engine(canvas, hardwareRenderer, settings) {
    var _this;
    _this = _EventDispatcher.call(this) || this;
    _this.physicsManager = void 0;
    _this.inputManager = void 0;
    _this._componentsManager = new ComponentsManager();
    _this._hardwareRenderer = void 0;
    _this._lastRenderState = new RenderState();
    _this._renderElementPool = new ClassPool(MeshRenderElement);
    _this._spriteElementPool = new ClassPool(SpriteElement);
    _this._spriteMaskElementPool = new ClassPool(SpriteMaskElement);
    _this._textElementPool = new ClassPool(TextRenderElement);
    _this._spriteDefaultMaterial = void 0;
    _this._spriteMaskDefaultMaterial = void 0;
    _this._renderContext = new RenderContext();
    _this._magentaTexture2D = void 0;
    _this._magentaTextureCube = void 0;
    _this._magentaTexture2DArray = void 0;
    _this._magentaMaterial = void 0;
    _this._backgroundTextureMaterial = void 0;
    _this._renderCount = 0;
    _this._shaderProgramPools = [];
    _this._spriteMaskManager = void 0;
    _this._canSpriteBatch = true;
    _this._macroCollection = new ShaderMacroCollection();
    _this._canvas = void 0;
    _this._settings = {};
    _this._resourceManager = new ResourceManager(_assertThisInitialized(_this));
    _this._sceneManager = new SceneManager(_assertThisInitialized(_this));
    _this._vSyncCount = 1;
    _this._targetFrameRate = 60;
    _this._time = new Time();
    _this._isPaused = true;
    _this._requestId = void 0;
    _this._timeoutId = void 0;
    _this._vSyncCounter = 1;
    _this._targetFrameInterval = 1000 / 60;
    _this._destroyed = false;
    _this._waittingDestroy = false;
    _this._animate = function () {
      if (_this._vSyncCount) {
        _this._requestId = requestAnimationFrame(_this._animate);
        if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
          _this.update();
          _this._vSyncCounter = 1;
        }
      } else {
        _this._timeoutId = window.setTimeout(_this._animate, _this._targetFrameInterval);
        _this.update();
      }
    };
    _this.features = [];
    _this._hardwareRenderer = hardwareRenderer;
    _this._hardwareRenderer.init(canvas);
    _this.physicsManager = new PhysicsManager(_assertThisInitialized(_this));
    _this._canvas = canvas;
    // @todo delete
    engineFeatureManager.addObject(_assertThisInitialized(_this));
    _this._sceneManager.activeScene = new Scene(_assertThisInitialized(_this), "DefaultScene");
    _this._spriteMaskManager = new SpriteMaskManager(_assertThisInitialized(_this));
    _this._spriteDefaultMaterial = _this._createSpriteMaterial();
    _this._spriteMaskDefaultMaterial = _this._createSpriteMaskMaterial();
    _this.inputManager = new InputManager(_assertThisInitialized(_this));
    var magentaPixel = new Uint8Array([255, 0, 255, 255]);
    var magentaTexture2D = new Texture2D(_assertThisInitialized(_this), 1, 1, TextureFormat.R8G8B8A8, false);
    magentaTexture2D.setPixelBuffer(magentaPixel);
    magentaTexture2D.isGCIgnored = true;
    var magentaTextureCube = new TextureCube(_assertThisInitialized(_this), 1, TextureFormat.R8G8B8A8, false);
    magentaTextureCube.setPixelBuffer(TextureCubeFace.PositiveX, magentaPixel);
    magentaTextureCube.setPixelBuffer(TextureCubeFace.NegativeX, magentaPixel);
    magentaTextureCube.setPixelBuffer(TextureCubeFace.PositiveY, magentaPixel);
    magentaTextureCube.setPixelBuffer(TextureCubeFace.NegativeY, magentaPixel);
    magentaTextureCube.setPixelBuffer(TextureCubeFace.PositiveZ, magentaPixel);
    magentaTextureCube.setPixelBuffer(TextureCubeFace.NegativeZ, magentaPixel);
    magentaTextureCube.isGCIgnored = true;
    _this._magentaTexture2D = magentaTexture2D;
    _this._magentaTextureCube = magentaTextureCube;
    if (hardwareRenderer.isWebGL2) {
      var magentaTexture2DArray = new Texture2DArray(_assertThisInitialized(_this), 1, 1, 1, TextureFormat.R8G8B8A8, false);
      magentaTexture2DArray.setPixelBuffer(0, magentaPixel);
      magentaTexture2DArray.isGCIgnored = true;
      _this._magentaTexture2DArray = magentaTexture2DArray;
    }
    var magentaMaterial = new Material(_assertThisInitialized(_this), Shader.find("unlit"));
    magentaMaterial.shaderData.setColor("u_baseColor", new Color(1.0, 0.0, 1.01, 1.0));
    _this._magentaMaterial = magentaMaterial;
    var backgroundTextureMaterial = new Material(_assertThisInitialized(_this), Shader.find("background-texture"));
    backgroundTextureMaterial.isGCIgnored = true;
    backgroundTextureMaterial.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this._backgroundTextureMaterial = backgroundTextureMaterial;
    var colorSpace = (settings === null || settings === void 0 ? void 0 : settings.colorSpace) || ColorSpace.Linear;
    colorSpace === ColorSpace.Gamma && _this._macroCollection.enable(Engine._gammaMacro);
    _this._settings.colorSpace = colorSpace;
    return _this;
  }

  /**
   * Create an entity.
   * @param name - The name of the entity
   * @returns Entity
   */
  var _proto = Engine.prototype;
  _proto.createEntity = function createEntity(name) {
    return new Entity(this, name);
  }

  /**
   * Pause the engine.
   */;
  _proto.pause = function pause() {
    this._isPaused = true;
    cancelAnimationFrame(this._requestId);
    clearTimeout(this._timeoutId);
  }

  /**
   * Resume the engine.
   */;
  _proto.resume = function resume() {
    if (!this._isPaused) return;
    this._isPaused = false;
    this.time.reset();
    this._requestId = requestAnimationFrame(this._animate);
  }

  /**
   * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
   */;
  _proto.update = function update() {
    var time = this._time;
    var deltaTime = time.deltaTime;
    time.tick();
    this._renderElementPool.resetPool();
    this._spriteElementPool.resetPool();
    this._spriteMaskElementPool.resetPool();
    this._textElementPool.resetPool();
    engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);
    var scene = this._sceneManager._activeScene;
    var componentsManager = this._componentsManager;
    if (scene) {
      scene._activeCameras.sort(function (camera1, camera2) {
        return camera1.priority - camera2.priority;
      });
      componentsManager.callScriptOnStart();
      this.physicsManager._initialized && this.physicsManager._update(deltaTime / 1000.0);
      this.inputManager._update();
      componentsManager.callScriptOnUpdate(deltaTime);
      componentsManager.callAnimationUpdate(deltaTime);
      componentsManager.callScriptOnLateUpdate(deltaTime);
      this._render(scene);
    }
    engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);

    // Engine is complete delayed destruction mechanism
    if (this._waittingDestroy) {
      this._sceneManager._destroyAllScene();
    }
    componentsManager.handlingInvalidScripts();
    if (this._waittingDestroy) {
      this._destroy();
    }
  }

  /**
   * Execution engine loop.
   */;
  _proto.run = function run() {
    // @todo: delete
    engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
    this.resume();
    this.trigger(new Event("run", this));
  }

  /**
   * Destroy engine.
   * @remarks The timing of engine destruction is at the end of the current frame
   */;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._waittingDestroy = true;
  }

  /**
   * @internal
   */;
  _proto._destroy = function _destroy() {
    this._resourceManager._destroy();
    this._magentaTexture2D.destroy(true);
    this._magentaTextureCube.destroy(true);
    this.inputManager._destroy();
    this.trigger(new Event("shutdown", this));
    engineFeatureManager.callFeatureMethod(this, "shutdown", [this]);

    // -- cancel animation
    this.pause();
    this._animate = null;
    this._sceneManager = null;
    this._resourceManager = null;
    this._canvas = null;
    this.features = [];
    this._time = null;

    // delete mask manager
    this._spriteMaskManager.destroy();

    // todo: delete
    engineFeatureManager._objects = [];
    this.removeAllEventListeners();
    this._waittingDestroy = false;
    this._destroyed = true;
  }

  /**
   * @internal
   */;
  _proto._getShaderProgramPool = function _getShaderProgramPool(shader) {
    var index = shader._shaderId;
    var shaderProgramPools = this._shaderProgramPools;
    var pool = shaderProgramPools[index];
    if (!pool) {
      var length = index + 1;
      if (length < shaderProgramPools.length) {
        shaderProgramPools.length = length;
      }
      shaderProgramPools[index] = pool = new ShaderProgramPool();
    }
    return pool;
  };
  _proto._render = function _render(scene) {
    var cameras = scene._activeCameras;
    var componentsManager = this._componentsManager;
    var deltaTime = this.time.deltaTime;
    componentsManager.callRendererOnUpdate(deltaTime);
    scene._updateShaderData();
    if (cameras.length > 0) {
      for (var i = 0, n = cameras.length; i < n; i++) {
        var camera = cameras[i];
        componentsManager.callCameraOnBeginRender(camera);
        Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [scene, camera]); //TODO: will be removed
        camera.render();
        Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [scene, camera]); //TODO: will be removed
        componentsManager.callCameraOnEndRender(camera);
      }
    } else {
      Logger.debug("NO active camera.");
    }
  };
  _proto._createSpriteMaterial = function _createSpriteMaterial() {
    var material = new Material(this, Shader.find("Sprite"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
    renderState.depthState.writeEnabled = false;
    renderState.rasterState.cullMode = CullMode.Off;
    material.renderQueueType = RenderQueueType.Transparent;
    material.isGCIgnored = true;
    return material;
  };
  _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial() {
    var material = new Material(this, Shader.find("SpriteMask"));
    var renderState = material.renderState;
    renderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.None;
    renderState.rasterState.cullMode = CullMode.Off;
    renderState.stencilState.enabled = true;
    renderState.depthState.enabled = false;
    material.isGCIgnored = true;
    return material;
  }

  //-----------------------------------------@deprecated-----------------------------------
  ;
  _proto.findFeature = function findFeature(Feature) {
    return engineFeatureManager.findFeature(this, Feature);
  };
  Engine.registerFeature = function registerFeature(Feature) {
    engineFeatureManager.registerFeature(Feature);
  };
  _createClass(Engine, [{
    key: "settings",
    get: /** @internal */

    /** @internal Conversion of space units to pixel units for 2D. */

    /** @internal */

    /** Physics manager of Engine. */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /** @internal */

    /** @internal */

    /** @internal @todo: temporary solution */

    /**
     * Settings of Engine.
     */
    function get() {
      return this._settings;
    }

    /**
     * The canvas to use for rendering.
     */
  }, {
    key: "canvas",
    get: function get() {
      return this._canvas;
    }

    /**
     * Get the resource manager.
     */
  }, {
    key: "resourceManager",
    get: function get() {
      return this._resourceManager;
    }

    /**
     * Get the scene manager.
     */
  }, {
    key: "sceneManager",
    get: function get() {
      return this._sceneManager;
    }

    /**
     * Get the Time class.
     */
  }, {
    key: "time",
    get: function get() {
      return this._time;
    }

    /**
     * Whether the engine is paused.
     */
  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }

    /**
     * The number of vertical synchronization means the number of vertical blanking for one frame.
     * @remarks 0 means that the vertical synchronization is turned off.
     */
  }, {
    key: "vSyncCount",
    get: function get() {
      return this._vSyncCount;
    },
    set: function set(value) {
      this._vSyncCount = Math.max(0, Math.floor(value));
    }

    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */
  }, {
    key: "targetFrameRate",
    get: function get() {
      return this._targetFrameRate;
    },
    set: function set(value) {
      value = Math.max(0.000001, value);
      this._targetFrameRate = value;
      this._targetFrameInterval = 1000 / value;
    }

    /**
     * Indicates whether the engine is destroyed.
     */
  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
  }]);
  return Engine;
}(EventDispatcher);
Engine._gammaMacro = Shader.getMacroByName("OASIS_COLORSPACE_GAMMA");
Engine._pixelsPerUnit = 100;
Engine._defaultBoundingBox = new BoundingBox(new Vector3(0, 0, 0), new Vector3(0, 0, 0));

/**
 * System info.
 */
var SystemInfo = /*#__PURE__*/function () {
  function SystemInfo() {}
  /**
   * @internal
   */
  SystemInfo._isIos = function _isIos() {
    if (!window) {
      return false;
    }
    var ua = window.navigator.userAgent.toLocaleLowerCase();
    return /iphone|ipad|ipod/.test(ua);
  };
  _createClass(SystemInfo, null, [{
    key: "devicePixelRatio",
    get:
    /**
     * The pixel ratio of the device.
     */
    function get() {
      return window.devicePixelRatio;
    }
  }]);
  return SystemInfo;
}();

/**
 * Engine feature plug-in.
 * @deprecated
 */
var EngineFeature = /*#__PURE__*/function () {
  function EngineFeature() {}
  var _proto = EngineFeature.prototype;
  /**
   * Callback before the engine main loop runs,used to load resource.
   * @param engine - Engine
   */
  _proto.preLoad = function preLoad(engine) {}

  /**
   * Callback before every engine tick.
   * @param engine - Engine
   * @param currentScene - Scene
   */;
  _proto.preTick = function preTick(engine, currentScene) {}

  /**
   * Callback after every engine tick.
   * @param  engine - Engine
   */;
  _proto.postTick = function postTick(engine, currentScene) {}

  /**
   * Callback after the engine is destroyed.
   * @param engine - Engine
   */;
  _proto.shutdown = function shutdown(engine) {};
  return EngineFeature;
}();

var _class$5, _descriptor$4, _descriptor2$4, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$4;
/**
 * Script class, used for logic writing.
 */
var Script = (_class$5 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Script, _Component);
  function Script() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_started", _descriptor$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onStartIndex", _descriptor2$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onLateUpdateIndex", _descriptor4$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPhysicsUpdateIndex", _descriptor5$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPreRenderIndex", _descriptor6$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPostRenderIndex", _descriptor7$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_entityScriptsIndex", _descriptor8$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_waitHandlingInValid", _descriptor9$4, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = Script.prototype;
  /**
   * Called when be enabled first time, only once.
   */
  _proto.onAwake = function onAwake() {}

  /**
   * Called when be enabled.
   */;
  _proto.onEnable = function onEnable() {}

  /**
   * Called before the frame-level loop start for the first time, only once.
   */;
  _proto.onStart = function onStart() {}

  /**
   * The main loop, called frame by frame.
   * @param deltaTime - The deltaTime when the script update.
   */;
  _proto.onUpdate = function onUpdate(deltaTime) {}

  /**
   * Called after the onUpdate finished, called frame by frame.
   * @param deltaTime - The deltaTime when the script update.
   */;
  _proto.onLateUpdate = function onLateUpdate(deltaTime) {}

  /**
   * Called before camera rendering, called per camera.
   * @param camera - Current camera.
   */;
  _proto.onBeginRender = function onBeginRender(camera) {}

  /**
   * Called after camera rendering, called per camera.
   * @param camera - Current camera.
   */;
  _proto.onEndRender = function onEndRender(camera) {}

  /**
   * Called before physics calculations, the number of times is related to the physical update frequency.
   */;
  _proto.onPhysicsUpdate = function onPhysicsUpdate() {}

  /**
   * Called when the collision enter.
   * @param other - ColliderShape
   */;
  _proto.onTriggerEnter = function onTriggerEnter(other) {}

  /**
   * Called when the collision stay.
   * @remarks onTriggerStay is called every frame while the collision stay.
   * @param other - ColliderShape
   */;
  _proto.onTriggerExit = function onTriggerExit(other) {}

  /**
   * Called when the collision exit.
   * @param other - ColliderShape
   */;
  _proto.onTriggerStay = function onTriggerStay(other) {}

  /**
   * Called when the collision enter.
   * @param other - ColliderShape
   */;
  _proto.onCollisionEnter = function onCollisionEnter(other) {}

  /**
   * Called when the collision stay.
   * @remarks onTriggerStay is called every frame while the collision stay.
   * @param other - ColliderShape
   */;
  _proto.onCollisionExit = function onCollisionExit(other) {}

  /**
   * Called when the collision exit.
   * @param other - ColliderShape
   */;
  _proto.onCollisionStay = function onCollisionStay(other) {}

  /**
   * Called when the pointer is down while over the ColliderShape.
   */;
  _proto.onPointerDown = function onPointerDown() {}

  /**
   * Called when the pointer is up while over the ColliderShape.
   */;
  _proto.onPointerUp = function onPointerUp() {}

  /**
   * Called when the pointer is down and up with the same collider.
   */;
  _proto.onPointerClick = function onPointerClick() {}

  /**
   * Called when the pointer is enters the ColliderShape.
   */;
  _proto.onPointerEnter = function onPointerEnter() {}

  /**
   * Called when the pointer is no longer over the ColliderShape.
   */;
  _proto.onPointerExit = function onPointerExit() {}

  /**
   * Called when the pointer is down while over the ColliderShape and is still holding down.
   * @remarks onPointerDrag is called every frame while the pointer is down.
   */;
  _proto.onPointerDrag = function onPointerDrag() {}

  /**
   * Called when be disabled.
   */;
  _proto.onDisable = function onDisable() {}

  /**
   * Called at the end of the destroyed frame.
   */;
  _proto.onDestroy = function onDestroy() {}

  /**
   * @internal
   * @inheritDoc
   * @override
   */;
  _proto._onAwake = function _onAwake() {
    this.onAwake();
  }

  /**
   * @internal
   * @inheritDoc
   * @override
   */;
  _proto._onEnable = function _onEnable() {
    if (this._waitHandlingInValid) {
      this._waitHandlingInValid = false;
    } else {
      var componentsManager = this.engine._componentsManager;
      var prototype = Script.prototype;
      if (!this._started) {
        componentsManager.addOnStartScript(this);
      }
      if (this.onUpdate !== prototype.onUpdate) {
        componentsManager.addOnUpdateScript(this);
      }
      if (this.onLateUpdate !== prototype.onLateUpdate) {
        componentsManager.addOnLateUpdateScript(this);
      }
      if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
        componentsManager.addOnPhysicsUpdateScript(this);
      }
      this._entity._addScript(this);
    }
    this.onEnable();
  }

  /**
   * @internal
   * @inheritDoc
   * @override
   */;
  _proto._onDisable = function _onDisable() {
    this._waitHandlingInValid = true;
    this._engine._componentsManager.addDisableScript(this);
    this.onDisable();
  }

  /**
   * @internal
   * @inheritDoc
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {
    this._engine._componentsManager.addDestroyScript(this);
  }

  /**
   * @internal
   */;
  _proto._handlingInValid = function _handlingInValid() {
    var componentsManager = this.engine._componentsManager;
    var prototype = Script.prototype;
    if (this.onUpdate !== prototype.onUpdate) {
      componentsManager.removeOnUpdateScript(this);
    }
    if (this.onLateUpdate !== prototype.onLateUpdate) {
      componentsManager.removeOnLateUpdateScript(this);
    }
    if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
      componentsManager.removeOnPhysicsUpdateScript(this);
    }
    this._entity._removeScript(this);
    this._waitHandlingInValid = false;
  };
  return Script;
}(Component), (_descriptor$4 = _applyDecoratedDescriptor(_class$5.prototype, "_started", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor2$4 = _applyDecoratedDescriptor(_class$5.prototype, "_onStartIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor3$4 = _applyDecoratedDescriptor(_class$5.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor4$4 = _applyDecoratedDescriptor(_class$5.prototype, "_onLateUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class$5.prototype, "_onPhysicsUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor6$4 = _applyDecoratedDescriptor(_class$5.prototype, "_onPreRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor7$4 = _applyDecoratedDescriptor(_class$5.prototype, "_onPostRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor8$4 = _applyDecoratedDescriptor(_class$5.prototype, "_entityScriptsIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor9$4 = _applyDecoratedDescriptor(_class$5.prototype, "_waitHandlingInValid", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class$5);

var passNum = 0;

/**
 * RenderPass.
 */
var RenderPass = /*#__PURE__*/function () {
  /**
   * Create a RenderPass.
   * @param name - Pass name
   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
   * @param renderTarget - The specified Render Target
   * @param replaceMaterial -  Replaced material
   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
   */
  function RenderPass(name, priority, renderTarget, replaceMaterial, mask) {
    if (name === void 0) {
      name = "RENDER_PASS" + passNum++;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }
    if (mask === void 0) {
      mask = null;
    }
    this.name = void 0;
    this.enabled = void 0;
    this.priority = void 0;
    this.renderTarget = void 0;
    this.replaceMaterial = void 0;
    this.mask = void 0;
    this.renderOverride = void 0;
    this.clearFlags = void 0;
    this.clearColor = void 0;
    this.name = name;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || Layer.Everything;
    this.renderOverride = false; // If renderOverride is set to true, you need to implement the render method
  }

  /**
   * Rendering callback, will be executed if renderOverride is set to true.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */
  var _proto = RenderPass.prototype;
  _proto.render = function render(camera, opaqueQueue, alphaTestQueue, transparentQueue) {}

  /**
   * Post rendering callback.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */;
  _proto.preRender = function preRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {}

  /**
   * Post rendering callback.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */;
  _proto.postRender = function postRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {};
  return RenderPass;
}();

/**
 * @internal
 */
var SpriteBatcher = /*#__PURE__*/function (_Basic2DBatcher) {
  _inheritsLoose(SpriteBatcher, _Basic2DBatcher);
  function SpriteBatcher() {
    return _Basic2DBatcher.apply(this, arguments) || this;
  }
  var _proto = SpriteBatcher.prototype;
  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    vertexElements[2] = new VertexElement("COLOR_0", 20, VertexElementFormat.Vector4, 0);
    return 36;
  };
  _proto.canBatch = function canBatch(preElement, curElement) {
    if (!this._engine._canSpriteBatch) {
      return false;
    }
    var preRenderer = preElement.component;
    var curRenderer = curElement.component;

    // Compare mask
    if (!this.checkBatchWithMask(preRenderer, curRenderer)) {
      return false;
    }

    // Compare texture
    if (preElement.texture !== curElement.texture) {
      return false;
    }

    // Compare material
    return preElement.material === curElement.material;
  };
  _proto.checkBatchWithMask = function checkBatchWithMask(left, right) {
    var leftMaskInteraction = left.maskInteraction;
    if (leftMaskInteraction !== right.maskInteraction) {
      return false;
    }
    if (leftMaskInteraction === SpriteMaskInteraction.None) {
      return true;
    }
    return left.maskLayer === right.maskLayer;
  };
  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var _element$renderData = element.renderData,
      positions = _element$renderData.positions,
      uvs = _element$renderData.uvs,
      color = _element$renderData.color,
      vertexCount = _element$renderData.vertexCount;
    for (var i = 0; i < vertexCount; i++) {
      var curPos = positions[i];
      var curUV = uvs[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
      vertices[vertexIndex++] = color.r;
      vertices[vertexIndex++] = color.g;
      vertices[vertexIndex++] = color.b;
      vertices[vertexIndex++] = color.a;
    }
    return vertexIndex;
  };
  _proto.drawBatches = function drawBatches(camera, replaceMaterial) {
    var engine = this._engine,
      batchedQueue = this._batchedQueue;
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var maskManager = engine._spriteMaskManager;
    var sceneData = camera.scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteElement = batchedQueue[i];
      if (!subMesh || !spriteElement) {
        return;
      }
      var renderer = spriteElement.component;
      var material = spriteElement.material;
      maskManager.preRender(camera, renderer);
      var compileMacros = Shader._compileMacros;
      // union render global macro and material self macro.
      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);

      // @todo: temporary solution
      (replaceMaterial || material)._preRender(spriteElement);
      var program = (replaceMaterial || material).shader._getShaderProgram(engine, compileMacros);
      if (!program.isValid) {
        return;
      }
      renderer.shaderData.setTexture(SpriteBatcher._textureProperty, spriteElement.texture);
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, sceneData);
      program.uploadAll(program.cameraUniformBlock, cameraData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);
      material.renderState._apply(engine, false);
      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
      maskManager.postRender(renderer);
    }
  };
  _proto.destroy = function destroy() {
    this._batchedQueue = null;
    var meshes = this._meshes,
      vertexBuffers = this._vertexBuffers,
      indiceBuffers = this._indiceBuffers;
    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }
    this._meshes = null;
    for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
      vertexBuffers[_i].destroy();
    }
    this._vertexBuffers = null;
    for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
      indiceBuffers[_i2].destroy();
    }
    this._indiceBuffers = null;
  };
  return SpriteBatcher;
}(Basic2DBatcher);
SpriteBatcher._textureProperty = Shader.getPropertyByName("u_spriteTexture");

/**
 * Render queue.
 */
var RenderQueue = /*#__PURE__*/function () {
  /**
   * @internal
   */
  RenderQueue._compareFromNearToFar = function _compareFromNearToFar(a, b) {
    return a.component.priority - b.component.priority || a.component._distanceForSort - b.component._distanceForSort;
  }

  /**
   * @internal
   */;
  RenderQueue._compareFromFarToNear = function _compareFromFarToNear(a, b) {
    return a.component.priority - b.component.priority || b.component._distanceForSort - a.component._distanceForSort;
  };
  function RenderQueue(engine) {
    this.items = [];
    this._spriteBatcher = void 0;
    this._spriteBatcher = new SpriteBatcher(engine);
  }

  /**
   * Push a render element.
   */
  var _proto = RenderQueue.prototype;
  _proto.pushPrimitive = function pushPrimitive(element) {
    this.items.push(element);
  };
  _proto.render = function render(camera, replaceMaterial, mask) {
    var items = this.items;
    if (items.length === 0) {
      return;
    }
    var engine = camera.engine,
      scene = camera.scene;
    var renderCount = engine._renderCount;
    var rhi = engine._hardwareRenderer;
    var sceneData = scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, n = items.length; i < n; i++) {
      var item = items[i];
      var renderPassFlag = item.component.entity.layer;
      if (!(renderPassFlag & mask)) {
        continue;
      }
      if (!!item.mesh) {
        this._spriteBatcher.flush(camera, replaceMaterial);
        var compileMacros = Shader._compileMacros;
        var element = item;
        var renderer = element.component;
        var material = element.material.destroyed ? engine._magentaMaterial : element.material;
        var rendererData = renderer.shaderData;
        var materialData = material.shaderData;

        // @todo: temporary solution
        (replaceMaterial || material)._preRender(element);

        // union render global macro and material self macro.
        ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
        var program = (replaceMaterial || material).shader._getShaderProgram(engine, compileMacros);
        if (!program.isValid) {
          continue;
        }
        var switchProgram = program.bind();
        var switchRenderCount = renderCount !== program._uploadRenderCount;
        if (switchRenderCount) {
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, rendererData);
          program.uploadAll(program.materialUniformBlock, materialData);
          // UnGroup textures should upload default value, texture uint maybe change by logic of texture bind.
          program.uploadUnGroupTextures();
          program._uploadCamera = camera;
          program._uploadRenderer = renderer;
          program._uploadMaterial = material;
          program._uploadRenderCount = renderCount;
        } else {
          if (program._uploadCamera !== camera) {
            program.uploadAll(program.cameraUniformBlock, cameraData);
            program._uploadCamera = camera;
          } else if (switchProgram) {
            program.uploadTextures(program.cameraUniformBlock, cameraData);
          }
          if (program._uploadRenderer !== renderer) {
            program.uploadAll(program.rendererUniformBlock, rendererData);
            program._uploadRenderer = renderer;
          } else if (switchProgram) {
            program.uploadTextures(program.rendererUniformBlock, rendererData);
          }
          if (program._uploadMaterial !== material) {
            program.uploadAll(program.materialUniformBlock, materialData);
            program._uploadMaterial = material;
          } else if (switchProgram) {
            program.uploadTextures(program.materialUniformBlock, materialData);
          }

          // We only consider switchProgram case, because UnGroup texture's value is always default.
          if (switchProgram) {
            program.uploadUnGroupTextures();
          }
        }
        material.renderState._apply(engine, renderer.entity.transform._isFrontFaceInvert());
        rhi.drawPrimitive(element.mesh, element.subMesh, program);
      } else {
        var spriteElement = item;
        this._spriteBatcher.drawElement(spriteElement, camera, replaceMaterial);
      }
    }
    this._spriteBatcher.flush(camera, replaceMaterial);
  }

  /**
   * Clear collection.
   */;
  _proto.clear = function clear() {
    this.items.length = 0;
    this._spriteBatcher.clear();
  }

  /**
   * Destroy internal resources.
   */;
  _proto.destroy = function destroy() {
    this._spriteBatcher.destroy();
    this._spriteBatcher = null;
  }

  /**
   * Sort the elements.
   */;
  _proto.sort = function sort(compareFunc) {
    this._quickSort(this.items, 0, this.items.length, compareFunc);
  }

  /**
   * @remarks
   * Modified based on v8.
   * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js
   */;
  _proto._quickSort = function _quickSort(a, from, to, compareFunc) {
    while (true) {
      // Insertion sort is faster for short arrays.
      if (to - from <= 10) {
        this._insertionSort(a, from, to, compareFunc);
        return;
      }
      var third_index = from + to >> 1;
      // Find a pivot as the median of first, last and middle element.
      var v0 = a[from];
      var v1 = a[to - 1];
      var v2 = a[third_index];
      var c01 = compareFunc(v0, v1);
      if (c01 > 0) {
        // v1 < v0, so swap them.
        var tmp = v0;
        v0 = v1;
        v1 = tmp;
      } // v0 <= v1.
      var c02 = compareFunc(v0, v2);
      if (c02 >= 0) {
        // v2 <= v0 <= v1.
        var _tmp = v0;
        v0 = v2;
        v2 = v1;
        v1 = _tmp;
      } else {
        // v0 <= v1 && v0 < v2
        var c12 = compareFunc(v1, v2);
        if (c12 > 0) {
          // v0 <= v2 < v1
          var _tmp2 = v1;
          v1 = v2;
          v2 = _tmp2;
        }
      }
      // v0 <= v1 <= v2
      a[from] = v0;
      a[to - 1] = v2;
      var pivot = v1;
      var low_end = from + 1; // Upper bound of elements lower than pivot.
      var high_start = to - 1; // Lower bound of elements greater than pivot.
      a[third_index] = a[low_end];
      a[low_end] = pivot;

      // From low_end to i are elements equal to pivot.
      // From i to high_start are elements that haven't been compared yet.
      partition: for (var i = low_end + 1; i < high_start; i++) {
        var element = a[i];
        var order = compareFunc(element, pivot);
        if (order < 0) {
          a[i] = a[low_end];
          a[low_end] = element;
          low_end++;
        } else if (order > 0) {
          do {
            high_start--;
            if (high_start == i) break partition;
            var top_elem = a[high_start];
            order = compareFunc(top_elem, pivot);
          } while (order > 0);
          a[i] = a[high_start];
          a[high_start] = element;
          if (order < 0) {
            element = a[i];
            a[i] = a[low_end];
            a[low_end] = element;
            low_end++;
          }
        }
      }
      if (to - high_start < low_end - from) {
        this._quickSort(a, high_start, to, compareFunc);
        to = low_end;
      } else {
        this._quickSort(a, from, low_end, compareFunc);
        from = high_start;
      }
    }
  };
  _proto._insertionSort = function _insertionSort(a, from, to, compareFunc) {
    for (var i = from + 1; i < to; i++) {
      var j = void 0;
      var element = a[i];
      for (j = i - 1; j >= from; j--) {
        var tmp = a[j];
        var order = compareFunc(tmp, element);
        if (order > 0) {
          a[j + 1] = tmp;
        } else {
          break;
        }
      }
      a[j + 1] = element;
    }
  };
  return RenderQueue;
}();

/**
 * Basic render pipeline.
 */
var BasicRenderPipeline = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * Create a basic render pipeline.
   * @param camera - Camera
   */
  function BasicRenderPipeline(camera) {
    this._opaqueQueue = void 0;
    this._transparentQueue = void 0;
    this._alphaTestQueue = void 0;
    this._allSpriteMasks = new DisorderedArray();
    this._camera = void 0;
    this._defaultPass = void 0;
    this._renderPassArray = void 0;
    this._lastCanvasSize = new Vector2();
    this._camera = camera;
    var engine = camera.engine;
    this._opaqueQueue = new RenderQueue(engine);
    this._alphaTestQueue = new RenderQueue(engine);
    this._transparentQueue = new RenderQueue(engine);
    this._renderPassArray = [];
    this._defaultPass = new RenderPass("default", 0, null, null, 0);
    this.addRenderPass(this._defaultPass);
  }

  /**
   * Default render pass.
   */
  var _proto = BasicRenderPipeline.prototype;
  /**
   * Add render pass.
   * @param nameOrPass - The name of this Pass or RenderPass object. When it is a name, the following parameters need to be provided
   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
   * @param renderTarget - The specified Render Target
   * @param replaceMaterial -  Replaced material
   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
   */
  _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask) {
    if (priority === void 0) {
      priority = null;
    }
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }
    if (mask === void 0) {
      mask = null;
    }
    if (typeof nameOrPass === "string") {
      var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);
      this._renderPassArray.push(renderPass);
    } else if (nameOrPass instanceof RenderPass) {
      this._renderPassArray.push(nameOrPass);
    }
    this._renderPassArray.sort(function (p1, p2) {
      return p1.priority - p2.priority;
    });
  }

  /**
   * Remove render pass by name or render pass object.
   * @param nameOrPass - Render pass name or render pass object
   */;
  _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
    var pass;
    if (typeof nameOrPass === "string") pass = this.getRenderPass(nameOrPass);else if (nameOrPass instanceof RenderPass) pass = nameOrPass;
    if (pass) {
      var idx = this._renderPassArray.indexOf(pass);
      this._renderPassArray.splice(idx, 1);
    }
  }

  /**
   * Get render pass by name.
   * @param  name - Render pass name
   */;
  _proto.getRenderPass = function getRenderPass(name) {
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      var pass = this._renderPassArray[i];
      if (pass.name === name) return pass;
    }
    return null;
  }

  /**
   * Destroy internal resources.
   */;
  _proto.destroy = function destroy() {
    this._opaqueQueue.destroy();
    this._alphaTestQueue.destroy();
    this._transparentQueue.destroy();
    this._allSpriteMasks = null;
    this._renderPassArray = null;
    this._defaultPass = null;
    this._camera = null;
  }

  /**
   * Perform scene rendering.
   * @param context - Render context
   * @param cubeFace - Render surface of cube texture
   * @param mipLevel - Set mip level the data want to write
   */;
  _proto.render = function render(context, cubeFace, mipLevel) {
    var camera = this._camera;
    var opaqueQueue = this._opaqueQueue;
    var alphaTestQueue = this._alphaTestQueue;
    var transparentQueue = this._transparentQueue;
    camera.engine._spriteMaskManager.clear();
    opaqueQueue.clear();
    alphaTestQueue.clear();
    transparentQueue.clear();
    this._allSpriteMasks.length = 0;
    camera.engine._componentsManager.callRender(context);
    opaqueQueue.sort(RenderQueue._compareFromNearToFar);
    alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
    transparentQueue.sort(RenderQueue._compareFromFarToNear);
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      this._drawRenderPass(this._renderPassArray[i], camera, cubeFace, mipLevel);
    }
  };
  _proto._drawRenderPass = function _drawRenderPass(pass, camera, cubeFace, mipLevel) {
    pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
    if (pass.enabled) {
      var _pass$clearFlags, _pass$clearColor;
      var engine = camera.engine,
        scene = camera.scene;
      var background = scene.background;
      var rhi = engine._hardwareRenderer;
      var renderTarget = camera.renderTarget || pass.renderTarget;
      rhi.activeRenderTarget(renderTarget, camera, mipLevel); // change viewport with mip level
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._setRenderTargetInfo(cubeFace, mipLevel);
      var clearFlags = (_pass$clearFlags = pass.clearFlags) != null ? _pass$clearFlags : camera.clearFlags;
      var color = (_pass$clearColor = pass.clearColor) != null ? _pass$clearColor : background.solidColor;
      if (clearFlags !== CameraClearFlags.None) {
        rhi.clearRenderTarget(camera.engine, clearFlags, color);
      }
      if (pass.renderOverride) {
        pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
      } else {
        this._opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);
        this._alphaTestQueue.render(camera, pass.replaceMaterial, pass.mask);
        if (camera.clearFlags & CameraClearFlags.Color) {
          if (background.mode === BackgroundMode.Sky) {
            this._drawSky(engine, camera, background.sky);
          } else if (background.mode === BackgroundMode.Texture && background.texture) {
            this._drawBackgroundTexture(engine, background);
          }
        }
        this._transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
      }
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._blitRenderTarget();
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget.generateMipmaps();
    }
    pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
  }

  /**
   * Push a render element to the render queue.
   * @param element - Render element
   */;
  _proto.pushPrimitive = function pushPrimitive(element) {
    switch (element.material.renderQueueType) {
      case RenderQueueType.Transparent:
        this._transparentQueue.pushPrimitive(element);
        break;
      case RenderQueueType.AlphaTest:
        this._alphaTestQueue.pushPrimitive(element);
        break;
      case RenderQueueType.Opaque:
        this._opaqueQueue.pushPrimitive(element);
        break;
    }
  };
  _proto._drawBackgroundTexture = function _drawBackgroundTexture(engine, background) {
    var rhi = engine._hardwareRenderer;
    var _backgroundTextureMaterial = engine._backgroundTextureMaterial,
      canvas = engine.canvas;
    var mesh = background._mesh;
    if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== BackgroundTextureFillMode.Fill) {
      this._lastCanvasSize.set(canvas.width, canvas.height);
      background._resizeBackgroundTexture();
    }
    var program = _backgroundTextureMaterial.shader._getShaderProgram(engine, Shader._compileMacros);
    program.bind();
    program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);
    program.uploadUnGroupTextures();
    _backgroundTextureMaterial.renderState._apply(engine, false);
    rhi.drawPrimitive(mesh, mesh.subMesh, program);
  };
  _proto._drawSky = function _drawSky(engine, camera, sky) {
    var material = sky.material,
      mesh = sky.mesh,
      _matrix = sky._matrix;
    if (!material) {
      Logger.warn("The material of sky is not defined.");
      return;
    }
    if (!mesh) {
      Logger.warn("The mesh of sky is not defined.");
      return;
    }
    var rhi = engine._hardwareRenderer;
    var shaderData = material.shaderData,
      shader = material.shader,
      renderState = material.renderState;
    var compileMacros = Shader._compileMacros;
    ShaderMacroCollection.unionCollection(camera._globalShaderMacro, shaderData._macroCollection, compileMacros);
    var viewMatrix = camera.viewMatrix,
      projectionMatrix = camera.projectionMatrix;
    _matrix.copyFrom(viewMatrix);
    var e = _matrix.elements;
    e[12] = e[13] = e[14] = 0;
    Matrix.multiply(projectionMatrix, _matrix, _matrix);
    shaderData.setMatrix("u_mvpNoscale", _matrix);
    var program = shader._getShaderProgram(engine, compileMacros);
    program.bind();
    program.groupingOtherUniformBlock();
    program.uploadAll(program.materialUniformBlock, shaderData);
    program.uploadUnGroupTextures();
    renderState._apply(engine, false);
    rhi.drawPrimitive(mesh, mesh.subMesh, program);
  };
  _createClass(BasicRenderPipeline, [{
    key: "defaultRenderPass",
    get: function get() {
      return this._defaultPass;
    }
  }]);
  return BasicRenderPipeline;
}();

var _dec$1, _class$4, _class2$4, _descriptor$3, _descriptor2$3, _descriptor3$3, _descriptor4$3, _descriptor5$3, _descriptor6$3, _descriptor7$3, _descriptor8$3, _descriptor9$3, _descriptor10$2, _descriptor11$2, _descriptor12$2, _class3;
var MathTemp = function MathTemp() {};
/**
 * Camera component, as the entrance to the three-dimensional world.
 * @decorator `@dependentComponents(Transform)`
 */
MathTemp.tempVec4 = new Vector4();
MathTemp.tempVec3 = new Vector3();
MathTemp.tempVec2 = new Vector2();
var Camera = (_dec$1 = dependentComponents(Transform), _dec$1(_class$4 = (_class2$4 = (_class3 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Camera, _Component);
  /**
   * @internal
   */
  function Camera(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this.shaderData = new ShaderData(ShaderDataGroup.Camera);
    _this.priority = 0;
    _this.enableFrustumCulling = true;
    _this.clearFlags = CameraClearFlags.All;
    _this.cullingMask = Layer.Everything;
    _this._globalShaderMacro = new ShaderMacroCollection();
    _initializerDefineProperty(_this, "_frustum", _descriptor$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_renderPipeline", _descriptor2$3, _assertThisInitialized(_this));
    _this._isOrthographic = false;
    _this._isProjMatSetting = false;
    _this._nearClipPlane = 0.1;
    _this._farClipPlane = 100;
    _this._fieldOfView = 45;
    _this._orthographicSize = 10;
    _this._isProjectionDirty = true;
    _this._isInvProjMatDirty = true;
    _this._isFrustumProjectDirty = true;
    _this._customAspectRatio = undefined;
    _this._renderTarget = null;
    _initializerDefineProperty(_this, "_frustumViewChangeFlag", _descriptor3$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_transform", _descriptor4$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isViewMatrixDirty", _descriptor5$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isInvViewProjDirty", _descriptor6$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_projectionMatrix", _descriptor7$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_viewMatrix", _descriptor8$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_viewport", _descriptor9$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_inverseProjectionMatrix", _descriptor10$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lastAspectSize", _descriptor11$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_invViewProjMat", _descriptor12$2, _assertThisInitialized(_this));
    var transform = _this.entity.transform;
    _this._transform = transform;
    _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
    _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
    _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
    _this._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this));
    _this.shaderData._addRefCount(1);
    return _this;
  }

  /**
   * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
   */
  var _proto = Camera.prototype;
  _proto.resetProjectionMatrix = function resetProjectionMatrix() {
    this._isProjMatSetting = false;
    this._projMatChange();
  }

  /**
   * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
   */;
  _proto.resetAspectRatio = function resetAspectRatio() {
    this._customAspectRatio = undefined;
    this._projMatChange();
  }

  /**
   * Transform a point from world space to viewport space.
   * @param point - Point in world space
   * @param out - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
   * @returns Point in viewport space
   */;
  _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
    var cameraPoint = MathTemp.tempVec3;
    var viewportPoint = MathTemp.tempVec4;
    Vector3.transformCoordinate(point, this.viewMatrix, cameraPoint);
    Vector3.transformToVec4(cameraPoint, this.projectionMatrix, viewportPoint);
    var w = viewportPoint.w;
    out.set((viewportPoint.x / w + 1.0) * 0.5, (1.0 - viewportPoint.y / w) * 0.5, -cameraPoint.z);
    return out;
  }

  /**
   * Transform a point from viewport space to world space.
   * @param point - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
   * @param out - Point in world space
   * @returns Point in world space
   */;
  _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
    var nearClipPlane = this.nearClipPlane,
      farClipPlane = this.farClipPlane;
    var nf = 1 / (nearClipPlane - farClipPlane);
    var z;
    if (this.isOrthographic) {
      z = -point.z * 2 * nf;
      z += (farClipPlane + nearClipPlane) * nf;
    } else {
      var pointZ = point.z;
      z = -pointZ * (nearClipPlane + farClipPlane) * nf;
      z += 2 * nearClipPlane * farClipPlane * nf;
      z = z / pointZ;
    }
    this._innerViewportToWorldPoint(point.x, point.y, (z + 1.0) / 2.0, this._getInvViewProjMat(), out);
    return out;
  }

  /**
   * Generate a ray by a point in viewport.
   * @param point - Point in viewport space, X and Y are the camera viewport space coordinates
   * @param out - Ray
   * @returns Ray
   */;
  _proto.viewportPointToRay = function viewportPointToRay(point, out) {
    var invViewProjMat = this._getInvViewProjMat();
    // Use the intersection of the near clipping plane as the origin point.
    var origin = this._innerViewportToWorldPoint(point.x, point.y, 0.0, invViewProjMat, out.origin);
    // Use the intersection of the far clipping plane as the origin point.
    var direction = this._innerViewportToWorldPoint(point.x, point.y, 1.0, invViewProjMat, out.direction);
    Vector3.subtract(direction, origin, direction);
    direction.normalize();
    return out;
  }

  /**
   * Transform the X and Y coordinates of a point from screen space to viewport space
   * @param point - Point in screen space
   * @param out - Point in viewport space
   * @returns Point in viewport space
   */;
  _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (point.x / canvas.width - viewport.x) / viewport.z;
    out.y = (point.y / canvas.height - viewport.y) / viewport.w;
    point.z !== undefined && (out.z = point.z);
    return out;
  }

  /**
   * Transform the X and Y coordinates of a point from viewport space to screen space.
   * @param point - Point in viewport space
   * @param out - Point in screen space
   * @returns Point in screen space
   */;
  _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (viewport.x + point.x * viewport.z) * canvas.width;
    out.y = (viewport.y + point.y * viewport.w) * canvas.height;
    point.z !== undefined && (out.z = point.z);
    return out;
  }

  /**
   * Transform a point from world space to screen space.
   * @param point - Point in world space
   * @param out - Point of screen space
   * @returns Point of screen space
   */;
  _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
    this.worldToViewportPoint(point, out);
    return this.viewportToScreenPoint(out, out);
  }

  /**
   * Transform a point from screen space to world space.
   *
   * @param point - Screen space point, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight), The z position is in world units from the camera
   * @param out - Point in world space
   * @returns Point in world space
   */;
  _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
    this.screenToViewportPoint(point, out);
    return this.viewportToWorldPoint(out, out);
  }

  /**
   * Generate a ray by a point in screen.
   * @param point - Point in screen space, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight)
   * @param out - Ray
   * @returns Ray
   */;
  _proto.screenPointToRay = function screenPointToRay(point, out) {
    var viewportPoint = MathTemp.tempVec2;
    this.screenToViewportPoint(point, viewportPoint);
    return this.viewportPointToRay(viewportPoint, out);
  }

  /**
   * Manually call the rendering of the camera.
   * @param cubeFace - Cube rendering surface collection
   * @param mipLevel - Set mip level the data want to write, only take effect in webgl2.0
   */;
  _proto.render = function render(cubeFace, mipLevel) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    // compute cull frustum.
    var context = this.engine._renderContext;
    context._setContext(this);
    if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
      this._frustum.calculateFromMatrix(context._viewProjectMatrix);
      this._frustumViewChangeFlag.flag = false;
      this._isFrustumProjectDirty = false;
    }
    this._updateShaderData(context);

    // union scene and camera macro.
    ShaderMacroCollection.unionCollection(this.scene._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
    if (mipLevel > 0 && !this.engine._hardwareRenderer.isWebGL2) {
      mipLevel = 0;
      Logger.error("mipLevel only take effect in WebGL2.0");
    }
    this._renderPipeline.render(context, cubeFace, mipLevel);
    this._engine._renderCount++;
  }

  /**
   * @override
   * @inheritdoc
   */;
  _proto._onEnable = function _onEnable() {
    this.entity.scene._attachRenderCamera(this);
  }

  /**
   * @override
   * @inheritdoc
   */;
  _proto._onDisable = function _onDisable() {
    this.entity.scene._detachRenderCamera(this);
  }

  /**
   * @override
   * @inheritdoc
   */;
  _proto._onDestroy = function _onDestroy() {
    var _this$_renderPipeline;
    (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();
    this._isInvViewProjDirty.destroy();
    this._isViewMatrixDirty.destroy();
    this.shaderData._addRefCount(-1);
  };
  _proto._projMatChange = function _projMatChange() {
    this._isFrustumProjectDirty = true;
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._isInvViewProjDirty.flag = true;
  };
  _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(x, y, z, invViewProjMat, out) {
    // Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.
    // Transform to clipping space matrix
    var clipPoint = MathTemp.tempVec3;
    clipPoint.set(x * 2 - 1, 1 - y * 2, z * 2 - 1);
    Vector3.transformCoordinate(clipPoint, invViewProjMat, out);
    return out;
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    shaderData.setMatrix(Camera._viewMatrixProperty, this.viewMatrix);
    shaderData.setMatrix(Camera._projectionMatrixProperty, this.projectionMatrix);
    shaderData.setMatrix(Camera._vpMatrixProperty, context._viewProjectMatrix);
    shaderData.setMatrix(Camera._inverseViewMatrixProperty, this._transform.worldMatrix);
    shaderData.setMatrix(Camera._inverseProjectionMatrixProperty, this._getInverseProjectionMatrix());
    shaderData.setVector3(Camera._cameraPositionProperty, this._transform.worldPosition);
  }

  /**
   * The inverse matrix of view projection matrix.
   */;
  _proto._getInvViewProjMat = function _getInvViewProjMat() {
    if (this._isInvViewProjDirty.flag) {
      this._isInvViewProjDirty.flag = false;
      Matrix.multiply(this._transform.worldMatrix, this._getInverseProjectionMatrix(), this._invViewProjMat);
    }
    return this._invViewProjMat;
  }

  /**
   * The inverse of the projection matrix.
   */;
  _proto._getInverseProjectionMatrix = function _getInverseProjectionMatrix() {
    if (this._isInvProjMatDirty) {
      this._isInvProjMatDirty = false;
      Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
    }
    return this._inverseProjectionMatrix;
  };
  _createClass(Camera, [{
    key: "nearClipPlane",
    get: /** Shader data. */

    /** Rendering priority - A Camera with higher priority will be rendered on top of a camera with lower priority. */

    /** Whether to enable frustum culling, it is enabled by default. */

    /**
     * Determining what to clear when rendering by a Camera.
     * @defaultValue `CameraClearFlags.All`
     */

    /**
     * Culling mask - which layers the camera renders.
     * @remarks Support bit manipulation, corresponding to Entity's layer.
     */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Near clip plane - the closest point to the camera when rendering occurs.
     */
    function get() {
      return this._nearClipPlane;
    },
    set: function set(value) {
      this._nearClipPlane = value;
      this._projMatChange();
    }

    /**
     * Far clip plane - the furthest point to the camera when rendering occurs.
     */
  }, {
    key: "farClipPlane",
    get: function get() {
      return this._farClipPlane;
    },
    set: function set(value) {
      this._farClipPlane = value;
      this._projMatChange();
    }

    /**
     * The camera's view angle. activating when camera use perspective projection.
     */
  }, {
    key: "fieldOfView",
    get: function get() {
      return this._fieldOfView;
    },
    set: function set(value) {
      this._fieldOfView = value;
      this._projMatChange();
    }

    /**
     * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
     * the manual value will be kept. Call resetAspectRatio() to restore it.
     */
  }, {
    key: "aspectRatio",
    get: function get() {
      var _this$_customAspectRa;
      var canvas = this._entity.engine.canvas;
      return (_this$_customAspectRa = this._customAspectRatio) != null ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
    },
    set: function set(value) {
      this._customAspectRatio = value;
      this._projMatChange();
    }

    /**
     * Viewport, normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
     * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
     */
  }, {
    key: "viewport",
    get: function get() {
      return this._viewport;
    },
    set: function set(value) {
      if (value !== this._viewport) {
        this._viewport.copyFrom(value);
      }
      this._projMatChange();
    }

    /**
     * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
     */
  }, {
    key: "isOrthographic",
    get: function get() {
      return this._isOrthographic;
    },
    set: function set(value) {
      this._isOrthographic = value;
      this._projMatChange();
    }

    /**
     * Half the size of the camera in orthographic mode.
     */
  }, {
    key: "orthographicSize",
    get: function get() {
      return this._orthographicSize;
    },
    set: function set(value) {
      this._orthographicSize = value;
      this._projMatChange();
    }

    /**
     * View matrix.
     */
  }, {
    key: "viewMatrix",
    get: function get() {
      if (this._isViewMatrixDirty.flag) {
        this._isViewMatrixDirty.flag = false;
        // Ignore scale.
        Matrix.rotationTranslation(this._transform.worldRotationQuaternion, this._transform.worldPosition, this._viewMatrix);
        this._viewMatrix.invert();
      }
      return this._viewMatrix;
    }

    /**
     * The projection matrix is ​​calculated by the relevant parameters of the camera by default.
     * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
     */
  }, {
    key: "projectionMatrix",
    get: function get() {
      var canvas = this._entity.engine.canvas;
      if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
        return this._projectionMatrix;
      }
      this._isProjectionDirty = false;
      this._lastAspectSize.x = canvas.width;
      this._lastAspectSize.y = canvas.height;
      var aspectRatio = this.aspectRatio;
      if (!this._isOrthographic) {
        Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      } else {
        var width = this._orthographicSize * aspectRatio;
        var height = this._orthographicSize;
        Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      }
      return this._projectionMatrix;
    }

    /**
     * Whether to enable HDR.
     * @todo When render pipeline modification
     */,
    set: function set(value) {
      this._projectionMatrix = value;
      this._isProjMatSetting = true;
      this._projMatChange();
    }
  }, {
    key: "enableHDR",
    get: function get() {
      console.log("not implementation");
      return false;
    },
    set: function set(value) {
      console.log("not implementation");
    }

    /**
     * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
     */
  }, {
    key: "renderTarget",
    get: function get() {
      return this._renderTarget;
    },
    set: function set(value) {
      this._renderTarget = value;
    }
  }]);
  return Camera;
}(Component), _class3._viewMatrixProperty = Shader.getPropertyByName("u_viewMat"), _class3._projectionMatrixProperty = Shader.getPropertyByName("u_projMat"), _class3._vpMatrixProperty = Shader.getPropertyByName("u_VPMat"), _class3._inverseViewMatrixProperty = Shader.getPropertyByName("u_viewInvMat"), _class3._inverseProjectionMatrixProperty = Shader.getPropertyByName("u_projInvMat"), _class3._cameraPositionProperty = Shader.getPropertyByName("u_cameraPos"), _class3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_frustum", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new BoundingFrustum();
  }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_renderPipeline", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_frustumViewChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_transform", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_isViewMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_isInvViewProjDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_projectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor8$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_viewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor9$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_viewport", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector4(0, 0, 1, 1);
  }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_inverseProjectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor11$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_lastAspectSize", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector2(0, 0);
  }
}), _descriptor12$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_invViewProjMat", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
})), _class2$4)) || _class$4);

var mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
var defaultRetryCount = 1;
var defaultTimeout = Infinity;
var defaultInterval = 500;
/**
 * Web request.
 * @param url - The link
 * @param config - Load configuration
 */
function request(url, config) {
  if (config === void 0) {
    config = {};
  }
  return new AssetPromise(function (resolve, reject, setProgress) {
    var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;
    var retryCount = (_config$retryCount = config.retryCount) != null ? _config$retryCount : defaultRetryCount;
    var retryInterval = (_config$retryInterval = config.retryInterval) != null ? _config$retryInterval : defaultInterval;
    config.timeout = (_config$timeout = config.timeout) != null ? _config$timeout : defaultTimeout;
    config.type = (_config$type = config.type) != null ? _config$type : getMimeTypeFromUrl(url);
    var realRequest = config.type === "image" ? requestImage : requestRes;
    var lastError;
    var executor = new MultiExecutor(function () {
      return realRequest(url, config).onProgress(setProgress).then(function (res) {
        resolve(res);
        executor.stop();
      }).catch(function (err) {
        return lastError = err;
      });
    }, retryCount, retryInterval);
    executor.start(function () {
      reject(lastError);
    });
  });
}
function requestImage(url, config) {
  return new AssetPromise(function (resolve, reject) {
    var timeout = config.timeout;
    var img = new Image();
    var onerror = function onerror() {
      reject(new Error("request " + url + " fail"));
    };
    img.onerror = onerror;
    img.onabort = onerror;
    var timeoutId = -1;
    if (timeout != Infinity) {
      timeoutId = window.setTimeout(function () {
        reject(new Error("request " + url + " timeout"));
      }, timeout);
    }
    img.onload = function (timeoutId) {
      return function () {
        // Call requestAnimationFrame to avoid iOS's bug.
        requestAnimationFrame(function () {
          //@ts-ignore
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
        clearTimeout(timeoutId);
      };
    }(timeoutId);
    img.crossOrigin = "anonymous";
    img.src = url;
  });
}
function requestRes(url, config) {
  return new AssetPromise(function (resolve, reject, setProgress) {
    var _config$method;
    var xhr = new XMLHttpRequest();
    xhr.timeout = config.timeout;
    config.method = (_config$method = config.method) != null ? _config$method : "get";
    xhr.onload = function () {
      var _xhr$response;
      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error("request failed from: " + url));
        return;
      }
      var result = (_xhr$response = xhr.response) != null ? _xhr$response : xhr.responseText;
      resolve(result);
    };
    xhr.onerror = function () {
      reject(new Error("request failed from: " + url));
    };
    xhr.ontimeout = function () {
      reject(new Error("request timeout from: " + url));
    };
    xhr.onprogress = function (e) {
      setProgress(e.loaded / e.total);
    };
    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include";
    //@ts-ignore
    xhr.responseType = config.type;
    var headers = config.headers;
    if (headers) {
      Object.keys(headers).forEach(function (name) {
        xhr.setRequestHeader(name, headers[name]);
      });
    }
    // @ts-ignore
    xhr.send(config.body);
  });
}
function getMimeTypeFromUrl(url) {
  var extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}
var MultiExecutor = /*#__PURE__*/function () {
  function MultiExecutor(execFunc, totalCount, interval) {
    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.done = void 0;
    this.exec = this.exec.bind(this);
  }
  var _proto = MultiExecutor.prototype;
  _proto.start = function start(done) {
    this.done = done;
    this.exec();
  };
  _proto.stop = function stop() {
    clearTimeout(this._timeoutId);
  };
  _proto.exec = function exec() {
    var _this = this;
    if (this._currentCount >= this.totalCount) {
      this.done && this.done();
      return;
    }
    this._currentCount++;
    this.execFunc(this._currentCount).then(function () {
      //@ts-ignore
      _this._timeoutId = setTimeout(_this.exec, _this.interval);
    });
  };
  return MultiExecutor;
}();

/**
 * Loader abstract class.
 */
var Loader = /*#__PURE__*/function () {
  /**
   * Register a class with a string name for serialization and deserialization.
   * @param key - class name
   * @param obj - class object
   */
  Loader.registerClass = function registerClass(className, classDefine) {
    this._engineObjects[className] = classDefine;
  }

  /**
   * Get the class object by class name.
   * @param key - class name
   * @returns class object
   */;
  Loader.getClass = function getClass(className) {
    return this._engineObjects[className];
  };
  function Loader(useCache) {
    this.useCache = useCache;
    this.request = request;
  }
  return Loader;
}();
Loader._engineObjects = {};

/**
 * Asset Type.
 */
var AssetType;
(function (AssetType) {
  AssetType["Text"] = "text";
  AssetType["JSON"] = "json";
  AssetType["Buffer"] = "buffer";
  AssetType["Texture2D"] = "texture2d";
  AssetType["TextureCube"] = "texture-cube";
  AssetType["Material"] = "material";
  AssetType["Mesh"] = "mesh";
  AssetType["AnimationClip"] = "AnimationClip";
  AssetType["AnimatorController"] = "AnimatorController";
  AssetType["Prefab"] = "prefab";
  AssetType["KTX"] = "ktx";
  AssetType["KTXCube"] = "ktx-cube";
  AssetType["Sprite"] = "sprite";
  AssetType["SpriteAtlas"] = "sprite-atlas";
  AssetType["Env"] = "environment";
  AssetType["Scene"] = "scene";
  AssetType["HDR"] = "HDR";
})(AssetType || (AssetType = {}));

/**
 * Set which face for render.
 */
var RenderFace;
(function (RenderFace) {
  RenderFace[RenderFace["Front"] = 0] = "Front";
  RenderFace[RenderFace["Back"] = 1] = "Back";
  RenderFace[RenderFace["Double"] = 2] = "Double";
})(RenderFace || (RenderFace = {}));

/**
 * Alpha blend mode.
 */
var BlendMode;
(function (BlendMode) {
  BlendMode[BlendMode["Normal"] = 0] = "Normal";
  BlendMode[BlendMode["Additive"] = 1] = "Additive";
})(BlendMode || (BlendMode = {}));

/**
 * Texture UV coordinate.
 */
var TextureCoordinate;
(function (TextureCoordinate) {
  TextureCoordinate[TextureCoordinate["UV0"] = 0] = "UV0";
  TextureCoordinate[TextureCoordinate["UV1"] = 1] = "UV1";
  TextureCoordinate[TextureCoordinate["UV2"] = 2] = "UV2";
  TextureCoordinate[TextureCoordinate["UV3"] = 3] = "UV3";
  TextureCoordinate[TextureCoordinate["UV4"] = 4] = "UV4";
  TextureCoordinate[TextureCoordinate["UV5"] = 5] = "UV5";
  TextureCoordinate[TextureCoordinate["UV6"] = 6] = "UV6";
  TextureCoordinate[TextureCoordinate["UV7"] = 7] = "UV7";
})(TextureCoordinate || (TextureCoordinate = {}));

var BaseMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(BaseMaterial, _Material);
  /**
   * Create a BaseMaterial instance.
   * @param engine - Engine to which the material belongs
   * @param shader - Shader used by the material
   */
  function BaseMaterial(engine, shader) {
    var _this;
    _this = _Material.call(this, engine, shader) || this;
    _this._renderFace = RenderFace.Front;
    _this._isTransparent = false;
    _this._blendMode = void 0;
    _this.blendMode = BlendMode.Normal;
    _this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, 0);
    return _this;
  }

  /**
   * @override
   * Clone and return the instance.
   */
  var _proto = BaseMaterial.prototype;
  _proto.clone = function clone() {
    var dest = new BaseMaterial(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  }

  /**
   * @override
   * Clone to the target material.
   * @param target - target material
   */;
  _proto.cloneTo = function cloneTo(target) {
    _Material.prototype.cloneTo.call(this, target);
    target._renderFace = this._renderFace;
    target._isTransparent = this._isTransparent;
    target._blendMode = this._blendMode;
  };
  _createClass(BaseMaterial, [{
    key: "isTransparent",
    get:
    /**
     * Is this material transparent.
     * @remarks
     * If material is transparent, transparent blend mode will be affected by `blendMode`, default is `BlendMode.Normal`.
     */
    function get() {
      return this._isTransparent;
    },
    set: function set(value) {
      if (value === this._isTransparent) return;
      this._isTransparent = value;
      var _this$renderState = this.renderState,
        depthState = _this$renderState.depthState,
        targetBlendState = _this$renderState.blendState.targetBlendState;
      if (value) {
        targetBlendState.enabled = true;
        depthState.writeEnabled = false;
        this.renderQueueType = RenderQueueType.Transparent;
      } else {
        targetBlendState.enabled = false;
        depthState.writeEnabled = true;
        this.renderQueueType = this.shaderData.getFloat(BaseMaterial._alphaCutoffProp) ? RenderQueueType.AlphaTest : RenderQueueType.Opaque;
      }
    }

    /**
     * Alpha cutoff value.
     * @remarks
     * Fragments with alpha channel lower than cutoff value will be discarded.
     * `0` means no fragment will be discarded.
     */
  }, {
    key: "alphaCutoff",
    get: function get() {
      return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, value);
      if (value > 0) {
        this.shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);
        this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;
      } else {
        this.shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);
        this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.Opaque;
      }
    }

    /**
     * Set which face for render.
     */
  }, {
    key: "renderFace",
    get: function get() {
      return this._renderFace;
    },
    set: function set(value) {
      if (value === this._renderFace) return;
      this._renderFace = value;
      switch (value) {
        case RenderFace.Front:
          this.renderState.rasterState.cullMode = CullMode.Back;
          break;
        case RenderFace.Back:
          this.renderState.rasterState.cullMode = CullMode.Front;
          break;
        case RenderFace.Double:
          this.renderState.rasterState.cullMode = CullMode.Off;
          break;
      }
    }

    /**
     * Alpha blend mode.
     * @remarks
     * Only take effect when `isTransparent` is `true`.
     */
  }, {
    key: "blendMode",
    get: function get() {
      return this._blendMode;
    },
    set: function set(value) {
      if (value === this._blendMode) return;
      this._blendMode = value;
      var target = this.renderState.blendState.targetBlendState;
      switch (value) {
        case BlendMode.Normal:
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
          break;
        case BlendMode.Additive:
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.One;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
          break;
      }
    }
  }]);
  return BaseMaterial;
}(Material);
BaseMaterial._baseColorProp = Shader.getPropertyByName("u_baseColor");
BaseMaterial._baseTextureProp = Shader.getPropertyByName("u_baseTexture");
BaseMaterial._baseTextureMacro = Shader.getMacroByName("BASETEXTURE");
BaseMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
BaseMaterial._normalTextureProp = Shader.getPropertyByName("u_normalTexture");
BaseMaterial._normalIntensityProp = Shader.getPropertyByName("u_normalIntensity");
BaseMaterial._normalTextureMacro = Shader.getMacroByName("NORMALTEXTURE");
BaseMaterial._emissiveColorProp = Shader.getPropertyByName("u_emissiveColor");
BaseMaterial._emissiveTextureProp = Shader.getPropertyByName("u_emissiveTexture");
BaseMaterial._emissiveTextureMacro = Shader.getMacroByName("EMISSIVETEXTURE");
BaseMaterial._alphaCutoffProp = Shader.getPropertyByName("u_alphaCutoff");
BaseMaterial._alphaCutoffMacro = Shader.getMacroByName("ALPHA_CUTOFF");

/**
 * Blinn-phong Material.
 */
var BlinnPhongMaterial = /*#__PURE__*/function (_BaseMaterial) {
  _inheritsLoose(BlinnPhongMaterial, _BaseMaterial);
  function BlinnPhongMaterial(engine) {
    var _this;
    _this = _BaseMaterial.call(this, engine, Shader.find("blinn-phong")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("O3_NEED_WORLDPOS");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(BlinnPhongMaterial._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial._specularColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
    shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(BlinnPhongMaterial._shininessProp, 16);
    shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, 1);
    return _this;
  }

  /**
   * @override
   */
  var _proto = BlinnPhongMaterial.prototype;
  _proto.clone = function clone() {
    var dest = new BlinnPhongMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(BlinnPhongMaterial, [{
    key: "baseColor",
    get:
    /**
     * Base color.
     */
    function get() {
      return this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);
    },
    set: function set(value) {
      var baseColor = this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);
      if (value !== baseColor) {
        baseColor.copyFrom(value);
      }
    }

    /**
     * Base texture.
     */
  }, {
    key: "baseTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(BlinnPhongMaterial._baseTextureMacro);
      } else {
        this.shaderData.disableMacro(BlinnPhongMaterial._baseTextureMacro);
      }
    }

    /**
     * Specular color.
     */
  }, {
    key: "specularColor",
    get: function get() {
      return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
    },
    set: function set(value) {
      var specularColor = this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
      if (value !== specularColor) {
        specularColor.copyFrom(value);
      }
    }

    /**
     * Specular texture.
     */
  }, {
    key: "specularTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");
      }
    }

    /**
     * Emissive color.
     */
  }, {
    key: "emissiveColor",
    get: function get() {
      return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
    },
    set: function set(value) {
      var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
      if (value !== emissiveColor) {
        emissiveColor.copyFrom(value);
      }
    }

    /**
     * Emissive texture.
     */
  }, {
    key: "emissiveTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(BlinnPhongMaterial._emissiveTextureMacro);
      } else {
        this.shaderData.disableMacro(BlinnPhongMaterial._emissiveTextureMacro);
      }
    }

    /**
     * Normal texture.
     */
  }, {
    key: "normalTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(BlinnPhongMaterial._normalTextureMacro);
      } else {
        this.shaderData.disableMacro(BlinnPhongMaterial._normalTextureMacro);
      }
    }

    /**
     * Normal texture intensity.
     */
  }, {
    key: "normalIntensity",
    get: function get() {
      return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, value);
    }

    /**
     * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.
     */
  }, {
    key: "shininess",
    get: function get() {
      return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(BlinnPhongMaterial._shininessProp, Math.max(value, 1e-4));
    }

    /**
     * Tiling and offset of main textures.
     */
  }, {
    key: "tilingOffset",
    get: function get() {
      return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
    },
    set: function set(value) {
      var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
      if (value !== tilingOffset) {
        tilingOffset.copyFrom(value);
      }
    }
  }]);
  return BlinnPhongMaterial;
}(BaseMaterial);
BlinnPhongMaterial._specularColorProp = Shader.getPropertyByName("u_specularColor");
BlinnPhongMaterial._shininessProp = Shader.getPropertyByName("u_shininess");
BlinnPhongMaterial._specularTextureProp = Shader.getPropertyByName("u_specularTexture");

/**
 * PBR (Physically-Based Rendering) Material.
 */
var PBRBaseMaterial = /*#__PURE__*/function (_BaseMaterial) {
  _inheritsLoose(PBRBaseMaterial, _BaseMaterial);
  /**
   * Create a pbr base material instance.
   * @param engine - Engine to which the material belongs
   * @param shader - Shader used by the material
   */
  function PBRBaseMaterial(engine, shader) {
    var _this;
    _this = _BaseMaterial.call(this, engine, shader) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("O3_NEED_WORLDPOS");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(PBRBaseMaterial._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(PBRBaseMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
    shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(PBRBaseMaterial._normalIntensityProp, 1);
    shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, 1);
    shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp, TextureCoordinate.UV0);
    shaderData.setFloat(PBRBaseMaterial._clearCoatProp, 0);
    shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp, 0);
    return _this;
  }
  _createClass(PBRBaseMaterial, [{
    key: "baseColor",
    get:
    /**
     * Base color.
     */
    function get() {
      return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
    },
    set: function set(value) {
      var baseColor = this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
      if (value !== baseColor) {
        baseColor.copyFrom(value);
      }
    }

    /**
     * Base texture.
     */
  }, {
    key: "baseTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(PBRBaseMaterial._baseTextureMacro);
      } else {
        this.shaderData.disableMacro(PBRBaseMaterial._baseTextureMacro);
      }
    }

    /**
     * Normal texture.
     */
  }, {
    key: "normalTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(PBRBaseMaterial._normalTextureMacro);
      } else {
        this.shaderData.disableMacro(PBRBaseMaterial._normalTextureMacro);
      }
    }

    /**
     * Normal texture intensity.
     */
  }, {
    key: "normalTextureIntensity",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._normalIntensityProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRBaseMaterial._normalIntensityProp, value);
    }

    /**
     * Emissive color.
     */
  }, {
    key: "emissiveColor",
    get: function get() {
      return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
    },
    set: function set(value) {
      var emissiveColor = this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
      if (value !== emissiveColor) {
        emissiveColor.copyFrom(value);
      }
    }

    /**
     * Emissive texture.
     */
  }, {
    key: "emissiveTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(PBRBaseMaterial._emissiveTextureMacro);
      } else {
        this.shaderData.disableMacro(PBRBaseMaterial._emissiveTextureMacro);
      }
    }

    /**
     * Occlusion texture.
     */
  }, {
    key: "occlusionTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("OCCLUSIONTEXTURE");
      } else {
        this.shaderData.disableMacro("OCCLUSIONTEXTURE");
      }
    }

    /**
     * Occlusion texture intensity.
     */
  }, {
    key: "occlusionTextureIntensity",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, value);
    }

    /**
     * Occlusion texture uv coordinate.
     * @remarks Must be UV0 or UV1.
     */
  }, {
    key: "occlusionTextureCoord",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureCoordProp);
    },
    set: function set(value) {
      if (value > TextureCoordinate.UV1) {
        Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
      }
      this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp, value);
    }

    /**
     * Tiling and offset of main textures.
     */
  }, {
    key: "tilingOffset",
    get: function get() {
      return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
    },
    set: function set(value) {
      var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
      if (value !== tilingOffset) {
        tilingOffset.copyFrom(value);
      }
    }

    /**
     * The clearCoat layer intensity, default 0.
     */
  }, {
    key: "clearCoat",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp);
    },
    set: function set(value) {
      if (!!this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp) !== !!value) {
        if (value === 0) {
          this.shaderData.disableMacro("CLEARCOAT");
        } else {
          this.shaderData.enableMacro("CLEARCOAT");
        }
      }
      this.shaderData.setFloat(PBRBaseMaterial._clearCoatProp, value);
    }

    /**
     * The clearCoat layer intensity texture.
     */
  }, {
    key: "clearCoatTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._clearCoatTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._clearCoatTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_CLEARCOATTEXTURE");
      } else {
        this.shaderData.disableMacro("HAS_CLEARCOATTEXTURE");
      }
    }

    /**
     * The clearCoat layer roughness, default 0.
     */
  }, {
    key: "clearCoatRoughness",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._clearCoatRoughnessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp, value);
    }

    /**
     * The clearCoat layer roughness texture.
     */
  }, {
    key: "clearCoatRoughnessTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_CLEARCOATROUGHNESSTEXTURE");
      } else {
        this.shaderData.disableMacro("HAS_CLEARCOATROUGHNESSTEXTURE");
      }
    }

    /**
     * The clearCoat normal map texture.
     */
  }, {
    key: "clearCoatNormalTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._clearCoatNormalTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._clearCoatNormalTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_CLEARCOATNORMALTEXTURE");
      } else {
        this.shaderData.disableMacro("HAS_CLEARCOATNORMALTEXTURE");
      }
    }
  }]);
  return PBRBaseMaterial;
}(BaseMaterial);
PBRBaseMaterial._occlusionTextureIntensityProp = Shader.getPropertyByName("u_occlusionIntensity");
PBRBaseMaterial._occlusionTextureCoordProp = Shader.getPropertyByName("u_occlusionTextureCoord");
PBRBaseMaterial._occlusionTextureProp = Shader.getPropertyByName("u_occlusionTexture");
PBRBaseMaterial._clearCoatProp = Shader.getPropertyByName("u_clearCoat");
PBRBaseMaterial._clearCoatTextureProp = Shader.getPropertyByName("u_clearCoatTexture");
PBRBaseMaterial._clearCoatRoughnessProp = Shader.getPropertyByName("u_clearCoatRoughness");
PBRBaseMaterial._clearCoatRoughnessTextureProp = Shader.getPropertyByName("u_clearCoatRoughnessTexture");
PBRBaseMaterial._clearCoatNormalTextureProp = Shader.getPropertyByName("u_clearCoatNormalTexture");

/**
 * PBR (Metallic-Roughness Workflow) Material.
 */
var PBRMaterial = /*#__PURE__*/function (_PBRBaseMaterial) {
  _inheritsLoose(PBRMaterial, _PBRBaseMaterial);
  /**
   * Create a pbr metallic-roughness workflow material instance.
   * @param engine - Engine to which the material belongs
   */
  function PBRMaterial(engine) {
    var _this;
    _this = _PBRBaseMaterial.call(this, engine, Shader.find("pbr")) || this;
    _this.shaderData.setFloat(PBRMaterial._metallicProp, 1);
    _this.shaderData.setFloat(PBRMaterial._roughnessProp, 1);
    return _this;
  }

  /**
   * @override
   */
  var _proto = PBRMaterial.prototype;
  _proto.clone = function clone() {
    var dest = new PBRMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(PBRMaterial, [{
    key: "metallic",
    get:
    /**
     * Metallic, default 1.0.
     */
    function get() {
      return this.shaderData.getFloat(PBRMaterial._metallicProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRMaterial._metallicProp, value);
    }

    /**
     * Roughness, default 1.0.
     */
  }, {
    key: "roughness",
    get: function get() {
      return this.shaderData.getFloat(PBRMaterial._roughnessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRMaterial._roughnessProp, value);
    }

    /**
     * Roughness metallic texture.
     * @remarks G channel is roughness, B channel is metallic
     */
  }, {
    key: "roughnessMetallicTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRMaterial._roughnessMetallicTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRMaterial._roughnessMetallicTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("ROUGHNESSMETALLICTEXTURE");
      } else {
        this.shaderData.disableMacro("ROUGHNESSMETALLICTEXTURE");
      }
    }
  }]);
  return PBRMaterial;
}(PBRBaseMaterial);
PBRMaterial._metallicProp = Shader.getPropertyByName("u_metal");
PBRMaterial._roughnessProp = Shader.getPropertyByName("u_roughness");
PBRMaterial._roughnessMetallicTextureProp = Shader.getPropertyByName("u_roughnessMetallicTexture");

/**
 * PBR (Specular-Glossiness Workflow) Material.
 */
var PBRSpecularMaterial = /*#__PURE__*/function (_PBRBaseMaterial) {
  _inheritsLoose(PBRSpecularMaterial, _PBRBaseMaterial);
  /**
   * Create a pbr specular-glossiness workflow material instance.
   * @param engine - Engine to which the material belongs
   */
  function PBRSpecularMaterial(engine) {
    var _this;
    _this = _PBRBaseMaterial.call(this, engine, Shader.find("pbr-specular")) || this;
    _this.shaderData.setColor(PBRSpecularMaterial._specularColorProp, new Color(1, 1, 1, 1));
    _this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, 1.0);
    return _this;
  }

  /**
   * @override
   */
  var _proto = PBRSpecularMaterial.prototype;
  _proto.clone = function clone() {
    var dest = new PBRSpecularMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(PBRSpecularMaterial, [{
    key: "specularColor",
    get:
    /**
     * Specular color.
     */
    function get() {
      return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
    },
    set: function set(value) {
      var specularColor = this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
      if (value !== specularColor) {
        specularColor.copyFrom(value);
      }
    }

    /**
     * Glossiness.
     */
  }, {
    key: "glossiness",
    get: function get() {
      return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, value);
    }

    /**
     * Specular glossiness texture.
     * @remarks RGB is specular, A is glossiness
     */
  }, {
    key: "specularGlossinessTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);
      } else {
        this.shaderData.disableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);
      }
    }
  }]);
  return PBRSpecularMaterial;
}(PBRBaseMaterial);
PBRSpecularMaterial._specularColorProp = Shader.getPropertyByName("u_PBRSpecularColor");
PBRSpecularMaterial._glossinessProp = Shader.getPropertyByName("u_glossiness");
PBRSpecularMaterial._specularGlossinessTextureProp = Shader.getPropertyByName("u_specularGlossinessTexture");
PBRSpecularMaterial._specularGlossinessTextureMacro = Shader.getMacroByName("SPECULARGLOSSINESSTEXTURE");

/**
 * Unlit Material.
 */
var UnlitMaterial = /*#__PURE__*/function (_BaseMaterial) {
  _inheritsLoose(UnlitMaterial, _BaseMaterial);
  /**
   * Create a unlit material instance.
   * @param engine - Engine to which the material belongs
   */
  function UnlitMaterial(engine) {
    var _this;
    _this = _BaseMaterial.call(this, engine, Shader.find("unlit")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("OMIT_NORMAL");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(UnlitMaterial._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setVector4(UnlitMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    return _this;
  }

  /**
   * @override
   */
  var _proto = UnlitMaterial.prototype;
  _proto.clone = function clone() {
    var dest = new UnlitMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(UnlitMaterial, [{
    key: "baseColor",
    get:
    /**
     * Base color.
     */
    function get() {
      return this.shaderData.getColor(UnlitMaterial._baseColorProp);
    },
    set: function set(value) {
      var baseColor = this.shaderData.getColor(UnlitMaterial._baseColorProp);
      if (value !== baseColor) {
        baseColor.copyFrom(value);
      }
    }

    /**
     * Base texture.
     */
  }, {
    key: "baseTexture",
    get: function get() {
      return this.shaderData.getTexture(UnlitMaterial._baseTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(UnlitMaterial._baseTextureProp, value);
      if (value) {
        this.shaderData.enableMacro(UnlitMaterial._baseTextureMacro);
      } else {
        this.shaderData.disableMacro(UnlitMaterial._baseTextureMacro);
      }
    }

    /**
     * Tiling and offset of main textures.
     */
  }, {
    key: "tilingOffset",
    get: function get() {
      return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
    },
    set: function set(value) {
      var tilingOffset = this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
      if (value !== tilingOffset) {
        tilingOffset.copyFrom(value);
      }
    }
  }]);
  return UnlitMaterial;
}(BaseMaterial);

/**
 * The horizontal alignment of the text.
 */
var TextHorizontalAlignment;

/**
 * The vertical alignment of the text.
 */
(function (TextHorizontalAlignment) {
  TextHorizontalAlignment[TextHorizontalAlignment["Left"] = 0] = "Left";
  TextHorizontalAlignment[TextHorizontalAlignment["Center"] = 1] = "Center";
  TextHorizontalAlignment[TextHorizontalAlignment["Right"] = 2] = "Right";
})(TextHorizontalAlignment || (TextHorizontalAlignment = {}));
var TextVerticalAlignment;
(function (TextVerticalAlignment) {
  TextVerticalAlignment[TextVerticalAlignment["Top"] = 0] = "Top";
  TextVerticalAlignment[TextVerticalAlignment["Center"] = 1] = "Center";
  TextVerticalAlignment[TextVerticalAlignment["Bottom"] = 2] = "Bottom";
})(TextVerticalAlignment || (TextVerticalAlignment = {}));

/**
 * The way to handle the situation where wrapped text is too tall to fit in the height.
 */
var OverflowMode;
(function (OverflowMode) {
  OverflowMode[OverflowMode["Overflow"] = 0] = "Overflow";
  OverflowMode[OverflowMode["Truncate"] = 1] = "Truncate";
})(OverflowMode || (OverflowMode = {}));

/**
 * The style of the font.
 */
var FontStyle;
(function (FontStyle) {
  FontStyle[FontStyle["None"] = 0] = "None";
  FontStyle[FontStyle["Bold"] = 1] = "Bold";
  FontStyle[FontStyle["Italic"] = 2] = "Italic";
})(FontStyle || (FontStyle = {}));

/**
 * Sprite Atlas.
 */
var SpriteAtlas = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(SpriteAtlas, _RefObject);
  var _proto = SpriteAtlas.prototype;
  /**
   * Get the last sprite named 'name' from the atlas.
   * @param name - The name of the sprite you want to find
   * @returns The sprite you want to find
   */
  _proto.getSprite = function getSprite(name) {
    var sprite = this._sprites[this._spriteNamesToIndex[name]];
    if (!sprite) {
      console.warn("There is no sprite named " + name + " in the atlas.");
    }
    return sprite;
  }

  /**
   * Get all the sprite named 'name' from the atlas.
   * @param name - The name of the sprites you want to find
   * @param outSprites - This array holds the sprites found
   * @returns The sprites you want to find
   */;
  _proto.getSprites = function getSprites(name, outSprites) {
    outSprites.length = 0;
    var i = this._spriteNamesToIndex[name];
    if (i !== undefined) {
      var _sprites = this._sprites;
      for (; i >= 0; i--) {
        var sprite = _sprites[i];
        sprite.name === name && outSprites.push(sprite);
      }
    } else {
      console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
    }
    return outSprites;
  }

  /**
   * Constructor a SpriteAtlas.
   * @param engine - Engine to which the SpriteAtlas belongs
   */;
  function SpriteAtlas(engine) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this._sprites = new Array();
    _this._spriteNamesToIndex = {};
    return _this;
  }

  /**
   * @internal
   */
  _proto._addSprite = function _addSprite(sprite) {
    this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
  }

  /**
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {
    this._sprites = null;
    this._spriteNamesToIndex = null;
  };
  _createClass(SpriteAtlas, [{
    key: "sprites",
    get:
    /**
     * All the sprites in the atlas.
     */
    function get() {
      return this._sprites;
    }
  }]);
  return SpriteAtlas;
}(RefObject);

/**
 * Sprite's drawing mode enumeration.
 */
var SpriteDrawMode;
(function (SpriteDrawMode) {
  SpriteDrawMode[SpriteDrawMode["Simple"] = 0] = "Simple";
  SpriteDrawMode[SpriteDrawMode["Sliced"] = 1] = "Sliced";
})(SpriteDrawMode || (SpriteDrawMode = {}));

/**
 * 2D sprite.
 */
var Sprite = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Sprite, _RefObject);
  /**
   * Constructor a Sprite.
   * @param engine - Engine to which the sprite belongs
   * @param texture - Texture from which to obtain the Sprite
   * @param region - Rectangle region of the texture to use for the Sprite, specified in normalized
   * @param pivot - Sprite's pivot point relative to its graphic rectangle, specified in normalized
   * @param border - Boundaries when using Slice DrawMode, specified in normalized
   * @param name - The name of Sprite
   */
  function Sprite(engine, texture, region, pivot, border, name) {
    var _this;
    if (texture === void 0) {
      texture = null;
    }
    if (region === void 0) {
      region = null;
    }
    if (pivot === void 0) {
      pivot = null;
    }
    if (border === void 0) {
      border = null;
    }
    if (name === void 0) {
      name = null;
    }
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this._assetID = void 0;
    _this._width = undefined;
    _this._height = undefined;
    _this._positions = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];
    _this._uvs = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];
    _this._bounds = new BoundingBox();
    _this._texture = null;
    _this._atlasRotated = false;
    _this._atlasRegion = new Rect(0, 0, 1, 1);
    _this._atlasRegionOffset = new Vector4(0, 0, 0, 0);
    _this._region = new Rect(0, 0, 1, 1);
    _this._pivot = new Vector2(0.5, 0.5);
    _this._border = new Vector4(0, 0, 0, 0);
    _this._dirtyFlag = DirtyFlag$2.all;
    _this._updateFlagManager = new UpdateFlagManager();
    _this._texture = texture;
    region && _this._region.copyFrom(region);
    pivot && _this._pivot.copyFrom(pivot);
    border && _this._border.copyFrom(border);
    _this.name = name;
    return _this;
  }

  /**
   * Clone.
   * @returns Cloned sprite
   */
  var _proto = Sprite.prototype;
  _proto.clone = function clone() {
    var cloneSprite = new Sprite(this._engine, this._texture, this._region, this._pivot, this._border, this.name);
    cloneSprite._assetID = this._assetID;
    cloneSprite._atlasRotated = this._atlasRotated;
    cloneSprite._atlasRegion.copyFrom(this._atlasRegion);
    cloneSprite._atlasRegionOffset.copyFrom(this._atlasRegionOffset);
    return cloneSprite;
  }

  /**
   * @internal
   */;
  _proto._registerUpdateFlag = function _registerUpdateFlag() {
    return this._updateFlagManager.createFlag(ListenerUpdateFlag);
  }

  /**
   * @internal
   */;
  _proto._getPositions = function _getPositions() {
    this._dirtyFlag & DirtyFlag$2.positions && this._updatePositions();
    return this._positions;
  }

  /**
   * @internal
   */;
  _proto._getUVs = function _getUVs() {
    this._dirtyFlag & DirtyFlag$2.uvs && this._updateUVs();
    return this._uvs;
  }

  /**
   * @internal
   */;
  _proto._getBounds = function _getBounds() {
    this._dirtyFlag & DirtyFlag$2.positions && this._updatePositions();
    return this._bounds;
  }

  /**
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {
    if (this._texture) {
      this._texture = null;
    }
  };
  _proto._calDefaultSize = function _calDefaultSize() {
    if (this._texture) {
      var _texture = this._texture,
        _atlasRegion = this._atlasRegion,
        _atlasRegionOffset = this._atlasRegionOffset,
        _region = this._region;
      var pixelsPerUnitReciprocal = 1.0 / Engine._pixelsPerUnit;
      this.width = _texture.width * _atlasRegion.width / (1 - _atlasRegionOffset.x - _atlasRegionOffset.z) * _region.width * pixelsPerUnitReciprocal;
      this.height = _texture.height * _atlasRegion.height / (1 - _atlasRegionOffset.y - _atlasRegionOffset.w) * _region.height * pixelsPerUnitReciprocal;
    }
  };
  _proto._updatePositions = function _updatePositions() {
    var blank = this._atlasRegionOffset;
    var _this$_region = this._region,
      regionX = _this$_region.x,
      regionY = _this$_region.y,
      regionW = _this$_region.width,
      regionH = _this$_region.height;
    var regionRight = 1 - regionX - regionW;
    var regionBottom = 1 - regionY - regionH;
    var left = Math.max(blank.x - regionX, 0) / regionW;
    var bottom = Math.max(blank.w - regionY, 0) / regionH;
    var right = 1 - Math.max(blank.z - regionRight, 0) / regionW;
    var top = 1 - Math.max(blank.y - regionBottom, 0) / regionH;

    // Update positions.
    // ---------------
    //  2 - 3
    //  |   |
    //  0 - 1
    // ---------------
    var positions = this._positions;
    positions[0].set(left, bottom);
    positions[1].set(right, bottom);
    positions[2].set(left, top);
    positions[3].set(right, top);
    var _this$_bounds = this._bounds,
      min = _this$_bounds.min,
      max = _this$_bounds.max;
    min.set(left, bottom, 0);
    max.set(right, top, 0);
    this._dirtyFlag &= ~DirtyFlag$2.positions;
  };
  _proto._updateUVs = function _updateUVs() {
    var uv = this._uvs,
      atlasRegionOffset = this._atlasRegionOffset;
    var _this$_region2 = this._region,
      regionX = _this$_region2.x,
      regionY = _this$_region2.y,
      regionW = _this$_region2.width,
      regionH = _this$_region2.height;
    var regionRight = 1 - regionX - regionW;
    var regionBottom = 1 - regionY - regionH;
    var _this$_atlasRegion = this._atlasRegion,
      atlasRegionX = _this$_atlasRegion.x,
      atlasRegionY = _this$_atlasRegion.y,
      atlasRegionW = _this$_atlasRegion.width,
      atlasRegionH = _this$_atlasRegion.height;
    var offsetLeft = atlasRegionOffset.x,
      offsetTop = atlasRegionOffset.y,
      offsetRight = atlasRegionOffset.z,
      offsetBottom = atlasRegionOffset.w;
    var realWidth = atlasRegionW / (1 - offsetLeft - offsetRight);
    var realHeight = atlasRegionH / (1 - offsetTop - offsetBottom);
    // Coordinates of the four boundaries.
    var left = Math.max(regionX - offsetLeft, 0) * realWidth + atlasRegionX;
    var top = Math.max(regionBottom - offsetTop, 0) * realHeight + atlasRegionY;
    var right = atlasRegionW + atlasRegionX - Math.max(regionRight - offsetRight, 0) * realWidth;
    var bottom = atlasRegionH + atlasRegionY - Math.max(regionY - offsetBottom, 0) * realHeight;
    var _this$_border = this._border,
      borderLeft = _this$_border.x,
      borderBottom = _this$_border.y,
      borderRight = _this$_border.z,
      borderTop = _this$_border.w;
    // Left-Bottom
    uv[0].set(left, bottom);
    // Border ( Left-Bottom )
    uv[1].set((regionX - offsetLeft + borderLeft * regionW) * realWidth + atlasRegionX, atlasRegionH + atlasRegionY - (regionY - offsetBottom + borderBottom * regionH) * realHeight);
    // Border ( Right-Top )
    uv[2].set(atlasRegionW + atlasRegionX - (regionRight - offsetRight + borderRight * regionW) * realWidth, (regionBottom - offsetTop + borderTop * regionH) * realHeight + atlasRegionY);
    // Right-Top
    uv[3].set(right, top);
    this._dirtyFlag &= ~DirtyFlag$2.uvs;
  };
  _proto._dispatchSpriteChange = function _dispatchSpriteChange(type) {
    switch (type) {
      case SpritePropertyDirtyFlag.atlasRegionOffset:
      case SpritePropertyDirtyFlag.region:
        this._dirtyFlag |= DirtyFlag$2.all;
        break;
      case SpritePropertyDirtyFlag.atlasRegion:
      case SpritePropertyDirtyFlag.border:
        this._dirtyFlag |= DirtyFlag$2.uvs;
        break;
    }
    this._updateFlagManager.dispatch(type);
  };
  _createClass(Sprite, [{
    key: "texture",
    get: /** The name of sprite. */

    /** @internal temp solution. */

    /**
     * The reference to the used texture.
     */
    function get() {
      return this._texture;
    },
    set: function set(value) {
      if (this._texture !== value) {
        this._texture = value;
        this._dispatchSpriteChange(SpritePropertyDirtyFlag.texture);
      }
    }

    /**
     * The width of the sprite (in world coordinates).
     */
  }, {
    key: "width",
    get: function get() {
      this._width === undefined && this._calDefaultSize();
      return this._width;
    },
    set: function set(value) {
      if (this._width !== value) {
        this._width = value;
        this._dispatchSpriteChange(SpritePropertyDirtyFlag.size);
      }
    }

    /**
     * The height of the sprite (in world coordinates).
     */
  }, {
    key: "height",
    get: function get() {
      this._height === undefined && this._calDefaultSize();
      return this._height;
    },
    set: function set(value) {
      if (this._height !== value) {
        this._height = value;
        this._dispatchSpriteChange(SpritePropertyDirtyFlag.size);
      }
    }

    /**
     * Is it rotated 90 degrees clockwise when packing.
     */
  }, {
    key: "atlasRotated",
    get: function get() {
      return this._atlasRotated;
    },
    set: function set(value) {
      if (this._atlasRotated != value) {
        this._atlasRotated = value;
      }
    }

    /**
     * The rectangle region of the original texture on its atlas texture, specified in normalized.
     */
  }, {
    key: "atlasRegion",
    get: function get() {
      return this._atlasRegion;
    },
    set: function set(value) {
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      this._atlasRegion.set(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));
      this._dispatchSpriteChange(SpritePropertyDirtyFlag.atlasRegion);
    }

    /**
     * The rectangle region offset of the original texture on its atlas texture, specified in normalized.
     */
  }, {
    key: "atlasRegionOffset",
    get: function get() {
      return this._atlasRegionOffset;
    },
    set: function set(value) {
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      this._atlasRegionOffset.set(x, y, MathUtil.clamp(value.z, 0, 1 - x), MathUtil.clamp(value.w, 0, 1 - y));
      this._dispatchSpriteChange(SpritePropertyDirtyFlag.atlasRegionOffset);
    }

    /**
     * The rectangle region of the sprite, specified in normalized.
     */
  }, {
    key: "region",
    get: function get() {
      return this._region;
    },
    set: function set(value) {
      var region = this._region;
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      region.set(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));
      this._dispatchSpriteChange(SpritePropertyDirtyFlag.region);
    }

    /**
     * Location of the sprite's center point in the rectangle region, specified in normalized.
     * The origin is at the bottom left and the default value is (0.5, 0.5).
     */
  }, {
    key: "pivot",
    get: function get() {
      return this._pivot;
    },
    set: function set(value) {
      var pivot = this._pivot;
      if (pivot === value) {
        this._dispatchSpriteChange(SpritePropertyDirtyFlag.pivot);
      } else {
        var x = value.x,
          y = value.y;
        if (pivot.x !== x || pivot.y !== y) {
          pivot.set(x, y);
          this._dispatchSpriteChange(SpritePropertyDirtyFlag.pivot);
        }
      }
    }

    /**
     * Get the border of the sprite.
     *  x      y       z     w
     *  |      |       |     |
     * Left, bottom, right, top.
     * @remarks only use in sliced mode.
     */
  }, {
    key: "border",
    get: function get() {
      return this._border;
    },
    set: function set(value) {
      var border = this._border;
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      border.set(x, y, MathUtil.clamp(value.z, 0, 1 - x), MathUtil.clamp(value.w, 0, 1 - y));
      this._dispatchSpriteChange(SpritePropertyDirtyFlag.border);
    }
  }]);
  return Sprite;
}(RefObject);
var DirtyFlag$2;
(function (DirtyFlag) {
  DirtyFlag[DirtyFlag["positions"] = 1] = "positions";
  DirtyFlag[DirtyFlag["uvs"] = 2] = "uvs";
  DirtyFlag[DirtyFlag["all"] = 3] = "all";
})(DirtyFlag$2 || (DirtyFlag$2 = {}));

var _dec, _class$3, _class2$3;

/**
 * @internal
 */
var SlicedSpriteAssembler = (_dec = StaticInterfaceImplement(), _dec(_class$3 = (_class2$3 = /*#__PURE__*/function () {
  function SlicedSpriteAssembler() {}
  SlicedSpriteAssembler.resetData = function resetData(renderer) {
    var renderData = renderer._renderData;
    var positions = renderData.positions,
      uvs = renderData.uvs;
    if (positions.length < 16) {
      for (var i = positions.length; i < 16; i++) {
        positions.push(new Vector3());
        uvs.push(new Vector2());
      }
    }
    renderData.triangles = [];
  };
  SlicedSpriteAssembler.updatePositions = function updatePositions(renderer) {
    var width = renderer.width,
      height = renderer.height,
      sprite = renderer.sprite;
    var _renderer$_renderData = renderer._renderData,
      positions = _renderer$_renderData.positions,
      uvs = _renderer$_renderData.uvs,
      triangles = _renderer$_renderData.triangles;
    var border = sprite.border;
    var spriteUVs = sprite._getUVs();
    // Update local positions.
    var spritePositions = sprite._getPositions();
    var _spritePositions$ = spritePositions[0],
      left = _spritePositions$.x,
      bottom = _spritePositions$.y;
    var _spritePositions$2 = spritePositions[3],
      right = _spritePositions$2.x,
      top = _spritePositions$2.y;
    var expectWidth = sprite.width,
      expectHeight = sprite.height;
    var fixedLeft = expectWidth * border.x;
    var fixedBottom = expectHeight * border.y;
    var fixedRight = expectHeight * border.z;
    var fixedTop = expectWidth * border.w;

    // ------------------------
    //     [3]
    //      |
    //     [2]
    //      |
    //     [1]
    //      |
    // row [0] - [1] - [2] - [3]
    //    column
    // ------------------------
    // Calculate row and column.
    var row, column;
    if (fixedLeft + fixedRight > width) {
      var widthScale = width / (fixedLeft + fixedRight);
      row = [expectWidth * left * widthScale, fixedLeft * widthScale, fixedLeft * widthScale, width - expectWidth * (1 - right) * widthScale];
    } else {
      row = [expectWidth * left, fixedLeft, width - fixedRight, width - expectWidth * (1 - right)];
    }
    if (fixedTop + fixedBottom > height) {
      var heightScale = height / (fixedTop + fixedBottom);
      column = [expectHeight * bottom * heightScale, fixedBottom * heightScale, fixedBottom * heightScale, height - expectHeight * (1 - top) * heightScale];
    } else {
      column = [expectHeight * bottom, fixedBottom, height - fixedTop, height - expectHeight * (1 - top)];
    }

    // Update renderer's worldMatrix.
    var _renderer$sprite$pivo = renderer.sprite.pivot,
      pivotX = _renderer$sprite$pivo.x,
      pivotY = _renderer$sprite$pivo.y;
    var localTransX = renderer.width * pivotX;
    var localTransY = renderer.height * pivotY;
    // Renderer's worldMatrix.
    var worldMatrix = SlicedSpriteAssembler._worldMatrix;
    var wE = worldMatrix.elements;
    // Parent's worldMatrix.
    var pWE = renderer.entity.transform.worldMatrix.elements;
    var sx = renderer.flipX ? -1 : 1;
    var sy = renderer.flipY ? -1 : 1;
    wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
    wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
    wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
    wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
    wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
    wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];

    // ------------------------
    //  3 - 7 - 11 - 15
    //  |   |   |    |
    //  2 - 6 - 10 - 14
    //  |   |   |    |
    //  1 - 5 - 9  - 13
    //  |   |   |    |
    //  0 - 4 - 8  - 12
    // ------------------------
    // Assemble position and uv.
    var vertexCount = 0;
    var realICount = 0;
    for (var i = 0; i < 4; i++) {
      var rowValue = row[i];
      var rowU = spriteUVs[i].x;
      for (var j = 0; j < 4; j++) {
        var columnValue = column[j];
        positions[vertexCount].set(wE[0] * rowValue + wE[4] * columnValue + wE[12], wE[1] * rowValue + wE[5] * columnValue + wE[13], wE[2] * rowValue + wE[6] * columnValue + wE[14]);
        uvs[vertexCount].set(rowU, spriteUVs[j].y);
        ++vertexCount;
      }
      ++realICount;
    }
    var realJCount = vertexCount / realICount;
    var indexOffset = 0;
    for (var _i = 0; _i < realICount - 1; ++_i) {
      for (var _j = 0; _j < realJCount - 1; ++_j) {
        var start = _i * realJCount + _j;
        triangles[indexOffset++] = start;
        triangles[indexOffset++] = start + 1;
        triangles[indexOffset++] = start + realJCount;
        triangles[indexOffset++] = start + 1;
        triangles[indexOffset++] = start + realJCount + 1;
        triangles[indexOffset++] = start + realJCount;
      }
    }
    renderer._renderData.vertexCount = realICount * realJCount;
    triangles.length = (realICount - 1) * (realJCount - 1) * 6;
    var _renderer$_bounds = renderer._bounds,
      min = _renderer$_bounds.min,
      max = _renderer$_bounds.max;
    min.set(row[0], column[0], 0);
    max.set(row[3], column[3], 0);
    renderer._bounds.transform(worldMatrix);
  };
  SlicedSpriteAssembler.updateUVs = function updateUVs(renderer) {};
  return SlicedSpriteAssembler;
}(), _class2$3._worldMatrix = new Matrix(), _class2$3)) || _class$3);

var _class$2, _descriptor$2, _descriptor2$2, _descriptor3$2, _descriptor4$2, _descriptor5$2, _descriptor6$2, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$1, _descriptor11$1, _descriptor12$1, _descriptor13$1, _class2$2;

/**
 * Renders a Sprite for 2D graphics.
 */
var SpriteRenderer = (_class$2 = (_class2$2 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(SpriteRenderer, _Renderer);
  /**
   * @internal
   */
  function SpriteRenderer(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "_renderData", _descriptor$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_drawMode", _descriptor2$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_assembler", _descriptor3$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_color", _descriptor4$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_sprite", _descriptor5$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_width", _descriptor6$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_height", _descriptor7$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_flipX", _descriptor8$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_flipY", _descriptor9$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_maskLayer", _descriptor10$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_maskInteraction", _descriptor11$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_dirtyFlag", _descriptor12$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_spriteChangeFlag", _descriptor13$1, _assertThisInitialized(_this));
    _this._renderData = new RenderData2D(4, [], [], null, _this._color);
    _this.drawMode = SpriteDrawMode.Simple;
    _this.setMaterial(_this._engine._spriteDefaultMaterial);
    _this._onSpriteChange = _this._onSpriteChange.bind(_assertThisInitialized(_this));
    return _this;
  }

  /**
   * @internal
   */
  var _proto = SpriteRenderer.prototype;
  _proto._render = function _render(camera) {
    var _this$sprite;
    if (!((_this$sprite = this.sprite) !== null && _this$sprite !== void 0 && _this$sprite.texture) || !this.width || !this.height) {
      return;
    }

    // Update position.
    if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$1.Position) {
      this._assembler.updatePositions(this);
      this._dirtyFlag &= ~DirtyFlag$1.Position;
      this._transformChangeFlag.flag = false;
    }

    // Update uv.
    if (this._dirtyFlag & DirtyFlag$1.UV) {
      this._assembler.updateUVs(this);
      this._dirtyFlag &= ~DirtyFlag$1.UV;
    }

    // Push primitive.
    var spriteElement = this._engine._spriteElementPool.getFromPool();
    spriteElement.setValue(this, this._renderData, this.getMaterial(), this.sprite.texture);
    camera._renderPipeline.pushPrimitive(spriteElement);
  }

  /**
   * @internal
   */;
  _proto._cloneTo = function _cloneTo(target) {
    target.sprite = this._sprite;
  }

  /**
   * @internal
   */;
  _proto._onDestroy = function _onDestroy() {
    this._color = null;
    this._sprite = null;
    this._assembler = null;
    this._renderData = null;
    if (this._spriteChangeFlag) {
      this._spriteChangeFlag.destroy();
      this._spriteChangeFlag = null;
    }
    _Renderer.prototype._onDestroy.call(this);
  };
  _proto._updateStencilState = function _updateStencilState() {
    // Update stencil.
    var material = this.getInstanceMaterial();
    var stencilState = material.renderState.stencilState;
    var maskInteraction = this._maskInteraction;
    if (maskInteraction === SpriteMaskInteraction.None) {
      stencilState.enabled = false;
      stencilState.writeMask = 0xff;
      stencilState.referenceValue = 0;
      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
    } else {
      stencilState.enabled = true;
      stencilState.writeMask = 0x00;
      stencilState.referenceValue = 1;
      var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
      stencilState.compareFunctionFront = compare;
      stencilState.compareFunctionBack = compare;
    }
  };
  _proto._onSpriteChange = function _onSpriteChange(dirtyFlag) {
    switch (dirtyFlag) {
      case SpritePropertyDirtyFlag.texture:
        this.shaderData.setTexture(SpriteRenderer._textureProperty, this.sprite.texture);
        break;
      case SpritePropertyDirtyFlag.size:
        this._drawMode === SpriteDrawMode.Sliced && (this._dirtyFlag |= DirtyFlag$1.Position);
        break;
      case SpritePropertyDirtyFlag.border:
        this._drawMode === SpriteDrawMode.Sliced && (this._dirtyFlag |= DirtyFlag$1.All);
        break;
      case SpritePropertyDirtyFlag.region:
      case SpritePropertyDirtyFlag.atlasRegionOffset:
        this._dirtyFlag |= DirtyFlag$1.All;
        break;
      case SpritePropertyDirtyFlag.atlasRegion:
        this._dirtyFlag |= DirtyFlag$1.UV;
        break;
      case SpritePropertyDirtyFlag.pivot:
        this._dirtyFlag |= DirtyFlag$1.Position;
        break;
    }
  };
  _createClass(SpriteRenderer, [{
    key: "drawMode",
    get: /** @internal */

    /** @internal */

    /**
     * The draw mode of the sprite renderer.
     */
    function get() {
      return this._drawMode;
    },
    set: function set(drawMode) {
      if (this._drawMode !== drawMode) {
        this._drawMode = drawMode;
        switch (drawMode) {
          case SpriteDrawMode.Simple:
            this._assembler = SimpleSpriteAssembler;
            break;
          case SpriteDrawMode.Sliced:
            this._assembler = SlicedSpriteAssembler;
            break;
        }
        this._assembler.resetData(this);
        this._dirtyFlag |= DirtyFlag$1.All;
      }
    }

    /**
     * The Sprite to render.
     */
  }, {
    key: "sprite",
    get: function get() {
      return this._sprite;
    },
    set: function set(value) {
      if (this._sprite !== value) {
        this._sprite = value;
        this._spriteChangeFlag && this._spriteChangeFlag.destroy();
        if (value) {
          this._spriteChangeFlag = value._registerUpdateFlag();
          this._spriteChangeFlag.listener = this._onSpriteChange;
          this._dirtyFlag |= DirtyFlag$1.All;
          this.shaderData.setTexture(SpriteRenderer._textureProperty, value.texture);
        } else {
          this._spriteChangeFlag = null;
          this.shaderData.setTexture(SpriteRenderer._textureProperty, null);
        }
      }
    }

    /**
     * Rendering color for the Sprite graphic.
     */
  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(value) {
      if (this._color !== value) {
        this._color.copyFrom(value);
      }
    }

    /**
     * Render width.
     */
  }, {
    key: "width",
    get: function get() {
      if (this._width === undefined && this._sprite) {
        this.width = this._sprite.width;
      }
      return this._width;
    },
    set: function set(value) {
      if (this._width !== value) {
        this._width = value;
        this._dirtyFlag |= DirtyFlag$1.Position;
      }
    }

    /**
     * Render height.
     */
  }, {
    key: "height",
    get: function get() {
      if (this._height === undefined && this._sprite) {
        this.height = this._sprite.height;
      }
      return this._height;
    },
    set: function set(value) {
      if (this._height !== value) {
        this._height = value;
        this._dirtyFlag |= DirtyFlag$1.Position;
      }
    }

    /**
     * Flips the sprite on the X axis.
     */
  }, {
    key: "flipX",
    get: function get() {
      return this._flipX;
    },
    set: function set(value) {
      if (this._flipX !== value) {
        this._flipX = value;
        this._dirtyFlag |= DirtyFlag$1.Position;
      }
    }

    /**
     * Flips the sprite on the Y axis.
     */
  }, {
    key: "flipY",
    get: function get() {
      return this._flipY;
    },
    set: function set(value) {
      if (this._flipY !== value) {
        this._flipY = value;
        this._dirtyFlag |= DirtyFlag$1.Position;
      }
    }

    /**
     * The bounding volume of the spriteRenderer.
     */
  }, {
    key: "bounds",
    get: function get() {
      var _this$sprite2;
      if (!((_this$sprite2 = this.sprite) !== null && _this$sprite2 !== void 0 && _this$sprite2.texture) || !this.width || !this.height) {
        return Engine._defaultBoundingBox;
      } else if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$1.Position) {
        this._assembler.updatePositions(this);
        this._dirtyFlag &= ~DirtyFlag$1.Position;
        this._transformChangeFlag.flag = false;
      }
      return this._bounds;
    }

    /**
     * The mask layer the sprite renderer belongs to.
     */
  }, {
    key: "maskLayer",
    get: function get() {
      return this._maskLayer;
    },
    set: function set(value) {
      this._maskLayer = value;
    }

    /**
     * Interacts with the masks.
     */
  }, {
    key: "maskInteraction",
    get: function get() {
      return this._maskInteraction;
    },
    set: function set(value) {
      if (this._maskInteraction !== value) {
        this._maskInteraction = value;
        this._updateStencilState();
      }
    }
  }]);
  return SpriteRenderer;
}(Renderer), _class2$2._textureProperty = Shader.getPropertyByName("u_spriteTexture"), _class2$2), (_descriptor$2 = _applyDecoratedDescriptor(_class$2.prototype, "_renderData", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$2 = _applyDecoratedDescriptor(_class$2.prototype, "_drawMode", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$2 = _applyDecoratedDescriptor(_class$2.prototype, "_assembler", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$2 = _applyDecoratedDescriptor(_class$2.prototype, "_color", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color(1, 1, 1, 1);
  }
}), _descriptor5$2 = _applyDecoratedDescriptor(_class$2.prototype, "_sprite", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor6$2 = _applyDecoratedDescriptor(_class$2.prototype, "_width", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return undefined;
  }
}), _descriptor7$2 = _applyDecoratedDescriptor(_class$2.prototype, "_height", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return undefined;
  }
}), _descriptor8$2 = _applyDecoratedDescriptor(_class$2.prototype, "_flipX", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class$2.prototype, "_flipY", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class$2.prototype, "_maskLayer", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskLayer.Layer0;
  }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class$2.prototype, "_maskInteraction", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskInteraction.None;
  }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class$2.prototype, "_dirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class$2.prototype, "_spriteChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class$2);
var DirtyFlag$1;
(function (DirtyFlag) {
  DirtyFlag[DirtyFlag["Position"] = 1] = "Position";
  DirtyFlag[DirtyFlag["UV"] = 2] = "UV";
  DirtyFlag[DirtyFlag["All"] = 3] = "All";
})(DirtyFlag$1 || (DirtyFlag$1 = {}));

/**
 * @internal
 * Font Atlas.
 */
var FontAtlas = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(FontAtlas, _RefObject);
  /**
   * Constructor a FontAtlas.
   * @param engine - Engine to which the FontAtlas belongs
   */
  function FontAtlas(engine) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this._charInfoMap = {};
    _this._texture = void 0;
    _this._space = 1;
    _this._curX = 1;
    _this._curY = 1;
    _this._nextY = 1;
    return _this;
  }

  /**
   * @override
   */
  var _proto = FontAtlas.prototype;
  _proto._onDestroy = function _onDestroy() {
    this._texture.destroy();
    this._texture = null;
    this._charInfoMap = {};
  };
  _proto.uploadCharTexture = function uploadCharTexture(charInfo) {
    var width = charInfo.w,
      height = charInfo.h,
      data = charInfo.data;
    var space = this._space,
      texture = this.texture;
    var textureSize = texture.width;
    var offsetWidth = width + space;
    var offsetHeight = height + space;
    if (1 + offsetWidth >= textureSize || 1 + offsetHeight >= textureSize) {
      throw Error("The char fontSize is too large.");
    }
    var endX = this._curX + offsetWidth;
    if (endX >= textureSize) {
      this._curX = space;
      this._curY = this._nextY + space;
    }
    var endY = this._curY + offsetHeight;
    if (endY > this._nextY) {
      this._nextY = endY;
    }
    if (endY >= textureSize) {
      return false;
    }
    if (width > 0 && height > 0 && data) {
      texture.setPixelBuffer(data, 0, this._curX, this._curY, width, height);
      texture.generateMipmaps();
    }
    var textureSizeReciprocal = 1.0 / textureSize;
    var x = this._curX;
    var y = this._curY;
    var w = width;
    var h = height;
    var u0 = x * textureSizeReciprocal;
    var u1 = (x + w) * textureSizeReciprocal;
    var v0 = y * textureSizeReciprocal;
    var v1 = (y + h) * textureSizeReciprocal;
    charInfo.x = x;
    charInfo.y = y;
    var uvs = charInfo.uvs;
    uvs[0].set(u0, v0);
    uvs[1].set(u1, v0);
    uvs[2].set(u1, v1);
    uvs[3].set(u0, v1);
    this._curX += offsetWidth + space;
    return true;
  };
  _proto.addCharInfo = function addCharInfo(char, charInfo) {
    this._charInfoMap[char.charCodeAt(0)] = charInfo;
  };
  _proto.getCharInfo = function getCharInfo(char) {
    return this._charInfoMap[char.charCodeAt(0)];
  };
  _createClass(FontAtlas, [{
    key: "texture",
    get: function get() {
      return this._texture;
    },
    set: function set(value) {
      this._texture = value;
    }
  }]);
  return FontAtlas;
}(RefObject);

/**
 * Font.
 */
var Font = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Font, _RefObject);
  /**
   * Create a font from OS.
   * @param engine - Engine to which the font belongs
   * @param name - The name of font
   * @returns The font object has been create
   */
  Font.createFromOS = function createFromOS(engine, name) {
    if (name === void 0) {
      name = "";
    }
    var fontMap = Font._fontMap;
    var font = fontMap[name];
    if (font) {
      return font;
    }
    font = new Font(engine, name);
    fontMap[name] = font;
    return font;
  };
  function Font(engine, name) {
    var _this;
    if (name === void 0) {
      name = "";
    }
    _this = _RefObject.call(this, engine) || this;
    _this._name = "";
    _this._fontAtlases = [];
    _this._lastIndex = -1;
    _this._name = name;
    return _this;
  }

  /**
   * @internal
   */
  var _proto = Font.prototype;
  _proto._uploadCharTexture = function _uploadCharTexture(charInfo) {
    var fontAtlases = this._fontAtlases;
    var lastIndex = this._lastIndex;
    if (lastIndex === -1) {
      this._createFontAtlas();
      lastIndex++;
    }
    var fontAtlas = fontAtlases[lastIndex];
    if (!fontAtlas.uploadCharTexture(charInfo)) {
      fontAtlas = this._createFontAtlas();
      fontAtlas.uploadCharTexture(charInfo);
      lastIndex++;
    }
    this._lastIndex = lastIndex;
    charInfo.data = null;
  }

  /**
   * @internal
   */;
  _proto._addCharInfo = function _addCharInfo(char, charInfo) {
    var lastIndex = this._lastIndex;
    charInfo.index = lastIndex;
    this._fontAtlases[lastIndex].addCharInfo(char, charInfo);
  }

  /**
   * @internal
   */;
  _proto._getCharInfo = function _getCharInfo(char) {
    var fontAtlases = this._fontAtlases;
    for (var i = 0, n = fontAtlases.length; i < n; ++i) {
      var fontAtlas = fontAtlases[i];
      var charInfo = fontAtlas.getCharInfo(char);
      if (charInfo) {
        return charInfo;
      }
    }
    return null;
  }

  /**
   * @internal
   */;
  _proto._getTextureByIndex = function _getTextureByIndex(index) {
    var fontAtlas = this._fontAtlases[index];
    if (fontAtlas) {
      return fontAtlas.texture;
    }
    return null;
  }

  /**
   * @internal
   */;
  _proto._getLastIndex = function _getLastIndex() {
    return this._lastIndex;
  }

  /**
   * @override
   */;
  _proto._onDestroy = function _onDestroy() {
    var fontAtlases = this._fontAtlases;
    for (var i = 0, n = fontAtlases.length; i < n; ++i) {
      fontAtlases[i].destroy(true);
    }
    fontAtlases.length = 0;
    delete Font._fontMap[this._name];
  };
  _proto._createFontAtlas = function _createFontAtlas() {
    var engine = this.engine;
    var fontAtlas = new FontAtlas(engine);
    var texture = new Texture2D(engine, 256, 256);
    fontAtlas.texture = texture;
    this._fontAtlases.push(fontAtlas);
    return fontAtlas;
  };
  _createClass(Font, [{
    key: "name",
    get:
    /**
     * The name of the font object.
     */
    function get() {
      return this._name;
    }
  }]);
  return Font;
}(RefObject);
Font._fontMap = {};

/**
 * @internal
 */
var CharRenderData = /** x:Top y:Left z:Bottom w:Right */

function CharRenderData() {
  this.texture = void 0;
  this.localPositions = new Vector4();
  this.renderData = void 0;
  var positions = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
  this.renderData = new RenderData2D(4, positions, null, CharRenderData.triangles, null);
};
CharRenderData.triangles = [0, 2, 1, 2, 0, 3];

/**
 * @internal
 */
var CharRenderDataPool = /*#__PURE__*/function () {
  function CharRenderDataPool(type, length) {
    this._elements = [];
    this._type = void 0;
    this._type = type;
    var elements = this._elements;
    for (var i = 0; i < length; ++i) {
      elements[i] = new type();
    }
  }
  var _proto = CharRenderDataPool.prototype;
  _proto.get = function get() {
    if (this._elements.length > 0) {
      return this._elements.pop();
    }
    return new this._type();
  };
  _proto.put = function put(data) {
    this._elements.push(data);
  };
  return CharRenderDataPool;
}();

/**
 * @internal
 * TextUtils includes some helper function for text.
 */
var TextUtils = /*#__PURE__*/function () {
  function TextUtils() {}
  /** @internal */
  /** These characters are all tall to help calculate the height required for text. */
  /**
   * The instance function to get an object includes 2d context and canvas.
   * @returns the TextContext object
   */
  TextUtils.textContext = function textContext() {
    var textContext = TextUtils._textContext;
    if (!textContext) {
      var canvas;
      try {
        canvas = new OffscreenCanvas(0, 0);
      } catch (_unused) {
        canvas = document.createElement("canvas");
      }
      var context = canvas.getContext("2d");
      textContext = {
        canvas: canvas,
        context: context
      };
      TextUtils._textContext = textContext;
    }
    return textContext;
  }

  /**
   * Measure the font.
   * @param fontString - the string of the font
   * @returns the font size info
   */;
  TextUtils.measureFont = function measureFont(fontString) {
    var fontSizeInfoCache = TextUtils._fontSizeInfoCache;
    var info = fontSizeInfoCache[fontString];
    if (info) {
      return info;
    }
    info = TextUtils._measureFontOrChar(fontString);
    fontSizeInfoCache[fontString] = info;
    return info;
  }

  /**
   * Get native font string.
   * @param fontName - The font name
   * @param fontSize - The font size
   * @param style - The font style
   * @returns The native font string
   */;
  TextUtils.getNativeFontString = function getNativeFontString(fontName, fontSize, style) {
    var str = style & FontStyle.Bold ? "bold " : "";
    style & FontStyle.Italic && (str += "italic ");
    // Check if font already contains strings
    if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils._genericFontFamilies.indexOf(fontName) == -1) {
      fontName = "\"" + fontName + "\"";
    }
    str += fontSize + "px " + fontName;
    return str;
  };
  TextUtils.measureChar = function measureChar(char, fontString) {
    return TextUtils._measureFontOrChar(fontString, char);
  };
  TextUtils.measureTextWithWrap = function measureTextWithWrap(renderer) {
    var fontSize = renderer.fontSize,
      fontStyle = renderer.fontStyle;
    var name = renderer.font.name;
    var fontString = TextUtils.getNativeFontString(name, fontSize, fontStyle);
    var charFont = renderer._styleFont;
    var fontSizeInfo = TextUtils.measureFont(fontString);
    var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
    var lines = new Array();
    var lineWidths = new Array();
    var lineMaxSizes = new Array();
    var _pixelsPerUnit = Engine._pixelsPerUnit;
    var lineHeight = fontSizeInfo.size + renderer.lineSpacing * _pixelsPerUnit;
    var wrapWidth = renderer.width * _pixelsPerUnit;
    var width = 0;
    for (var i = 0, n = subTexts.length; i < n; ++i) {
      var subText = subTexts[i];
      var chars = "";
      var charsWidth = 0;
      var maxAscent = -1;
      var maxDescent = -1;
      for (var j = 0, m = subText.length; j < m; ++j) {
        var char = subText[j];
        var charInfo = TextUtils._getCharInfo(char, fontString, charFont);
        var w = charInfo.w,
          offsetY = charInfo.offsetY;
        var halfH = charInfo.h * 0.5;
        var ascent = halfH + offsetY;
        var descent = halfH - offsetY;
        if (charsWidth + w > wrapWidth) {
          if (charsWidth === 0) {
            lines.push(char);
            lineWidths.push(w);
            lineMaxSizes.push({
              ascent: ascent,
              descent: descent,
              size: ascent + descent
            });
          } else {
            lines.push(chars);
            lineWidths.push(charsWidth);
            lineMaxSizes.push({
              ascent: maxAscent,
              descent: maxDescent,
              size: maxAscent + maxDescent
            });
            chars = char;
            charsWidth = charInfo.xAdvance;
            maxAscent = ascent;
            maxDescent = descent;
          }
        } else {
          chars += char;
          charsWidth += charInfo.xAdvance;
          maxAscent < ascent && (maxAscent = ascent);
          maxDescent < descent && (maxDescent = descent);
        }
      }
      if (charsWidth > 0) {
        lines.push(chars);
        lineWidths.push(charsWidth);
        lineMaxSizes.push({
          ascent: maxAscent,
          descent: maxDescent,
          size: maxAscent + maxDescent
        });
      }
    }
    var height = renderer.height * _pixelsPerUnit;
    if (renderer.overflowMode === OverflowMode.Overflow) {
      height = lineHeight * lines.length;
    }
    return {
      width: width,
      height: height,
      lines: lines,
      lineWidths: lineWidths,
      lineHeight: lineHeight,
      lineMaxSizes: lineMaxSizes
    };
  };
  TextUtils.measureTextWithoutWrap = function measureTextWithoutWrap(renderer) {
    var fontSize = renderer.fontSize,
      fontStyle = renderer.fontStyle;
    var name = renderer.font.name;
    var fontString = TextUtils.getNativeFontString(name, fontSize, fontStyle);
    var charFont = renderer._styleFont;
    var fontSizeInfo = TextUtils.measureFont(fontString);
    var lines = renderer.text.split(/(?:\r\n|\r|\n)/);
    var lineCount = lines.length;
    var lineWidths = new Array();
    var lineMaxSizes = new Array();
    var _pixelsPerUnit = Engine._pixelsPerUnit;
    var lineHeight = fontSizeInfo.size + renderer.lineSpacing * _pixelsPerUnit;
    var width = 0;
    var height = renderer.height * _pixelsPerUnit;
    if (renderer.overflowMode === OverflowMode.Overflow) {
      height = lineHeight * lineCount;
    }
    for (var i = 0; i < lineCount; ++i) {
      var line = lines[i];
      var curWidth = 0;
      var maxAscent = -1;
      var maxDescent = -1;
      for (var j = 0, m = line.length; j < m; ++j) {
        var charInfo = TextUtils._getCharInfo(line[j], fontString, charFont);
        curWidth += charInfo.xAdvance;
        var offsetY = charInfo.offsetY;
        var halfH = charInfo.h * 0.5;
        var ascent = halfH + offsetY;
        var descent = halfH - offsetY;
        maxAscent < ascent && (maxAscent = ascent);
        maxDescent < descent && (maxDescent = descent);
      }
      lineWidths[i] = curWidth;
      lineMaxSizes[i] = {
        ascent: maxAscent,
        descent: maxDescent,
        size: maxAscent + maxDescent
      };
      if (curWidth > width) {
        width = curWidth;
      }
    }
    return {
      width: width,
      height: height,
      lines: lines,
      lineWidths: lineWidths,
      lineHeight: lineHeight,
      lineMaxSizes: lineMaxSizes
    };
  }

  /**
   * Get native font hash.
   * @param fontName - The font name
   * @param fontSize - The font size
   * @param style - The font style
   * @returns The native font hash
   */;
  TextUtils.getNativeFontHash = function getNativeFontHash(fontName, fontSize, style) {
    var str = style & FontStyle.Bold ? "bold" : "";
    style & FontStyle.Italic && (str += "italic");
    // Check if font already contains strings
    if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils._genericFontFamilies.indexOf(fontName) == -1) {
      fontName = "" + fontName;
    }
    str += fontSize + "px" + fontName;
    return str;
  };
  TextUtils._measureFontOrChar = function _measureFontOrChar(fontString, char) {
    if (char === void 0) {
      char = "";
    }
    var _TextUtils$textContex = TextUtils.textContext(),
      canvas = _TextUtils$textContex.canvas,
      context = _TextUtils$textContex.context;
    context.font = fontString;
    var measureString = char || TextUtils._measureString;
    // Safari gets data confusion through getImageData when the canvas width is not an integer.
    // @todo: Text layout may vary from standard.
    var width = Math.round(context.measureText(measureString).width);
    var baseline = Math.ceil(context.measureText(TextUtils._measureBaseline).width);
    var height = baseline * TextUtils._heightMultiplier;
    baseline = TextUtils._baselineMultiplier * baseline | 0;
    canvas.width = width;
    canvas.height = height;
    context.font = fontString;
    context.fillStyle = "#000";
    context.clearRect(0, 0, width, height);
    context.textBaseline = "middle";
    context.fillStyle = "#fff";
    context.fillText(measureString, 0, baseline);
    var colorData = context.getImageData(0, 0, width, height).data;
    var len = colorData.length;
    var top = -1;
    var bottom = -1;
    var y;
    var ascent = 0;
    var descent = 0;
    var size = 0;
    var integerW = canvas.width;
    var integerWReciprocal = 1.0 / integerW;
    for (var i = 0; i < len; i += 4) {
      if (colorData[i + 3] !== 0) {
        var idx = i * 0.25;
        y = ~~(idx * integerWReciprocal);
        if (top === -1) {
          top = y;
        }
        if (y > bottom) {
          bottom = y;
        }
      }
    }
    if (top !== -1 && bottom !== -1) {
      ascent = baseline - top;
      descent = bottom - baseline + 1;
      size = ascent + descent;
    }
    var sizeInfo = {
      ascent: ascent,
      descent: descent,
      size: size
    };
    if (char) {
      var data = null;
      if (size > 0) {
        var lineIntegerW = integerW * 4;
        // gl.texSubImage2D uploading data of type Uint8ClampedArray is not supported in some devices(eg: IphoneX IOS 13.6.1).
        data = new Uint8Array(colorData.buffer, top * lineIntegerW, size * lineIntegerW);
      }
      return {
        x: 0,
        y: 0,
        w: width,
        h: size,
        offsetX: 0,
        offsetY: (ascent - descent) * 0.5,
        xAdvance: width,
        uvs: [new Vector2(), new Vector2(), new Vector2(), new Vector2()],
        ascent: ascent,
        descent: descent,
        index: 0,
        data: data
      };
    } else {
      return sizeInfo;
    }
  };
  TextUtils._getCharInfo = function _getCharInfo(char, fontString, font) {
    var charInfo = font._getCharInfo(char);
    if (!charInfo) {
      charInfo = TextUtils.measureChar(char, fontString);
      font._uploadCharTexture(charInfo);
      font._addCharInfo(char, charInfo);
    }
    return charInfo;
  };
  return TextUtils;
}();

/**
 * @internal
 * TextContext.
 */
TextUtils._genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "math", "emoji", "fangsong"];
TextUtils._measureString = "|ÉqÅ";
TextUtils._measureBaseline = "M";
TextUtils._heightMultiplier = 2;
TextUtils._baselineMultiplier = 1.4;
TextUtils._fontSizeInfoCache = {};
TextUtils._textContext = null;

var _class$1, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _class2$1;

/**
 * Renders a text for 2D graphics.
 */
var TextRenderer = (_class$1 = (_class2$1 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(TextRenderer, _Renderer);
  function TextRenderer(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "_styleFont", _descriptor$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_charRenderDatas", _descriptor2$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_dirtyFlag", _descriptor3$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isWorldMatrixDirty", _descriptor4$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_color", _descriptor5$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_text", _descriptor6$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_width", _descriptor7$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_height", _descriptor8$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_localBounds", _descriptor9$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_font", _descriptor10, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_fontSize", _descriptor11, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_fontStyle", _descriptor12, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lineSpacing", _descriptor13, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_horizontalAlignment", _descriptor14, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_verticalAlignment", _descriptor15, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_enableWrapping", _descriptor16, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_overflowMode", _descriptor17, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_maskInteraction", _descriptor18, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_maskLayer", _descriptor19, _assertThisInitialized(_this));
    var _assertThisInitialize = _assertThisInitialized(_this),
      engine = _assertThisInitialize.engine;
    _this._isWorldMatrixDirty = entity.transform._registerWorldChangeListener();
    _this._isWorldMatrixDirty.listener = function () {
      _this._setDirtyFlagTrue(DirtyFlag.WorldPosition | DirtyFlag.WorldBounds);
    };
    _this.font = Font.createFromOS(engine);
    _this.setMaterial(engine._spriteDefaultMaterial);
    return _this;
  }

  /**
   * @internal
   */
  var _proto = TextRenderer.prototype;
  _proto._render = function _render(camera) {
    if (this._text === "" || this.enableWrapping && this.width <= 0 || this.overflowMode === OverflowMode.Truncate && this.height <= 0) {
      return;
    }
    if (this._isContainDirtyFlag(DirtyFlag.MaskInteraction)) {
      this._updateStencilState();
      this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);
    }
    if (this._isContainDirtyFlag(DirtyFlag.StyleFont)) {
      this._resetStyleFont();
      this._setDirtyFlagFalse(DirtyFlag.StyleFont);
    }
    if (this._isContainDirtyFlag(DirtyFlag.LocalPositionBounds)) {
      this._updateLocalData();
      this._setDirtyFlagFalse(DirtyFlag.LocalPositionBounds);
    }
    if (this._isContainDirtyFlag(DirtyFlag.WorldPosition)) {
      this._updatePosition();
      this._setDirtyFlagFalse(DirtyFlag.WorldPosition);
    }
    var spriteElementPool = this._engine._spriteElementPool;
    var textElement = this._engine._textElementPool.getFromPool();
    var charElements = textElement.charElements;
    var material = this.getMaterial();
    var charRenderDatas = this._charRenderDatas;
    var charCount = charRenderDatas.length;
    textElement.component = this;
    textElement.material = material;
    charElements.length = charCount;
    for (var i = 0; i < charCount; ++i) {
      var charRenderData = charRenderDatas[i];
      var spriteElement = spriteElementPool.getFromPool();
      spriteElement.setValue(this, charRenderData.renderData, material, charRenderData.texture);
      charElements[i] = spriteElement;
    }
    camera._renderPipeline.pushPrimitive(textElement);
  }

  /**
   * @internal
   */;
  _proto._onDestroy = function _onDestroy() {
    // Clear render data.
    var charRenderDatas = this._charRenderDatas;
    for (var i = 0, n = charRenderDatas.length; i < n; ++i) {
      TextRenderer._charRenderDataPool.put(charRenderDatas[i]);
    }
    charRenderDatas.length = 0;
    this._isWorldMatrixDirty.destroy();
    _Renderer.prototype._onDestroy.call(this);
  }

  /**
   * @internal
   */;
  _proto._cloneTo = function _cloneTo(target) {
    target.font = this._font;
  }

  /**
   * @internal
   */;
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  }

  /**
   * @internal
   */;
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  }

  /**
   * @internal
   */;
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  }

  /**
   * @override
   */;
  _proto._updateBounds = function _updateBounds(worldBounds) {
    BoundingBox.transform(this._localBounds, this._entity.transform.worldMatrix, worldBounds);
  };
  _proto._updateStencilState = function _updateStencilState() {
    // Update stencil.
    var material = this.getInstanceMaterial();
    var stencilState = material.renderState.stencilState;
    var maskInteraction = this._maskInteraction;
    if (maskInteraction === SpriteMaskInteraction.None) {
      stencilState.enabled = false;
      stencilState.writeMask = 0xff;
      stencilState.referenceValue = 0;
      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
    } else {
      stencilState.enabled = true;
      stencilState.writeMask = 0x00;
      stencilState.referenceValue = 1;
      var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
      stencilState.compareFunctionFront = compare;
      stencilState.compareFunctionBack = compare;
    }
  };
  _proto._resetStyleFont = function _resetStyleFont() {
    var lastStyleFont = this._styleFont;
    if (lastStyleFont) {
      lastStyleFont._addRefCount(-1);
      lastStyleFont.destroy();
    }
    this._styleFont = Font.createFromOS(this.engine, TextUtils.getNativeFontHash(this.font.name, this.fontSize, this.fontStyle));
    this._styleFont._addRefCount(1);
  };
  _proto._updatePosition = function _updatePosition() {
    var transform = this.entity.transform;
    var e = transform.worldMatrix.elements;
    var charRenderDatas = this._charRenderDatas;

    // prettier-ignore
    var e0 = e[0],
      e1 = e[1],
      e2 = e[2];
    // prettier-ignore
    var e4 = e[4],
      e5 = e[5],
      e6 = e[6];
    // prettier-ignore
    var e12 = e[12],
      e13 = e[13],
      e14 = e[14];
    var up = TextRenderer._tempVec31.set(e4, e5, e6);
    var right = TextRenderer._tempVec30.set(e0, e1, e2);
    for (var i = 0, n = charRenderDatas.length; i < n; ++i) {
      var charRenderData = charRenderDatas[i];
      var localPositions = charRenderData.localPositions;
      var positions = charRenderData.renderData.positions;
      var topLeftX = localPositions.x,
        topLeftY = localPositions.y;

      // Top-Left
      var worldPosition0 = positions[0];
      worldPosition0.x = topLeftX * e0 + topLeftY * e4 + e12;
      worldPosition0.y = topLeftX * e1 + topLeftY * e5 + e13;
      worldPosition0.z = topLeftX * e2 + topLeftY * e6 + e14;

      // Right offset
      var worldPosition1 = positions[1];
      Vector3.scale(right, localPositions.z - topLeftX, worldPosition1);

      // Top-Right
      Vector3.add(worldPosition0, worldPosition1, worldPosition1);

      // Up offset
      var worldPosition2 = positions[2];
      Vector3.scale(up, localPositions.w - topLeftY, worldPosition2);

      // Bottom-Left
      Vector3.add(worldPosition0, worldPosition2, positions[3]);
      // Bottom-Right
      Vector3.add(worldPosition1, worldPosition2, worldPosition2);
    }
  };
  _proto._updateLocalData = function _updateLocalData() {
    var color = this.color,
      horizontalAlignment = this.horizontalAlignment,
      verticalAlignment = this.verticalAlignment,
      charRenderDatas = this._charRenderDatas;
    var _this$_localBounds = this._localBounds,
      min = _this$_localBounds.min,
      max = _this$_localBounds.max;
    min.set(0, 0, 0);
    max.set(0, 0, 0);
    var _pixelsPerUnit = Engine._pixelsPerUnit;
    var pixelsPerUnitReciprocal = 1.0 / _pixelsPerUnit;
    var charFont = this._styleFont;
    var rendererWidth = this.width * _pixelsPerUnit;
    var halfRendererWidth = rendererWidth * 0.5;
    var rendererHeight = this.height * _pixelsPerUnit;
    var textMetrics = this.enableWrapping ? TextUtils.measureTextWithWrap(this) : TextUtils.measureTextWithoutWrap(this);
    var height = textMetrics.height,
      lines = textMetrics.lines,
      lineWidths = textMetrics.lineWidths,
      lineHeight = textMetrics.lineHeight,
      lineMaxSizes = textMetrics.lineMaxSizes;
    var charRenderDataPool = TextRenderer._charRenderDataPool;
    var halfLineHeight = lineHeight * 0.5;
    var linesLen = lines.length;
    var startY = 0;
    var topDiff = lineHeight * 0.5 - lineMaxSizes[0].ascent;
    var bottomDiff = lineHeight * 0.5 - lineMaxSizes[linesLen - 1].descent - 1;
    switch (verticalAlignment) {
      case TextVerticalAlignment.Top:
        startY = rendererHeight * 0.5 - halfLineHeight + topDiff;
        break;
      case TextVerticalAlignment.Center:
        startY = height * 0.5 - halfLineHeight - (bottomDiff - topDiff) * 0.5;
        break;
      case TextVerticalAlignment.Bottom:
        startY = height - rendererHeight * 0.5 - halfLineHeight - bottomDiff;
        break;
    }
    var renderDataCount = 0;
    var minX = Number.MAX_SAFE_INTEGER;
    var minY = Number.MAX_SAFE_INTEGER;
    var maxX = Number.MIN_SAFE_INTEGER;
    var maxY = Number.MIN_SAFE_INTEGER;
    var lastLineIndex = linesLen - 1;
    for (var i = 0; i < linesLen; ++i) {
      var line = lines[i];
      var lineWidth = lineWidths[i];
      var startX = 0;
      switch (horizontalAlignment) {
        case TextHorizontalAlignment.Left:
          startX = -halfRendererWidth;
          break;
        case TextHorizontalAlignment.Center:
          startX = -lineWidth * 0.5;
          break;
        case TextHorizontalAlignment.Right:
          startX = halfRendererWidth - lineWidth;
          break;
      }
      for (var j = 0, m = line.length - 1; j <= m; ++j) {
        var char = line[j];
        var charInfo = charFont._getCharInfo(char);
        if (charInfo.h > 0) {
          var charRenderData = charRenderDatas[renderDataCount] || charRenderDataPool.get();
          var renderData = charRenderData.renderData,
            localPositions = charRenderData.localPositions;
          charRenderData.texture = charFont._getTextureByIndex(charInfo.index);
          renderData.color = color;
          renderData.uvs = charInfo.uvs;
          var w = charInfo.w,
            ascent = charInfo.ascent,
            descent = charInfo.descent;
          var left = startX * pixelsPerUnitReciprocal;
          var right = (startX + w) * pixelsPerUnitReciprocal;
          var top = (startY + ascent) * pixelsPerUnitReciprocal;
          var bottom = (startY - descent + 1) * pixelsPerUnitReciprocal;
          localPositions.set(left, top, right, bottom);
          charRenderDatas[renderDataCount] = charRenderData;
          renderDataCount++;
          i === 0 && (maxY = Math.max(maxY, top));
          i === lastLineIndex && (minY = Math.min(minY, bottom));
          j === 0 && (minX = Math.min(minX, left));
          j === m && (maxX = Math.max(maxX, right));
        }
        startX += charInfo.xAdvance;
      }
      startY -= lineHeight;
    }
    min.set(minX, minY, 0);
    max.set(maxX, maxY, 0);

    // Revert excess render data to pool.
    var lastRenderDataCount = charRenderDatas.length;
    if (lastRenderDataCount > renderDataCount) {
      for (var _i = renderDataCount; _i < lastRenderDataCount; ++_i) {
        charRenderDataPool.put(charRenderDatas[_i]);
      }
      charRenderDatas.length = renderDataCount;
    }
    charFont._getLastIndex() > 0 && charRenderDatas.sort(function (a, b) {
      return a.texture.instanceId - b.texture.instanceId;
    });
  };
  _createClass(TextRenderer, [{
    key: "color",
    get: /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Rendering color for the Text.
     */
    function get() {
      return this._color;
    },
    set: function set(value) {
      if (this._color !== value) {
        this._color.copyFrom(value);
      }
    }

    /**
     * Rendering string for the Text.
     */
  }, {
    key: "text",
    get: function get() {
      return this._text;
    },
    set: function set(value) {
      value = value || "";
      if (this._text !== value) {
        this._text = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * The width of the TextRenderer (in 3D world coordinates).
     */
  }, {
    key: "width",
    get: function get() {
      return this._width;
    },
    set: function set(value) {
      if (this._width !== value) {
        this._width = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * The height of the TextRenderer (in 3D world coordinates).
     */
  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(value) {
      if (this._height !== value) {
        this._height = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * The font of the Text.
     */
  }, {
    key: "font",
    get: function get() {
      return this._font;
    },
    set: function set(value) {
      if (this._font !== value) {
        this._font = value;
        this._setDirtyFlagTrue(DirtyFlag.Font);
      }
    }

    /**
     * The font size of the Text.
     */
  }, {
    key: "fontSize",
    get: function get() {
      return this._fontSize;
    },
    set: function set(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this._setDirtyFlagTrue(DirtyFlag.Font);
      }
    }

    /**
     * The style of the font.
     */
  }, {
    key: "fontStyle",
    get: function get() {
      return this._fontStyle;
    },
    set: function set(value) {
      if (this.fontStyle !== value) {
        this._fontStyle = value;
        this._setDirtyFlagTrue(DirtyFlag.Font);
      }
    }

    /**
     * The space between two lines (in pixels).
     */
  }, {
    key: "lineSpacing",
    get: function get() {
      return this._lineSpacing;
    },
    set: function set(value) {
      if (this._lineSpacing !== value) {
        this._lineSpacing = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * The horizontal alignment.
     */
  }, {
    key: "horizontalAlignment",
    get: function get() {
      return this._horizontalAlignment;
    },
    set: function set(value) {
      if (this._horizontalAlignment !== value) {
        this._horizontalAlignment = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * The vertical alignment.
     */
  }, {
    key: "verticalAlignment",
    get: function get() {
      return this._verticalAlignment;
    },
    set: function set(value) {
      if (this._verticalAlignment !== value) {
        this._verticalAlignment = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * Whether wrap text to next line when exceeds the width of the container.
     */
  }, {
    key: "enableWrapping",
    get: function get() {
      return this._enableWrapping;
    },
    set: function set(value) {
      if (this._enableWrapping !== value) {
        this._enableWrapping = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * The overflow mode.
     */
  }, {
    key: "overflowMode",
    get: function get() {
      return this._overflowMode;
    },
    set: function set(value) {
      if (this._overflowMode !== value) {
        this._overflowMode = value;
        this._setDirtyFlagTrue(DirtyFlag.Position);
      }
    }

    /**
     * Interacts with the masks.
     */
  }, {
    key: "maskInteraction",
    get: function get() {
      return this._maskInteraction;
    },
    set: function set(value) {
      if (this._maskInteraction !== value) {
        this._maskInteraction = value;
        this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);
      }
    }

    /**
     * The mask layer the sprite renderer belongs to.
     */
  }, {
    key: "maskLayer",
    get: function get() {
      return this._maskLayer;
    },
    set: function set(value) {
      this._maskLayer = value;
    }

    /**
     * The bounding volume of the TextRenderer.
     */
  }, {
    key: "bounds",
    get: function get() {
      this._isContainDirtyFlag(DirtyFlag.StyleFont) && this._resetStyleFont();
      this._isContainDirtyFlag(DirtyFlag.LocalPositionBounds) && this._updateLocalData();
      this._isContainDirtyFlag(DirtyFlag.WorldPosition) && this._updatePosition();
      this._isContainDirtyFlag(DirtyFlag.WorldBounds) && this._updateBounds(this._bounds);
      this._setDirtyFlagFalse(DirtyFlag.Font);
      return this._bounds;
    }
  }]);
  return TextRenderer;
}(Renderer), _class2$1._charRenderDataPool = new CharRenderDataPool(CharRenderData, 50), _class2$1._tempVec30 = new Vector3(), _class2$1._tempVec31 = new Vector3(), _class2$1), (_descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "_styleFont", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor2$1 = _applyDecoratedDescriptor(_class$1.prototype, "_charRenderDatas", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class$1.prototype, "_dirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return DirtyFlag.Font;
  }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class$1.prototype, "_isWorldMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$1 = _applyDecoratedDescriptor(_class$1.prototype, "_color", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color(1, 1, 1, 1);
  }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class$1.prototype, "_text", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return "";
  }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class$1.prototype, "_width", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor8$1 = _applyDecoratedDescriptor(_class$1.prototype, "_height", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class$1.prototype, "_localBounds", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new BoundingBox();
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class$1.prototype, "_font", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class$1.prototype, "_fontSize", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 24;
  }
}), _descriptor12 = _applyDecoratedDescriptor(_class$1.prototype, "_fontStyle", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return FontStyle.None;
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class$1.prototype, "_lineSpacing", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor14 = _applyDecoratedDescriptor(_class$1.prototype, "_horizontalAlignment", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return TextHorizontalAlignment.Center;
  }
}), _descriptor15 = _applyDecoratedDescriptor(_class$1.prototype, "_verticalAlignment", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return TextVerticalAlignment.Center;
  }
}), _descriptor16 = _applyDecoratedDescriptor(_class$1.prototype, "_enableWrapping", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor17 = _applyDecoratedDescriptor(_class$1.prototype, "_overflowMode", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return OverflowMode.Overflow;
  }
}), _descriptor18 = _applyDecoratedDescriptor(_class$1.prototype, "_maskInteraction", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskInteraction.None;
  }
}), _descriptor19 = _applyDecoratedDescriptor(_class$1.prototype, "_maskLayer", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskLayer.Layer0;
  }
})), _class$1);
var DirtyFlag;
(function (DirtyFlag) {
  DirtyFlag[DirtyFlag["StyleFont"] = 1] = "StyleFont";
  DirtyFlag[DirtyFlag["LocalPositionBounds"] = 2] = "LocalPositionBounds";
  DirtyFlag[DirtyFlag["WorldPosition"] = 4] = "WorldPosition";
  DirtyFlag[DirtyFlag["WorldBounds"] = 8] = "WorldBounds";
  DirtyFlag[DirtyFlag["MaskInteraction"] = 16] = "MaskInteraction";
  DirtyFlag[DirtyFlag["Position"] = 14] = "Position";
  DirtyFlag[DirtyFlag["Font"] = 15] = "Font";
})(DirtyFlag || (DirtyFlag = {}));

/**
 * Associate AnimationCurve and the Entity
 */
var AnimationClipCurveBinding = function AnimationClipCurveBinding() {
  this.relativePath = void 0;
  this.type = void 0;
  this.property = void 0;
  this.curve = void 0;
};

/**
 * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
 */
var AnimationEvent = function AnimationEvent() {
  this.time = void 0;
  this.functionName = void 0;
  this.parameter = void 0;
};

var AnimationProperty;
(function (AnimationProperty) {
  AnimationProperty[AnimationProperty["Position"] = 0] = "Position";
  AnimationProperty[AnimationProperty["Rotation"] = 1] = "Rotation";
  AnimationProperty[AnimationProperty["Scale"] = 2] = "Scale";
  AnimationProperty[AnimationProperty["BlendShapeWeights"] = 3] = "BlendShapeWeights";
})(AnimationProperty || (AnimationProperty = {}));

/**
 * Base class for AnimationClips and BlendTrees.
 */
var Motion = function Motion() {};

/**
 * Stores keyframe based animations.
 */
var AnimationClip = /*#__PURE__*/function (_Motion) {
  _inheritsLoose(AnimationClip, _Motion);
  /**
   * @param name - The AnimationClip's name
   */
  function AnimationClip(name) {
    var _this;
    _this = _Motion.call(this) || this;
    _this.name = name;
    _this._curveBindings = [];
    _this._length = 0;
    _this._events = [];
    return _this;
  }

  /**
   * Adds an animation event to the clip.
   * @param functionName - The name of the method called in the script
   * @param time - The time when the event be triggered
   * @param parameter - The parameter that is stored in the event and will be sent to the function
   */
  var _proto = AnimationClip.prototype;
  _proto.addEvent = function addEvent(param, time, parameter) {
    if (typeof param === "string") {
      var _event = new AnimationEvent();
      _event.functionName = param;
      _event.time = time;
      _event.parameter = parameter;
      this._events.push(_event);
    } else {
      this._events.push(param);
    }
    this._events.sort(function (a, b) {
      return a.time - b.time;
    });
  }

  /**
   * Clears all events from the clip.
   */;
  _proto.clearEvents = function clearEvents() {
    this._events.length = 0;
  }

  /**
   * Add curve binding for the clip.
   * @param relativePath - Path to the game object this curve applies to. The relativePath is formatted similar to a pathname, e.g. "/root/spine/leftArm"
   * @param type- The class type of the component that is animated
   * @param propertyName - The name to the property being animated
   * @param curve - The animation curve
   */;
  _proto.addCurveBinding = function addCurveBinding(relativePath, type, propertyName, curve) {
    var property;
    switch (propertyName) {
      case "position":
        property = AnimationProperty.Position;
        break;
      case "rotation":
        property = AnimationProperty.Rotation;
        break;
      case "scale":
        property = AnimationProperty.Scale;
        break;
      case "blendShapeWeights":
        property = AnimationProperty.BlendShapeWeights;
        break;
    }
    var curveBinding = new AnimationClipCurveBinding();
    curveBinding.relativePath = relativePath;
    curveBinding.type = type;
    curveBinding.property = property;
    curveBinding.curve = curve;
    if (curve.length > this._length) {
      this._length = curve.length;
    }
    this._curveBindings.push(curveBinding);
  }

  /**
   * Clears all curve bindings from the clip.
   */;
  _proto.clearCurveBindings = function clearCurveBindings() {
    this._curveBindings.length = 0;
    this._length = 0;
  }

  /**
   * @internal
   * Samples an animation at a given time.
   * @param entity - The animated entity
   * @param time - The time to sample an animation
   */;
  _proto._sampleAnimation = function _sampleAnimation(entity, time) {
    var length = this._curveBindings.length;
    for (var i = length - 1; i >= 0; i--) {
      var curveData = this._curveBindings[i];
      var curve = curveData.curve,
        property = curveData.property,
        relativePath = curveData.relativePath,
        type = curveData.type;
      var val = curve.evaluate(time);
      var target = entity.findByName(relativePath);
      var transform = target.transform;
      if (type === Transform) {
        switch (property) {
          case AnimationProperty.Position:
            transform.position = val;
            break;
          case AnimationProperty.Rotation:
            transform.rotationQuaternion = val;
            break;
          case AnimationProperty.Scale:
            transform.scale = val;
            break;
        }
      }
    }
  };
  _createClass(AnimationClip, [{
    key: "events",
    get: /** @internal */

    /**
     * Animation events for this animation clip.
     */
    function get() {
      return this._events;
    }

    /**
     * Animation curve bindings for this animation clip.
     */
  }, {
    key: "curveBindings",
    get: function get() {
      return this._curveBindings;
    }

    /**
     * Animation length in seconds.
     */
  }, {
    key: "length",
    get: function get() {
      return this._length;
    }
  }]);
  return AnimationClip;
}(Motion);

var InterpolableValueType;
(function (InterpolableValueType) {
  InterpolableValueType[InterpolableValueType["Float"] = 0] = "Float";
  InterpolableValueType[InterpolableValueType["FloatArray"] = 1] = "FloatArray";
  InterpolableValueType[InterpolableValueType["Vector2"] = 2] = "Vector2";
  InterpolableValueType[InterpolableValueType["Vector3"] = 3] = "Vector3";
  InterpolableValueType[InterpolableValueType["Vector4"] = 4] = "Vector4";
  InterpolableValueType[InterpolableValueType["Quaternion"] = 5] = "Quaternion";
})(InterpolableValueType || (InterpolableValueType = {}));

/**
 * @internal
 */
var AnimatorUtils = /*#__PURE__*/function () {
  function AnimatorUtils() {}
  AnimatorUtils.scaleWeight = function scaleWeight(s, w, out) {
    var sX = s.x;
    var sY = s.y;
    var sZ = s.z;
    out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
    out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
    out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
  };
  AnimatorUtils.scaleBlend = function scaleBlend(sa, sb, w, out) {
    var saw = AnimatorUtils._tempVector30;
    var sbw = AnimatorUtils._tempVector31;
    AnimatorUtils.scaleWeight(sa, 1.0 - w, saw);
    AnimatorUtils.scaleWeight(sb, w, sbw);
    var sng = w > 0.5 ? sb : sa;
    out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
    out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
    out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
  };
  AnimatorUtils.quaternionWeight = function quaternionWeight(s, w, out) {
    out.x = s.x * w;
    out.y = s.y * w;
    out.z = s.z * w;
    out.w = s.w;
  };
  return AnimatorUtils;
}();
AnimatorUtils._tempVector30 = new Vector3();
AnimatorUtils._tempVector31 = new Vector3();

var AnimatorLayerBlendingMode;
(function (AnimatorLayerBlendingMode) {
  AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"] = 0] = "Override";
  AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"] = 1] = "Additive";
})(AnimatorLayerBlendingMode || (AnimatorLayerBlendingMode = {}));

/**
 * @internal
 */
var AnimatorStatePlayState;
(function (AnimatorStatePlayState) {
  AnimatorStatePlayState[AnimatorStatePlayState["UnStarted"] = 0] = "UnStarted";
  AnimatorStatePlayState[AnimatorStatePlayState["Playing"] = 1] = "Playing";
  AnimatorStatePlayState[AnimatorStatePlayState["Finished"] = 2] = "Finished";
})(AnimatorStatePlayState || (AnimatorStatePlayState = {}));

/**
 * Layer state.
 */
var LayerState;
(function (LayerState) {
  LayerState[LayerState["Standby"] = 0] = "Standby";
  LayerState[LayerState["Playing"] = 1] = "Playing";
  LayerState[LayerState["CrossFading"] = 2] = "CrossFading";
  LayerState[LayerState["FixedCrossFading"] = 3] = "FixedCrossFading";
})(LayerState || (LayerState = {}));

/**
 * @internal
 */
var AnimationCurveOwner = /*#__PURE__*/function () {
  /** @internal */

  function AnimationCurveOwner(target, type, property) {
    this.crossCurveMark = 0;
    this.crossCurveIndex = void 0;
    this.target = void 0;
    this.type = void 0;
    this.property = void 0;
    this.component = void 0;
    this.defaultValue = void 0;
    this.fixedPoseValue = void 0;
    this._hasSavedDefaultValue = false;
    this.target = target;
    this.type = type;
    this.property = property;
    switch (property) {
      case AnimationProperty.Position:
        this.defaultValue = new Vector3();
        this.fixedPoseValue = new Vector3();
        this.component = target.transform;
        break;
      case AnimationProperty.Rotation:
        this.defaultValue = new Quaternion();
        this.fixedPoseValue = new Quaternion();
        this.component = target.transform;
        break;
      case AnimationProperty.Scale:
        this.defaultValue = new Vector3();
        this.fixedPoseValue = new Vector3();
        this.component = target.transform;
        break;
      case AnimationProperty.BlendShapeWeights:
        this.component = target.getComponent(SkinnedMeshRenderer);
        var weightLength = this.component.blendShapeWeights.length;
        this.defaultValue = new Float32Array(weightLength);
        this.fixedPoseValue = new Float32Array(weightLength);
        break;
    }
  }
  var _proto = AnimationCurveOwner.prototype;
  _proto.saveDefaultValue = function saveDefaultValue() {
    switch (this.property) {
      case AnimationProperty.Position:
        this.defaultValue.copyFrom(this.target.transform.position);
        break;
      case AnimationProperty.Rotation:
        this.defaultValue.copyFrom(this.target.transform.rotationQuaternion);
        break;
      case AnimationProperty.Scale:
        this.defaultValue.copyFrom(this.target.transform.scale);
        break;
      case AnimationProperty.BlendShapeWeights:
        var _ref = this.component,
          blendShapeWeights = _ref.blendShapeWeights;
        for (var i = 0, length = blendShapeWeights.length; i < length; ++i) {
          this.defaultValue[i] = blendShapeWeights[i];
        }
        break;
    }
    this._hasSavedDefaultValue = true;
  };
  _proto.saveFixedPoseValue = function saveFixedPoseValue() {
    switch (this.property) {
      case AnimationProperty.Position:
        this.fixedPoseValue.copyFrom(this.target.transform.position);
        break;
      case AnimationProperty.Rotation:
        this.fixedPoseValue.copyFrom(this.target.transform.rotationQuaternion);
        break;
      case AnimationProperty.Scale:
        this.fixedPoseValue.copyFrom(this.target.transform.scale);
        break;
      case AnimationProperty.BlendShapeWeights:
        var _ref2 = this.component,
          blendShapeWeights = _ref2.blendShapeWeights;
        for (var i = 0, length = blendShapeWeights.length; i < length; ++i) {
          this.fixedPoseValue[i] = this.component.blendShapeWeights[i];
        }
        break;
    }
  };
  return AnimationCurveOwner;
}();

/**
 * @internal
 */
var AnimationEventHandler = function AnimationEventHandler() {
  this.event = void 0;
  this.handlers = [];
};

/**
 * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.
 */
var AnimatorStateTransition = function AnimatorStateTransition() {
  this.duration = 0;
  this.offset = 0;
  this.exitTime = 1;
  this.destinationState = void 0;
};

/**
 * Animation wrap mode.
 */
var WrapMode;
(function (WrapMode) {
  WrapMode[WrapMode["Once"] = 0] = "Once";
  WrapMode[WrapMode["Loop"] = 1] = "Loop";
})(WrapMode || (WrapMode = {}));

/**
 * @internal
 */
var AnimatorStatePlayData = /*#__PURE__*/function () {
  function AnimatorStatePlayData() {
    this.state = void 0;
    this.stateData = void 0;
    this.frameTime = void 0;
    this.playState = void 0;
    this.clipTime = void 0;
    this.currentEventIndex = void 0;
  }
  var _proto = AnimatorStatePlayData.prototype;
  _proto.reset = function reset(state, stateData, offsetFrameTime) {
    this.state = state;
    this.frameTime = offsetFrameTime;
    this.stateData = stateData;
    this.playState = AnimatorStatePlayState.UnStarted;
    this.clipTime = state.clipStartTime * state.clip.length;
    this.currentEventIndex = 0;
  };
  _proto.update = function update(isBackwards) {
    var state = this.state;
    var time = this.frameTime;
    var duration = state._getDuration();
    this.playState = AnimatorStatePlayState.Playing;
    if (state.wrapMode === WrapMode.Loop) {
      time = duration ? time % duration : 0;
    } else {
      if (Math.abs(time) > duration) {
        time = time < 0 ? -duration : duration;
        this.playState = AnimatorStatePlayState.Finished;
      }
    }
    if (isBackwards && time === 0) {
      this.clipTime = state.clipEndTime * state.clip.length;
    } else {
      time < 0 && (time += duration);
      this.clipTime = time + state.clipStartTime * state.clip.length;
    }
  };
  return AnimatorStatePlayData;
}();

/**
 * @internal
 */
var AnimatorLayerData = /*#__PURE__*/function () {
  function AnimatorLayerData() {
    this.animatorStateDataMap = {};
    this.srcPlayData = new AnimatorStatePlayData();
    this.destPlayData = new AnimatorStatePlayData();
    this.layerState = LayerState.Standby;
    this.crossCurveMark = 0;
    this.manuallyTransition = new AnimatorStateTransition();
    this.crossFadeTransition = void 0;
  }
  var _proto = AnimatorLayerData.prototype;
  _proto.switchPlayData = function switchPlayData() {
    var srcPlayData = this.destPlayData;
    var switchTemp = this.srcPlayData;
    this.srcPlayData = srcPlayData;
    this.destPlayData = switchTemp;
  };
  return AnimatorLayerData;
}();

/**
 * @internal
 */
var AnimatorStateData = function AnimatorStateData() {
  this.curveOwners = [];
  this.eventHandlers = [];
};

/**
 * @internal
 */
var AnimatorStateInfo = function AnimatorStateInfo() {
  this.layerIndex = void 0;
  this.state = void 0;
};

/**
 * @internal
 */
var CrossCurveData = function CrossCurveData() {
  this.curveOwner = void 0;
  this.srcCurveIndex = void 0;
  this.destCurveIndex = void 0;
};

/**
 * @internal
 */
var AnimatorTempValue = /*#__PURE__*/function () {
  function AnimatorTempValue() {
    this.vector2 = new Vector2();
    this.vector3 = new Vector3();
    this.vector4 = new Vector4();
    this.quaternion = new Quaternion();
    this._floatArrayPool = [];
  }
  var _proto = AnimatorTempValue.prototype;
  _proto.getFloatArray = function getFloatArray(length) {
    var floatArray = this._floatArrayPool[length];
    if (!floatArray) {
      this._floatArrayPool[length] = floatArray = new Float32Array(length);
    }
    return floatArray;
  };
  return AnimatorTempValue;
}();

var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _class2;
/**
 * The controller of the animation system.
 */
var Animator = (_class = (_class2 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Animator, _Component);
  /**
   * @internal
   */
  function Animator(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._animatorController = void 0;
    _initializerDefineProperty(_this, "_speed", _descriptor, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_controllerUpdateFlag", _descriptor2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animatorLayersData", _descriptor3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_crossCurveDataCollection", _descriptor4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animationCurveOwners", _descriptor5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_crossCurveDataPool", _descriptor6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animationEventHandlerPool", _descriptor7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_baseTempValue", _descriptor8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_crossTempValue", _descriptor9, _assertThisInitialized(_this));
    return _this;
  }

  /**
   * Play a state by name.
   * @param stateName - The state name
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
   */
  var _proto = Animator.prototype;
  _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
    var _this$_controllerUpda;
    if (layerIndex === void 0) {
      layerIndex = -1;
    }
    if (normalizedTimeOffset === void 0) {
      normalizedTimeOffset = 0;
    }
    if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
      this._clearPlayData();
    }
    var animatorInfo = this._getAnimatorStateInfo(stateName, layerIndex, Animator._animatorInfo);
    var state = animatorInfo.state;
    if (!state) {
      return;
    }
    if (!state.clip) {
      console.warn("The state named " + stateName + " has no AnimationClip data.");
      return;
    }
    var animatorLayerData = this._getAnimatorLayerData(animatorInfo.layerIndex);
    var srcPlayData = animatorLayerData.srcPlayData;
    var curState = srcPlayData.state;
    if (curState && curState !== state) {
      this._revertDefaultValue(srcPlayData.state, srcPlayData.stateData);
    }

    //CM: Not consider same stateName, but different animation
    var animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData);
    animatorLayerData.layerState = LayerState.Playing;
    srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);
    this._saveDefaultValues(animatorStateData);
  }

  /**
   * @internal
   */;
  _proto._reset = function _reset() {
    var animatorController = this._animatorController;
    if (animatorController) {
      var layers = animatorController.layers;
      for (var i = 0, n = layers.length; i < n; ++i) {
        var states = layers[i].stateMachine.states;
        var animatorLayerData = this._getAnimatorLayerData(i);
        for (var j = 0, m = states.length; j < m; ++j) {
          var state = states[j];
          var animatorStateData = this._getAnimatorStateData(state.name, state, animatorLayerData);
          this._revertDefaultValue(state, animatorStateData);
        }
      }
    }
    this._clearPlayData();
  }

  /**
   * Create a cross fade from the current state to another state.
   * @param stateName - The state name
   * @param normalizedTransitionDuration - The duration of the transition (normalized)
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
   */;
  _proto.crossFade = function crossFade(stateName, normalizedTransitionDuration, layerIndex, normalizedTimeOffset) {
    var _this$_controllerUpda2;
    if (layerIndex === void 0) {
      layerIndex = -1;
    }
    if (normalizedTimeOffset === void 0) {
      normalizedTimeOffset = 0;
    }
    if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
      this._clearPlayData();
    }
    var _this$_getAnimatorSta = this._getAnimatorStateInfo(stateName, layerIndex, Animator._animatorInfo),
      state = _this$_getAnimatorSta.state;
    var _this$_getAnimatorLay = this._getAnimatorLayerData(layerIndex),
      manuallyTransition = _this$_getAnimatorLay.manuallyTransition;
    manuallyTransition.duration = normalizedTransitionDuration;
    manuallyTransition.offset = normalizedTimeOffset;
    manuallyTransition.destinationState = state;
    this._crossFadeByTransition(manuallyTransition, layerIndex);
  }

  /**
   * Evaluates the animator component based on deltaTime.
   * @param deltaTime - The deltaTime when the animation update
   */;
  _proto.update = function update(deltaTime) {
    var _this$_controllerUpda3;
    if (this.speed === 0) {
      return;
    }
    var animatorController = this._animatorController;
    if (!animatorController) {
      return;
    }
    if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
      return;
    }
    deltaTime *= this.speed;
    for (var i = 0, n = animatorController.layers.length; i < n; i++) {
      var animatorLayerData = this._getAnimatorLayerData(i);
      if (animatorLayerData.layerState === LayerState.Standby) {
        continue;
      }
      this._updateLayer(i, i === 0, deltaTime / 1000);
    }
  }

  /**
   * Get the playing state from the target layerIndex.
   * @param layerIndex - The layer index
   */;
  _proto.getCurrentAnimatorState = function getCurrentAnimatorState(layerIndex) {
    var _this$_animatorLayers, _this$_animatorLayers2;
    return (_this$_animatorLayers = this._animatorLayersData[layerIndex]) === null || _this$_animatorLayers === void 0 ? void 0 : (_this$_animatorLayers2 = _this$_animatorLayers.srcPlayData) === null || _this$_animatorLayers2 === void 0 ? void 0 : _this$_animatorLayers2.state;
  }

  /**
   * @override
   * @internal
   */;
  _proto._onEnable = function _onEnable() {
    this.engine._componentsManager.addOnUpdateAnimations(this);
  }

  /**
   * @override
   * @internal
   */;
  _proto._onDisable = function _onDisable() {
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };
  _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex, out) {
    var state = null;
    var animatorController = this._animatorController;
    if (animatorController) {
      var layers = animatorController.layers;
      if (layerIndex === -1) {
        for (var i = 0, n = layers.length; i < n; i++) {
          state = layers[i].stateMachine.findStateByName(stateName);
          if (state) {
            layerIndex = i;
            break;
          }
        }
      } else {
        state = layers[layerIndex].stateMachine.findStateByName(stateName);
      }
    }
    out.layerIndex = layerIndex;
    out.state = state;
    return out;
  };
  _proto._saveDefaultValues = function _saveDefaultValues(stateData) {
    var curveOwners = stateData.curveOwners;
    for (var i = curveOwners.length - 1; i >= 0; i--) {
      curveOwners[i].saveDefaultValue();
    }
  };
  _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData) {
    var animatorStateDataCollection = animatorLayerData.animatorStateDataMap;
    var animatorStateData = animatorStateDataCollection[stateName];
    if (!animatorStateData) {
      animatorStateData = new AnimatorStateData();
      animatorStateDataCollection[stateName] = animatorStateData;
      this._saveAnimatorStateData(animatorState, animatorStateData);
      this._saveAnimatorEventHandlers(animatorState, animatorStateData);
    }
    return animatorStateData;
  };
  _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData) {
    var entity = this.entity,
      animationCureOwners = this._animationCurveOwners;
    var curveOwners = animatorStateData.curveOwners;
    var curves = animatorState.clip._curveBindings;
    for (var i = curves.length - 1; i >= 0; i--) {
      var curve = curves[i];
      var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
      var property = curve.property;
      var _targetEntity = targetEntity,
        instanceId = _targetEntity.instanceId;
      var propertyOwners = animationCureOwners[instanceId] || (animationCureOwners[instanceId] = []);
      curveOwners[i] = propertyOwners[property] || (propertyOwners[property] = new AnimationCurveOwner(targetEntity, curve.type, property));
    }
  };
  _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
    var eventHandlerPool = this._animationEventHandlerPool;
    var scripts = this._entity._scripts;
    var scriptCount = scripts.length;
    var eventHandlers = animatorStateData.eventHandlers;
    var events = state.clip.events;
    eventHandlers.length = 0;
    for (var i = 0, n = events.length; i < n; i++) {
      var event = events[i];
      var eventHandler = eventHandlerPool.getFromPool();
      var funcName = event.functionName;
      var handlers = eventHandler.handlers;
      eventHandler.event = event;
      handlers.length = 0;
      for (var j = scriptCount - 1; j >= 0; j--) {
        var handler = scripts.get(j)[funcName];
        handler && handlers.push(handler);
      }
      eventHandlers.push(eventHandler);
    }
  };
  _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
    animatorLayerData.crossCurveMark++;
    this._crossCurveDataCollection.length = 0;
    this._crossCurveDataPool.resetPool();
  };
  _proto._addCrossCurveData = function _addCrossCurveData(crossCurveData, owner, curCurveIndex, nextCurveIndex) {
    var dataItem = this._crossCurveDataPool.getFromPool();
    dataItem.curveOwner = owner;
    dataItem.srcCurveIndex = curCurveIndex;
    dataItem.destCurveIndex = nextCurveIndex;
    crossCurveData.push(dataItem);
  };
  _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    var crossCurveMark = animatorLayerData.crossCurveMark;

    // Add src cross curve data.
    this._prepareSrcCrossData(crossCurveData, animatorLayerData.srcPlayData, crossCurveMark, false);
    // Add dest cross curve data.
    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, false);
  };
  _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    var srcPlayData = animatorLayerData.srcPlayData,
      crossCurveMark = animatorLayerData.crossCurveMark;

    // Standby have two sub state, one is never play, one is finished, never play srcPlayData.state is null.
    srcPlayData.state && this._prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, true);
    // Add dest cross curve data.
    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, true);
  };
  _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;

    // Save current cross curve data owner fixed pose.
    for (var i = crossCurveData.length - 1; i >= 0; i--) {
      var item = crossCurveData[i];
      item.curveOwner.saveFixedPoseValue();
      // Reset destCurveIndex When fixed pose crossFading again.
      item.destCurveIndex = -1;
    }
    // prepare dest AnimatorState cross data.
    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, animatorLayerData.crossCurveMark, true);
  };
  _proto._prepareSrcCrossData = function _prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, saveFixed) {
    var curveOwners = srcPlayData.stateData.curveOwners;
    for (var i = curveOwners.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      owner.crossCurveMark = crossCurveMark;
      owner.crossCurveIndex = crossCurveData.length;
      saveFixed && owner.saveFixedPoseValue();
      this._addCrossCurveData(crossCurveData, owner, i, -1);
    }
  };
  _proto._prepareDestCrossData = function _prepareDestCrossData(crossCurveData, destPlayData, crossCurveMark, saveFixed) {
    var curveOwners = destPlayData.stateData.curveOwners;
    for (var i = curveOwners.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      // Not include in previous AnimatorState.
      if (owner.crossCurveMark === crossCurveMark) {
        crossCurveData[owner.crossCurveIndex].destCurveIndex = i;
      } else {
        owner.saveDefaultValue();
        saveFixed && owner.saveFixedPoseValue();
        owner.crossCurveMark = crossCurveMark;
        owner.crossCurveIndex = crossCurveData.length;
        this._addCrossCurveData(crossCurveData, owner, -1, i);
      }
    }
  };
  _proto._evaluateCurve = function _evaluateCurve(property, curve, time, additive, tempValue) {
    var baseValue;
    if (additive) {
      baseValue = curve.keys[0].value;
    }
    switch (curve._valueType) {
      case InterpolableValueType.Float:
        {
          var value = curve.evaluate(time);
          if (additive) {
            return value - baseValue;
          }
          return value;
        }
      case InterpolableValueType.FloatArray:
        {
          var _value = tempValue.getFloatArray(curve._valueSize);
          curve._evaluate(time, _value);
          if (additive) {
            for (var i = 0, n = _value.length; i < n; i++) {
              _value[i] = _value[i] - baseValue[i];
            }
          }
          return _value;
        }
      case InterpolableValueType.Vector2:
        {
          var _value2 = tempValue.vector2;
          curve._evaluate(time, _value2);
          if (additive) {
            if (property === AnimationProperty.Scale) {
              Vector2.divide(_value2, baseValue, _value2);
            } else {
              Vector2.subtract(_value2, baseValue, _value2);
            }
          }
          return _value2;
        }
      case InterpolableValueType.Vector3:
        {
          var _value3 = tempValue.vector3;
          curve._evaluate(time, _value3);
          if (additive) {
            if (property === AnimationProperty.Scale) {
              Vector3.divide(_value3, baseValue, _value3);
            } else {
              Vector3.subtract(_value3, baseValue, _value3);
            }
          }
          return _value3;
        }
      case InterpolableValueType.Vector4:
        {
          var _value4 = tempValue.vector4;
          curve._evaluate(time, _value4);
          if (additive) {
            Vector4.subtract(_value4, baseValue, _value4);
          }
          return _value4;
        }
      case InterpolableValueType.Quaternion:
        {
          var _value5 = tempValue.quaternion;
          curve._evaluate(time, _value5);
          if (additive) {
            var tempQuat = Animator._tempQuat;
            Quaternion.conjugate(baseValue, tempQuat);
            Quaternion.multiply(tempQuat, _value5, _value5);
          }
          return _value5;
        }
    }
  };
  _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
    var animatorLayerData = this._animatorLayersData[layerIndex];
    animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());
    return animatorLayerData;
  };
  _proto._updateLayer = function _updateLayer(layerIndex, firstLayer, deltaTime) {
    var _this$_animatorContro = this._animatorController.layers[layerIndex],
      blendingMode = _this$_animatorContro.blendingMode,
      weight = _this$_animatorContro.weight;
    var animLayerData = this._animatorLayersData[layerIndex];
    var srcPlayData = animLayerData.srcPlayData,
      destPlayData = animLayerData.destPlayData,
      crossFadeTransitionInfo = animLayerData.crossFadeTransition;
    var layerAdditive = blendingMode === AnimatorLayerBlendingMode.Additive;
    var layerWeight = firstLayer ? 1.0 : weight;
    //TODO: 任意情况都应该检查，后面要优化
    animLayerData.layerState !== LayerState.FixedCrossFading && this._checkTransition(srcPlayData, crossFadeTransitionInfo, layerIndex);
    switch (animLayerData.layerState) {
      case LayerState.Playing:
        this._updatePlayingState(srcPlayData, animLayerData, layerIndex, layerWeight, deltaTime, layerAdditive);
        break;
      case LayerState.FixedCrossFading:
        this._updateCrossFadeFromPose(destPlayData, animLayerData, layerIndex, layerWeight, deltaTime, layerAdditive);
        break;
      case LayerState.CrossFading:
        this._updateCrossFade(srcPlayData, destPlayData, animLayerData, layerIndex, layerWeight, deltaTime, layerAdditive);
        break;
    }
  };
  _proto._updatePlayingState = function _updatePlayingState(playData, layerData, layerIndex, weight, delta, additive) {
    var _playData$stateData = playData.stateData,
      curveOwners = _playData$stateData.curveOwners,
      eventHandlers = _playData$stateData.eventHandlers;
    var state = playData.state,
      lastPlayState = playData.playState,
      lastClipTime = playData.clipTime;
    var curves = state.clip._curveBindings;
    playData.update(this.speed < 0);
    var clipTime = playData.clipTime,
      playState = playData.playState;
    eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
    for (var i = curves.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      var value = this._evaluateCurve(owner.property, curves[i].curve, clipTime, additive, this._baseTempValue);
      if (additive) {
        this._applyClipValueAdditive(owner, value, weight);
      } else {
        this._applyClipValue(owner, value, weight);
      }
    }
    playData.frameTime += state.speed * delta;
    if (playState === AnimatorStatePlayState.Finished) {
      layerData.layerState = LayerState.Standby;
    }
    if (lastPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(state, layerIndex);
    }
    if (playState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(state, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(state, layerIndex);
    }
  };
  _proto._updateCrossFade = function _updateCrossFade(srcPlayData, destPlayData, layerData, layerIndex, weight, delta, additive) {
    var crossCurveDataCollection = this._crossCurveDataCollection;
    var srcCurves = srcPlayData.state.clip._curveBindings;
    var srcState = srcPlayData.state,
      srcStateData = srcPlayData.stateData,
      lastSrcPlayState = srcPlayData.playState;
    var srcEventHandler = srcStateData.eventHandlers;
    var destState = destPlayData.state,
      destStateData = destPlayData.stateData,
      lastDstPlayState = destPlayData.playState;
    var destEventHandler = destStateData.eventHandlers;
    var destCurves = destState.clip._curveBindings;
    var lastSrcClipTime = srcPlayData.clipTime;
    var lastDestClipTime = destPlayData.clipTime;
    var crossWeight = Math.abs(destPlayData.frameTime) / (destState._getDuration() * layerData.crossFadeTransition.duration);
    crossWeight >= 1.0 && (crossWeight = 1.0);
    srcPlayData.update(this.speed < 0);
    destPlayData.update(this.speed < 0);
    var srcPlayState = srcPlayData.playState;
    var destPlayState = destPlayData.playState;
    this._updateCrossFadeData(layerData, crossWeight, delta, false);
    var srcClipTime = srcPlayData.clipTime;
    var destClipTime = destPlayData.clipTime;
    srcEventHandler.length && this._fireAnimationEvents(srcPlayData, srcEventHandler, lastSrcClipTime, srcClipTime);
    destEventHandler.length && this._fireAnimationEvents(destPlayData, destEventHandler, lastDestClipTime, destClipTime);
    if (lastSrcPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(srcState, layerIndex);
    }
    if (crossWeight === 1 || srcPlayState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(srcState, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(srcState, layerIndex);
    }
    if (lastDstPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(destState, layerIndex);
    }
    if (destPlayState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(destState, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(destState, layerIndex);
    }
    for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
      var _crossCurveDataCollec = crossCurveDataCollection[i],
        curveOwner = _crossCurveDataCollec.curveOwner,
        srcCurveIndex = _crossCurveDataCollec.srcCurveIndex,
        destCurveIndex = _crossCurveDataCollec.destCurveIndex;
      var property = curveOwner.property,
        defaultValue = curveOwner.defaultValue;
      var srcValue = srcCurveIndex >= 0 ? this._evaluateCurve(property, srcCurves[srcCurveIndex].curve, srcClipTime, additive, this._baseTempValue) : defaultValue;
      var destValue = destCurveIndex >= 0 ? this._evaluateCurve(property, destCurves[destCurveIndex].curve, destClipTime, additive, this._crossTempValue) : defaultValue;
      this._applyCrossClipValue(curveOwner, srcValue, destValue, crossWeight, weight, additive);
    }
  };
  _proto._updateCrossFadeFromPose = function _updateCrossFadeFromPose(destPlayData, layerData, layerIndex, weight, delta, additive) {
    var crossCurveDataCollection = this._crossCurveDataCollection;
    var state = destPlayData.state,
      stateData = destPlayData.stateData,
      lastPlayState = destPlayData.playState;
    var eventHandlers = stateData.eventHandlers;
    var curves = state.clip._curveBindings;
    var lastDestClipTime = destPlayData.clipTime;
    var crossWeight = Math.abs(destPlayData.frameTime) / (state._getDuration() * layerData.crossFadeTransition.duration);
    crossWeight >= 1.0 && (crossWeight = 1.0);
    destPlayData.update(this.speed < 0);
    var playState = destPlayData.playState;
    this._updateCrossFadeData(layerData, crossWeight, delta, true);
    var destClipTime = destPlayData.clipTime;
    //TODO: srcState 少了最新一段时间的判断
    eventHandlers.length && this._fireAnimationEvents(destPlayData, eventHandlers, lastDestClipTime, destClipTime);
    if (lastPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(state, layerIndex);
    }
    if (playState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(state, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(state, layerIndex);
    }
    for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
      var _crossCurveDataCollec2 = crossCurveDataCollection[i],
        curveOwner = _crossCurveDataCollec2.curveOwner,
        destCurveIndex = _crossCurveDataCollec2.destCurveIndex;
      var destValue = destCurveIndex >= 0 ? this._evaluateCurve(curveOwner.property, curves[destCurveIndex].curve, destClipTime, additive, this._crossTempValue) : curveOwner.defaultValue;
      this._applyCrossClipValue(curveOwner, curveOwner.fixedPoseValue, destValue, crossWeight, weight, additive);
    }
  };
  _proto._updateCrossFadeData = function _updateCrossFadeData(layerData, crossWeight, delta, fixed) {
    var destPlayData = layerData.destPlayData;
    destPlayData.frameTime += destPlayData.state.speed * delta;
    if (crossWeight === 1.0) {
      if (destPlayData.playState === AnimatorStatePlayState.Finished) {
        layerData.layerState = LayerState.Standby;
      } else {
        layerData.layerState = LayerState.Playing;
      }
      layerData.switchPlayData();
    } else {
      fixed || (layerData.srcPlayData.frameTime += layerData.srcPlayData.state.speed * delta);
    }
  };
  _proto._applyCrossClipValue = function _applyCrossClipValue(owner, srcValue, destValue, crossWeight, layerWeight, additive) {
    var value;
    if (owner.type === Transform) {
      switch (owner.property) {
        case AnimationProperty.Position:
          value = this._baseTempValue.vector3;
          Vector3.lerp(srcValue, destValue, crossWeight, value);
          break;
        case AnimationProperty.Rotation:
          value = this._baseTempValue.quaternion;
          Quaternion.slerp(srcValue, destValue, crossWeight, value);
          break;
        case AnimationProperty.Scale:
          {
            value = this._baseTempValue.vector3;
            Vector3.lerp(srcValue, destValue, crossWeight, value);
            break;
          }
      }
    } else if (owner.type === SkinnedMeshRenderer) {
      switch (owner.property) {
        case AnimationProperty.BlendShapeWeights:
          value = this._baseTempValue.getFloatArray(srcValue.length);
          for (var i = 0, length = value.length; i < length; ++i) {
            value[i] = srcValue[i] + (destValue[i] - srcValue[i]) * crossWeight;
          }
          break;
      }
    }
    if (additive) {
      this._applyClipValueAdditive(owner, value, layerWeight);
    } else {
      this._applyClipValue(owner, value, layerWeight);
    }
  };
  _proto._applyClipValue = function _applyClipValue(owner, value, weight) {
    if (owner.type === Transform) {
      var transform = owner.target.transform;
      switch (owner.property) {
        case AnimationProperty.Position:
          if (weight === 1.0) {
            transform.position = value;
          } else {
            var position = transform.position;
            Vector3.lerp(position, value, weight, position);
          }
          break;
        case AnimationProperty.Rotation:
          if (weight === 1.0) {
            transform.rotationQuaternion = value;
          } else {
            var rotationQuaternion = transform.rotationQuaternion;
            Quaternion.slerp(rotationQuaternion, value, weight, rotationQuaternion);
          }
          break;
        case AnimationProperty.Scale:
          if (weight === 1.0) {
            transform.scale = value;
          } else {
            var scale = transform.scale;
            Vector3.lerp(scale, value, weight, scale);
          }
          break;
      }
    } else if (owner.type === SkinnedMeshRenderer) {
      switch (owner.property) {
        case AnimationProperty.BlendShapeWeights:
          if (weight === 1.0) {
            owner.component.blendShapeWeights = value;
          } else {
            var _ref = owner.component,
              blendShapeWeights = _ref.blendShapeWeights;
            for (var i = 0, length = blendShapeWeights.length; i < length; ++i) {
              blendShapeWeights[i] += (value[i] - blendShapeWeights[i]) * weight;
            }
          }
          break;
      }
    }
  };
  _proto._applyClipValueAdditive = function _applyClipValueAdditive(owner, additiveValue, weight) {
    if (owner.type === Transform) {
      var transform = owner.target.transform;
      switch (owner.property) {
        case AnimationProperty.Position:
          var position = transform.position;
          position.x += additiveValue.x * weight;
          position.y += additiveValue.y * weight;
          position.z += additiveValue.z * weight;
          transform.position = position;
          break;
        case AnimationProperty.Rotation:
          var rotationQuaternion = transform.rotationQuaternion;
          AnimatorUtils.quaternionWeight(additiveValue, weight, additiveValue);
          additiveValue.normalize();
          rotationQuaternion.multiply(additiveValue);
          transform.rotationQuaternion = rotationQuaternion;
          break;
        case AnimationProperty.Scale:
          var scale = transform.scale;
          AnimatorUtils.scaleWeight(scale, weight, scale);
          Vector3.multiply(scale, additiveValue, scale);
          transform.scale = scale;
          break;
        case AnimationProperty.BlendShapeWeights:
          var _ref2 = owner.component,
            blendShapeWeights = _ref2.blendShapeWeights;
          for (var i = 0, length = blendShapeWeights.length; i < length; ++i) {
            owner.component.blendShapeWeights[i] += additiveValue[i] * weight;
          }
          break;
      }
    }
  };
  _proto._revertDefaultValue = function _revertDefaultValue(state, stateData) {
    var clip = state.clip;
    if (clip) {
      var curves = clip._curveBindings;
      var curveOwners = stateData.curveOwners;
      for (var i = curves.length - 1; i >= 0; i--) {
        var owner = curveOwners[i];
        var transform = owner.target.transform;
        if (!owner._hasSavedDefaultValue) continue;
        switch (owner.property) {
          case AnimationProperty.Position:
            transform.position = owner.defaultValue;
            break;
          case AnimationProperty.Rotation:
            transform.rotationQuaternion = owner.defaultValue;
            break;
          case AnimationProperty.Scale:
            transform.scale = owner.defaultValue;
            break;
          case AnimationProperty.BlendShapeWeights:
            var _ref3 = owner.component,
              blendShapeWeights = _ref3.blendShapeWeights;
            for (var j = 0, length = blendShapeWeights.length; j < length; ++j) {
              owner.component.blendShapeWeights[j] = owner.defaultValue[j];
            }
            break;
        }
      }
    }
  };
  _proto._checkTransition = function _checkTransition(stateData, crossFadeTransition, layerIndex) {
    var state = stateData.state,
      clipTime = stateData.clipTime;
    var duration = state._getDuration();
    var transitions = state.transitions;
    for (var i = 0, n = transitions.length; i < n; ++i) {
      var transition = transitions[i];
      if (duration * transition.exitTime <= clipTime) {
        crossFadeTransition !== transition && this._crossFadeByTransition(transition, layerIndex);
      }
    }
  };
  _proto._crossFadeByTransition = function _crossFadeByTransition(transition, layerIndex) {
    var name = transition.destinationState.name;
    var animatorStateInfo = this._getAnimatorStateInfo(name, layerIndex, Animator._animatorInfo);
    var crossState = animatorStateInfo.state;
    if (!crossState) {
      return;
    }
    if (!crossState.clip) {
      console.warn("The state named " + name + " has no AnimationClip data.");
      return;
    }
    var animatorLayerData = this._getAnimatorLayerData(animatorStateInfo.layerIndex);
    var layerState = animatorLayerData.layerState;
    var destPlayData = animatorLayerData.destPlayData;
    var animatorStateData = this._getAnimatorStateData(name, crossState, animatorLayerData);
    var duration = crossState._getDuration();
    var offset = duration * transition.offset;
    destPlayData.reset(crossState, animatorStateData, offset);
    switch (layerState) {
      // Maybe not play, maybe end.
      case LayerState.Standby:
        animatorLayerData.layerState = LayerState.FixedCrossFading;
        this._clearCrossData(animatorLayerData);
        this._prepareStandbyCrossFading(animatorLayerData);
        break;
      case LayerState.Playing:
        animatorLayerData.layerState = LayerState.CrossFading;
        this._clearCrossData(animatorLayerData);
        this._prepareCrossFading(animatorLayerData);
        break;
      case LayerState.CrossFading:
        animatorLayerData.layerState = LayerState.FixedCrossFading;
        this._prepareFixedPoseCrossFading(animatorLayerData);
        break;
      case LayerState.FixedCrossFading:
        this._prepareFixedPoseCrossFading(animatorLayerData);
        break;
    }
    animatorLayerData.crossFadeTransition = transition;
  };
  _proto._fireAnimationEvents = function _fireAnimationEvents(playState, eventHandlers, lastClipTime, clipTime) {
    var state = playState.state;
    var clipDuration = state.clip.length;
    if (this.speed >= 0) {
      if (clipTime < lastClipTime) {
        this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipEndTime * clipDuration);
        playState.currentEventIndex = 0;
        this._fireSubAnimationEvents(playState, eventHandlers, state.clipStartTime * clipDuration, clipTime);
      } else {
        this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
      }
    } else {
      if (clipTime > lastClipTime) {
        this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipStartTime * clipDuration);
        playState.currentEventIndex = eventHandlers.length - 1;
        this._fireBackwardSubAnimationEvents(playState, eventHandlers, state.clipEndTime * clipDuration, clipTime);
      } else {
        this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
      }
    }
  };
  _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
    var eventIndex = playState.currentEventIndex;
    for (var n = eventHandlers.length; eventIndex < n; eventIndex++) {
      var eventHandler = eventHandlers[eventIndex];
      var _eventHandler$event = eventHandler.event,
        time = _eventHandler$event.time,
        parameter = _eventHandler$event.parameter;
      if (time > curClipTime) {
        break;
      }
      var _eventHandler = eventHandler,
        handlers = _eventHandler.handlers;
      if (time >= lastClipTime) {
        for (var j = handlers.length - 1; j >= 0; j--) {
          handlers[j](parameter);
        }
        playState.currentEventIndex = Math.min(eventIndex + 1, n - 1);
      }
    }
  };
  _proto._fireBackwardSubAnimationEvents = function _fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
    var eventIndex = playState.currentEventIndex;
    for (; eventIndex >= 0; eventIndex--) {
      var eventHandler = eventHandlers[eventIndex];
      var _eventHandler$event2 = eventHandler.event,
        time = _eventHandler$event2.time,
        parameter = _eventHandler$event2.parameter;
      if (time < curClipTime) {
        break;
      }
      var _eventHandler2 = eventHandler,
        handlers = _eventHandler2.handlers;
      if (time <= lastClipTime) {
        for (var j = handlers.length - 1; j >= 0; j--) {
          handlers[j](parameter);
        }
        playState.currentEventIndex = Math.max(eventIndex - 1, 0);
      }
    }
  };
  _proto._callAnimatorScriptOnEnter = function _callAnimatorScriptOnEnter(state, layerIndex) {
    var scripts = state._onStateEnterScripts;
    for (var i = 0, n = scripts.length; i < n; i++) {
      scripts[i].onStateEnter(this, state, layerIndex);
    }
  };
  _proto._callAnimatorScriptOnUpdate = function _callAnimatorScriptOnUpdate(state, layerIndex) {
    var scripts = state._onStateUpdateScripts;
    for (var i = 0, n = scripts.length; i < n; i++) {
      scripts[i].onStateUpdate(this, state, layerIndex);
    }
  };
  _proto._callAnimatorScriptOnExit = function _callAnimatorScriptOnExit(state, layerIndex) {
    var scripts = state._onStateExitScripts;
    for (var i = 0, n = scripts.length; i < n; i++) {
      scripts[i].onStateExit(this, state, layerIndex);
    }
  };
  _proto._clearPlayData = function _clearPlayData() {
    this._animatorLayersData.length = 0;
    this._crossCurveDataCollection.length = 0;
    this._animationCurveOwners.length = 0;
    this._animationEventHandlerPool.resetPool();
    if (this._controllerUpdateFlag) {
      this._controllerUpdateFlag.flag = false;
    }
  };
  _createClass(Animator, [{
    key: "speed",
    get:
    /**
     * The playback speed of the Animator, 1.0 is normal playback speed.
     */
    function get() {
      return this._speed;
    },
    set: function set(value) {
      this._speed = value;
    }

    /**
     * All layers from the AnimatorController which belongs this Animator.
     */
  }, {
    key: "animatorController",
    get: function get() {
      return this._animatorController;
    },
    set: function set(animatorController) {
      if (animatorController !== this._animatorController) {
        this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
        this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
        this._animatorController = animatorController;
      }
    }
  }]);
  return Animator;
}(Component), _class2._tempQuat = new Quaternion(), _class2._animatorInfo = new AnimatorStateInfo(), _class2), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "_speed", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1.0;
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "_controllerUpdateFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "_animatorLayersData", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "_crossCurveDataCollection", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "_animationCurveOwners", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "_crossCurveDataPool", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ClassPool(CrossCurveData);
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, "_animationEventHandlerPool", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ClassPool(AnimationEventHandler);
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, "_baseTempValue", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new AnimatorTempValue();
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, "_crossTempValue", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new AnimatorTempValue();
  }
})), _class);

/**
 * Store the data for Animator playback.
 */
var AnimatorController = /*#__PURE__*/function () {
  function AnimatorController() {
    this._updateFlagManager = new UpdateFlagManager();
    this._layers = [];
    this._layersMap = {};
  }
  var _proto = AnimatorController.prototype;
  /**
   * Get the layer by name.
   * @param name - The layer's name.
   */
  _proto.findLayerByName = function findLayerByName(name) {
    return this._layersMap[name];
  }

  /**
   * Add a layer to the controller.
   * @param layer - The layer to add
   */;
  _proto.addLayer = function addLayer(layer) {
    this._layers.push(layer);
    this._layersMap[layer.name] = layer;
    this._distributeUpdateFlag();
  }

  /**
   * Remove a layer from the controller.
   * @param layerIndex - The index of the AnimatorLayer
   */;
  _proto.removeLayer = function removeLayer(layerIndex) {
    var theLayer = this.layers[layerIndex];
    this._layers.splice(layerIndex, 1);
    delete this._layersMap[theLayer.name];
    this._distributeUpdateFlag();
  }

  /**
   * Clear layers.
   */;
  _proto.clearLayers = function clearLayers() {
    this._layers.length = 0;
    for (var name in this._layersMap) {
      delete this._layersMap[name];
    }
    this._distributeUpdateFlag();
  }

  /**
   * @internal
   */;
  _proto._registerChangeFlag = function _registerChangeFlag() {
    return this._updateFlagManager.createFlag(BoolUpdateFlag);
  };
  _proto._distributeUpdateFlag = function _distributeUpdateFlag() {
    this._updateFlagManager.dispatch();
  };
  _createClass(AnimatorController, [{
    key: "layers",
    get:
    /**
     * The layers in the controller.
     */
    function get() {
      return this._layers;
    }
  }]);
  return AnimatorController;
}();

/**
 * The Animation Layer contains a state machine that controls animations of a model or part of it.
 */
var AnimatorControllerLayer = /** The blending weight that the layers has. It is not taken into account for the first layer. */

/** The blending mode used by the layer. It is not taken into account for the first layer. */

/** The state machine for the layer. */

/**
 * @param name - The layer's name
 */
function AnimatorControllerLayer(name) {
  this.name = name;
  this.weight = 1.0;
  this.blendingMode = AnimatorLayerBlendingMode.Override;
  this.stateMachine = void 0;
};

/**
 * StateMachineScript is a component that can be added to a animator state. It's the base class every script on a state derives from.
 */
var StateMachineScript = /*#__PURE__*/function () {
  function StateMachineScript() {
    this._destroyed = false;
    this._state = void 0;
  }
  var _proto = StateMachineScript.prototype;
  /**
   * onStateEnter is called when a transition starts and the state machine starts to evaluate this state.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */
  _proto.onStateEnter = function onStateEnter(animator, animatorState, layerIndex) {}

  /**
   * onStateUpdate is called on each Update frame between onStateEnter and onStateExit callbacks.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */;
  _proto.onStateUpdate = function onStateUpdate(animator, animatorState, layerIndex) {}

  /**
   * onStateExit is called when a transition ends and the state machine finishes evaluating this state.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */;
  _proto.onStateExit = function onStateExit(animator, animatorState, layerIndex) {}

  /**
   * Destroy this instance.
   */;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._state._removeStateMachineScript(this);
    this._destroyed = true;
  };
  return StateMachineScript;
}();

/**
 * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.
 */
var AnimatorState = /*#__PURE__*/function () {
  /**
   * @param name - The state's name
   */
  function AnimatorState(name) {
    this.name = name;
    this.speed = 1.0;
    this.wrapMode = WrapMode.Loop;
    this._onStateEnterScripts = [];
    this._onStateUpdateScripts = [];
    this._onStateExitScripts = [];
    this._clipStartTime = 0;
    this._clipEndTime = 1;
    this._clip = void 0;
    this._transitions = [];
  }

  /**
   * Add an outgoing transition to the destination state.
   * @param transition - The transition
   */
  var _proto = AnimatorState.prototype;
  _proto.addTransition = function addTransition(transition) {
    this._transitions.push(transition);
  }

  /**
   * Remove a transition from the state.
   * @param transition - The transition
   */;
  _proto.removeTransition = function removeTransition(transition) {
    var index = this._transitions.indexOf(transition);
    index !== -1 && this._transitions.splice(index, 1);
  }

  /**
   * Adds a state machine script class of type T to the AnimatorState.
   * @param scriptType - The state machine script class of type T
   */;
  _proto.addStateMachineScript = function addStateMachineScript(scriptType) {
    var script = new scriptType();
    script._state = this;
    var prototype = StateMachineScript.prototype;
    if (script.onStateEnter !== prototype.onStateEnter) {
      this._onStateEnterScripts.push(script);
    }
    if (script.onStateUpdate !== prototype.onStateUpdate) {
      this._onStateUpdateScripts.push(script);
    }
    if (script.onStateExit !== prototype.onStateExit) {
      this._onStateExitScripts.push(script);
    }
    return script;
  }

  /**
   * Clears all transitions from the state.
   */;
  _proto.clearTransitions = function clearTransitions() {
    this._transitions.length = 0;
  }

  /**
   * @internal
   */;
  _proto._getDuration = function _getDuration() {
    if (this.clip) {
      return (this._clipEndTime - this._clipStartTime) * this.clip.length;
    }
    return null;
  }

  /**
   * @internal
   */;
  _proto._removeStateMachineScript = function _removeStateMachineScript(script) {
    var prototype = StateMachineScript.prototype;
    if (script.onStateEnter !== prototype.onStateEnter) {
      var index = this._onStateEnterScripts.indexOf(script);
      index !== -1 && this._onStateEnterScripts.splice(index, 1);
    }
    if (script.onStateUpdate !== prototype.onStateUpdate) {
      var _index = this._onStateUpdateScripts.indexOf(script);
      _index !== -1 && this._onStateUpdateScripts.splice(_index, 1);
    }
    if (script.onStateExit !== prototype.onStateExit) {
      var _index2 = this._onStateExitScripts.indexOf(script);
      _index2 !== -1 && this._onStateExitScripts.splice(_index2, 1);
    }
  };
  _createClass(AnimatorState, [{
    key: "transitions",
    get: /** The speed of the clip. 1 is normal speed, default 1. */

    /** The wrap mode used in the state. */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * The transitions that are going out of the state.
     */
    function get() {
      return this._transitions;
    }

    /**
     * The clip that is being played by this animator state.
     */
  }, {
    key: "clip",
    get: function get() {
      return this._clip;
    },
    set: function set(clip) {
      this._clip = clip;
      this._clipEndTime = Math.min(this._clipEndTime, 1);
    }

    /**
     * The start time of the clip, the range is 0 to 1, default is 0.
     */
  }, {
    key: "clipStartTime",
    get: function get() {
      return this._clipStartTime;
    },
    set: function set(time) {
      this._clipStartTime = Math.max(time, 0);
    }

    /**
     * The end time of the clip, the range is 0 to 1, default is 1.
     */
  }, {
    key: "clipEndTime",
    get: function get() {
      return this._clipEndTime;
    },
    set: function set(time) {
      this._clipEndTime = Math.min(time, 1);
    }
  }]);
  return AnimatorState;
}();

/**
 * A graph controlling the interaction of states. Each state references a motion.
 */
var AnimatorStateMachine = /*#__PURE__*/function () {
  function AnimatorStateMachine() {
    this.states = [];
    this._statesMap = {};
  }
  var _proto = AnimatorStateMachine.prototype;
  /**
   * Add a state to the state machine.
   * @param name - The name of the new state
   */
  _proto.addState = function addState(name) {
    var state = this.findStateByName(name);
    if (!state) {
      state = new AnimatorState(name);
      this.states.push(state);
      this._statesMap[name] = state;
    } else {
      console.warn("The state named " + name + " has existed.");
    }
    return state;
  }

  /**
   * Remove a state from the state machine.
   * @param state - The state
   */;
  _proto.removeState = function removeState(state) {
    var name = state.name;
    var index = this.states.indexOf(state);
    if (index > -1) {
      this.states.splice(index, 1);
    }
    delete this._statesMap[name];
  }

  /**
   * Get the state by name.
   * @param name - The layer's name
   */;
  _proto.findStateByName = function findStateByName(name) {
    return this._statesMap[name];
  }

  /**
   * Makes a unique state name in the state machine.
   * @param name - Desired name for the state.
   * @returns Unique name.
   */;
  _proto.makeUniqueStateName = function makeUniqueStateName(name) {
    var _statesMap = this._statesMap;
    var originName = name;
    var index = 0;
    while (_statesMap[name]) {
      name = originName + " " + index;
      index++;
    }
    return name;
  };
  return AnimatorStateMachine;
}();

/**
 * Animation interpolation method.
 */
var InterpolationType;
(function (InterpolationType) {
  InterpolationType[InterpolationType["Linear"] = 0] = "Linear";
  InterpolationType[InterpolationType["CubicSpine"] = 1] = "CubicSpine";
  InterpolationType[InterpolationType["Step"] = 2] = "Step";
  InterpolationType[InterpolationType["Hermite"] = 3] = "Hermite";
})(InterpolationType || (InterpolationType = {}));

/**
 * Store a collection of Keyframes that can be evaluated over time.
 */
var AnimationCurve = /*#__PURE__*/function () {
  function AnimationCurve() {
    this.keys = [];
    this.interpolation = void 0;
    this._valueSize = void 0;
    this._valueType = void 0;
    this._tempValue = void 0;
    this._length = 0;
    this._currentIndex = 0;
  }
  var _proto = AnimationCurve.prototype;
  /**
   * Add a new key to the curve.
   * @param key - The keyframe
   */
  _proto.addKey = function addKey(key) {
    var time = key.time;
    this.keys.push(key);
    if (time > this._length) {
      this._length = time;
    }
    if (!this._valueSize) {
      if (typeof key.value == "number") {
        this._valueSize = 1;
        this._valueType = InterpolableValueType.Float;
        this._tempValue = 0;
      }
      if (key.value instanceof Vector2) {
        this._valueSize = 2;
        this._valueType = InterpolableValueType.Vector2;
        this._tempValue = new Vector2();
      }
      if (key.value instanceof Vector3) {
        this._valueSize = 3;
        this._valueType = InterpolableValueType.Vector3;
        this._tempValue = new Vector3();
      }
      if (key.value instanceof Vector4) {
        this._valueSize = 4;
        this._valueType = InterpolableValueType.Vector4;
        this._tempValue = new Vector4();
      }
      if (key.value instanceof Quaternion) {
        this._valueSize = 4;
        this._valueType = InterpolableValueType.Quaternion;
        this._tempValue = new Quaternion();
      }
      if (key.value instanceof Float32Array) {
        var size = key.value.length;
        this._valueSize = size;
        this._valueType = InterpolableValueType.FloatArray;
        this._tempValue = new Float32Array(size);
      }
    }
    this.keys.sort(function (a, b) {
      return a.time - b.time;
    });
  }

  /**
   * Evaluate the curve at time.
   * @param time - The time within the curve you want to evaluate
   */;
  _proto.evaluate = function evaluate(time) {
    return this._evaluate(time, this._tempValue);
  }

  /**
   * Removes the keyframe at index and inserts key.
   * @param index - The index of the key to move
   * @param key - The key to insert
   */;
  _proto.moveKey = function moveKey(index, key) {
    this.keys[index] = key;
  }

  /**
   * Removes a key.
   * @param index - The index of the key to remove
   */;
  _proto.removeKey = function removeKey(index) {
    this.keys.splice(index, 1);
    var keys = this.keys;
    var count = this.keys.length;
    var newLength = 0;
    for (var i = count - 1; i >= 0; i--) {
      if (keys[i].time > length) {
        newLength = keys[i].time;
      }
    }
    this._length = newLength;
  }

  /**
   * @internal
   * Samples an animation at a given time.
   * @param time - The time to sample an animation
   * @param out - The value calculated
   */;
  _proto._evaluate = function _evaluate(time, out) {
    var keys = this.keys,
      interpolation = this.interpolation;
      this._valueType;
    var length = this.keys.length;

    // Compute curIndex and nextIndex.
    var curIndex = this._currentIndex;

    // Reset loop.
    if (curIndex !== -1 && time < keys[curIndex].time) {
      curIndex = -1;
    }
    var nextIndex = curIndex + 1;
    while (nextIndex < length) {
      if (time < keys[nextIndex].time) {
        break;
      }
      curIndex++;
      nextIndex++;
    }
    this._currentIndex = curIndex;
    // Evaluate value.
    var value;
    if (curIndex === -1) {
      value = this._evaluateStep(0, out);
    } else if (nextIndex === length) {
      value = this._evaluateStep(curIndex, out);
    } else {
      // Time between first frame and end frame.
      var curFrameTime = keys[curIndex].time;
      var duration = keys[nextIndex].time - curFrameTime;
      var t = (time - curFrameTime) / duration;
      var dur = duration;
      switch (interpolation) {
        case InterpolationType.Linear:
          value = this._evaluateLinear(curIndex, nextIndex, t, out);
          break;
        case InterpolationType.Step:
          value = this._evaluateStep(curIndex, out);
          break;
        case InterpolationType.CubicSpine:
        case InterpolationType.Hermite:
          value = this._evaluateHermite(curIndex, nextIndex, t, dur, out);
      }
    }
    return value;
  };
  _proto._evaluateLinear = function _evaluateLinear(frameIndex, nextFrameIndex, t, out) {
    var _valueType = this._valueType,
      keys = this.keys;
    switch (_valueType) {
      case InterpolableValueType.Float:
        return keys[frameIndex].value * (1 - t) + keys[nextFrameIndex].value * t;
      case InterpolableValueType.FloatArray:
        var value = keys[frameIndex].value;
        var nextValue = keys[nextFrameIndex].value;
        for (var i = 0, n = value.length; i < n; i++) {
          out[i] = value[i] * (1 - t) + nextValue[i] * t;
        }
        return out;
      case InterpolableValueType.Vector2:
        Vector2.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
        return out;
      case InterpolableValueType.Vector3:
        Vector3.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
        return out;
      case InterpolableValueType.Vector4:
        Vector4.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
        return out;
      case InterpolableValueType.Quaternion:
        Quaternion.slerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
        return out;
    }
  };
  _proto._evaluateStep = function _evaluateStep(frameIndex, out) {
    var _valueType = this._valueType,
      keys = this.keys;
    switch (_valueType) {
      case InterpolableValueType.Float:
        return keys[frameIndex].value;
      case InterpolableValueType.FloatArray:
        var value = keys[frameIndex].value;
        for (var i = 0, n = value.length; i < n; i++) {
          out[i] = value[i];
        }
        return out;
      case InterpolableValueType.Vector2:
      case InterpolableValueType.Vector3:
      case InterpolableValueType.Vector4:
      case InterpolableValueType.Quaternion:
        out.copyFrom(keys[frameIndex].value);
        return out;
    }
  };
  _proto._evaluateHermite = function _evaluateHermite(frameIndex, nextFrameIndex, t, dur, out) {
    var _valueSize = this._valueSize,
      keys = this.keys;
    var curKey = keys[frameIndex];
    var nextKey = keys[nextFrameIndex];
    switch (_valueSize) {
      case 1:
        {
          var t0 = curKey.outTangent,
            t1 = nextKey.inTangent,
            p0 = curKey.value,
            p1 = nextKey.value;
          if (Number.isFinite(t0) && Number.isFinite(t1)) {
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            return a * p0 + b * t0 * dur + c * t1 * dur + d * p1;
          } else {
            return curKey.value;
          }
        }
      case 2:
        {
          var _p = curKey.value;
          var tan0 = curKey.outTangent;
          var _p2 = nextKey.value;
          var tan1 = nextKey.inTangent;
          var _t = t * t;
          var _t2 = _t * t;
          var _a = 2.0 * _t2 - 3.0 * _t + 1.0;
          var _b = _t2 - 2.0 * _t + t;
          var _c = _t2 - _t;
          var _d = -2.0 * _t2 + 3.0 * _t;
          var _t3 = tan0.x,
            _t4 = tan1.x;
          if (Number.isFinite(_t3) && Number.isFinite(_t4)) {
            out.x = _a * _p.x + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.x;
          } else {
            out.x = _p.x;
          }
          _t3 = tan0.y, _t4 = tan1.y;
          if (Number.isFinite(_t3) && Number.isFinite(_t4)) out.y = _a * _p.y + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.y;else {
            out.y = _p.y;
          }
          return out;
        }
      case 3:
        {
          var _p3 = curKey.value;
          var _tan = curKey.outTangent;
          var _p4 = nextKey.value;
          var _tan2 = nextKey.inTangent;
          var _t5 = t * t;
          var _t6 = _t5 * t;
          var _a2 = 2.0 * _t6 - 3.0 * _t5 + 1.0;
          var _b2 = _t6 - 2.0 * _t5 + t;
          var _c2 = _t6 - _t5;
          var _d2 = -2.0 * _t6 + 3.0 * _t5;
          var _t7 = _tan.x,
            _t8 = _tan2.x;
          if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
            out.x = _a2 * _p3.x + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.x;
          } else {
            out.x = _p3.x;
          }
          _t7 = _tan.y, _t8 = _tan2.y;
          if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
            out.y = _a2 * _p3.y + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.y;
          } else {
            out.y = _p3.y;
          }
          _t7 = _tan.z, _t8 = _tan2.z;
          if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
            out.z = _a2 * _p3.z + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.z;
          } else {
            out.z = _p3.z;
          }
          return out;
        }
      case 4:
        {
          var _p5 = curKey.value;
          var _tan3 = curKey.outTangent;
          var _p6 = nextKey.value;
          var _tan4 = nextKey.inTangent;
          var _t9 = t * t;
          var _t10 = _t9 * t;
          var _a3 = 2.0 * _t10 - 3.0 * _t9 + 1.0;
          var _b3 = _t10 - 2.0 * _t9 + t;
          var _c3 = _t10 - _t9;
          var _d3 = -2.0 * _t10 + 3.0 * _t9;
          var _t11 = _tan3.x,
            _t12 = _tan4.x;
          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            out.x = _a3 * _p5.x + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.x;
          } else {
            out.x = _p5.x;
          }
          _t11 = _tan3.y, _t12 = _tan4.y;
          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            out.y = _a3 * _p5.y + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.y;
          } else {
            out.y = _p5.y;
          }
          _t11 = _tan3.z, _t12 = _tan4.z;
          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            out.z = _a3 * _p5.z + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.z;
          } else {
            out.z = _p5.z;
          }
          _t11 = _tan3.w, _t12 = _tan4.w;
          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            out.w = _a3 * _p5.w + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.w;
          } else {
            out.w = _p5.w;
          }
          return out;
        }
    }
  };
  _createClass(AnimationCurve, [{
    key: "length",
    get:
    /**
     * Animation curve length in seconds.
     */
    function get() {
      return this._length;
    }
  }]);
  return AnimationCurve;
}();

/**
 * Keyframe.
 * @typeParam V - Type of Keyframe value
 */
var Keyframe = function Keyframe() {
  this.time = void 0;
  this.value = void 0;
};

/**
 * InterpolableKeyframe.
 * @typeParam T - Type of Tangent value
 * @typeParam V - Type of Keyframe value
 */
var InterpolableKeyframe = /*#__PURE__*/function (_Keyframe) {
  _inheritsLoose(InterpolableKeyframe, _Keyframe);
  function InterpolableKeyframe() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Keyframe.call.apply(_Keyframe, [this].concat(args)) || this;
    _this.inTangent = void 0;
    _this.outTangent = void 0;
    return _this;
  }
  return InterpolableKeyframe;
}(Keyframe);

var AnimatorConditionMode;
(function (AnimatorConditionMode) {
  AnimatorConditionMode[AnimatorConditionMode["If"] = 0] = "If";
  AnimatorConditionMode[AnimatorConditionMode["IfNot"] = 1] = "IfNot";
  AnimatorConditionMode[AnimatorConditionMode["Greater"] = 2] = "Greater";
  AnimatorConditionMode[AnimatorConditionMode["Less"] = 3] = "Less";
  AnimatorConditionMode[AnimatorConditionMode["Equals"] = 4] = "Equals";
  AnimatorConditionMode[AnimatorConditionMode["NotEquals"] = 5] = "NotEquals";
})(AnimatorConditionMode || (AnimatorConditionMode = {}));

/**
 * SkyboxMaterial
 */
var SkyBoxMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(SkyBoxMaterial, _Material);
  function SkyBoxMaterial(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("skybox")) || this;
    _this._decodeParam = new Vector4(0, 5, 0, 0);
    _this.renderState.rasterState.cullMode = CullMode.Off;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this.shaderData.setVector4("u_cubeDecodeParam", _this._decodeParam);
    return _this;
  }
  _createClass(SkyBoxMaterial, [{
    key: "textureDecodeRGBM",
    get:
    /**
     * Whether to decode from texture with RGBM format.
     */
    function get() {
      return Boolean(this._decodeParam.x);
    },
    set: function set(value) {
      this._decodeParam.x = Number(value);
    }

    /**
     * RGBM decode factor, default 5.0.
     */
  }, {
    key: "RGBMDecodeFactor",
    get: function get() {
      return this._decodeParam.y;
    },
    set: function set(value) {
      this._decodeParam.y = value;
    }

    /**
     * Texture cube map of the sky box material.
     */
  }, {
    key: "textureCubeMap",
    get: function get() {
      return this.shaderData.getTexture("u_cube");
    },
    set: function set(v) {
      this.shaderData.setTexture("u_cube", v);
    }
  }]);
  return SkyBoxMaterial;
}(Material);

var DirtyFlagType;
/**
 * Blend mode enums of the particle renderer's material.
 */
(function (DirtyFlagType) {
  DirtyFlagType[DirtyFlagType["Position"] = 1] = "Position";
  DirtyFlagType[DirtyFlagType["Velocity"] = 2] = "Velocity";
  DirtyFlagType[DirtyFlagType["Acceleration"] = 4] = "Acceleration";
  DirtyFlagType[DirtyFlagType["Color"] = 8] = "Color";
  DirtyFlagType[DirtyFlagType["Alpha"] = 16] = "Alpha";
  DirtyFlagType[DirtyFlagType["Size"] = 32] = "Size";
  DirtyFlagType[DirtyFlagType["StartAngle"] = 64] = "StartAngle";
  DirtyFlagType[DirtyFlagType["StartTime"] = 128] = "StartTime";
  DirtyFlagType[DirtyFlagType["LifeTime"] = 256] = "LifeTime";
  DirtyFlagType[DirtyFlagType["RotateVelocity"] = 512] = "RotateVelocity";
  DirtyFlagType[DirtyFlagType["Scale"] = 1024] = "Scale";
  DirtyFlagType[DirtyFlagType["Everything"] = 4294967295] = "Everything";
})(DirtyFlagType || (DirtyFlagType = {}));
var ParticleRendererBlendMode;

/**
 * Particle Renderer Component.
 */
(function (ParticleRendererBlendMode) {
  ParticleRendererBlendMode[ParticleRendererBlendMode["Transparent"] = 0] = "Transparent";
  ParticleRendererBlendMode[ParticleRendererBlendMode["Additive"] = 1] = "Additive";
})(ParticleRendererBlendMode || (ParticleRendererBlendMode = {}));
var ParticleRenderer = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(ParticleRenderer, _MeshRenderer);
  /** The max number of indices that Uint16Array can support. */
  ParticleRenderer._getRandom = function _getRandom() {
    return Math.random() - 0.5;
  };
  function ParticleRenderer(props) {
    var _this;
    _this = _MeshRenderer.call(this, props) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._maxCount = 1000;
    _this._position = new Vector3();
    _this._positionRandomness = new Vector3();
    _this._positionArray = void 0;
    _this._velocity = new Vector3();
    _this._velocityRandomness = new Vector3();
    _this._acceleration = new Vector3();
    _this._accelerationRandomness = new Vector3();
    _this._color = new Color(1, 1, 1, 1);
    _this._colorRandomness = 0;
    _this._size = 1;
    _this._sizeRandomness = 0;
    _this._alpha = 1;
    _this._alphaRandomness = 0;
    _this._startAngle = 0;
    _this._startAngleRandomness = 0;
    _this._rotateVelocity = 0;
    _this._rotateVelocityRandomness = 0;
    _this._lifetime = 5;
    _this._startTimeRandomness = 0;
    _this._scale = 1;
    _this._isOnce = false;
    _this._onceTime = 0;
    _this._time = 0;
    _this._isInit = false;
    _this._isStart = false;
    _this._updateDirtyFlag = DirtyFlagType.Everything;
    _this._isRotateToVelocity = false;
    _this._isUseOriginColor = false;
    _this._isScaleByLifetime = false;
    _this._is2d = true;
    _this._isFadeIn = false;
    _this._isFadeOut = false;
    _this._playOnEnable = true;
    _this._blendMode = ParticleRendererBlendMode.Transparent;
    _this.spriteSheet = void 0;
    _this.setMaterial(_this._createMaterial());
    return _this;
  }

  /**
   * @override
   * @internal
   */
  var _proto = ParticleRenderer.prototype;
  _proto.update = function update(deltaTime) {
    if (!this._isInit || !this._isStart) {
      return;
    }

    // Stop after play once
    if (this._isOnce && this._time > this._onceTime) {
      return this.stop();
    }
    if (this._updateDirtyFlag) {
      this._updateBuffer();
      this._updateDirtyFlag = 0;
    }
    this._time += deltaTime / 1000;
    this.shaderData.setFloat("u_time", this._time);
  }

  /**
   * @override
   * @internal
   */;
  _proto._onEnable = function _onEnable() {
    _MeshRenderer.prototype._onEnable.call(this);
    if (this._playOnEnable) {
      this.start();
    }
  }

  /**
   * Start emitting.
   */;
  _proto.start = function start() {
    this._isStart = true;
    this._time = 0;
  }

  /**
   * Stop emitting.
   */;
  _proto.stop = function stop() {
    this._isStart = false;
  };
  _proto._createMaterial = function _createMaterial() {
    var material = new Material(this.engine, Shader.find("particle-shader"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    renderState.depthState.writeEnabled = false;
    material.renderQueueType = RenderQueueType.Transparent;
    this.isUseOriginColor = true;
    this.is2d = true;
    this.isFadeOut = true;
    return material;
  };
  _proto._createMesh = function _createMesh() {
    var mesh = new BufferMesh(this._entity.engine, "particleMesh");
    var vertexStride = 96;
    var vertexCount = this._maxCount * 4;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var indices = null;
    var useUint32 = false;
    if (vertexCount > ParticleRenderer._uint16VertexLimit) {
      if (this.engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        useUint32 = true;
        indices = new Uint32Array(6 * this._maxCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(6 * this._maxCount);
    }
    for (var i = 0, idx = 0; i < this._maxCount; ++i) {
      var startIndex = i * 4;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 1;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 3;
    }
    var vertexElements = [new VertexElement("a_position", 0, VertexElementFormat.Vector3, 0), new VertexElement("a_velocity", 12, VertexElementFormat.Vector3, 0), new VertexElement("a_acceleration", 24, VertexElementFormat.Vector3, 0), new VertexElement("a_color", 36, VertexElementFormat.Vector4, 0), new VertexElement("a_lifeAndSize", 52, VertexElementFormat.Vector4, 0), new VertexElement("a_rotation", 68, VertexElementFormat.Vector2, 0), new VertexElement("a_uv", 76, VertexElementFormat.Vector3, 0), new VertexElement("a_normalizedUv", 88, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
    var indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setIndexBufferBinding(indexBuffer, useUint32 ? IndexFormat.UInt32 : IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, indices.length);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride / 4;
    this._vertices = vertices;
    return mesh;
  };
  _proto._updateBuffer = function _updateBuffer() {
    for (var x = 0; x < this._maxCount; x++) {
      this._updateSingleBuffer(x);
    }
    this._vertexBuffer.setData(this._vertices);
  };
  _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
    var _updateDirtyFlag = this._updateDirtyFlag,
      vertices = this._vertices,
      vertexStride = this._vertexStride;
    var getRandom = ParticleRenderer._getRandom;
    var offset = i * 4;
    var k0 = offset * vertexStride;
    var k1 = (offset + 1) * vertexStride;
    var k2 = (offset + 2) * vertexStride;
    var k3 = (offset + 3) * vertexStride;
    if (_updateDirtyFlag & DirtyFlagType.Position) {
      var _this$_position = this._position,
        x = _this$_position.x,
        y = _this$_position.y,
        z = _this$_position.z;
      var _positionArray = this._positionArray,
        _positionRandomness = this._positionRandomness;
      if (_positionArray) {
        if (_positionArray.length !== this._maxCount) {
          throw Error("The length of positionArray must be equal to maxCount.");
        }
        var pos = _positionArray[i];
        x += pos.x;
        y += pos.y;
        z += pos.z;
      } else {
        x += getRandom() * _positionRandomness.x;
        y += getRandom() * _positionRandomness.y;
        z += getRandom() * _positionRandomness.z;
      }
      vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
      vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
      vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Velocity) {
      var _velocity = this._velocity,
        _velocityRandomness = this._velocityRandomness;
      vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
      vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
      vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Acceleration) {
      var _acceleration = this._acceleration,
        _accelerationRandomness = this._accelerationRandomness;
      vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
      vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
      vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Color) {
      var _color = this._color,
        _colorRandomness = this._colorRandomness;
      vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = MathUtil.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = MathUtil.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = MathUtil.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
    }
    if (_updateDirtyFlag & DirtyFlagType.Alpha) {
      vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = MathUtil.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
    }
    if (_updateDirtyFlag & DirtyFlagType.StartTime) {
      vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
    }
    if (_updateDirtyFlag & DirtyFlagType.LifeTime) {
      var _lifetime = this._lifetime;
      vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
    }

    // Update the duration of play once when startTime or lifetime changes.
    if (_updateDirtyFlag & DirtyFlagType.StartTime || _updateDirtyFlag & DirtyFlagType.LifeTime) {
      this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);
    }
    if (_updateDirtyFlag & DirtyFlagType.Size) {
      var _size = this._size;
      vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
    }
    if (_updateDirtyFlag & DirtyFlagType.Scale) {
      vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
    }
    if (_updateDirtyFlag & DirtyFlagType.StartAngle) {
      vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
    }
    if (_updateDirtyFlag & DirtyFlagType.RotateVelocity) {
      vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
    }
    this._updateSingleUv(i, k0, k1, k2, k3);
  };
  _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
    var spriteSheet = this.spriteSheet;
    var texture = this.getMaterial().shaderData.getTexture("u_texture");
    var vertices = this._vertices;
    if (texture) {
      var width = texture.width;
      var height = texture.height;
      if (spriteSheet) {
        var _spriteSheet = spriteSheet[i % spriteSheet.length],
          x = _spriteSheet.x,
          y = _spriteSheet.y,
          w = _spriteSheet.w,
          h = _spriteSheet.h;
        var u = x / width;
        var v = y / height;
        var p = u + w / width;
        var q = v + h / height;
        var ratio = h / w;

        // left bottom
        vertices[k0 + 19] = u;
        vertices[k0 + 20] = q;
        vertices[k0 + 21] = ratio;

        // right bottom
        vertices[k1 + 19] = p;
        vertices[k1 + 20] = q;
        vertices[k1 + 21] = ratio;

        // right top
        vertices[k2 + 19] = p;
        vertices[k2 + 20] = v;
        vertices[k2 + 21] = ratio;

        // left top
        vertices[k3 + 19] = u;
        vertices[k3 + 20] = v;
        vertices[k3 + 21] = ratio;
      } else {
        var _ratio = height / width;

        // left bottom
        vertices[k0 + 19] = 0;
        vertices[k0 + 20] = 1;
        vertices[k0 + 21] = _ratio;

        // right bottom
        vertices[k1 + 19] = 1;
        vertices[k1 + 20] = 1;
        vertices[k1 + 21] = _ratio;

        // right top
        vertices[k2 + 19] = 1;
        vertices[k2 + 20] = 0;
        vertices[k2 + 21] = _ratio;

        // left top
        vertices[k3 + 19] = 0;
        vertices[k3 + 20] = 0;
        vertices[k3 + 21] = _ratio;
      }
    } else {
      // left bottom
      vertices[k0 + 19] = 0;
      vertices[k0 + 20] = 0;
      vertices[k0 + 21] = 1;

      // right bottom
      vertices[k1 + 19] = 1;
      vertices[k1 + 20] = 0;
      vertices[k1 + 21] = 1;

      // right top
      vertices[k2 + 19] = 1;
      vertices[k2 + 20] = 1;
      vertices[k2 + 21] = 1;

      // left top
      vertices[k3 + 19] = 0;
      vertices[k3 + 20] = 1;
      vertices[k3 + 21] = 1;
    }
    vertices[k0 + 22] = -0.5;
    vertices[k0 + 23] = -0.5;
    vertices[k1 + 22] = 0.5;
    vertices[k1 + 23] = -0.5;
    vertices[k2 + 22] = 0.5;
    vertices[k2 + 23] = 0.5;
    vertices[k3 + 22] = -0.5;
    vertices[k3 + 23] = 0.5;
  };
  _createClass(ParticleRenderer, [{
    key: "texture",
    get:
    /**
     * Texture of particle.
     */
    function get() {
      return this.getMaterial().shaderData.getTexture("u_texture");
    },
    set: function set(texture) {
      if (texture) {
        this.shaderData.enableMacro("particleTexture");
        this.getMaterial().shaderData.setTexture("u_texture", texture);
      } else {
        this.shaderData.disableMacro("particleTexture");
      }
    }

    /**
     * Position of particles.
     */
  }, {
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._position = value;
    }

    /**
     * Random range of positions.
     */
  }, {
    key: "positionRandomness",
    get: function get() {
      return this._positionRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionRandomness = value;
    }

    /**
     * Array of fixed positions.
     */
  }, {
    key: "positionArray",
    get: function get() {
      return this._positionArray;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionArray = value;
    }

    /**
     * Velocity of particles.
     */
  }, {
    key: "velocity",
    get: function get() {
      return this._velocity;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocity = value;
    }

    /**
     * Random range of velocity.
     */
  }, {
    key: "velocityRandomness",
    get: function get() {
      return this._velocityRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocityRandomness = value;
    }

    /**
     * Acceleration of particles.
     */
  }, {
    key: "acceleration",
    get: function get() {
      return this._acceleration;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._acceleration = value;
    }

    /**
     * Random range of acceleration.
     */
  }, {
    key: "accelerationRandomness",
    get: function get() {
      return this._accelerationRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._accelerationRandomness = value;
    }

    /**
     * Color of particles.
     */
  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._color = value;
    }

    /**
     * Random range of color.
     */
  }, {
    key: "colorRandomness",
    get: function get() {
      return this._colorRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._colorRandomness = value;
    }

    /**
     * Size of particles.
     */
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._size = value;
    }

    /**
     * Random range of size.
     */
  }, {
    key: "sizeRandomness",
    get: function get() {
      return this._sizeRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._sizeRandomness = value;
    }

    /**
     * Alpha of particles.
     */
  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Alpha;
      this._alpha = value;
    }

    /**
     * Random range of alpha.
     */
  }, {
    key: "alphaRandomness",
    get: function get() {
      return this._alphaRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Alpha;
      this._alphaRandomness = value;
    }

    /**
     * Angle of particles.
     */
  }, {
    key: "angle",
    get: function get() {
      return this._startAngle;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngle = value;
    }

    /**
     * Random range of angle.
     */
  }, {
    key: "angleRandomness",
    get: function get() {
      return this._startAngleRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngleRandomness = value;
    }

    /**
     * Rotate velocity of particles.
     */
  }, {
    key: "rotateVelocity",
    get: function get() {
      return this._rotateVelocity;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocity = value;
    }

    /**
     * Random range of rotate velocity.
     */
  }, {
    key: "rotateVelocityRandomness",
    get: function get() {
      return this._rotateVelocityRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocityRandomness = value;
    }

    /**
     * Lifetime of particles.
     */
  }, {
    key: "lifetime",
    get: function get() {
      return this._lifetime;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.LifeTime;
      this._lifetime = value;
      this._onceTime = 0;
    }

    /**
     * Random range of start time.
     */
  }, {
    key: "startTimeRandomness",
    get: function get() {
      return this._startTimeRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartTime;
      this._startTimeRandomness = value;
      this._onceTime = 0;
    }

    /**
     * Scale factor of particles.
     */
  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Scale;
      this._scale = value;
    }

    /**
     * Max count of particles.
     */
  }, {
    key: "maxCount",
    get: function get() {
      return this._maxCount;
    },
    set: function set(value) {
      this._isStart = false;
      this._isInit = false;
      this._maxCount = value;
      this._updateDirtyFlag = DirtyFlagType.Everything;
      this.mesh = this._createMesh();
      this._updateBuffer();
      this._isInit = true;
      this.shaderData.setFloat("u_time", 0);
    }

    /**
     * Whether play once.
     */
  }, {
    key: "isOnce",
    get: function get() {
      return this._isOnce;
    },
    set: function set(value) {
      this._time = 0;
      this.shaderData.setInt("u_once", value ? 1 : 0);
      this._isOnce = value;
    }

    /**
     * Whether follow the direction of velocity.
     */
  }, {
    key: "isRotateToVelocity",
    get: function get() {
      return this._isRotateToVelocity;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("rotateToVelocity");
      } else {
        this.shaderData.disableMacro("rotateToVelocity");
      }
      this._isRotateToVelocity = value;
    }

    /**
     * Whether use origin color.
     */
  }, {
    key: "isUseOriginColor",
    get: function get() {
      return this._isUseOriginColor;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("useOriginColor");
      } else {
        this.shaderData.disableMacro("useOriginColor");
      }
      this._isUseOriginColor = value;
    }

    /**
     * Whether scale by lifetime.
     */
  }, {
    key: "isScaleByLifetime",
    get: function get() {
      return this._isScaleByLifetime;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("isScaleByLifetime");
      } else {
        this.shaderData.disableMacro("isScaleByLifetime");
      }
      this._isScaleByLifetime = value;
    }

    /**
     * Whether 2D rendering.
     */
  }, {
    key: "is2d",
    get: function get() {
      return this._is2d;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("is2d");
      } else {
        this.shaderData.disableMacro("is2d");
        this.getMaterial().renderState.rasterState.cullMode = CullMode.Off;
      }
      this._is2d = value;
    }

    /**
     * Whether fade in.
     */
  }, {
    key: "isFadeIn",
    get: function get() {
      return this._isFadeIn;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("fadeIn");
      } else {
        this.shaderData.disableMacro("fadeIn");
      }
      this._isFadeIn = value;
    }

    /**
     * Whether fade out.
     */
  }, {
    key: "isFadeOut",
    get: function get() {
      return this._isFadeOut;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("fadeOut");
      } else {
        this.shaderData.disableMacro("fadeOut");
      }
      this._isFadeOut = value;
    }

    /**
     * Whether play on enable.
     */
  }, {
    key: "playOnEnable",
    get: function get() {
      return this._playOnEnable;
    },
    set: function set(value) {
      this._playOnEnable = value;
      if (value) {
        this.start();
      } else {
        this.stop();
      }
    }

    /**
     * Blend mode of the particle renderer's material.
     */
  }, {
    key: "blendMode",
    get: function get() {
      return this._blendMode;
    },
    set: function set(value) {
      var blendState = this.getMaterial().renderState.blendState;
      var target = blendState.targetBlendState;
      if (value === ParticleRendererBlendMode.Transparent) {
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      } else if (value === ParticleRendererBlendMode.Additive) {
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.One;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      }
      this._blendMode = value;
    }
  }]);
  return ParticleRenderer;
}(MeshRenderer);
ParticleRenderer._uint16VertexLimit = 65535;

var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}"; // eslint-disable-line

var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(TrailMaterial, _Material);
  function TrailMaterial(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("trail")) || this;
    var target = _this.renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
    _this.renderState.depthState.writeEnabled = false;
    return _this;
  }
  return TrailMaterial;
}(Material);

var _tempVector3 = new Vector3();

/**
 * @deprecated
 */
var TrailRenderer = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(TrailRenderer, _MeshRenderer);
  /**
   * @deprecated
   */
  function TrailRenderer(entity, props) {
    var _this;
    _this = _MeshRenderer.call(this, entity) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._stroke = void 0;
    _this._minSeg = void 0;
    _this._lifetime = void 0;
    _this._maxPointNum = void 0;
    _this._points = void 0;
    _this._pointStates = void 0;
    _this._strapPoints = void 0;
    _this._curPointNum = void 0;
    _this._prePointsNum = void 0;
    _this._stroke = props.stroke || 0.2;
    _this._minSeg = props.minSeg || 0.02;
    _this._lifetime = props.lifetime || 1000;
    _this._maxPointNum = _this._lifetime / 1000.0 * entity.engine.targetFrameRate;
    _this._points = [];
    _this._pointStates = [];
    _this._strapPoints = [];
    for (var i = 0; i < _this._maxPointNum; i++) {
      _this._points.push(new Vector3());
      _this._pointStates.push(_this._lifetime);
      _this._strapPoints.push(new Vector3());
      _this._strapPoints.push(new Vector3());
    }
    _this._curPointNum = 0;
    var mtl = props.material || new TrailMaterial(_this.engine);
    _this.setMaterial(mtl);
    _this.setTexture(props.texture);
    _this._initGeometry();
    return _this;
  }

  /**
   * @internal
   */
  var _proto = TrailRenderer.prototype;
  _proto.update = function update(deltaTime) {
    var mov = 0,
      newIdx = 0;
    for (var i = 0; i < this._curPointNum; i++) {
      this._pointStates[i] -= deltaTime;
      if (this._pointStates[i] < 0) {
        mov++;
      } else if (mov > 0) {
        newIdx = i - mov;

        // Move data
        this._pointStates[newIdx] = this._pointStates[i];

        // Move point
        this._points[newIdx].copyFrom(this._points[i]);
      }
    }
    this._curPointNum -= mov;
    var appendNewPoint = true;
    if (this._curPointNum === this._maxPointNum) {
      appendNewPoint = false;
    } else if (this._curPointNum > 0) {
      var lastPoint = this._points[this._points.length - 1];
      if (Vector3.distance(this.entity.transform.worldPosition, lastPoint) < this._minSeg) {
        appendNewPoint = false;
      }
    }
    if (appendNewPoint) {
      this._pointStates[this._curPointNum] = this._lifetime;
      this._points[this._curPointNum].copyFrom(this.entity.transform.worldPosition);
      this._curPointNum++;
    }
  }

  /**
   * @internal
   */;
  _proto._render = function _render(camera) {
    this._updateStrapVertices(camera, this._points);
    this._updateStrapCoords();
    this._vertexBuffer.setData(this._vertices);
    _MeshRenderer.prototype._render.call(this, camera);
  }

  /**
   * @deprecated
   * Set trail texture.
   * @param texture
   */;
  _proto.setTexture = function setTexture(texture) {
    if (texture) {
      this.getMaterial().shaderData.setTexture("u_texture", texture);
    }
  };
  _proto._initGeometry = function _initGeometry() {
    var mesh = new BufferMesh(this._entity.engine);
    var vertexStride = 20;
    var vertexCount = this._maxPointNum * 2;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    this.mesh = mesh;
  };
  _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
    var m = camera.viewMatrix;
    var e = m.elements;
    var vx = new Vector3(e[0], e[4], e[8]);
    var vy = new Vector3(e[1], e[5], e[9]);
    var vz = new Vector3(e[2], e[6], e[10]);
    var s = this._stroke;
    vy.scale(s);
    var up = new Vector3();
    var down = new Vector3();
    var rotation = new Quaternion();
    Vector3.transformByQuat(vx, rotation, vx);
    Vector3.transformByQuat(vy, rotation, vy);
    var dy = new Vector3();
    var cross = new Vector3();
    var perpVector = new Vector3();
    vx.normalize();
    var vertices = this._vertices;
    //-- quad pos
    for (var i = 0; i < this._maxPointNum; i++) {
      //-- center pos
      if (i < this._curPointNum) {
        var p = points[i];
        if (i === this._curPointNum - 1 && i !== 0) {
          Vector3.subtract(p, points[i - 1], perpVector);
        } else {
          Vector3.subtract(points[i + 1], p, perpVector);
        }
        this._projectOnPlane(perpVector, vz, perpVector);
        perpVector.normalize();

        // Calculate angle between vectors
        var angle = Math.acos(Vector3.dot(vx, perpVector));
        Vector3.cross(vx, perpVector, cross);
        if (Vector3.dot(cross, vz) <= 0) {
          angle = Math.PI * 2 - angle;
        }
        Quaternion.rotationAxisAngle(vz, angle, rotation);
        Vector3.transformByQuat(vy, rotation, dy);
        Vector3.add(p, dy, up);
        Vector3.subtract(p, dy, down);
      }
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = up.x;
      vertices[p0 + 1] = up.y;
      vertices[p0 + 2] = up.z;
      vertices[p1] = down.x;
      vertices[p1 + 1] = down.y;
      vertices[p1 + 2] = down.z;
    }
  };
  _proto._updateStrapCoords = function _updateStrapCoords() {
    if (this._prePointsNum === this._curPointNum) {
      return;
    }
    this._prePointsNum = this._curPointNum;
    var count = this._curPointNum;
    var texDelta = 1.0 / count;
    var vertices = this._vertices;
    for (var i = 0; i < count; i++) {
      var d = 1.0 - i * texDelta;
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = 0;
      vertices[p0 + 1] = d;
      vertices[p1] = 1.0;
      vertices[p1 + 1] = d;
    }
  };
  _proto._projectOnVector = function _projectOnVector(a, p, out) {
    var n_p = p.clone();
    Vector3.normalize(n_p, n_p);
    var cosine = Vector3.dot(a, n_p);
    out.x = n_p.x * cosine;
    out.y = n_p.y * cosine;
    out.z = n_p.z * cosine;
  };
  _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
    this._projectOnVector(a, n, _tempVector3);
    Vector3.subtract(a, _tempVector3, out);
  };
  return TrailRenderer;
}(MeshRenderer);

/**
 * Fog.
 */
var Fog = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Fog, _Component);
  /**
   * @internal
   */
  function Fog(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._color = new Color(1, 0, 0, 1);
    _this.color = _this._color;
    return _this;
  }

  /**
   * @internal
   * @override
   */
  var _proto = Fog.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_HAS_FOG");
  }

  /**
   * @internal
   * @override
   */;
  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_HAS_FOG");
  };
  _createClass(Fog, [{
    key: "color",
    get:
    /**
     * Fog color.
     */
    function get() {
      return this._color;
    },
    set: function set(value) {
      this._color = value;
      this.scene.shaderData.setColor(Fog._colorProperty, value);
    }
  }]);
  return Fog;
}(Component);
Fog._colorProperty = Shader.getPropertyByName("u_fogColor");

/**
 * Exponential fog.
 */
var EXP2Fog = /*#__PURE__*/function (_Fog) {
  _inheritsLoose(EXP2Fog, _Fog);
  function EXP2Fog(entity) {
    var _this;
    _this = _Fog.call(this, entity) || this;
    _this._density = 0.0025;
    _this.density = _this._density;
    return _this;
  }
  /**
   * @internal
   * @override
   */
  var _proto = EXP2Fog.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_FOG_EXP2");
  }

  /**
   * @internal
   * @override
   */;
  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_FOG_EXP2");
  };
  _createClass(EXP2Fog, [{
    key: "density",
    get:
    /**
     * Density of fog.
     */
    function get() {
      return this._density;
    },
    set: function set(value) {
      this._density = value;
      this.scene.shaderData.setFloat(EXP2Fog._densityProperty, value);
    }
  }]);
  return EXP2Fog;
}(Fog);
EXP2Fog._densityProperty = Shader.getPropertyByName("u_fogDensity");

/**
 * Linear fog, according to the distance of the camera linear difference fog density.
 */
var LinearFog = /*#__PURE__*/function (_Fog) {
  _inheritsLoose(LinearFog, _Fog);
  function LinearFog(entity) {
    var _this;
    _this = _Fog.call(this, entity) || this;
    _this._near = 1;
    _this._far = 1000;
    _this.near = _this._near;
    _this.far = _this._far;
    return _this;
  }
  _createClass(LinearFog, [{
    key: "near",
    get:
    /**
     * Start of fog.
     */
    function get() {
      return this._near;
    },
    set: function set(value) {
      this._near = value;
      this.scene.shaderData.setFloat(LinearFog._nearProperty, value);
    }

    /**
     * End of fog.
     */
  }, {
    key: "far",
    get: function get() {
      return this._far;
    },
    set: function set(value) {
      this._far = value;
      this.scene.shaderData.setFloat(LinearFog._farProperty, value);
    }
  }]);
  return LinearFog;
}(Fog);
LinearFog._nearProperty = Shader.getPropertyByName("u_fogNear");
LinearFog._farProperty = Shader.getPropertyByName("u_fogFar");

/**
 * Environmental probes, providing necessary capabilities such as reflection and refraction.
 * @example
 * ```ts
 * const probe = cameraEntity.addComponent( CubeProbe )
 * probe.onTextureChange = cubeTexture => {
 *   envLight.specularTexture = cubeTexture;
 *   skybox.specularTexture = cubeTexture;
 * }
 * ```
 */
var Probe = /*#__PURE__*/function (_Script) {
  _inheritsLoose(Probe, _Script);
  function Probe() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Script.call.apply(_Script, [this].concat(args)) || this;
    _this.probeLayer = Layer.Everything;
    _this.width = 1024;
    _this.height = 1024;
    _this.antiAliasing = 1;
    _this._isCube = false;
    _this._oriCameraRenderTarget = void 0;
    _this._renderTarget = void 0;
    _this._renderTargetSwap = void 0;
    _this._activeRenderTarget = void 0;
    _this._camera = void 0;
    _this._oriCameraCullingMask = void 0;
    return _this;
  }
  var _proto = Probe.prototype;
  /**
   * Provide hooks for users to exchange Texture.
   * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.
   */
  _proto.onTextureChange = function onTextureChange(renderColorTexture) {}

  /**
   * @override
   */;
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled) return;
    this._camera = camera;
    this._oriCameraCullingMask = camera.cullingMask;
    camera.cullingMask = this.probeLayer;
    if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
      this._renderTarget = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._activeRenderTarget = this._renderTarget;
    }
    this._oriCameraRenderTarget = camera.renderTarget;
    camera.renderTarget = this._activeRenderTarget;
  }

  /**
   * @override
   */;
  _proto.onEndRender = function onEndRender(camera) {
    if (!this.enabled) return;
    this.onTextureChange && this.onTextureChange(this._texture);
    this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
  };
  _proto._reset = function _reset() {
    if (!this.enabled) return;
    this._camera.renderTarget = this._oriCameraRenderTarget;
    this._camera.cullingMask = this._oriCameraCullingMask;
  };
  _createClass(Probe, [{
    key: "_texture",
    get: function get() {
      var _this$_activeRenderTa;
      return (_this$_activeRenderTa = this._activeRenderTarget) === null || _this$_activeRenderTa === void 0 ? void 0 : _this$_activeRenderTa.getColorTexture();
    }
  }]);
  return Probe;
}(Script);

var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();

/**
 * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.
 */
var CubeProbe = /*#__PURE__*/function (_Probe) {
  _inheritsLoose(CubeProbe, _Probe);
  function CubeProbe() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Probe.call.apply(_Probe, [this].concat(args)) || this;
    _this.position = new Vector3(0, 0, 0);
    _this._isCube = true;
    _this.oriViewMatrix = new Matrix();
    _this._oriFieldOfView = void 0;
    return _this;
  }
  var _proto = CubeProbe.prototype;
  /**
   * @override
   */
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled) return;
    _Probe.prototype.onBeginRender.call(this, camera);
    this._storeCamera(camera);

    // Render 6 faces
    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
      // Change camera parameters
      this._setCamera(faceIndex, camera);
      camera.render(TextureCubeFace.PositiveX + faceIndex);
    }
    this._restoreCamera(camera);
    _Probe.prototype._reset.call(this);
  }

  /**
   * Store original camera parameters.
   */;
  _proto._storeCamera = function _storeCamera(camera) {
    this.oriViewMatrix.copyFrom(camera.viewMatrix);
    this._oriFieldOfView = camera.fieldOfView;
  }

  /**
   * Restore camera parameters.
   */;
  _proto._restoreCamera = function _restoreCamera(camera) {
    camera.viewMatrix.copyFrom(this.oriViewMatrix);
    camera.fieldOfView = this._oriFieldOfView;
  }

  /**
   * Set camera parameters according to the rendering surface.
   */;
  _proto._setCamera = function _setCamera(faceIndex, camera) {
    switch (faceIndex) {
      // positive_x
      case 0:
        cacheUp.set(0, -1, 0);
        cacheDir.set(1, 0, 0);
        break;
      // negative_x
      case 1:
        cacheUp.set(0, -1, 0);
        cacheDir.set(-1, 0, 0);
        break;
      // positive_y
      case 2:
        cacheUp.set(0, 0, 1);
        cacheDir.set(0, 1, 0);
        break;
      // negative_y
      case 3:
        cacheUp.set(0, 0, -1);
        cacheDir.set(0, -1, 0);
        break;
      // positive_z
      case 4:
        cacheUp.set(0, -1, 0);
        cacheDir.set(0, 0, 1);
        break;
      // negative_z
      case 5:
        cacheUp.set(0, -1, 0);
        cacheDir.set(0, 0, -1);
        break;
    }
    Vector3.add(this.position, cacheDir, cacheTarget);
    Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
    camera.fieldOfView = 90;
  };
  return CubeProbe;
}(Probe);

/**
 * Shadow manager.
 */
var LightShadow = /*#__PURE__*/function () {
  /**
   * @internal
   */
  LightShadow._updateShaderData = function _updateShaderData(shaderData) {
    var data = LightShadow._combinedData;
    shaderData.setFloatArray(LightShadow._viewMatFromLightProperty, data.viewMatrix);
    shaderData.setFloatArray(LightShadow._projMatFromLightProperty, data.projectionMatrix);
    shaderData.setFloatArray(LightShadow._shadowBiasProperty, data.bias);
    shaderData.setFloatArray(LightShadow._shadowIntensityProperty, data.intensity);
    shaderData.setFloatArray(LightShadow._shadowRadiusProperty, data.radius);
    shaderData.setFloatArray(LightShadow._shadowMapSizeProperty, data.mapSize);
    shaderData.setTextureArray(LightShadow._shadowMapsProperty, data.map);
  }

  /**
   * Clear all shadow maps.
   */;
  LightShadow.clearMap = function clearMap() {
    LightShadow._combinedData.map.length = 0;
  };
  function LightShadow(light, props) {
    if (props === void 0) {
      props = {
        engine: null,
        width: 512,
        height: 512
      };
    }
    this._mapSize = void 0;
    this._renderTarget = void 0;
    this.light = void 0;
    this.bias = 0.005;
    this.intensity = 0.2;
    this.radius = 1;
    this.projectionMatrix = new Matrix();
    this.light = light;
    var _props = props,
      engine = _props.engine,
      width = _props.width,
      height = _props.height;
    this._mapSize = new Vector2(width, height);
    this._renderTarget = new RenderTarget(engine, width, height, new Texture2D(engine, width, height));
  }

  /**
   * The RenderTarget corresponding to the shadow map.
   */
  var _proto = LightShadow.prototype;
  /**
   * Initialize the projection matrix for lighting.
   * @param light - The light to generate shadow
   */
  _proto.initShadowProjectionMatrix = function initShadowProjectionMatrix(light) {
    /**
     * Directional light projection matrix, the default coverage area is left: -5, right: 5, bottom: -5, up: 5, near: 0.5, far: 50.
     */
    if (light instanceof DirectLight) {
      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
    }

    /**
     * Point light projection matrix, default configuration: fov: 50, aspect: 1, near: 0.5, far: 50.
     */
    if (light instanceof PointLight) {
      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
    }

    /**
     * Spotlight projection matrix, the default configuration: fov: this.angle * 2 * Math.sqrt(2), aspect: 1, near: 0.1, far: this.distance + 5
     */
    if (light instanceof SpotLight) {
      var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
    }
  };
  _proto.appendData = function appendData(lightIndex) {
    var viewStart = lightIndex * 16;
    var projectionStart = lightIndex * 16;
    var biasStart = lightIndex;
    var intensityStart = lightIndex;
    var radiusStart = lightIndex;
    var mapSizeStart = lightIndex * 2;
    var mapStart = lightIndex;
    var data = LightShadow._combinedData;
    data.viewMatrix.set(this.light.viewMatrix.elements, viewStart);
    data.projectionMatrix.set(this.projectionMatrix.elements, projectionStart);
    data.bias[biasStart] = this.bias;
    data.intensity[intensityStart] = this.intensity;
    data.radius[radiusStart] = this.radius;
    data.mapSize[mapSizeStart] = this.mapSize.x;
    data.mapSize[mapSizeStart + 1] = this.mapSize.y;
    data.map[mapStart] = this.map;
  };
  _createClass(LightShadow, [{
    key: "renderTarget",
    get: function get() {
      return this._renderTarget;
    }

    /**
     * Shadow map's color render texture.
     */
  }, {
    key: "map",
    get: function get() {
      return this._renderTarget.getColorTexture();
    }

    /**
     * Shadow map size.
     */
  }, {
    key: "mapSize",
    get: function get() {
      return this._mapSize;
    }
  }]);
  return LightShadow;
}();
LightShadow._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
LightShadow._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
LightShadow._shadowBiasProperty = Shader.getPropertyByName("u_shadowBias");
LightShadow._shadowIntensityProperty = Shader.getPropertyByName("u_shadowIntensity");
LightShadow._shadowRadiusProperty = Shader.getPropertyByName("u_shadowRadius");
LightShadow._shadowMapSizeProperty = Shader.getPropertyByName("u_shadowMapSize");
LightShadow._shadowMapsProperty = Shader.getPropertyByName("u_shadowMaps");
LightShadow._maxLight = 3;
LightShadow._combinedData = {
  viewMatrix: new Float32Array(16 * LightShadow._maxLight),
  projectionMatrix: new Float32Array(16 * LightShadow._maxLight),
  bias: new Float32Array(LightShadow._maxLight),
  intensity: new Float32Array(LightShadow._maxLight),
  radius: new Float32Array(LightShadow._maxLight),
  mapSize: new Float32Array(2 * LightShadow._maxLight),
  map: []
};

/**
 * Set whether the light to generate shadows.
 */
Object.defineProperty(Light.prototype, "enableShadow", {
  get: function get() {
    return this._enableShadow;
  },
  set: function set(enabled) {
    this._enableShadow = enabled;
    if (this._enableShadow) {
      if (this instanceof AmbientLight) {
        this._enableShadow = false;
        Logger.warn("Has no shadow!");
        return;
      }
      this.shadow = this.shadow || new LightShadow(this, {
        engine: this.engine,
        width: 512,
        height: 512
      });
      this.shadow.initShadowProjectionMatrix(this);
    }
  }
});

/**
 * Set whether the renderer to receive shadows.
 */
Object.defineProperty(Component.prototype, "receiveShadow", {
  get: function get() {
    return this._receiveShadow;
  },
  set: function set(enabled) {
    this._receiveShadow = enabled;
  }
});

/**
 * Set whether the renderer to cast shadows.
 */
Object.defineProperty(Component.prototype, "castShadow", {
  get: function get() {
    return this._castShadow;
  },
  set: function set(enabled) {
    this._castShadow = enabled;
  }
});

/**
 * Shadow Map material.
 */
var ShadowMapMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(ShadowMapMaterial, _Material);
  function ShadowMapMaterial(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("shadow-map")) || this;
    _this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");
    return _this;
  }
  return ShadowMapMaterial;
}(Material);

/**
 * RenderPass for rendering shadow map.
 */
var ShadowMapPass = /*#__PURE__*/function (_RenderPass) {
  _inheritsLoose(ShadowMapPass, _RenderPass);
  /**
   * Constructor.
   * @param light  - The light that the shadow belongs to
   */
  function ShadowMapPass(name, priority, renderTarget, replaceMaterial, mask, light) {
    var _this;
    _this = _RenderPass.call(this, name, priority, renderTarget, replaceMaterial, mask) || this;
    _this.light = void 0;
    _this.light = light;
    _this.clearColor = new Color(1, 1, 1, 1);
    return _this;
  }

  /**
   * @override
   */
  var _proto = ShadowMapPass.prototype;
  _proto.preRender = function preRender(camera, queue) {
    // The viewProjection matrix from the light.
    var shaderData = this.replaceMaterial.shaderData;
    shaderData.setMatrix(ShadowMapPass._viewMatFromLightProperty, this.light.viewMatrix);
    shaderData.setMatrix(ShadowMapPass._projMatFromLightProperty, this.light.shadow.projectionMatrix);
  };
  return ShadowMapPass;
}(RenderPass);
ShadowMapPass._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
ShadowMapPass._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");

/**
 * Shadow material.
 */
var ShadowMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(ShadowMaterial, _Material);
  function ShadowMaterial(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("shadow")) || this;
    var targetBlendState = _this.renderState.blendState.targetBlendState;
    targetBlendState.enabled = true;
    targetBlendState.sourceColorBlendFactor = targetBlendState.sourceAlphaBlendFactor = BlendFactor.DestinationColor;
    targetBlendState.destinationColorBlendFactor = targetBlendState.destinationAlphaBlendFactor = BlendFactor.Zero;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this.renderQueueType = RenderQueueType.Transparent;
    return _this;
  }
  return ShadowMaterial;
}(Material);

/**
 * RenderPass for rendering shadow.
 */
var ShadowPass = /*#__PURE__*/function (_RenderPass) {
  _inheritsLoose(ShadowPass, _RenderPass);
  function ShadowPass() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
    _this.clearFlags = CameraClearFlags.None;
    return _this;
  }

  /**
   * @override
   */
  var _proto = ShadowPass.prototype;
  _proto.preRender = function preRender(camera, queue) {
    this.enabled = false;
    var lightMgr = camera.scene.findFeature(LightFeature);
    var lights = lightMgr.visibleLights;
    var shaderData = this.replaceMaterial.shaderData;

    // keep render based on default render pass
    var pass = camera._renderPipeline.defaultRenderPass;
    this.renderTarget = pass.renderTarget;
    var shadowMapCount = 0;
    LightShadow.clearMap();
    for (var i = 0, len = lights.length; i < len; i++) {
      var lgt = lights[i];
      if (lgt.enableShadow) {
        lgt.shadow.appendData(shadowMapCount++);
      }
    }
    if (shadowMapCount) {
      this.enabled = true;
      LightShadow._updateShaderData(shaderData);
      shaderData.enableMacro("O3_SHADOW_MAP_COUNT", shadowMapCount.toString());
    } else {
      shaderData.disableMacro("O3_SHADOW_MAP_COUNT");
    }
  };
  return ShadowPass;
}(RenderPass);

/**
 * Shadow plug-in.
 */
var ShadowFeature = /*#__PURE__*/function (_SceneFeature) {
  _inheritsLoose(ShadowFeature, _SceneFeature);
  function ShadowFeature() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SceneFeature.call.apply(_SceneFeature, [this].concat(args)) || this;
    _this._shadowPass = void 0;
    _this._shadowMapMaterial = void 0;
    return _this;
  }
  var _proto = ShadowFeature.prototype;
  /**
   * @override
   */
  _proto.preRender = function preRender(scene, camera) {
    var lights = scene.findFeature(LightFeature).visibleLights;
    if (lights.length > 0) {
      // Check RenderPass for rendering shadows.
      if (!this._shadowPass) {
        this.addShadowPass(camera);
      }

      // Check RenderPass for rendering shadow map.
      var renderPipeline = camera._renderPipeline;
      for (var i = 0, len = lights.length; i < len; i++) {
        var lgt = lights[i];
        if (lgt.enableShadow && !lgt.shadowMapPass) {
          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
        } else if (!lgt.enableShadow && lgt.shadowMapPass) {
          renderPipeline.removeRenderPass(lgt.shadowMapPass);
          lgt.shadowMapPass = null;
        }
      }
      this.updatePassRenderFlag(renderPipeline._opaqueQueue);
      this.updatePassRenderFlag(renderPipeline._alphaTestQueue);
      this.updatePassRenderFlag(renderPipeline._transparentQueue);
    }
  }

  /**
   * Add RenderPass for rendering shadows.
   * @param camera - The camera for rendering
   */;
  _proto.addShadowPass = function addShadowPass(camera) {
    var shadowMaterial = new ShadowMaterial(camera.engine);
    this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, Layer.Layer30); // SHADOW
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(this._shadowPass);
  }

  /**
   * Add RenderPass for rendering shadow map.
   * @param camera - The camera for rendering
   * @param light - The light that the shadow belongs to
   */;
  _proto.addShadowMapPass = function addShadowMapPass(camera, light) {
    // Share shadow map material.
    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine);
    var shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, Layer.Layer31,
    // SHADOW_MAP
    light);
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(shadowMapPass);
    return shadowMapPass;
  }

  /**
   * Update the renderPassFlag state of renderers in the scene.
   * @param renderQueue - Render queue
   */;
  _proto.updatePassRenderFlag = function updatePassRenderFlag(renderQueue) {
    var items = renderQueue.items;
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
      var component = item.component;
      var receiveShadow = component.receiveShadow;
      var castShadow = component.castShadow;
      if (receiveShadow === true) {
        component.entity.layer |= Layer.Layer30; //SHADOW;
      } else if (receiveShadow === false) {
        component.entity.layer &= ~Layer.Layer30; //SHADOW;
      }

      if (castShadow === true) {
        component.entity.layer |= Layer.Layer31; //SHADOW_MAP;
      } else if (castShadow === false) {
        component.entity.layer &= ~Layer.Layer31; //SHADOW_MAP;
      }
    }
  };
  return ShadowFeature;
}(SceneFeature);

Scene.registerFeature(ShadowFeature);

Scene.registerFeature(LightFeature);
Scene.prototype.hasLight = hasLight;

export { AmbientLight, AnimationClip, AnimationClipCurveBinding, AnimationCurve, AnimationEvent, AnimationProperty, Animator, AnimatorConditionMode, AnimatorController, AnimatorControllerLayer, AnimatorLayerBlendingMode, AnimatorState, AnimatorStateMachine, AnimatorStateTransition, AssetPromise, AssetPromiseStatus, AssetType, Background, BackgroundMode, BackgroundTextureFillMode, BaseMaterial, BasicRenderPipeline, BlendFactor, BlendMode, BlendOperation, BlendShape, BlendShapeFrame, BlinnPhongMaterial, BoolUpdateFlag, BoxColliderShape, Buffer, BufferBindFlag, BufferMesh, BufferUsage, BufferUtil, Camera, CameraClearFlags, CapsuleColliderShape, CharacterController, CloneManager, Collider, ColliderShape, ColliderShapeUpAxis, CollisionDetectionMode, ColorSpace, ColorWriteMask, CompareFunction, Component, ControllerCollisionFlag, ControllerNonWalkableMode, CubeProbe, CullMode, DataType, DiffuseMode, DirectLight, DynamicCollider, DynamicColliderConstraints, EXP2Fog, Engine, EngineFeature, EngineObject, Entity, Event, EventDispatcher, FixedJoint, Fog, Font, FontStyle, GLCapabilityType, HingeJoint, HitResult, IndexBufferBinding, IndexFormat, InputManager, InterpolableKeyframe, InterpolableValueType, InterpolationType, Joint, JointLimits, JointMotor, Keyframe, Keys, Layer, Light, LinearFog, ListenerUpdateFlag, Loader, Logger, Material, Mesh, MeshRenderElement, MeshRenderer, MeshTopology, ModelMesh, ObjectValues, OverflowMode, PBRBaseMaterial, PBRMaterial, PBRSpecularMaterial, ParticleRenderer, ParticleRendererBlendMode, PhysicsManager, PhysicsMaterial, PhysicsMaterialCombineMode, PlaneColliderShape, PointLight, Pointer, PointerButton, PointerPhase, PrimitiveMesh, Probe, RefObject, RenderBufferDepthFormat, RenderFace, RenderPass, RenderQueue, RenderQueueType, RenderTarget, Renderer, ResourceManager, Scene, SceneFeature, SceneManager, Script, SetDataOptions, Shader, ShaderData, ShaderFactory, ShaderProperty, ShaderPropertyType, Skin, SkinnedMeshRenderer, Sky, SkyBoxMaterial, SphereColliderShape, SpotLight, SpringJoint, Sprite, SpriteAtlas, SpriteDrawMode, SpriteElement, SpriteMask, SpriteMaskInteraction, SpriteMaskLayer, SpriteRenderer, StateMachineScript, StaticCollider, StencilOperation, SubMesh, SystemInfo, TextHorizontalAlignment, TextRenderer, TextVerticalAlignment, Texture, Texture2D, Texture2DArray, TextureCoordinate, TextureCube, TextureCubeFace, TextureFilterMode, TextureFormat, TextureWrapMode, Time, TrailMaterial, TrailRenderer, Transform, UnlitMaterial, Util, VertexBufferBinding, VertexElement, VertexElementFormat, WrapMode, assignmentClone, deepClone, dependentComponents, ignoreClone, request, resourceLoader, shallowClone };
//# sourceMappingURL=module.js.map
