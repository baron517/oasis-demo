{"version":3,"file":"main.js","sources":["../src/DRACOWorker.ts","../src/worker/worker.js","../src/decoder.ts"],"sourcesContent":["import { Logger } from \"@oasis-engine/core\";\n\nexport class DRACOWorker {\n  // Worker instance.\n  private _worker: Worker;\n  // Record byteLength of each task.\n  private _costs: { [taskId: number]: number } = {};\n  // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.\n  private _currentLoad: number = 0;\n  private _callbacks: { [taskId: number]: IResolveReject } = {};\n  get currentLoad(): number {\n    return this._currentLoad;\n  }\n\n  constructor(workerSourceURL: string, decoderWASMBinary?: ArrayBuffer) {\n    this._worker = new Worker(workerSourceURL);\n    this._worker.onmessage = (e) => {\n      const message = e.data;\n      switch (message.type) {\n        case \"decode\":\n          this._callbacks[message.id].resolve(message.geometry);\n          break;\n\n        case \"error\":\n          this._callbacks[message.id].reject(message);\n          break;\n        default:\n          Logger.error('DRACOWorker: Unexpected message, \"' + message.type + '\"');\n      }\n    };\n    if (decoderWASMBinary) {\n      this._worker.postMessage({ type: \"init\", decoderConfig: { wasmBinary: decoderWASMBinary } });\n    } else {\n      this._worker.postMessage({ type: \"init\", decoderConfig: {} });\n    }\n  }\n\n  setCosts(taskId: number, cost: number) {\n    this._costs[taskId] = cost;\n  }\n\n  addCurrentLoad(cost: number) {\n    this._currentLoad += cost;\n  }\n\n  setCallback(taskId: number, resolve: (any) => void, reject: (any) => void) {\n    this._callbacks[taskId] = { resolve, reject };\n  }\n\n  decode(taskId: number, taskConfig: ITaskConfig, buffer: ArrayBuffer) {\n    this._worker.postMessage({ type: \"decode\", id: taskId, taskConfig, buffer }, [buffer]);\n  }\n\n  releaseTask(taskId: number) {\n    this._currentLoad -= this._costs[taskId];\n    delete this._callbacks[taskId];\n    delete this._costs[taskId];\n  }\n}\n\ninterface IResolveReject {\n  resolve: (any) => void;\n  reject: (any) => void;\n}\n\nexport interface ITaskConfig {\n  attributeIDs: { [attribute: string]: number };\n  attributeTypes: { [attribute: string]: string };\n  useUniqueIDs: boolean;\n  indexType: string;\n}\n","export default `let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n`;","import { Logger, request } from \"@oasis-engine/core\";\n\nimport { DRACOWorker, ITaskConfig } from \"./DRACOWorker\";\n\nimport workerString from \"./worker/worker.js\";\n\nconst LIB_PATH = \"https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/\";\nconst JS_FILE = \"draco_decoder_gltf.js\";\n\nconst WASM_FILE = \"draco_decoder_gltf.r3bin\";\nconst WASM_WRAPPER_FILE = \"draco_wasm_wrapper_gltf.js\";\n\nexport class DRACODecoder {\n  private pool: DRACOWorker[] = [];\n  private workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);\n  private useJS: boolean;\n  private currentTaskId: number = 1;\n  private taskCache = new WeakMap();\n  private loadLibPromise: Promise<any>;\n\n  constructor(config: IDecoderConfig = { type: \"wasm\", workerLimit: 4 }) {\n    if (config.workerLimit > this.workerLimit) {\n      Logger.warn(\"DRACOWorkerPool: Can not initialize worker pool with limit:\" + config.workerLimit);\n    } else {\n      this.workerLimit = config.workerLimit ?? 4;\n    }\n    this.useJS = typeof WebAssembly !== \"object\" || config.type === \"js\";\n    this.loadLibPromise = this.preloadLib();\n  }\n\n  private preloadLib(): Promise<any> {\n    if (this.loadLibPromise) {\n      return this.loadLibPromise;\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.useJS) {\n        request(`${LIB_PATH}${JS_FILE}`, { type: \"text\" })\n          .then((jsSource) => {\n            const body = [jsSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary: null });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      } else {\n        Promise.all([\n          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, { type: \"text\" }),\n          request(`${LIB_PATH}${WASM_FILE}`, { type: \"arraybuffer\" })\n        ])\n          .then((resources) => {\n            const [wrapperSource, decoderWASMBinary] = resources;\n            const body = [wrapperSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      }\n    });\n  }\n\n  private getWorker(): Promise<DRACOWorker> {\n    return this.preloadLib().then((worderResources) => {\n      if (this.pool.length < this.workerLimit) {\n        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);\n        this.pool.push(dracoWorker);\n      } else {\n        this.pool.sort(function (a, b) {\n          return a.currentLoad > b.currentLoad ? -1 : 1;\n        });\n      }\n      return this.pool[this.pool.length - 1];\n    });\n  }\n\n  decode(buffer: ArrayBuffer, taskConfig: ITaskConfig): Promise<any> {\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred.\n    // again from this thread.\n    if (this.taskCache.has(buffer)) {\n      const cachedTask = this.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          \"DRACODecoder: Unable to re-decode a buffer with different \" +\n            \"settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n\n    const taskId = this.currentTaskId++;\n    const cost = buffer.byteLength;\n    let taskWorker;\n    const task = new Promise((resolve, reject) => {\n      this.getWorker()\n        .then((worker) => {\n          taskWorker = worker;\n          worker.setCosts(taskId, cost);\n          worker.addCurrentLoad(cost);\n\n          worker.setCallback(taskId, resolve, reject);\n          worker.decode(taskId, taskConfig, buffer);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    task.finally(() => {\n      if (taskWorker && taskId) {\n        taskWorker.releaseTask(taskId);\n      }\n    });\n\n    this.taskCache.set(buffer, {\n      key: taskKey,\n      promise: task\n    });\n    return task;\n  }\n}\n\ninterface IDecoderConfig {\n  type?: \"js\" | \"wasm\";\n  workerLimit?: number;\n}\n"],"names":["DRACOWorker","workerSourceURL","decoderWASMBinary","_worker","_costs","_currentLoad","_callbacks","Worker","onmessage","e","message","data","type","id","resolve","geometry","reject","Logger","error","postMessage","decoderConfig","wasmBinary","setCosts","taskId","cost","addCurrentLoad","setCallback","decode","taskConfig","buffer","releaseTask","LIB_PATH","JS_FILE","WASM_FILE","WASM_WRAPPER_FILE","DRACODecoder","config","workerLimit","pool","Math","min","navigator","hardwareConcurrency","useJS","currentTaskId","taskCache","WeakMap","loadLibPromise","warn","WebAssembly","preloadLib","Promise","request","then","jsSource","body","workerString","join","URL","createObjectURL","Blob","catch","reason","all","resources","wrapperSource","getWorker","worderResources","length","dracoWorker","push","sort","a","b","currentLoad","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","taskWorker","task","worker","finally","set"],"mappings":"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"}