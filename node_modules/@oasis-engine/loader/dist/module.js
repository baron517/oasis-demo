import { resourceLoader, AssetType, AssetPromise, Loader, VertexElement, IndexFormat, VertexElementFormat, AnimationClip, InterpolationType, InterpolableValueType, AnimationCurve, InterpolableKeyframe, SkinnedMeshRenderer, Transform, Entity, PBRMaterial, TextureCoordinate, Logger, RenderFace, BlendShape, ModelMesh, BlinnPhongMaterial, Camera, Animator, AnimatorController, AnimatorControllerLayer, AnimatorStateMachine, MeshRenderer, Skin, TextureWrapMode as TextureWrapMode$1, Texture2D, EngineObject, TextureFormat, TextureCube, TextureCubeFace, Sprite, SpriteAtlas, TextureFilterMode, AmbientLight, DiffuseMode, DirectLight, PointLight, SpotLight, PBRSpecularMaterial, UnlitMaterial, Scene, AnimatorStateTransition, BackgroundMode, SkyBoxMaterial, PrimitiveMesh } from '@oasis-engine/core';
import { Vector2, Vector3, Vector4, Color, Quaternion, Matrix, Rect, SphericalHarmonics3 } from '@oasis-engine/math';
import { GLCompressedTextureInternalFormat } from '@oasis-engine/rhi-webgl';
import { DRACODecoder } from '@oasis-engine/draco';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var _dec$r, _class$r;
function isBase64(url) {
  return /^data:(.+?);base64,/.test(url);
}
(_dec$r = resourceLoader(AssetType.Buffer, ["bin", "r3bin"], false), _dec$r(_class$r = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(BufferLoader, _Loader);
  function BufferLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = BufferLoader.prototype;
  _proto.load = function load(item) {
    var url = item.url;
    if (isBase64(url)) {
      return new AssetPromise(function (resolve) {
        var base64Str = url.slice(13 + RegExp.$1.length);
        var result = Uint8Array.from(atob(base64Str), function (c) {
          return c.charCodeAt(0);
        });
        resolve(result.buffer);
      });
    }
    return this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
      type: "arraybuffer"
    }));
  };
  return BufferLoader;
}(Loader)) || _class$r);

/**
 * Module for glTF 2.0 Interface
 */

/**
 * The datatype of the components in the attribute
 */
var AccessorComponentType;

/**
 * Specifies if the attirbute is a scalar, vector, or matrix
 */
(function (AccessorComponentType) {
  AccessorComponentType[AccessorComponentType["BYTE"] = 5120] = "BYTE";
  AccessorComponentType[AccessorComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  AccessorComponentType[AccessorComponentType["SHORT"] = 5122] = "SHORT";
  AccessorComponentType[AccessorComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  AccessorComponentType[AccessorComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  AccessorComponentType[AccessorComponentType["FLOAT"] = 5126] = "FLOAT";
})(AccessorComponentType || (AccessorComponentType = {}));
var AccessorType;

/**
 * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates
 */
(function (AccessorType) {
  AccessorType["SCALAR"] = "SCALAR";
  AccessorType["VEC2"] = "VEC2";
  AccessorType["VEC3"] = "VEC3";
  AccessorType["VEC4"] = "VEC4";
  AccessorType["MAT2"] = "MAT2";
  AccessorType["MAT3"] = "MAT3";
  AccessorType["MAT4"] = "MAT4";
})(AccessorType || (AccessorType = {}));
var AnimationChannelTargetPath;

/**
 * Interpolation algorithm
 */
(function (AnimationChannelTargetPath) {
  AnimationChannelTargetPath["TRANSLATION"] = "translation";
  AnimationChannelTargetPath["ROTATION"] = "rotation";
  AnimationChannelTargetPath["SCALE"] = "scale";
  AnimationChannelTargetPath["WEIGHTS"] = "weights";
})(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
var AnimationSamplerInterpolation;

/**
 * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
 */
(function (AnimationSamplerInterpolation) {
  AnimationSamplerInterpolation["Linear"] = "LINEAR";
  AnimationSamplerInterpolation["Step"] = "STEP";
  AnimationSamplerInterpolation["CubicSpine"] = "CUBICSPLINE";
})(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
var CameraType;

/**
 * The mime-type of the image
 */
(function (CameraType) {
  CameraType["PERSPECTIVE"] = "perspective";
  CameraType["ORTHOGRAPHIC"] = "orthographic";
})(CameraType || (CameraType = {}));
var ImageMimeType;

/**
 * The alpha rendering mode of the material
 */
(function (ImageMimeType) {
  ImageMimeType["JPEG"] = "image/jpeg";
  ImageMimeType["PNG"] = "image/png";
})(ImageMimeType || (ImageMimeType = {}));
var MaterialAlphaMode;

/**
 * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
 */
(function (MaterialAlphaMode) {
  MaterialAlphaMode["OPAQUE"] = "OPAQUE";
  MaterialAlphaMode["MASK"] = "MASK";
  MaterialAlphaMode["BLEND"] = "BLEND";
})(MaterialAlphaMode || (MaterialAlphaMode = {}));
var TextureMagFilter;

/**
 * Minification filter.  All valid values correspond to WebGL enums
 */
(function (TextureMagFilter) {
  TextureMagFilter[TextureMagFilter["NEAREST"] = 9728] = "NEAREST";
  TextureMagFilter[TextureMagFilter["LINEAR"] = 9729] = "LINEAR";
})(TextureMagFilter || (TextureMagFilter = {}));
var TextureMinFilter;

/**
 * S (U) wrapping mode.  All valid values correspond to WebGL enums
 */
(function (TextureMinFilter) {
  TextureMinFilter[TextureMinFilter["NEAREST"] = 9728] = "NEAREST";
  TextureMinFilter[TextureMinFilter["LINEAR"] = 9729] = "LINEAR";
  TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureMinFilter || (TextureMinFilter = {}));
var TextureWrapMode;

/**
 * glTF Property
 */
(function (TextureWrapMode) {
  TextureWrapMode[TextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  TextureWrapMode[TextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode || (TextureWrapMode = {}));

/**
 * @internal
 */
var GLTFUtil = /*#__PURE__*/function () {
  function GLTFUtil() {}
  GLTFUtil.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 2);
    for (var i = 0; i < bufferLen; i += 2) {
      array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
    }
    return array;
  };
  GLTFUtil.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 3);
    for (var i = 0; i < bufferLen; i += 3) {
      array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
    }
    return array;
  };
  GLTFUtil.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 4);
    for (var i = 0; i < bufferLen; i += 4) {
      array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
    }
    return array;
  };
  GLTFUtil.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
    var bufferLen = buffer.length;
    var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
    if (isColor3) {
      for (var i = 0; i < bufferLen; i += 3) {
        colors[i / 3] = new Color(buffer[i], buffer[i + 1], buffer[i + 2], 1.0);
      }
    } else {
      for (var _i = 0; _i < bufferLen; _i += 4) {
        colors[_i / 4] = new Color(buffer[_i], buffer[_i + 1], buffer[_i + 2], buffer[_i + 3]);
      }
    }
    return colors;
  }

  /**
   * Parse binary text for glb loader.
   */;
  GLTFUtil.decodeText = function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }

    // TextDecoder polyfill
    var s = "";
    for (var i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    return decodeURIComponent(encodeURIComponent(s));
  }

  /**
   * Get the number of bytes occupied by accessor type.
   */;
  GLTFUtil.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
    switch (accessorType) {
      case AccessorType.SCALAR:
        return 1;
      case AccessorType.VEC2:
        return 2;
      case AccessorType.VEC3:
        return 3;
      case AccessorType.VEC4:
        return 4;
      case AccessorType.MAT2:
        return 4;
      case AccessorType.MAT3:
        return 9;
      case AccessorType.MAT4:
        return 16;
    }
  }

  /**
   * Get the TypedArray corresponding to the component type.
   */;
  GLTFUtil.getComponentType = function getComponentType(componentType) {
    switch (componentType) {
      case AccessorComponentType.BYTE:
        return Int8Array;
      case AccessorComponentType.UNSIGNED_BYTE:
        return Uint8Array;
      case AccessorComponentType.SHORT:
        return Int16Array;
      case AccessorComponentType.UNSIGNED_SHORT:
        return Uint16Array;
      case AccessorComponentType.UNSIGNED_INT:
        return Uint32Array;
      case AccessorComponentType.FLOAT:
        return Float32Array;
    }
  }

  /**
   * Get accessor data.
   */;
  GLTFUtil.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
    var _bufferView$byteStrid;
    var bufferViews = gltf.bufferViews;
    var bufferView = bufferViews[accessor.bufferView];
    var arrayBuffer = buffers[bufferView.buffer];
    var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
    var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
    var byteOffset = accessorByteOffset + bufferViewByteOffset;
    var accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);
    var length = accessorTypeSize * accessor.count;
    var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
    var arrayType = GLTFUtil.getComponentType(accessor.componentType);
    var uint8Array;
    if (byteStride) {
      var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
      uint8Array = new Uint8Array(accessor.count * accessorByteSize);
      var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
      for (var i = 0; i < accessor.count; i++) {
        for (var j = 0; j < accessorByteSize; j++) {
          uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
        }
      }
    } else {
      uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));
    }
    var typedArray = new arrayType(uint8Array.buffer);
    if (accessor.sparse) {
      var _indices$byteOffset, _indicesBufferView$by, _values$byteOffset, _valuesBufferView$byt;
      var _accessor$sparse = accessor.sparse,
        count = _accessor$sparse.count,
        indices = _accessor$sparse.indices,
        values = _accessor$sparse.values;
      var indicesBufferView = bufferViews[indices.bufferView];
      var valuesBufferView = bufferViews[values.bufferView];
      var indicesArrayBuffer = buffers[indicesBufferView.buffer];
      var valuesArrayBuffer = buffers[valuesBufferView.buffer];
      var indicesByteOffset = ((_indices$byteOffset = indices.byteOffset) != null ? _indices$byteOffset : 0) + ((_indicesBufferView$by = indicesBufferView.byteOffset) != null ? _indicesBufferView$by : 0);
      var indicesByteLength = indicesBufferView.byteLength;
      var valuesByteOffset = ((_values$byteOffset = values.byteOffset) != null ? _values$byteOffset : 0) + ((_valuesBufferView$byt = valuesBufferView.byteOffset) != null ? _valuesBufferView$byt : 0);
      var valuesByteLength = valuesBufferView.byteLength;
      var indicesType = GLTFUtil.getComponentType(indices.componentType);
      var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
      var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
      for (var _i2 = 0; _i2 < count; _i2++) {
        var replaceIndex = indicesArray[_i2];
        for (var _j = 0; _j < accessorTypeSize; _j++) {
          typedArray[replaceIndex * accessorTypeSize + _j] = valuesArray[_i2 * accessorTypeSize + _j];
        }
      }
    }
    return typedArray;
  };
  GLTFUtil.getBufferViewData = function getBufferViewData(bufferView, buffers) {
    var buffer = bufferView.buffer,
      _bufferView$byteOffse = bufferView.byteOffset,
      byteOffset = _bufferView$byteOffse === void 0 ? 0 : _bufferView$byteOffse,
      byteLength = bufferView.byteLength;
    var arrayBuffer = buffers[buffer];
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
  };
  GLTFUtil.getVertexStride = function getVertexStride(gltf, accessor) {
    var _accessor$bufferView;
    var stride = gltf.bufferViews[(_accessor$bufferView = accessor.bufferView) != null ? _accessor$bufferView : 0].byteStride;
    if (stride) {
      return stride;
    }
    var size = GLTFUtil.getAccessorTypeSize(accessor.type);
    var componentType = GLTFUtil.getComponentType(accessor.componentType);
    return size * componentType.BYTES_PER_ELEMENT;
  };
  GLTFUtil.createVertexElement = function createVertexElement(semantic, accessor, index) {
    var size = GLTFUtil.getAccessorTypeSize(accessor.type);
    return new VertexElement(semantic, 0, GLTFUtil.getElementFormat(accessor.componentType, size, accessor.normalized), index);
  };
  GLTFUtil.getIndexFormat = function getIndexFormat(type) {
    switch (type) {
      case AccessorComponentType.UNSIGNED_BYTE:
        return IndexFormat.UInt8;
      case AccessorComponentType.UNSIGNED_SHORT:
        return IndexFormat.UInt16;
      case AccessorComponentType.UNSIGNED_INT:
        return IndexFormat.UInt32;
    }
  };
  GLTFUtil.getElementFormat = function getElementFormat(type, size, normalized) {
    if (normalized === void 0) {
      normalized = false;
    }
    if (type == AccessorComponentType.FLOAT) {
      switch (size) {
        case 1:
          return VertexElementFormat.Float;
        case 2:
          return VertexElementFormat.Vector2;
        case 3:
          return VertexElementFormat.Vector3;
        case 4:
          return VertexElementFormat.Vector4;
      }
    }
    if (type == AccessorComponentType.SHORT) {
      switch (size) {
        case 2:
          return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
      }
    }
    if (type == AccessorComponentType.UNSIGNED_SHORT) {
      switch (size) {
        case 2:
          return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
      }
    }
    if (type == AccessorComponentType.BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
      }
    }
    if (type == AccessorComponentType.UNSIGNED_BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
      }
    }
  }

  /**
   * Load image buffer
   */;
  GLTFUtil.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
    return new Promise(function (resolve, reject) {
      var blob = new window.Blob([imageBuffer], {
        type: type
      });
      var img = new Image();
      img.onerror = function () {
        reject(new Error("Failed to load image buffer"));
      };
      img.onload = function () {
        // Call requestAnimationFrame to avoid iOS's bug.
        requestAnimationFrame(function () {
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
      };
      img.crossOrigin = "anonymous";
      img.src = URL.createObjectURL(blob);
    });
  };
  GLTFUtil.isAbsoluteUrl = function isAbsoluteUrl(url) {
    return /^(?:http|blob|data:|\/)/.test(url);
  };
  GLTFUtil.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
    if (GLTFUtil.isAbsoluteUrl(relativeUrl)) {
      return relativeUrl;
    }
    var char0 = relativeUrl.charAt(0);
    if (char0 === ".") {
      return GLTFUtil._formatRelativePath(relativeUrl + relativeUrl);
    }
    return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
  }

  /**
   * Parse the glb format.
   */;
  GLTFUtil.parseGLB = function parseGLB(glb) {
    var UINT32_LENGTH = 4;
    var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'
    var GLB_HEADER_LENGTH = 12;
    var GLB_CHUNK_TYPES = {
      JSON: 0x4e4f534a,
      BIN: 0x004e4942
    };
    var dataView = new DataView(glb);

    // read header
    var header = {
      magic: dataView.getUint32(0, true),
      version: dataView.getUint32(UINT32_LENGTH, true),
      length: dataView.getUint32(2 * UINT32_LENGTH, true)
    };
    if (header.magic !== GLB_HEADER_MAGIC) {
      console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
      return null;
    }

    // read main data
    var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
    var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);

    // read glTF json
    if (chunkType !== GLB_CHUNK_TYPES.JSON) {
      console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
      return null;
    }
    var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
    var gltf = JSON.parse(GLTFUtil.decodeText(glTFData));

    // read all buffers
    var buffers = [];
    var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
    while (byteOffset < header.length) {
      chunkLength = dataView.getUint32(byteOffset, true);
      chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
      if (chunkType !== GLB_CHUNK_TYPES.BIN) {
        console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
        return null;
      }
      var currentOffset = byteOffset + 2 * UINT32_LENGTH;
      var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
      buffers.push(buffer);
      byteOffset += chunkLength + 2 * UINT32_LENGTH;
    }
    return {
      gltf: gltf,
      buffers: buffers
    };
  };
  GLTFUtil._formatRelativePath = function _formatRelativePath(value) {
    var parts = value.split("/");
    for (var i = 0, n = parts.length; i < n; i++) {
      if (parts[i] == "..") {
        parts.splice(i - 1, 2);
        i -= 2;
      }
    }
    return parts.join("/");
  };
  return GLTFUtil;
}();

var Parser = /*#__PURE__*/function () {
  function Parser() {}
  Parser.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
    var parsers = Parser._extensionParsers[extensionName];
    if (parsers !== null && parsers !== void 0 && parsers.length) {
      for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        extra[_key - 4] = arguments[_key];
      }
      for (var i = 0; i < parsers.length; i++) {
        var _parsers$i;
        (_parsers$i = parsers[i]).parseEngineResource.apply(_parsers$i, [extensionSchema, parseResource, context].concat(extra));
      }
    }
  };
  Parser.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
    var parsers = Parser._extensionParsers[extensionName];
    if (parsers !== null && parsers !== void 0 && parsers.length) {
      var _parsers$;
      for (var _len2 = arguments.length, extra = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        extra[_key2 - 3] = arguments[_key2];
      }
      return (_parsers$ = parsers[0]).createEngineResource.apply(_parsers$, [extensionSchema, context].concat(extra));
    }
  };
  Parser.hasExtensionParser = function hasExtensionParser(extensionName) {
    var parsers = Parser._extensionParsers[extensionName];
    return !!(parsers !== null && parsers !== void 0 && parsers.length);
  };
  Parser.initialize = function initialize(extensionName) {
    var parsers = Parser._extensionParsers[extensionName];
    if (parsers !== null && parsers !== void 0 && parsers.length) {
      for (var i = 0; i < parsers.length; i++) {
        parsers[i].initialize();
      }
    }
  }

  /**
   * @internal
   */;
  Parser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
    if (!Parser._extensionParsers[extensionName]) {
      Parser._extensionParsers[extensionName] = [];
    }
    Parser._extensionParsers[extensionName].push(extensionParser);
  };
  return Parser;
}();

/**
 * Declare ExtensionParser's decorator.
 * @param extensionName - Extension name
 */
Parser._extensionParsers = {};
function registerExtension(extensionName) {
  return function (parser) {
    var extensionParser = new parser();
    Parser._addExtensionParser(extensionName, extensionParser);
  };
}

var AnimationParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(AnimationParser, _Parser);
  function AnimationParser() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = AnimationParser.prototype;
  _proto.parse = function parse(context) {
    var gltf = context.gltf,
      buffers = context.buffers,
      entities = context.entities;
    var animations = gltf.animations,
      accessors = gltf.accessors;
    if (!animations) {
      return;
    }
    var animationClipCount = animations.length;
    var animationClips = new Array(animationClipCount);
    var animationsIndices = new Array(animationClipCount);
    for (var i = 0; i < animationClipCount; i++) {
      var gltfAnimation = animations[i];
      var channels = gltfAnimation.channels,
        samplers = gltfAnimation.samplers,
        _gltfAnimation$name = gltfAnimation.name,
        name = _gltfAnimation$name === void 0 ? "AnimationClip" + i : _gltfAnimation$name;
      var animationClip = new AnimationClip(name);
      var sampleDataCollection = new Array();

      // parse samplers
      for (var _i = 0; _i < samplers.length; _i++) {
        var _gltfSampler$interpol;
        var gltfSampler = samplers[_i];
        var inputAccessor = accessors[gltfSampler.input];
        var outputAccessor = accessors[gltfSampler.output];
        var input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);
        var output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);
        var outputAccessorSize = output.length / input.length;
        var interpolation = (_gltfSampler$interpol = gltfSampler.interpolation) != null ? _gltfSampler$interpol : AnimationSamplerInterpolation.Linear;
        var samplerInterpolation = void 0;
        switch (interpolation) {
          case AnimationSamplerInterpolation.CubicSpine:
            samplerInterpolation = InterpolationType.CubicSpine;
            break;
          case AnimationSamplerInterpolation.Step:
            samplerInterpolation = InterpolationType.Step;
            break;
          case AnimationSamplerInterpolation.Linear:
            samplerInterpolation = InterpolationType.Linear;
            break;
        }
        input[input.length - 1];
        sampleDataCollection.push({
          type: outputAccessor.type,
          interpolation: samplerInterpolation,
          input: input,
          output: output,
          outputSize: outputAccessorSize
        });
      }
      for (var _i2 = 0; _i2 < channels.length; _i2++) {
        var gltfChannel = channels[_i2];
        var target = gltfChannel.target;
        var channelTargetEntity = entities[target.node];
        var relativePath = "";
        var entity = channelTargetEntity;
        while (entity.parent) {
          relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
          entity = entity.parent;
        }
        var compType = void 0;
        var propertyName = void 0;
        var interpolableValueType = void 0;
        switch (target.path) {
          case AnimationChannelTargetPath.TRANSLATION:
            compType = Transform;
            propertyName = "position";
            interpolableValueType = InterpolableValueType.Vector3;
            break;
          case AnimationChannelTargetPath.ROTATION:
            compType = Transform;
            propertyName = "rotation";
            interpolableValueType = InterpolableValueType.Quaternion;
            break;
          case AnimationChannelTargetPath.SCALE:
            compType = Transform;
            propertyName = "scale";
            interpolableValueType = InterpolableValueType.Vector3;
            break;
          case AnimationChannelTargetPath.WEIGHTS:
            compType = SkinnedMeshRenderer;
            propertyName = "blendShapeWeights";
            interpolableValueType = InterpolableValueType.FloatArray;
            break;
        }
        var curve = this._addCurve(interpolableValueType, gltfChannel, sampleDataCollection);
        animationClip.addCurveBinding(relativePath, compType, propertyName, curve);
      }
      animationClips[i] = animationClip;
      animationsIndices[i] = {
        name: name,
        index: i
      };
    }
    context.animations = animationClips;
    // @ts-ignore for editor
    context._animationsIndices = animationsIndices;
  };
  _proto._addCurve = function _addCurve(interpolableValueType, gltfChannel, sampleDataCollection) {
    var curve = new AnimationCurve();
    var sampleData = sampleDataCollection[gltfChannel.sampler];
    var input = sampleData.input,
      output = sampleData.output,
      outputSize = sampleData.outputSize;
    curve.interpolation = sampleData.interpolation;
    for (var j = 0, n = input.length; j < n; j++) {
      var offset = j * outputSize;
      if (interpolableValueType === InterpolableValueType.Float) {
        var keyframe = new InterpolableKeyframe();
        keyframe.time = input[j];
        keyframe.inTangent = 0;
        keyframe.outTangent = 0;
        keyframe.value = output[offset];
        curve.addKey(keyframe);
      } else if (interpolableValueType === InterpolableValueType.FloatArray) {
        var _keyframe = new InterpolableKeyframe();
        _keyframe.time = input[j];
        _keyframe.inTangent = new Float32Array(outputSize);
        _keyframe.outTangent = new Float32Array(outputSize);
        _keyframe.value = output.subarray(offset, offset + outputSize);
        curve.addKey(_keyframe);
      } else if (interpolableValueType === InterpolableValueType.Vector2) {
        var _keyframe2 = new InterpolableKeyframe();
        _keyframe2.time = input[j];
        _keyframe2.value = new Vector2(output[offset], output[offset + 1]);
        _keyframe2.inTangent = new Vector2();
        _keyframe2.outTangent = new Vector2();
        curve.addKey(_keyframe2);
      } else if (interpolableValueType === InterpolableValueType.Vector3) {
        var _keyframe3 = new InterpolableKeyframe();
        _keyframe3.time = input[j];
        _keyframe3.value = new Vector3(output[offset], output[offset + 1], output[offset + 2]);
        _keyframe3.inTangent = new Vector3();
        _keyframe3.outTangent = new Vector3();
        curve.addKey(_keyframe3);
      } else if (interpolableValueType === InterpolableValueType.Vector4) {
        var _keyframe4 = new InterpolableKeyframe();
        _keyframe4.time = input[j];
        _keyframe4.value = new Vector4(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
        _keyframe4.inTangent = new Vector4();
        _keyframe4.outTangent = new Vector4();
        curve.addKey(_keyframe4);
      } else if (interpolableValueType === InterpolableValueType.Quaternion) {
        var _keyframe5 = new InterpolableKeyframe();
        _keyframe5.time = input[j];
        _keyframe5.value = new Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
        _keyframe5.inTangent = new Vector4();
        _keyframe5.outTangent = new Vector4();
        curve.addKey(_keyframe5);
      }
    }
    return curve;
  };
  return AnimationParser;
}(Parser);

var BufferParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(BufferParser, _Parser);
  function BufferParser() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = BufferParser.prototype;
  _proto.parse = function parse(context) {
    var url = context.url,
      engine = context.engine;
    if (this._isGLB(url)) {
      return engine.resourceManager.load({
        url: url,
        type: AssetType.Buffer
      }).then(GLTFUtil.parseGLB).then(function (_ref) {
        var gltf = _ref.gltf,
          buffers = _ref.buffers;
        context.gltf = gltf;
        context.buffers = buffers;
      });
    } else {
      return engine.resourceManager.load({
        url: url,
        type: AssetType.JSON
      }).then(function (gltf) {
        context.gltf = gltf;
        return Promise.all(gltf.buffers.map(function (buffer) {
          return engine.resourceManager.load({
            type: AssetType.Buffer,
            url: GLTFUtil.parseRelativeUrl(url, buffer.uri)
          });
        })).then(function (buffers) {
          context.buffers = buffers;
        });
      });
    }
  };
  _proto._isGLB = function _isGLB(url) {
    return url.substring(url.lastIndexOf(".") + 1) === "glb";
  };
  return BufferParser;
}(Parser);

var EntityParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(EntityParser, _Parser);
  function EntityParser() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = EntityParser.prototype;
  /** @internal */
  _proto.parse = function parse(context) {
    var engine = context.engine,
      nodes = context.gltf.nodes;
    if (!nodes) return;
    var entities = [];
    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var matrix = gltfNode.matrix,
        translation = gltfNode.translation,
        rotation = gltfNode.rotation,
        scale = gltfNode.scale;
      var entity = new Entity(engine, gltfNode.name || "" + EntityParser._defaultName + i);
      var _entity = entity,
        transform = _entity.transform;
      if (matrix) {
        var localMatrix = transform.localMatrix;
        localMatrix.copyFromArray(matrix);
        transform.localMatrix = localMatrix;
      } else {
        if (translation) {
          transform.setPosition(translation[0], translation[1], translation[2]);
        }
        if (rotation) {
          transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
        }
        if (scale) {
          transform.setScale(scale[0], scale[1], scale[2]);
        }
      }
      entities[i] = entity;
    }
    context.entities = entities;
    this._buildEntityTree(context);
    this._createSceneRoots(context);
  };
  _proto._buildEntityTree = function _buildEntityTree(context) {
    var nodes = context.gltf.nodes,
      entities = context.entities;
    for (var i = 0; i < nodes.length; i++) {
      var children = nodes[i].children;
      var entity = entities[i];
      if (children) {
        for (var j = 0; j < children.length; j++) {
          var childEntity = entities[children[j]];
          entity.addChild(childEntity);
        }
      }
    }
  };
  _proto._createSceneRoots = function _createSceneRoots(context) {
    var engine = context.engine,
      _context$gltf = context.gltf,
      _context$gltf$scene = _context$gltf.scene,
      sceneID = _context$gltf$scene === void 0 ? 0 : _context$gltf$scene,
      scenes = _context$gltf.scenes,
      entities = context.entities;
    if (!scenes) return;
    var sceneRoots = [];
    for (var i = 0; i < scenes.length; i++) {
      var nodes = scenes[i].nodes;
      if (!nodes) continue;
      if (nodes.length === 1) {
        sceneRoots[i] = entities[nodes[0]];
      } else {
        var rootEntity = new Entity(engine, "GLTF_ROOT");
        for (var j = 0; j < nodes.length; j++) {
          rootEntity.addChild(entities[nodes[j]]);
        }
        sceneRoots[i] = rootEntity;
      }
    }
    context.sceneRoots = sceneRoots;
    context.defaultSceneRoot = sceneRoots[sceneID];
  };
  return EntityParser;
}(Parser);
EntityParser._defaultName = "_GLTF_ENTITY_";

var MaterialParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(MaterialParser, _Parser);
  function MaterialParser() {
    return _Parser.apply(this, arguments) || this;
  }
  /** @internal */
  MaterialParser._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
    if (extensions === void 0) {
      extensions = {};
    }
    var schema = extensions.KHR_texture_transform;
    if (schema) {
      Parser.parseEngineResource("KHR_texture_transform", schema, material, context);
    }
  };
  var _proto = MaterialParser.prototype;
  _proto.parse = function parse(context) {
    var gltf = context.gltf,
      engine = context.engine,
      textures = context.textures;
    if (!gltf.materials) return;
    var materials = [];
    for (var i = 0; i < gltf.materials.length; i++) {
      var _gltf$materials$i = gltf.materials[i],
        _gltf$materials$i$ext = _gltf$materials$i.extensions,
        extensions = _gltf$materials$i$ext === void 0 ? {} : _gltf$materials$i$ext,
        pbrMetallicRoughness = _gltf$materials$i.pbrMetallicRoughness,
        normalTexture = _gltf$materials$i.normalTexture,
        occlusionTexture = _gltf$materials$i.occlusionTexture,
        emissiveTexture = _gltf$materials$i.emissiveTexture,
        emissiveFactor = _gltf$materials$i.emissiveFactor,
        alphaMode = _gltf$materials$i.alphaMode,
        alphaCutoff = _gltf$materials$i.alphaCutoff,
        doubleSided = _gltf$materials$i.doubleSided,
        _gltf$materials$i$nam = _gltf$materials$i.name,
        name = _gltf$materials$i$nam === void 0 ? "" : _gltf$materials$i$nam;
      var KHR_materials_unlit = extensions.KHR_materials_unlit,
        KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness,
        KHR_materials_clearcoat = extensions.KHR_materials_clearcoat,
        OASIS_materials_remap = extensions.OASIS_materials_remap;
      var material = null;
      if (KHR_materials_unlit) {
        material = Parser.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
      } else if (KHR_materials_pbrSpecularGlossiness) {
        material = Parser.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
      } else {
        material = new PBRMaterial(engine);
      }
      material.name = name;
      if (KHR_materials_clearcoat) {
        Parser.parseEngineResource("KHR_materials_clearcoat", KHR_materials_clearcoat, material, context);
      }
      if (pbrMetallicRoughness) {
        var baseColorFactor = pbrMetallicRoughness.baseColorFactor,
          baseColorTexture = pbrMetallicRoughness.baseColorTexture,
          metallicFactor = pbrMetallicRoughness.metallicFactor,
          roughnessFactor = pbrMetallicRoughness.roughnessFactor,
          metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
        if (baseColorFactor) {
          material.baseColor = new Color(Color.linearToGammaSpace(baseColorFactor[0]), Color.linearToGammaSpace(baseColorFactor[1]), Color.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
        }
        if (baseColorTexture) {
          material.baseTexture = textures[baseColorTexture.index];
          MaterialParser._parseTextureTransform(material, baseColorTexture.extensions, context);
        }
        if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
          var m = material;
          m.metallic = metallicFactor != null ? metallicFactor : 1;
          m.roughness = roughnessFactor != null ? roughnessFactor : 1;
          if (metallicRoughnessTexture) {
            m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
            MaterialParser._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
          }
        }
      }
      if (!KHR_materials_unlit) {
        var _m = material;
        if (emissiveTexture) {
          _m.emissiveTexture = textures[emissiveTexture.index];
          MaterialParser._parseTextureTransform(material, emissiveTexture.extensions, context);
        }
        if (emissiveFactor) {
          _m.emissiveColor = new Color(Color.linearToGammaSpace(emissiveFactor[0]), Color.linearToGammaSpace(emissiveFactor[1]), Color.linearToGammaSpace(emissiveFactor[2]));
        }
        if (normalTexture) {
          var index = normalTexture.index,
            scale = normalTexture.scale;
          _m.normalTexture = textures[index];
          MaterialParser._parseTextureTransform(material, normalTexture.extensions, context);
          if (scale !== undefined) {
            _m.normalTextureIntensity = scale;
          }
        }
        if (occlusionTexture) {
          var _index = occlusionTexture.index,
            strength = occlusionTexture.strength,
            texCoord = occlusionTexture.texCoord;
          _m.occlusionTexture = textures[_index];
          MaterialParser._parseTextureTransform(material, occlusionTexture.extensions, context);
          if (strength !== undefined) {
            _m.occlusionTextureIntensity = strength;
          }
          if (texCoord === TextureCoordinate.UV1) {
            _m.occlusionTextureCoord = TextureCoordinate.UV1;
          } else if (texCoord > TextureCoordinate.UV1) {
            Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
          }
        }
      }
      if (OASIS_materials_remap) {
        var _context$gltf$extensi, _context$gltf$extensi2;
        context.gltf.extensions = (_context$gltf$extensi = context.gltf.extensions) != null ? _context$gltf$extensi : {};
        context.gltf.extensions["OASIS_materials_remap"] = (_context$gltf$extensi2 = context.gltf.extensions["OASIS_materials_remap"]) != null ? _context$gltf$extensi2 : {};
        context.gltf.extensions["OASIS_materials_remap"][i] = Parser.createEngineResource("OASIS_materials_remap", OASIS_materials_remap, context);
      }
      if (doubleSided) {
        material.renderFace = RenderFace.Double;
      } else {
        material.renderFace = RenderFace.Front;
      }
      switch (alphaMode) {
        case MaterialAlphaMode.OPAQUE:
          material.isTransparent = false;
          break;
        case MaterialAlphaMode.BLEND:
          material.isTransparent = true;
          break;
        case MaterialAlphaMode.MASK:
          material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
          break;
      }
      materials[i] = material;
    }
    context.materials = materials;
  };
  return MaterialParser;
}(Parser);

var MeshParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(MeshParser, _Parser);
  function MeshParser() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = MeshParser.prototype;
  _proto.parse = function parse(context) {
    var _this = this;
    var engine = context.engine,
      gltf = context.gltf,
      buffers = context.buffers;
    if (!gltf.meshes) return;
    var meshPromises = [];
    var _loop = function _loop(i) {
      var gltfMesh = gltf.meshes[i];
      var primitivePromises = [];
      var _loop2 = function _loop2(j) {
        var gltfPrimitive = gltfMesh.primitives[j];
        var _gltfPrimitive$extens = gltfPrimitive.extensions,
          extensions = _gltfPrimitive$extens === void 0 ? {} : _gltfPrimitive$extens;
        var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
        primitivePromises.push(new Promise(function (resolve) {
          var mesh = new ModelMesh(engine, gltfMesh.name || j + "");
          if (KHR_draco_mesh_compression) {
            Parser.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function (decodedGeometry) {
              return _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
                for (var _j = 0; _j < decodedGeometry.attributes.length; _j++) {
                  if (decodedGeometry.attributes[_j].name === attributeSemantic) {
                    return decodedGeometry.attributes[_j].array;
                  }
                }
                return null;
              }, function (attributeSemantic, shapeIndex) {
                throw "BlendShape animation is not supported when using draco.";
              }, function () {
                return decodedGeometry.index.array;
              }, engine);
            }).then(resolve);
          } else {
            _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
              var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
              var accessor = gltf.accessors[accessorIdx];
              return GLTFUtil.getAccessorData(gltf, accessor, buffers);
            }, function (attributeName, shapeIndex) {
              var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
              var attributeAccessorIdx = shapeAccessorIdx[attributeName];
              if (attributeAccessorIdx) {
                var accessor = gltf.accessors[attributeAccessorIdx];
                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
              } else {
                return null;
              }
            }, function () {
              var indexAccessor = gltf.accessors[gltfPrimitive.indices];
              return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
            }, engine).then(resolve);
          }
        }));
      };
      for (var j = 0; j < gltfMesh.primitives.length; j++) {
        _loop2(j);
      }
      meshPromises.push(Promise.all(primitivePromises));
    };
    for (var i = 0; i < gltf.meshes.length; i++) {
      _loop(i);
    }
    return Promise.all(meshPromises).then(function (meshes) {
      context.meshes = meshes;
    });
  };
  _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, engine) {
    var attributes = gltfPrimitive.attributes,
      targets = gltfPrimitive.targets,
      indices = gltfPrimitive.indices,
      mode = gltfPrimitive.mode;
    var vertexCount;
    var accessors = gltf.accessors;
    var accessor = accessors[attributes["POSITION"]];
    var positionBuffer = getVertexBufferData("POSITION");
    var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
    mesh.setPositions(positions);
    var bounds = mesh.bounds;
    vertexCount = accessor.count;
    if (accessor.min && accessor.max) {
      bounds.min.copyFromArray(accessor.min);
      bounds.max.copyFromArray(accessor.max);
    } else {
      var position = MeshParser._tempVector3;
      var min = bounds.min,
        max = bounds.max;
      min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      var stride = positionBuffer.length / vertexCount;
      for (var j = 0; j < vertexCount; j++) {
        var offset = j * stride;
        position.copyFromArray(positionBuffer, offset);
        Vector3.min(min, position, min);
        Vector3.max(max, position, max);
      }
    }
    for (var attributeSemantic in attributes) {
      if (attributeSemantic === "POSITION") {
        continue;
      }
      var bufferData = getVertexBufferData(attributeSemantic);
      switch (attributeSemantic) {
        case "NORMAL":
          var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
          mesh.setNormals(normals);
          break;
        case "TEXCOORD_0":
          var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords, 0);
          break;
        case "TEXCOORD_1":
          var texturecoords1 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords1, 1);
          break;
        case "TEXCOORD_2":
          var texturecoords2 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords2, 2);
          break;
        case "TEXCOORD_3":
          var texturecoords3 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords3, 3);
          break;
        case "TEXCOORD_4":
          var texturecoords4 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords4, 4);
          break;
        case "TEXCOORD_5":
          var texturecoords5 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords5, 5);
          break;
        case "TEXCOORD_6":
          var texturecoords6 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords6, 6);
          break;
        case "TEXCOORD_7":
          var texturecoords7 = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords7, 7);
          break;
        case "COLOR_0":
          var colors = GLTFUtil.floatBufferToColorArray(bufferData, accessors[attributes["COLOR_0"]].type === AccessorType.VEC3);
          mesh.setColors(colors);
          break;
        case "TANGENT":
          var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setTangents(tangents);
          break;
        case "JOINTS_0":
          var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setBoneIndices(joints);
          break;
        case "WEIGHTS_0":
          var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setBoneWeights(weights);
          break;
      }
    }

    // Indices
    if (indices !== undefined) {
      var indexAccessor = gltf.accessors[indices];
      var indexData = getIndexBufferData();
      mesh.setIndices(indexData);
      mesh.addSubMesh(0, indexAccessor.count, mode);
    } else {
      mesh.addSubMesh(0, vertexCount, mode);
    }

    // BlendShapes
    targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
    mesh.uploadData(true);
    return Promise.resolve(mesh);
  };
  _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
    var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
    for (var i = 0, n = glTFTargets.length; i < n; i++) {
      var _name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
      var deltaPosBuffer = getBlendShapeData("POSITION", i);
      var deltaNorBuffer = getBlendShapeData("NORMAL", i);
      var deltaTanBuffer = getBlendShapeData("TANGENT", i);
      var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
      var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
      var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
      var blendShape = new BlendShape(_name);
      blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);
      mesh.addBlendShape(blendShape);
    }
  };
  return MeshParser;
}(Parser);
MeshParser._tempVector3 = new Vector3();

var SceneParser$1 = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(SceneParser, _Parser);
  function SceneParser() {
    return _Parser.apply(this, arguments) || this;
  }
  SceneParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
    if (!SceneParser._defaultMaterial) {
      SceneParser._defaultMaterial = new BlinnPhongMaterial(engine);
    }
    return SceneParser._defaultMaterial;
  };
  var _proto = SceneParser.prototype;
  _proto.parse = function parse(context) {
    var _context$gltf = context.gltf,
      nodes = _context$gltf.nodes,
      gltfCameras = _context$gltf.cameras,
      entities = context.entities;
    if (!nodes) return;
    var promises = [];
    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var cameraID = gltfNode.camera,
        meshID = gltfNode.mesh,
        _gltfNode$extensions = gltfNode.extensions,
        extensions = _gltfNode$extensions === void 0 ? {} : _gltfNode$extensions;
      var KHR_lights_punctual = extensions.KHR_lights_punctual;
      var entity = entities[i];
      if (cameraID !== undefined) {
        this._createCamera(context, gltfCameras[cameraID], entity);
      }
      if (meshID !== undefined) {
        promises.push(this._createRenderer(context, gltfNode, entity));
      }
      if (KHR_lights_punctual) {
        var lightIndex = KHR_lights_punctual.light;
        var lights = context.gltf.extensions.KHR_lights_punctual.lights;
        Parser.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
      }
    }
    if (context.defaultSceneRoot) {
      this._createAnimator(context);
    }
    context.gltf.extensions && delete context.gltf.extensions["OASIS_materials_remap"];
    return Promise.all(promises);
  };
  _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
    var orthographic = cameraSchema.orthographic,
      perspective = cameraSchema.perspective,
      type = cameraSchema.type;
    var camera = entity.addComponent(Camera);
    if (type === CameraType.ORTHOGRAPHIC) {
      var xmag = orthographic.xmag,
        ymag = orthographic.ymag,
        zfar = orthographic.zfar,
        znear = orthographic.znear;
      camera.isOrthographic = true;
      if (znear !== undefined) {
        camera.nearClipPlane = znear;
      }
      if (zfar !== undefined) {
        camera.farClipPlane = zfar;
      }
      camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
    } else if (type === CameraType.PERSPECTIVE) {
      var aspectRatio = perspective.aspectRatio,
        yfov = perspective.yfov,
        _zfar = perspective.zfar,
        _znear = perspective.znear;
      if (aspectRatio !== undefined) {
        camera.aspectRatio = aspectRatio;
      }
      if (yfov !== undefined) {
        camera.fieldOfView = yfov * 180 / Math.PI;
      }
      if (_zfar !== undefined) {
        camera.farClipPlane = _zfar;
      }
      if (_znear !== undefined) {
        camera.nearClipPlane = _znear;
      }
    }
    if (!context.cameras) context.cameras = [];
    context.cameras.push(camera);
    // @todo: use engine camera by default
    camera.enabled = false;
  };
  _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
    var engine = context.engine,
      gltfMeshes = context.gltf.meshes,
      meshes = context.meshes,
      materials = context.materials,
      skins = context.skins;
    var meshID = gltfNode.mesh,
      skinID = gltfNode.skin;
    var glTFMesh = gltfMeshes[meshID];
    var gltfMeshPrimitives = glTFMesh.primitives;
    var blendShapeWeights = gltfNode.weights || glTFMesh.weights;
    var promises = [];
    var _loop = function _loop(i) {
      var mesh = meshes[meshID][i];
      var renderer = void 0;
      if (skinID !== undefined || blendShapeWeights) {
        var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
        skinRenderer.mesh = mesh;
        if (skinID !== undefined) {
          skinRenderer.skin = skins[skinID];
        }
        if (blendShapeWeights) {
          skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
        }
        renderer = skinRenderer;
      } else {
        renderer = entity.addComponent(MeshRenderer);
        renderer.mesh = mesh;
      }
      var materialIndex = gltfMeshPrimitives[i].material;
      var remapMaterials = context.gltf.extensions && context.gltf.extensions["OASIS_materials_remap"];
      if (remapMaterials && remapMaterials[materialIndex]) {
        promises.push(remapMaterials[materialIndex].then(function (mtl) {
          renderer.setMaterial(mtl);
        }));
      } else {
        var material = (materials === null || materials === void 0 ? void 0 : materials[materialIndex]) || SceneParser._getDefaultMaterial(engine);
        renderer.setMaterial(material);
      }
      var _gltfMeshPrimitives$i = gltfMeshPrimitives[i].extensions,
        extensions = _gltfMeshPrimitives$i === void 0 ? {} : _gltfMeshPrimitives$i;
      var KHR_materials_variants = extensions.KHR_materials_variants;
      if (KHR_materials_variants) {
        Parser.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
      }
    };
    for (var i = 0; i < gltfMeshPrimitives.length; i++) {
      _loop(i);
    }
    return Promise.all(promises);
  };
  _proto._createAnimator = function _createAnimator(context) {
    var defaultSceneRoot = context.defaultSceneRoot,
      animations = context.animations;
    if (!animations) return;
    var animator = defaultSceneRoot.addComponent(Animator);
    var animatorController = new AnimatorController();
    var layer = new AnimatorControllerLayer("layer");
    var animatorStateMachine = new AnimatorStateMachine();
    animatorController.addLayer(layer);
    animator.animatorController = animatorController;
    layer.stateMachine = animatorStateMachine;
    if (animations) {
      for (var i = 0; i < animations.length; i++) {
        var animationClip = animations[i];
        var name = animationClip.name;
        var uniqueName = animatorStateMachine.makeUniqueStateName(name);
        if (uniqueName !== name) {
          console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
        }
        var animatorState = animatorStateMachine.addState(uniqueName);
        animatorState.clip = animationClip;
      }
    }
  };
  return SceneParser;
}(Parser);
SceneParser$1._defaultMaterial = void 0;

var SkinParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(SkinParser, _Parser);
  function SkinParser() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = SkinParser.prototype;
  _proto.parse = function parse(context) {
    var gltf = context.gltf,
      buffers = context.buffers,
      entities = context.entities,
      defaultSceneRoot = context.defaultSceneRoot;
    var gltfSkins = gltf.skins;
    if (!gltfSkins) return;
    var skins = [];
    for (var i = 0; i < gltfSkins.length; i++) {
      var _gltfSkins$i = gltfSkins[i],
        inverseBindMatrices = _gltfSkins$i.inverseBindMatrices,
        skeleton = _gltfSkins$i.skeleton,
        joints = _gltfSkins$i.joints,
        _gltfSkins$i$name = _gltfSkins$i.name,
        name = _gltfSkins$i$name === void 0 ? "SKIN_" + i : _gltfSkins$i$name;
      var jointCount = joints.length;
      var skin = new Skin(name);
      skin.inverseBindMatrices.length = jointCount;

      // parse IBM
      var accessor = gltf.accessors[inverseBindMatrices];
      var buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);
      for (var _i = 0; _i < jointCount; _i++) {
        var inverseBindMatrix = new Matrix();
        inverseBindMatrix.copyFromArray(buffer, _i * 16);
        skin.inverseBindMatrices[_i] = inverseBindMatrix;
      }

      // get joints
      for (var _i2 = 0; _i2 < jointCount; _i2++) {
        skin.joints[_i2] = entities[joints[_i2]].name;
      }

      // get skeleton
      if (skeleton !== undefined) {
        skin.skeleton = entities[skeleton].name;
      } else {
        skin.skeleton = defaultSceneRoot.name;
      }
      skins[i] = skin;
    }
    context.skins = skins;
  };
  return SkinParser;
}(Parser);

var TextureParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(TextureParser, _Parser);
  function TextureParser() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = TextureParser.prototype;
  _proto.parse = function parse(context) {
    var _this = this;
    var gltf = context.gltf,
      buffers = context.buffers,
      engine = context.engine,
      url = context.url;
    if (gltf.textures) {
      return Promise.all(gltf.textures.map(function (_ref, index) {
        var sampler = _ref.sampler,
          _ref$source = _ref.source,
          source = _ref$source === void 0 ? 0 : _ref$source,
          textureName = _ref.name;
        var _gltf$images$source = gltf.images[source],
          uri = _gltf$images$source.uri,
          bufferViewIndex = _gltf$images$source.bufferView,
          mimeType = _gltf$images$source.mimeType,
          imageName = _gltf$images$source.name;
        if (uri) {
          return engine.resourceManager.load({
            url: GLTFUtil.parseRelativeUrl(url, uri),
            type: AssetType.Texture2D
          }).then(function (texture) {
            if (!texture.name) {
              texture.name = textureName || imageName || "texture_" + index;
            }
            if (sampler !== undefined) {
              _this._parseSampler(texture, gltf.samplers[sampler]);
            }
            return texture;
          });
        } else {
          var bufferView = gltf.bufferViews[bufferViewIndex];
          var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
          return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then(function (image) {
            var texture = new Texture2D(engine, image.width, image.height);
            texture.setImageSource(image);
            texture.generateMipmaps();
            texture.name = textureName || imageName || "texture_" + index;
            if (sampler !== undefined) {
              _this._parseSampler(texture, gltf.samplers[sampler]);
            }
            return texture;
          });
        }
      })).then(function (textures) {
        context.textures = textures;
      });
    }
  };
  _proto._parseSampler = function _parseSampler(texture, sampler) {
    var magFilter = sampler.magFilter,
      minFilter = sampler.minFilter,
      wrapS = sampler.wrapS,
      wrapT = sampler.wrapT;
    if (magFilter || minFilter) {
      Logger.warn("texture use filterMode in engine");
    }
    if (wrapS) {
      texture.wrapModeU = TextureParser._wrapMap[wrapS];
    }
    if (wrapT) {
      texture.wrapModeV = TextureParser._wrapMap[wrapT];
    }
  };
  return TextureParser;
}(Parser);
TextureParser._wrapMap = {
  33071: TextureWrapMode$1.Clamp,
  33648: TextureWrapMode$1.Mirror,
  10497: TextureWrapMode$1.Repeat
};

var Validator = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(Validator, _Parser);
  function Validator() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = Validator.prototype;
  _proto.parse = function parse(context) {
    var _context$gltf = context.gltf,
      version = _context$gltf.asset.version,
      extensionsUsed = _context$gltf.extensionsUsed,
      extensionsRequired = _context$gltf.extensionsRequired;
    var gltfVersion = Number(version);
    if (!(gltfVersion >= 2 && gltfVersion < 3)) {
      throw "Only support gltf 2.x.";
    }
    if (extensionsUsed) {
      Logger.info("extensionsUsed: ", extensionsUsed);
      for (var i = 0; i < extensionsUsed.length; i++) {
        if (!Parser.hasExtensionParser(extensionsUsed[i])) {
          Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
        }
      }
    }
    if (extensionsRequired) {
      Logger.info("extensionsRequired: " + extensionsRequired);
      for (var _i = 0; _i < extensionsRequired.length; _i++) {
        var extensionRequired = extensionsRequired[_i];
        if (!Parser.hasExtensionParser(extensionRequired)) {
          Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
        } else {
          Parser.initialize(extensionRequired);
        }
      }
    }
  };
  return Validator;
}(Parser);

var GLTFParser = /*#__PURE__*/function () {
  function GLTFParser(pipes) {
    var _this = this;
    this._pipes = [];
    pipes.forEach(function (pipe, index) {
      _this._pipes[index] = new pipe();
    });
  }
  var _proto = GLTFParser.prototype;
  _proto.parse = function parse(context) {
    var _this2 = this;
    var lastPipe;
    return new Promise(function (resolve, reject) {
      _this2._pipes.forEach(function (parser) {
        if (lastPipe) {
          lastPipe = lastPipe.then(function () {
            return parser.parse(context);
          });
        } else {
          lastPipe = parser.parse(context);
        }
      });
      if (lastPipe) {
        lastPipe.then(function () {
          resolve(context);
        }).catch(reject);
      } else {
        resolve(context);
      }
    });
  };
  return GLTFParser;
}();
GLTFParser.instance = new GLTFParser([BufferParser, Validator, TextureParser, MaterialParser, MeshParser, EntityParser, SkinParser, AnimationParser, SceneParser$1]);

/**
 * Product after GLTF parser, usually, `defaultSceneRoot` is only needed to use.
 */
var GLTFResource = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(GLTFResource, _EngineObject);
  function GLTFResource() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
    _this.url = void 0;
    _this.gltf = void 0;
    _this.buffers = void 0;
    _this.textures = void 0;
    _this.materials = void 0;
    _this.meshes = void 0;
    _this.skins = void 0;
    _this.animations = void 0;
    _this.entities = void 0;
    _this.cameras = void 0;
    _this.lights = void 0;
    _this.sceneRoots = void 0;
    _this.defaultSceneRoot = void 0;
    _this.variants = void 0;
    return _this;
  }
  return GLTFResource;
}(EngineObject);

var _dec$q, _class$q;
(_dec$q = resourceLoader(AssetType.Prefab, ["gltf", "glb"]), _dec$q(_class$q = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(GLTFLoader, _Loader);
  function GLTFLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = GLTFLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var url = item.url;
    return new AssetPromise(function (resolve, reject) {
      var resource = new GLTFResource(resourceManager.engine);
      resource.url = url;
      GLTFParser.instance.parse(resource).then(resolve).catch(function (e) {
        console.error(e);
        reject("Error loading glTF model from " + url + " .");
      });
    });
  };
  return GLTFLoader;
}(Loader)) || _class$q);

var _dec$p, _class$p;
(_dec$p = resourceLoader(AssetType.JSON, ["json"], false), _dec$p(_class$p = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(JSONLoader, _Loader);
  function JSONLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = JSONLoader.prototype;
  _proto.load = function load(item) {
    return this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
      type: "json"
    }));
  };
  return JSONLoader;
}(Loader)) || _class$p);

/**
 *
 * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts
 */
var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)

// load types
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()

function getMipmaps(ktxContainer, loadMipmaps) {
  var mipmaps = [];

  // initialize width & height for level 1
  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
  var width = ktxContainer.pixelWidth;
  var height = ktxContainer.pixelHeight;
  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
  for (var level = 0; level < mipmapCount; level++) {
    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
    dataOffset += 4; // size of the image + 4 for the imageSize field

    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
      mipmaps.push({
        data: byteArray,
        width: width,
        height: height
      });
      dataOffset += imageSize;
      dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
    }

    width = Math.max(1.0, width * 0.5);
    height = Math.max(1.0, height * 0.5);
  }
  return mipmaps;
}

/**
 * Checks if the given data starts with a KTX file identifier.
 * @param data the data to check
 * @returns true if the data is a KTX file or false otherwise
 */
function isValid(data) {
  if (data.byteLength >= 12) {
    // '', 'K', 'T', 'X', ' ', '1', '1', '', '\r', '\n', '\x1A', '\n'
    var identifier = new Uint8Array(data, 0, 12);
    if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
      return true;
    }
  }
  return false;
}
function getEngineFormat(internalFormat) {
  switch (internalFormat) {
    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
    // break;
    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
      return TextureFormat.DXT1;
    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      return TextureFormat.DXT5;
    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
      return TextureFormat.ETC1_RGB;
    case GLCompressedTextureInternalFormat.RGB8_ETC2:
      return TextureFormat.ETC2_RGB;
    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return TextureFormat.ETC2_RGBA5;
    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
      return TextureFormat.ETC2_RGBA8;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGB2;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA2;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGB4;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
      return TextureFormat.ASTC_4x4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
      return TextureFormat.ASTC_5x5;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
      return TextureFormat.ASTC_6x6;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
      return TextureFormat.ASTC_8x8;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
      return TextureFormat.ASTC_10x10;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
      return TextureFormat.ASTC_12x12;
    default:
      var formatName = GLCompressedTextureInternalFormat[internalFormat];
      throw new Error("this format is not supported in Oasis Engine: " + formatName);
  }
}
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */
var khronosTextureContainerParser = {
  /**
   *
   * @param buffer contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
   * @param mapEngineFormat get Oasis Engine native TextureFormat?
   */
  parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
    if (mapEngineFormat === void 0) {
      mapEngineFormat = false;
    }
    if (!isValid(buffer)) {
      throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
    }

    // load the reset of the header in native 32 bit uint
    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(buffer, 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 0x04030201;
    var parsedResult = {
      buffer: buffer,
      glType: headerDataView.getUint32(1 * dataSize, littleEndian),
      // must be 0 for compressed textures
      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
      // must be 1 for compressed textures
      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
      // must be 0 for compressed textures
      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
      // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
      // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
      // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
      // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
      // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
      // used for texture arrays
      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
      // used for cubemap textures, should either be 1 or 6
      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
      // number of levels; disregard possibility of 0 for compressed textures
      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
      // the amount of space after the header for meta-data
      // would need to make this more elaborate & adjust checks above to support more than one load type
      loadType: COMPRESSED_2D
    };

    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
    if (parsedResult.glType !== 0) {
      throw new Error("only compressed formats currently supported");
    } else {
      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
    }
    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
      throw new Error("only 2D textures currently supported");
    }
    if (parsedResult.numberOfArrayElements !== 0) {
      throw new Error("texture arrays not currently supported");
    }
    if (parsedResult.numberOfFaces !== facesExpected) {
      throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
    }
    if (withMipmaps) {
      parsedResult.mipmaps = getMipmaps(parsedResult, true);
    }
    if (mapEngineFormat) {
      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
    }
    return parsedResult;
  }
};

function parseSingleKTX(data) {
  var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
  return {
    mipmaps: ktx.mipmaps,
    engineFormat: ktx.engineFormat,
    internalFormat: ktx.glInternalFormat,
    width: ktx.pixelWidth,
    height: ktx.pixelHeight
  };
}
function parseCubeKTX(dataArray) {
  var mipmapsFaces = [];
  var internalFormat;
  var engineFormat;
  var width;
  var height;
  for (var i = 0; i < dataArray.length; i++) {
    var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
    mipmapsFaces.push(ktx.mipmaps);
    if (i === 0) {
      width = ktx.pixelWidth;
      height = ktx.pixelHeight;
      internalFormat = ktx.glInternalFormat;
      engineFormat = ktx.engineFormat;
    }
  }
  return {
    mipmapsFaces: mipmapsFaces,
    engineFormat: engineFormat,
    internalFormat: internalFormat,
    width: width,
    height: height
  };
}

var _dec$o, _class$o;
(_dec$o = resourceLoader(AssetType.KTXCube, []), _dec$o(_class$o = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(KTXCubeLoader, _Loader);
  function KTXCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = KTXCubeLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      Promise.all(item.urls.map(function (url) {
        return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        }));
      })).then(function (data) {
        var parsedData = parseCubeKTX(data);
        var width = parsedData.width,
          mipmapsFaces = parsedData.mipmapsFaces,
          engineFormat = parsedData.engineFormat;
        var mipmap = mipmapsFaces[0].length > 1;
        var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
        for (var face = 0; face < 6; face++) {
          var length = mipmapsFaces[face].length;
          for (var miplevel = 0; miplevel < length; miplevel++) {
            var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel],
              _data = _mipmapsFaces$face$mi.data,
              _width = _mipmapsFaces$face$mi.width,
              height = _mipmapsFaces$face$mi.height;
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
          }
        }
        resolve(texture);
      }).catch(function (e) {
        reject(e);
      });
    });
  };
  return KTXCubeLoader;
}(Loader)) || _class$o);

var _dec$n, _class$n;
(_dec$n = resourceLoader(AssetType.KTX, ["ktx"]), _dec$n(_class$n = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(KTXLoader, _Loader);
  function KTXLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = KTXLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "arraybuffer"
      })).then(function (bin) {
        var parsedData = parseSingleKTX(bin);
        var width = parsedData.width,
          height = parsedData.height,
          mipmaps = parsedData.mipmaps,
          engineFormat = parsedData.engineFormat;
        var mipmap = mipmaps.length > 1;
        var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
        for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
          var _mipmaps$miplevel = mipmaps[miplevel],
            _width = _mipmaps$miplevel.width,
            _height = _mipmaps$miplevel.height,
            data = _mipmaps$miplevel.data;
          texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
        }
        resolve(texture);
      }).catch(function (e) {
        reject(e);
      });
    });
  };
  return KTXLoader;
}(Loader)) || _class$n);

var _dec$m, _class$m;
(_dec$m = resourceLoader(AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$m(_class$m = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(Texture2DLoader, _Loader);
  function Texture2DLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = Texture2DLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "image"
      })).then(function (image) {
        var texture = new Texture2D(resourceManager.engine, image.width, image.height);
        /** @ts-ignore */
        if (!texture._platformTexture) return;
        texture.setImageSource(image);
        texture.generateMipmaps();
        if (item.url.indexOf("data:") !== 0) {
          var splitPath = item.url.split("/");
          texture.name = splitPath[splitPath.length - 1];
        }
        resolve(texture);
      }).catch(function (e) {
        reject(e);
      });
    });
  };
  return Texture2DLoader;
}(Loader)) || _class$m);

var _dec$l, _class$l;
(_dec$l = resourceLoader(AssetType.TextureCube, [""]), _dec$l(_class$l = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(TextureCubeLoader, _Loader);
  function TextureCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = TextureCubeLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      Promise.all(item.urls.map(function (url) {
        return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "image"
        }));
      })).then(function (images) {
        var _images$ = images[0],
          width = _images$.width,
          height = _images$.height;
        if (width !== height) {
          console.error("The cube texture must have the same width and height");
          return;
        }
        var tex = new TextureCube(resourceManager.engine, width);

        /** @ts-ignore */
        if (!tex._platformTexture) return;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }
        tex.generateMipmaps();
        resolve(tex);
      }).catch(function (e) {
        reject(e);
      });
    });
  };
  return TextureCubeLoader;
}(Loader)) || _class$l);

var _dec$k, _class$k;
(_dec$k = resourceLoader(AssetType.Sprite, ["sprite"], false), _dec$k(_class$k = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(SpriteLoader, _Loader);
  function SpriteLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = SpriteLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      })).then(function (data) {
        resourceManager.getResourceByRef(data.texture).then(function (texture) {
          var sprite = new Sprite(resourceManager.engine, texture);
          sprite.region = data.region;
          sprite.pivot = data.pivot;
          resolve(sprite);
        });
      });
    });
  };
  return SpriteLoader;
}(Loader)) || _class$k);

var _dec$j, _class$j;
(_dec$j = resourceLoader(AssetType.SpriteAtlas, ["atlas"], false), _dec$j(_class$j = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(SpriteAtlasLoader, _Loader);
  function SpriteAtlasLoader() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Loader.call.apply(_Loader, [this].concat(args)) || this;
    _this._tempRect = new Rect();
    _this._tempVec2 = new Vector2();
    return _this;
  }
  var _proto = SpriteAtlasLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this2 = this;
    return new AssetPromise(function (resolve, reject) {
      _this2.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      })).then(function (atlasData) {
        var atlasItems = atlasData.atlasItems,
          format = atlasData.format;
        var atlasItemsLen = atlasItems.length;
        Promise.all(atlasItems.map(function (_ref) {
          var img = _ref.img;
          return _this2.request(GLTFUtil.parseRelativeUrl(item.url, img), _objectSpread2(_objectSpread2({}, item), {}, {
            type: "image"
          }));
        })).then(function (imgs) {
          var engine = resourceManager.engine;
          // Generate a SpriteAtlas object.
          var tempRect = _this2._tempRect,
            tempVec2 = _this2._tempVec2;
          var spriteAtlas = new SpriteAtlas(engine);
          for (var i = 0; i < atlasItemsLen; i++) {
            // Generate Texture2D according to configuration.
            var originalImg = imgs[i];
            var width = originalImg.width,
              height = originalImg.height;
            var texture = new Texture2D(engine, width, height, format);
            texture.setImageSource(originalImg);
            texture.generateMipmaps();
            // Generate all the sprites on this texture.
            var atlasItem = atlasItems[i];
            var sprites = atlasItem.sprites;
            var sourceWidthReciprocal = 1.0 / width;
            var sourceHeightReciprocal = 1.0 / height;
            for (var j = sprites.length - 1; j >= 0; j--) {
              var atlasSprite = sprites[j];
              var region = atlasSprite.region,
                atlasRegionOffset = atlasSprite.atlasRegionOffset,
                atlasRegion = atlasSprite.atlasRegion,
                id = atlasSprite.id,
                pivot = atlasSprite.pivot;
              var sprite = new Sprite(engine, texture, region ? tempRect.set(region.x, region.y, region.w, region.h) : undefined, pivot ? tempVec2.set(pivot.x, pivot.y) : undefined, undefined, atlasSprite.name);
              sprite.atlasRegion.set(atlasRegion.x * sourceWidthReciprocal, atlasRegion.y * sourceHeightReciprocal, atlasRegion.w * sourceWidthReciprocal, atlasRegion.h * sourceHeightReciprocal);
              atlasSprite.atlasRotated && (sprite.atlasRotated = true);
              if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x,
                  offsetTop = atlasRegionOffset.y,
                  offsetRight = atlasRegionOffset.z,
                  offsetBottom = atlasRegionOffset.w;
                sprite.atlasRegionOffset.set(offsetLeft * sourceWidthReciprocal, offsetTop * sourceHeightReciprocal, offsetRight * sourceWidthReciprocal, offsetBottom * sourceHeightReciprocal);
              }
              if (id !== undefined) {
                // @ts-ignore
                sprite._assetID = id;
              }
              // @ts-ignore
              spriteAtlas._addSprite(sprite);
            }
          }
          resolve(spriteAtlas);
        });
      }).catch(function (e) {
        reject(e);
      });
    });
  };
  return SpriteAtlasLoader;
}(Loader)) || _class$j);

var _dec$i, _class$i;
(_dec$i = resourceLoader(AssetType.Env, ["env"]), _dec$i(_class$i = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(EnvLoader, _Loader);
  function EnvLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = EnvLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function (arraybuffer) {
        var _Uint16Array;
        var shArray = new Float32Array(arraybuffer, 0, 27);
        var shByteLength = 27 * 4;
        var size = (_Uint16Array = new Uint16Array(arraybuffer, shByteLength, 1)) === null || _Uint16Array === void 0 ? void 0 : _Uint16Array[0];
        var texture = new TextureCube(resourceManager.engine, size);
        texture.filterMode = TextureFilterMode.Trilinear;
        var mipmapCount = texture.mipmapCount;
        var offset = shByteLength + 2;
        for (var mipLevel = 0; mipLevel < mipmapCount; mipLevel++) {
          var mipSize = size >> mipLevel;
          for (var face = 0; face < 6; face++) {
            var dataSize = mipSize * mipSize * 4;
            var data = new Uint8Array(arraybuffer, offset, dataSize);
            offset += dataSize;
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, mipLevel);
          }
        }
        var ambientLight = new AmbientLight();
        var sh = new SphericalHarmonics3();
        ambientLight.diffuseMode = DiffuseMode.SphericalHarmonics;
        sh.copyFromArray(shArray);
        ambientLight.diffuseSphericalHarmonics = sh;
        ambientLight.specularTexture = texture;
        ambientLight.specularTextureDecodeRGBM = true;
        resolve(ambientLight);
      }).catch(function (e) {
        reject(e);
      });
    });
  };
  return EnvLoader;
}(Loader)) || _class$i);

var _dec$h, _class$h, _class2$1;
var PI = Math.PI;
(_dec$h = resourceLoader(AssetType.HDR, ["hdr"]), _dec$h(_class$h = (_class2$1 = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(HDRLoader, _Loader);
  function HDRLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  HDRLoader._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
    if (!pixels) {
      throw "ConvertPanoramaToCubemap: input cannot be null";
    }
    if (pixels.length != inputWidth * inputHeight * 4) {
      throw "ConvertPanoramaToCubemap: input size is wrong";
    }
    var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
    var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
    var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
    var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
    var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
    var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
    return [textureRight, textureLeft, textureUp, textureDown, textureFront, textureBack];
  };
  HDRLoader._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
    var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
    var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
    var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
    var dy = 1 / texSize;
    var fy = 0;
    for (var y = 0; y < texSize; y++) {
      var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
      var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
      for (var x = 0; x < texSize; x++) {
        var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
        v.normalize();
        var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
        this._RGBEToLinear(color);
        this._linearToRGBM(color, 5);

        // 4 channels per pixels
        var index = y * texSize * 4 + x * 4;
        textureArray[index] = color.r;
        textureArray[index + 1] = color.g;
        textureArray[index + 2] = color.b;
        textureArray[index + 3] = color.a;
        xv1.add(rotDX1);
        xv2.add(rotDX2);
      }
      fy += dy;
    }
    return textureArray;
  };
  HDRLoader._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
    var theta = Math.atan2(vDir.z, -vDir.x);
    var phi = Math.acos(vDir.y);
    while (theta < -PI) {
      theta += 2 * PI;
    }
    while (theta > PI) {
      theta -= 2 * PI;
    }
    var dx = theta / PI;
    var dy = phi / PI;

    // recenter.
    dx = dx * 0.5 + 0.5;
    var px = Math.round(dx * inputWidth);
    if (px < 0) {
      px = 0;
    } else if (px >= inputWidth) {
      px = inputWidth - 1;
    }
    var py = Math.round(dy * inputHeight);
    if (py < 0) {
      py = 0;
    } else if (py >= inputHeight) {
      py = inputHeight - 1;
    }
    var inputY = inputHeight - py - 1;
    var index = inputY * inputWidth * 4 + px * 4;
    var r = pixels[index];
    var g = pixels[index + 1];
    var b = pixels[index + 2];
    var a = pixels[index + 3];
    return new Color(r, g, b, a);
  };
  HDRLoader._readStringLine = function _readStringLine(uint8array, startIndex) {
    var line = "";
    var character = "";
    for (var i = startIndex; i < uint8array.length - startIndex; i++) {
      character = String.fromCharCode(uint8array[i]);
      if (character == "\n") {
        break;
      }
      line += character;
    }
    return line;
  };
  HDRLoader._parseHeader = function _parseHeader(uint8array) {
    var height = 0;
    var width = 0;
    var line = this._readStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
      throw "Bad HDR Format.";
    }
    var endOfHeader = false;
    var findFormat = false;
    var lineIndex = 0;
    do {
      lineIndex += line.length + 1;
      line = this._readStringLine(uint8array, lineIndex);
      if (line == "FORMAT=32-bit_rle_rgbe") {
        findFormat = true;
      } else if (line.length == 0) {
        endOfHeader = true;
      }
    } while (!endOfHeader);
    if (!findFormat) {
      throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = this._readStringLine(uint8array, lineIndex);
    var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
    var match = sizeRegexp.exec(line);

    // TODO. Support +Y and -X if needed.
    if (!match || match.length < 3) {
      throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 0x7fff) {
      throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
      height: height,
      width: width,
      dataPosition: lineIndex
    };
  };
  HDRLoader._readPixels = function _readPixels(buffer, width, height) {
    var scanLineWidth = width;
    var byteLength = buffer.byteLength;
    var dataRGBA = new Uint8Array(4 * width * height);
    var offset = 0,
      pos = 0;
    var ptrEnd = 4 * scanLineWidth;
    var rgbeStart = new Uint8Array(4);
    var scanLineBuffer = new Uint8Array(ptrEnd);
    var numScanLines = height; // read in each successive scanLine

    while (numScanLines > 0 && pos < byteLength) {
      rgbeStart[0] = buffer[pos++];
      rgbeStart[1] = buffer[pos++];
      rgbeStart[2] = buffer[pos++];
      rgbeStart[3] = buffer[pos++];
      if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanLineWidth) {
        throw "HDR Bad header format, wrong scan line width";
      }

      // read each of the four channels for the scanline into the buffer
      // first red, then green, then blue, then exponent

      var ptr = 0,
        count = void 0;
      while (ptr < ptrEnd && pos < byteLength) {
        count = buffer[pos++];
        var isEncodedRun = count > 128;
        if (isEncodedRun) count -= 128;
        if (0 === count || ptr + count > ptrEnd) {
          throw "HDR Bad Format, bad scanline data (run)";
        }
        if (isEncodedRun) {
          // a (encoded) run of the same value
          var byteValue = buffer[pos++];
          for (var i = 0; i < count; i++) {
            scanLineBuffer[ptr++] = byteValue;
          } //ptr += count;
        } else {
          // a literal-run
          scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
          ptr += count;
          pos += count;
        }
      } // now convert data from buffer into rgba
      // first red, then green, then blue, then exponent (alpha)

      var l = scanLineWidth; //scanLine_buffer.byteLength;

      for (var _i = 0; _i < l; _i++) {
        var off = 0;
        dataRGBA[offset] = scanLineBuffer[_i + off];
        off += scanLineWidth;
        dataRGBA[offset + 1] = scanLineBuffer[_i + off];
        off += scanLineWidth;
        dataRGBA[offset + 2] = scanLineBuffer[_i + off];
        off += scanLineWidth;
        dataRGBA[offset + 3] = scanLineBuffer[_i + off];
        offset += 4;
      }
      numScanLines--;
    }
    return dataRGBA;
  };
  HDRLoader._RGBEToLinear = function _RGBEToLinear(color) {
    var scaleFactor = Math.pow(2, color.a - 128) / 255;
    color.r *= scaleFactor;
    color.g *= scaleFactor;
    color.b *= scaleFactor;
    color.a = 1;
  };
  HDRLoader._linearToRGBM = function _linearToRGBM(color, maxRange) {
    var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
    var M = Math.min(maxRGB / maxRange, 1);
    M = Math.ceil(M * 255);
    var scaleFactor = 65025 / (M * maxRange); // 255 * (255 / (M * maxRange) )

    color.r *= scaleFactor;
    color.g *= scaleFactor;
    color.b *= scaleFactor;
    color.a *= M;
  };
  var _proto = HDRLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      var engine = resourceManager.engine;
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function (buffer) {
        var uint8Array = new Uint8Array(buffer);
        var _HDRLoader$_parseHead = HDRLoader._parseHeader(uint8Array),
          width = _HDRLoader$_parseHead.width,
          height = _HDRLoader$_parseHead.height,
          dataPosition = _HDRLoader$_parseHead.dataPosition;
        var pixels = HDRLoader._readPixels(uint8Array.subarray(dataPosition), width, height);
        var cubeSize = height >> 1;
        var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
        var texture = new TextureCube(engine, cubeSize);
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          texture.setPixelBuffer(TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
        }
        texture.generateMipmaps();
        resolve(texture);
      }).catch(reject);
    });
  };
  return HDRLoader;
}(Loader), _class2$1._rightBottomBack = new Vector3(1.0, -1.0, -1.0), _class2$1._rightBottomFront = new Vector3(1.0, -1.0, 1.0), _class2$1._rightUpBack = new Vector3(1.0, 1.0, -1.0), _class2$1._rightUpFront = new Vector3(1.0, 1.0, 1.0), _class2$1._leftBottomBack = new Vector3(-1.0, -1.0, -1.0), _class2$1._leftBottomFront = new Vector3(-1.0, -1.0, 1.0), _class2$1._leftUpBack = new Vector3(-1.0, 1.0, -1.0), _class2$1._leftUpFront = new Vector3(-1.0, 1.0, 1.0), _class2$1._faceRight = [_class2$1._rightBottomBack, _class2$1._rightBottomFront, _class2$1._rightUpBack, _class2$1._rightUpFront], _class2$1._faceLeft = [_class2$1._leftBottomFront, _class2$1._leftBottomBack, _class2$1._leftUpFront, _class2$1._leftUpBack], _class2$1._faceUp = [_class2$1._leftBottomFront, _class2$1._rightBottomFront, _class2$1._leftBottomBack, _class2$1._rightBottomBack], _class2$1._faceBottom = [_class2$1._leftUpBack, _class2$1._rightUpBack, _class2$1._leftUpFront, _class2$1._rightUpFront], _class2$1._faceFront = [_class2$1._leftBottomBack, _class2$1._rightBottomBack, _class2$1._leftUpBack, _class2$1._rightUpBack], _class2$1._faceBack = [_class2$1._rightBottomFront, _class2$1._leftBottomFront, _class2$1._rightUpFront, _class2$1._leftUpFront], _class2$1._tempVector3 = new Vector3(), _class2$1._temp2Vector3 = new Vector3(), _class2$1._temp3Vector3 = new Vector3(), _class2$1._temp4Vector3 = new Vector3(), _class2$1._temp5Vector3 = new Vector3(), _class2$1)) || _class$h);

var ExtensionParser = /*#__PURE__*/function () {
  function ExtensionParser() {}
  var _proto = ExtensionParser.prototype;
  _proto.initialize = function initialize() {};
  _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {};
  _proto.createEngineResource = function createEngineResource(schema, context) {
    return null;
  };
  return ExtensionParser;
}();

var _dec$g, _class$g, _class2;
(_dec$g = registerExtension("KHR_draco_mesh_compression"), _dec$g(_class$g = (_class2 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_draco_mesh_compression, _ExtensionParser);
  function KHR_draco_mesh_compression() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_draco_mesh_compression.prototype;
  _proto.initialize = function initialize() {
    if (!KHR_draco_mesh_compression._decoder) {
      KHR_draco_mesh_compression._decoder = new DRACODecoder();
    }
  };
  _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
    var gltf = context.gltf,
      buffers = context.buffers;
    var bufferViews = gltf.bufferViews,
      accessors = gltf.accessors;
    var bufferViewIndex = schema.bufferView,
      gltfAttributeMap = schema.attributes;
    var attributeMap = {};
    var attributeTypeMap = {};
    for (var attributeName in gltfAttributeMap) {
      attributeMap[attributeName] = gltfAttributeMap[attributeName];
    }
    for (var _attributeName in gltfPrimitive.attributes) {
      if (gltfAttributeMap[_attributeName] !== undefined) {
        var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
        attributeTypeMap[_attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;
      }
    }
    var indexAccessor = accessors[gltfPrimitive.indices];
    var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
    var taskConfig = {
      attributeIDs: attributeMap,
      attributeTypes: attributeTypeMap,
      useUniqueIDs: true,
      indexType: indexType
    };
    var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
    return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function (parsedGeometry) {
      return parsedGeometry;
    });
  };
  return KHR_draco_mesh_compression;
}(ExtensionParser), _class2._decoder = void 0, _class2)) || _class$g);

var _dec$f, _class$f;
(_dec$f = registerExtension("KHR_lights_punctual"), _dec$f(_class$f = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_lights_punctual, _ExtensionParser);
  function KHR_lights_punctual() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_lights_punctual.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
    var color = schema.color,
      _schema$intensity = schema.intensity,
      intensity = _schema$intensity === void 0 ? 1 : _schema$intensity,
      type = schema.type,
      range = schema.range,
      spot = schema.spot;
    var light;
    if (type === "directional") {
      light = entity.addComponent(DirectLight);
    } else if (type === "point") {
      light = entity.addComponent(PointLight);
    } else if (type === "spot") {
      light = entity.addComponent(SpotLight);
    }
    if (color) {
      light.color.set(color[0], color[1], color[2], 1);
    }
    light.intensity = intensity;
    if (range && !(light instanceof DirectLight)) {
      light.distance = range;
    }
    if (spot && light instanceof SpotLight) {
      var _spot$innerConeAngle = spot.innerConeAngle,
        innerConeAngle = _spot$innerConeAngle === void 0 ? 0 : _spot$innerConeAngle,
        _spot$outerConeAngle = spot.outerConeAngle,
        outerConeAngle = _spot$outerConeAngle === void 0 ? Math.PI / 4 : _spot$outerConeAngle;
      light.angle = innerConeAngle;
      light.penumbra = outerConeAngle - innerConeAngle;
    }
    if (!context.lights) context.lights = [];
    context.lights.push(light);
  };
  return KHR_lights_punctual;
}(ExtensionParser)) || _class$f);

var _dec$e, _class$e;
(_dec$e = registerExtension("KHR_materials_clearcoat"), _dec$e(_class$e = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_clearcoat, _ExtensionParser);
  function KHR_materials_clearcoat() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_clearcoat.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
    var textures = context.textures;
    var _schema$clearcoatFact = schema.clearcoatFactor,
      clearcoatFactor = _schema$clearcoatFact === void 0 ? 0 : _schema$clearcoatFact,
      clearcoatTexture = schema.clearcoatTexture,
      _schema$clearcoatRoug = schema.clearcoatRoughnessFactor,
      clearcoatRoughnessFactor = _schema$clearcoatRoug === void 0 ? 0 : _schema$clearcoatRoug,
      clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture,
      clearcoatNormalTexture = schema.clearcoatNormalTexture;
    material.clearCoat = clearcoatFactor;
    material.clearCoatRoughness = clearcoatRoughnessFactor;
    if (clearcoatTexture) {
      material.clearCoatTexture = textures[clearcoatTexture.index];
      MaterialParser._parseTextureTransform(material, clearcoatTexture.extensions, context);
    }
    if (clearcoatRoughnessTexture) {
      material.clearCoatRoughnessTexture = textures[clearcoatRoughnessTexture.index];
      MaterialParser._parseTextureTransform(material, clearcoatRoughnessTexture.extensions, context);
    }
    if (clearcoatNormalTexture) {
      material.clearCoatNormalTexture = textures[clearcoatNormalTexture.index];
      MaterialParser._parseTextureTransform(material, clearcoatNormalTexture.extensions, context);
    }
  };
  return KHR_materials_clearcoat;
}(ExtensionParser)) || _class$e);

var _dec$d, _class$d;
(_dec$d = registerExtension("KHR_materials_pbrSpecularGlossiness"), _dec$d(_class$d = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_pbrSpecularGlossiness, _ExtensionParser);
  function KHR_materials_pbrSpecularGlossiness() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine,
      textures = context.textures;
    var material = new PBRSpecularMaterial(engine);
    var diffuseFactor = schema.diffuseFactor,
      diffuseTexture = schema.diffuseTexture,
      specularFactor = schema.specularFactor,
      glossinessFactor = schema.glossinessFactor,
      specularGlossinessTexture = schema.specularGlossinessTexture;
    if (diffuseFactor) {
      material.baseColor = new Color(Color.linearToGammaSpace(diffuseFactor[0]), Color.linearToGammaSpace(diffuseFactor[1]), Color.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
    }
    if (diffuseTexture) {
      material.baseTexture = textures[diffuseTexture.index];
      MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
    }
    if (specularFactor) {
      material.specularColor = new Color(Color.linearToGammaSpace(specularFactor[0]), Color.linearToGammaSpace(specularFactor[1]), Color.linearToGammaSpace(specularFactor[2]));
    }
    if (glossinessFactor !== undefined) {
      material.glossiness = glossinessFactor;
    }
    if (specularGlossinessTexture) {
      material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
      MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
    }
    return material;
  };
  return KHR_materials_pbrSpecularGlossiness;
}(ExtensionParser)) || _class$d);

var _dec$c, _class$c;
(_dec$c = registerExtension("KHR_materials_unlit"), _dec$c(_class$c = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_unlit, _ExtensionParser);
  function KHR_materials_unlit() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_unlit.prototype;
  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine;
    var material = new UnlitMaterial(engine);
    return material;
  };
  return KHR_materials_unlit;
}(ExtensionParser)) || _class$c);

var _dec$b, _class$b;
(_dec$b = registerExtension("KHR_materials_variants"), _dec$b(_class$b = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_variants, _ExtensionParser);
  function KHR_materials_variants() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_variants.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
    var variantNames = context.gltf.extensions.KHR_materials_variants.variants,
      materials = context.materials;
    var mappings = schema.mappings;
    for (var i = 0; i < mappings.length; i++) {
      var _mappings$i = mappings[i],
        material = _mappings$i.material,
        variants = _mappings$i.variants;
      if (!context.variants) context.variants = [];
      context.variants.push({
        renderer: renderer,
        material: materials[material],
        variants: variants.map(function (index) {
          return variantNames[index].name;
        })
      });
    }
  };
  return KHR_materials_variants;
}(ExtensionParser)) || _class$b);

var _dec$a, _class$a;
(_dec$a = registerExtension("KHR_mesh_quantization"), _dec$a(_class$a = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_mesh_quantization, _ExtensionParser);
  function KHR_mesh_quantization() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  return KHR_mesh_quantization;
}(ExtensionParser)) || _class$a);

var _dec$9, _class$9;
(_dec$9 = registerExtension("KHR_texture_transform"), _dec$9(_class$9 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_texture_transform, _ExtensionParser);
  function KHR_texture_transform() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_texture_transform.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
    var offset = schema.offset,
      rotation = schema.rotation,
      scale = schema.scale,
      texCoord = schema.texCoord;
    if (offset) {
      material.tilingOffset.z = offset[0];
      material.tilingOffset.w = offset[1];
    }
    if (scale) {
      material.tilingOffset.x = scale[0];
      material.tilingOffset.y = scale[1];
    }
    if (rotation) {
      Logger.warn("rotation in KHR_texture_transform is not supported now");
    }
    if (texCoord) {
      Logger.warn("texCoord in KHR_texture_transform is not supported now");
    }
  };
  return KHR_texture_transform;
}(ExtensionParser)) || _class$9);

var _dec$8, _class$8;
(_dec$8 = registerExtension("OASIS_materials_remap"), _dec$8(_class$8 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(OasisMaterialsRemap, _ExtensionParser);
  function OasisMaterialsRemap() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = OasisMaterialsRemap.prototype;
  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine;
    return engine.resourceManager.getResourceByRef(schema);
  };
  return OasisMaterialsRemap;
}(ExtensionParser)) || _class$8);

var _dec$7, _class$7;
(_dec$7 = resourceLoader(AssetType.Material, ["json"]), _dec$7(_class$7 = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(MaterialLoader, _Loader);
  function MaterialLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = MaterialLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      })).then(function (json) {
        var engine = resourceManager.engine;
        var shader = json.shader,
          shaderData = json.shaderData,
          macros = json.macros,
          renderState = json.renderState;
        var material;
        switch (shader) {
          case "pbr":
            material = new PBRMaterial(engine);
            break;
          case "pbr-specular":
            material = new PBRSpecularMaterial(engine);
            break;
          case "unlit":
            material = new UnlitMaterial(engine);
            break;
          case "blinn-phong":
            material = new BlinnPhongMaterial(engine);
            break;
        }
        var texturePromises = new Array();
        var materialShaderData = material.shaderData;
        var _loop = function _loop(_key) {
          var _shaderData$_key = shaderData[_key],
            type = _shaderData$_key.type,
            value = _shaderData$_key.value;
          switch (type) {
            case "Vector2":
              materialShaderData.setVector2(_key, new Vector2(value.x, value.y));
              break;
            case "Vector3":
              materialShaderData.setVector3(_key, new Vector3(value.x, value.y, value.z));
              break;
            case "Vector4":
              materialShaderData.setVector4(_key, new Vector4(value.x, value.y, value.z, value.w));
              break;
            case "Color":
              materialShaderData.setColor(_key, new Color(value.r, value.g, value.b, value.a));
              break;
            case "Float":
              materialShaderData.setFloat(_key, value);
              break;
            case "Texture":
              texturePromises.push(resourceManager.getResourceByRef(value).then(function (texture) {
                materialShaderData.setTexture(_key, texture);
              }));
              break;
          }
        };
        for (var _key in shaderData) {
          _loop(_key);
        }
        for (var i = 0, length = macros.length; i < length; i++) {
          var _macros$i = macros[i],
            name = _macros$i.name,
            value = _macros$i.value;
          if (value == undefined) {
            materialShaderData.enableMacro(name);
          } else {
            materialShaderData.enableMacro(name, value);
          }
        }
        for (var _key2 in renderState) {
          material[_key2] = renderState[_key2];
        }
        Promise.all(texturePromises).then(function () {
          resolve(material);
        });
      });
    });
  };
  return MaterialLoader;
}(Loader)) || _class$7);

var BufferReader = /*#__PURE__*/function () {
  function BufferReader(buffer, byteOffset, byteLength, littleEndian) {
    if (byteOffset === void 0) {
      byteOffset = 0;
    }
    if (littleEndian === void 0) {
      littleEndian = true;
    }
    this.buffer = buffer;
    this._dataView = void 0;
    this._littleEndian = void 0;
    this._offset = void 0;
    // byteLength = byteLength ?? _buffer.byteLength;
    this._dataView = new DataView(buffer);
    this._littleEndian = littleEndian;
    this._offset = byteOffset;
  }
  var _proto = BufferReader.prototype;
  _proto.nextUint8 = function nextUint8() {
    var value = this._dataView.getUint8(this._offset);
    this._offset += 1;
    return value;
  };
  _proto.nextUint16 = function nextUint16() {
    var value = this._dataView.getUint16(this._offset, this._littleEndian);
    this._offset += 2;
    return value;
  };
  _proto.nextUint32 = function nextUint32() {
    var value = this._dataView.getUint32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  };
  _proto.nextInt32 = function nextInt32() {
    var value = this._dataView.getInt32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  };
  _proto.nextInt32Array = function nextInt32Array(len) {
    var value = new Int32Array(this.buffer, this._offset, len);
    this._offset += 4 * len;
    return value;
  };
  _proto.nextFloat32 = function nextFloat32() {
    var value = this._dataView.getFloat32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  };
  _proto.nextFloat32Array = function nextFloat32Array(len) {
    var value = new Float32Array(this.buffer, this._offset, len);
    this._offset += 4 * len;
    return value;
  };
  _proto.nextUint32Array = function nextUint32Array(len) {
    var value = new Uint32Array(this.buffer, this._offset, len);
    this._offset += 4 * len;
    return value;
  };
  _proto.nextUint8Array = function nextUint8Array(len) {
    var value = new Uint8Array(this.buffer, this._offset, len);
    this._offset += len;
    return value;
  };
  _proto.nextUint64 = function nextUint64() {
    var left = this._dataView.getUint32(this._offset, this._littleEndian);
    var right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    var value = left + Math.pow(2, 32) * right;
    this._offset += 8;
    return value;
  };
  _proto.nextStr = function nextStr() {
    var strByteLength = this.nextUint16();
    var uint8Array = new Uint8Array(this.buffer, this._offset, strByteLength);
    this._offset += strByteLength;
    return GLTFUtil.decodeText(uint8Array);
  }

  /**
   * image data 
   */;
  _proto.nextImageData = function nextImageData(count) {
    return this.buffer.slice(this._offset);
  };
  _proto.nextImagesData = function nextImagesData(count) {
    var imagesLen = new Array(count);
    // Start offset of Uint32Array should be a multiple of 4. ref: https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
    for (var i = 0; i < count; i++) {
      var len = this._dataView.getUint32(this._offset, this._littleEndian);
      imagesLen[i] = len;
      this._offset += 4;
    }
    var imagesData = [];
    for (var _i = 0; _i < count; _i++) {
      var _len = imagesLen[_i];
      var _buffer = this.buffer.slice(this._offset, this._offset + _len);
      this._offset += _len;
      imagesData.push(_buffer);
    }
    return imagesData;
  };
  _proto.skip = function skip(bytes) {
    this._offset += bytes;
    return this;
  };
  _proto.scan = function scan(maxByteLength, term) {
    if (term === void 0) {
      term = 0x00;
    }
    var byteOffset = this._offset;
    var byteLength = 0;
    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
      byteLength++;
      this._offset++;
    }
    if (byteLength < maxByteLength) this._offset++;
    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
  };
  _createClass(BufferReader, [{
    key: "offset",
    get: function get() {
      return this._offset;
    }
  }]);
  return BufferReader;
}();
BufferReader.imageMapping = {
  0: "image/png",
  1: "image/jpg",
  2: "image/webp",
  3: "ktx"
};

var decoderMap = {};

/**
 * Decoder decorator generator.
 * @param type - resource file type.
 * @returns Decoder decorator
 */
function decoder(type) {
  return function (target) {
    decoderMap[type] = target;
  };
}

var FileHeader = /*#__PURE__*/function () {
  function FileHeader() {
    this.totalLength = 0;
    this.version = 0;
    this.type = "";
    this.name = "";
    this.headerLength = 0;
  }
  FileHeader.decode = function decode(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var totalLen = dataView.getUint32(0, true);
    var fileVersion = dataView.getUint8(4);
    var typeLen = dataView.getUint16(5, true);
    var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
    var nameLen = dataView.getUint16(7 + typeLen, true);
    var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
    var name = GLTFUtil.decodeText(nameUint8Array);
    var type = GLTFUtil.decodeText(typeUint8Array);
    var header = new FileHeader();
    header.totalLength = totalLen;
    header.name = name;
    header.type = type;
    header.version = fileVersion;
    header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
    return header;
  };
  _createClass(FileHeader, [{
    key: "dataLength",
    get: function get() {
      return this.totalLength - this.headerLength;
    }
  }]);
  return FileHeader;
}();

var _dec$6, _class$6;
var MeshDecoder = (_dec$6 = decoder("Mesh"), _dec$6(_class$6 = /*#__PURE__*/function () {
  function MeshDecoder() {}
  MeshDecoder.decode = function decode(engine, bufferReader) {
    return new Promise(function (resolve) {
      var modelMesh = new ModelMesh(engine);
      var jsonDataString = bufferReader.nextStr();
      var encodedMeshData = JSON.parse(jsonDataString);
      var offset = Math.ceil(bufferReader.offset / 4) * 4;
      var float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
      var vertexCount = float32Array.length / 3;
      var positions = float32ArrayToVector3(float32Array, vertexCount);
      modelMesh.setPositions(positions);
      if (encodedMeshData.normals) {
        var _float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
        var normals = float32ArrayToVector3(_float32Array, vertexCount);
        modelMesh.setNormals(normals);
      }
      if (encodedMeshData.uvs) {
        var _float32Array2 = new Float32Array(bufferReader.buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array2, vertexCount));
      }
      if (encodedMeshData.uv1) {
        var _float32Array3 = new Float32Array(bufferReader.buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array3, vertexCount), 1);
      }
      if (encodedMeshData.uv2) {
        var _float32Array4 = new Float32Array(bufferReader.buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array4, vertexCount), 2);
      }
      if (encodedMeshData.uv3) {
        var _float32Array5 = new Float32Array(bufferReader.buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array5, vertexCount), 3);
      }
      if (encodedMeshData.uv4) {
        var _float32Array6 = new Float32Array(bufferReader.buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array6, vertexCount), 4);
      }
      if (encodedMeshData.uv5) {
        var _float32Array7 = new Float32Array(bufferReader.buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array7, vertexCount), 5);
      }
      if (encodedMeshData.uv6) {
        var _float32Array8 = new Float32Array(bufferReader.buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array8, vertexCount), 6);
      }
      if (encodedMeshData.uv7) {
        var _float32Array9 = new Float32Array(bufferReader.buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(_float32Array9, vertexCount), 7);
      }
      if (encodedMeshData.colors) {
        var _float32Array10 = new Float32Array(bufferReader.buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
        modelMesh.setColors(float32ArrayToVColor(_float32Array10, vertexCount));
      }
      if (encodedMeshData.boneWeights) {
        var _float32Array11 = new Float32Array(bufferReader.buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
        modelMesh.setBoneWeights(float32ArrayToVector4(_float32Array11, vertexCount));
      }
      if (encodedMeshData.boneIndices) {
        var _float32Array12 = new Float32Array(bufferReader.buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
        modelMesh.setBoneIndices(float32ArrayToVector4(_float32Array12, vertexCount));
      }
      if (encodedMeshData.blendShapes) {
        encodedMeshData.blendShapes.forEach(function (blendShapeData) {
          var blendShape = new BlendShape(blendShapeData.name);
          blendShapeData.frames.forEach(function (frameData) {
            var positionArray = new Float32Array(bufferReader.buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
            var count = positionArray.length / 3;
            var deltaPosition = float32ArrayToVector3(positionArray, count);
            if (frameData.deltaNormals) {
              var normalsArray = new Float32Array(bufferReader.buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
              float32ArrayToVector3(normalsArray, count);
            }
            if (frameData.deltaTangents) {
              var tangentsArray = new Float32Array(bufferReader.buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
              float32ArrayToVector4(tangentsArray, count);
            }
            blendShape.addFrame(frameData.weight, deltaPosition);
          });
          modelMesh.addBlendShape(blendShape);
        });
      }
      if (encodedMeshData.indices) {
        var indices = null;
        if (encodedMeshData.indices.type === 0) {
          indices = new Uint16Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
        } else {
          indices = new Uint32Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
        }
        modelMesh.setIndices(indices);
      }
      encodedMeshData.subMeshes.forEach(function (subMesh) {
        modelMesh.addSubMesh(subMesh);
      });
      modelMesh.uploadData(false);
      resolve(modelMesh);
    });
  };
  return MeshDecoder;
}()) || _class$6);
function float32ArrayToVColor(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Color(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
  }
  return array;
}
function float32ArrayToVector4(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
  }
  return array;
}
function float32ArrayToVector3(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
  }
  return array;
}
function float32ArrayToVector2(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
  }
  return array;
}

var _dec$5, _class$5;
var Texture2DDecoder = (_dec$5 = decoder("Texture2D"), _dec$5(_class$5 = /*#__PURE__*/function () {
  function Texture2DDecoder() {}
  Texture2DDecoder.decode = function decode(engine, bufferReader) {
    return new Promise(function (resolve, reject) {
      var objectId = bufferReader.nextStr();
      var mipmap = !!bufferReader.nextUint8();
      var filterMode = bufferReader.nextUint8();
      var anisoLevel = bufferReader.nextUint8();
      var wrapModeU = bufferReader.nextUint8();
      var wrapModeV = bufferReader.nextUint8();
      var format = bufferReader.nextUint8();
      var width = bufferReader.nextUint16();
      var height = bufferReader.nextUint16();
      var isPixelBuffer = bufferReader.nextUint8();
      var mipCount = bufferReader.nextUint8();
      var imagesData = bufferReader.nextImagesData(mipCount);
      var texture2D = new Texture2D(engine, width, height, format, mipmap);
      texture2D.filterMode = filterMode;
      texture2D.anisoLevel = anisoLevel;
      texture2D.wrapModeU = wrapModeU;
      texture2D.wrapModeV = wrapModeV;
      if (isPixelBuffer) {
        var pixelBuffer = new Uint8Array(imagesData[0]);
        texture2D.setPixelBuffer(pixelBuffer);
        if (mipmap) {
          texture2D.generateMipmaps();
          for (var i = 1; i < mipCount; i++) {
            var _pixelBuffer = new Uint8Array(imagesData[i]);
            texture2D.setPixelBuffer(_pixelBuffer, i);
          }
        }
        // @ts-ignore
        engine.resourceManager._objectPool[objectId] = texture2D;
        resolve(texture2D);
      } else {
        var blob = new window.Blob([imagesData[0]]);
        var img = new Image();
        img.onload = function () {
          texture2D.setImageSource(img);
          var completedCount = 0;
          var onComplete = function onComplete() {
            completedCount++;
            if (completedCount >= mipCount) {
              resolve(texture2D);
            }
          };
          onComplete();
          if (mipmap) {
            texture2D.generateMipmaps();
            var _loop = function _loop(_i) {
              var blob = new window.Blob([imagesData[_i]]);
              var img = new Image();
              img.onload = function () {
                texture2D.setImageSource(img, _i);
                onComplete();
              };
              img.src = URL.createObjectURL(blob);
            };
            for (var _i = 1; _i < mipCount; _i++) {
              _loop(_i);
            }
          }
        };
        img.src = URL.createObjectURL(blob);
      }
    });
  };
  return Texture2DDecoder;
}()) || _class$5);

var ReflectionParser = /*#__PURE__*/function () {
  function ReflectionParser() {}
  ReflectionParser.parseEntity = function parseEntity(entityConfig, engine) {
    var _this = this;
    return ReflectionParser.getEntityByConfig(entityConfig, engine).then(function (entity) {
      var _entityConfig$isActiv;
      entity.isActive = (_entityConfig$isActiv = entityConfig.isActive) != null ? _entityConfig$isActiv : true;
      var position = entityConfig.position,
        rotation = entityConfig.rotation,
        scale = entityConfig.scale;
      if (position) {
        entity.transform.setPosition(position.x, position.y, position.z);
      }
      if (rotation) {
        entity.transform.setRotation(rotation.x, rotation.y, rotation.z);
      }
      if (scale) {
        entity.transform.setScale(scale.x, scale.y, scale.z);
      }
      var promises = [];
      for (var i = 0; i < entityConfig.components.length; i++) {
        var componentConfig = entityConfig.components[i];
        var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
        var component = void 0;
        if (key === "Animator") {
          component = entity.getComponent(Loader.getClass(key));
        }
        component = component || entity.addComponent(Loader.getClass(key));
        var promise = _this.parsePropsAndMethods(component, componentConfig, engine);
        promises.push(promise);
      }
      return Promise.all(promises).then(function () {
        return entity;
      });
    });
  };
  ReflectionParser.getEntityByConfig = function getEntityByConfig(entityConfig, engine) {
    // @ts-ignore
    var assetRefId = entityConfig.assetRefId;
    if (assetRefId) {
      // @ts-ignore
      return engine.resourceManager.getResourceByRef({
        refId: assetRefId,
        key: entityConfig.key
      });
    } else {
      var entity = new Entity(engine, entityConfig.name);
      return Promise.resolve(entity);
    }
  };
  ReflectionParser.parseClassObject = function parseClassObject(item, engine, resourceManager) {
    var _item$constructParams;
    if (resourceManager === void 0) {
      resourceManager = engine.resourceManager;
    }
    var Class = Loader.getClass(item.class);
    var params = (_item$constructParams = item.constructParams) != null ? _item$constructParams : [];
    var instance = _construct(Class, params);
    return this.parsePropsAndMethods(instance, item, engine, resourceManager);
  };
  ReflectionParser.parseBasicType = function parseBasicType(value, engine, resourceManager) {
    var _this2 = this;
    if (resourceManager === void 0) {
      resourceManager = engine.resourceManager;
    }
    if (Array.isArray(value)) {
      return Promise.all(value.map(function (item) {
        return _this2.parseBasicType(item, engine, resourceManager);
      }));
    } else if (typeof value === "object" && value != null) {
      if (this._isClass(value)) {
        // 
        return this.parseClassObject(value, engine, resourceManager);
      } else if (this._isRef(value)) {
        // 
        return resourceManager.getResourceByRef(value);
      } else {
        // 
        return Promise.resolve(value);
      }
    } else {
      return Promise.resolve(value);
    }
  };
  ReflectionParser.parsePropsAndMethods = function parsePropsAndMethods(instance, item, engine, resourceManager) {
    var _this3 = this;
    if (resourceManager === void 0) {
      resourceManager = engine.resourceManager;
    }
    var promises = [];
    if (item.methods) {
      for (var methodName in item.methods) {
        var methodParams = item.methods[methodName];
        for (var i = 0, count = methodParams.length; i < count; i++) {
          var params = methodParams[i];
          var promise = this.parseMethod(instance, methodName, params, engine, resourceManager);
          promises.push(promise);
        }
      }
    }
    if (item.props) {
      var _loop = function _loop(key) {
        var value = item.props[key];
        var promise = _this3.parseBasicType(value, engine).then(function (v) {
          return instance[key] = v;
        });
        promises.push(promise);
      };
      for (var key in item.props) {
        _loop(key);
      }
    }
    return Promise.all(promises).then(function () {
      return instance;
    });
  };
  ReflectionParser.parseMethod = function parseMethod(instance, methodName, methodParams, engine, resourceManager) {
    var _this4 = this;
    if (resourceManager === void 0) {
      resourceManager = engine.resourceManager;
    }
    return Promise.all(methodParams.map(function (param) {
      return _this4.parseBasicType(param, engine, resourceManager);
    })).then(function (result) {
      return instance[methodName].apply(instance, result);
    });
  };
  ReflectionParser._isClass = function _isClass(value) {
    return value["class"] != undefined;
  };
  ReflectionParser._isRef = function _isRef(value) {
    return value["refId"] != undefined;
  };
  return ReflectionParser;
}();

var PrefabParser = /*#__PURE__*/function () {
  function PrefabParser(_engine) {
    this._engine = _engine;
  }
  var _proto = PrefabParser.prototype;
  _proto.parse = function parse(data) {
    var entitiesMap = {};
    var entitiesConfigMap = {};
    var promises = [];
    var entitiesConfig = data.entities;
    for (var _iterator = _createForOfIteratorHelperLoose(entitiesConfig), _step; !(_step = _iterator()).done;) {
      var entity = _step.value;
      entitiesConfigMap[entity.id] = entity;
      promises.push(ReflectionParser.parseEntity(entity, this._engine));
    }
    return Promise.all(promises).then(function (entities) {
      var rootId = entitiesConfig[0].id;
      entities.forEach(function (entity, index) {
        entitiesMap[entitiesConfig[index].id] = entity;
      });
      PrefabParser.parseChildren(entitiesConfigMap, entitiesMap, rootId);
      return entitiesMap[rootId];
    });
  };
  PrefabParser.parseChildren = function parseChildren(entitiesConfig, entities, parentId) {
    var children = entitiesConfig[parentId].children;
    if (children && children.length > 0) {
      var parent = entities[parentId];
      for (var i = 0; i < children.length; i++) {
        var childId = children[i];
        var entity = entities[childId];
        parent.addChild(entity);
        this.parseChildren(entitiesConfig, entities, childId);
      }
    }
  };
  return PrefabParser;
}();

var SceneParser = /*#__PURE__*/function () {
  function SceneParser() {}
  SceneParser.parse = function parse(engine, sceneData) {
    var scene = new Scene(engine);
    var entitiesMap = {};
    var entitiesConfigMap = {};
    var promises = [];
    var entitiesConfig = sceneData.entities;
    for (var _iterator = _createForOfIteratorHelperLoose(entitiesConfig), _step; !(_step = _iterator()).done;) {
      var entity = _step.value;
      entitiesConfigMap[entity.id] = entity;
      promises.push(ReflectionParser.parseEntity(entity, engine));
    }
    return Promise.all(promises).then(function (entities) {
      var rootIds = [];
      entities.forEach(function (entity, index) {
        entitiesMap[entitiesConfig[index].id] = entity;
        if (!entitiesConfig[index].parent) {
          rootIds.push(entitiesConfig[index].id);
        }
      });
      for (var _i = 0, _rootIds = rootIds; _i < _rootIds.length; _i++) {
        var rootId = _rootIds[_i];
        PrefabParser.parseChildren(entitiesConfigMap, entitiesMap, rootId);
      }
      var rootEntities = rootIds.map(function (id) {
        return entitiesMap[id];
      });
      for (var i = 0; i < rootEntities.length; i++) {
        scene.addRootEntity(rootEntities[i]);
      }
      return scene;
    });
  };
  return SceneParser;
}();

var _dec$4, _class$4;
var MeshLoader = (_dec$4 = resourceLoader("Mesh", ["prefab"], true), _dec$4(_class$4 = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(MeshLoader, _Loader);
  function MeshLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = MeshLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function (data) {
        decode(data, resourceManager.engine).then(function (mesh) {
          resolve(mesh);
        });
      });
    });
  };
  return MeshLoader;
}(Loader)) || _class$4);

var _dec$3, _class$3;
var EditorTextureLoader = (_dec$3 = resourceLoader("EditorTexture2D", ["prefab"], true), _dec$3(_class$3 = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(EditorTextureLoader, _Loader);
  function EditorTextureLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = EditorTextureLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve) {
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function (data) {
        decode(data, resourceManager.engine).then(function (texture) {
          resolve(texture);
        });
      });
    });
  };
  return EditorTextureLoader;
}(Loader)) || _class$3);

/**
 * Decode engine binary resource.
 * @param arrayBuffer - array buffer of decode binary file
 * @param engine - engine
 * @returns
 */
function decode(arrayBuffer, engine) {
  var header = FileHeader.decode(arrayBuffer);
  var bufferReader = new BufferReader(arrayBuffer, header.headerLength, header.dataLength);
  return decoderMap[header.type].decode(engine, bufferReader).then(function (object) {
    object.name = header.name;
    return object;
  });
}

var _dec$2, _class$2;
(_dec$2 = resourceLoader(AssetType.Mesh, ["mesh"]), _dec$2(_class$2 = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(MeshLoader, _Loader);
  function MeshLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = MeshLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "arraybuffer"
      })).then(function (data) {
        return decode(data, resourceManager.engine);
      }).then(function (mesh) {
        resolve(mesh);
      });
    });
  };
  return MeshLoader;
}(Loader)) || _class$2);

var _dec$1, _class$1;
(_dec$1 = resourceLoader(AssetType.AnimatorController, ["json"], false), _dec$1(_class$1 = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(AnimatorControllerLoader, _Loader);
  function AnimatorControllerLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = AnimatorControllerLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      })).then( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {
          var animatorController, layers, promises;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  animatorController = new AnimatorController();
                  layers = data.layers;
                  promises = [];
                  layers.forEach(function (layerData, layerIndex) {
                    var name = layerData.name,
                      blendingMode = layerData.blendingMode,
                      weight = layerData.weight,
                      stateMachineData = layerData.stateMachine;
                    var layer = new AnimatorControllerLayer(name);
                    layer.blendingMode = blendingMode;
                    layer.weight = weight;
                    if (stateMachineData) {
                      var states = stateMachineData.states;
                      var stateMachine = layer.stateMachine = new AnimatorStateMachine();
                      states.forEach(function (stateData, stateIndex) {
                        var name = stateData.name,
                          speed = stateData.speed,
                          wrapMode = stateData.wrapMode,
                          clipStartNormalizedTime = stateData.clipStartNormalizedTime,
                          clipEndNormalizedTime = stateData.clipEndNormalizedTime;
                          stateData.isDefaultState;
                          var clipData = stateData.clip;
                        var state = stateMachine.addState(name);
                        state.speed = speed;
                        state.wrapMode = wrapMode;
                        state.clipStartTime = clipStartNormalizedTime;
                        state.clipEndTime = clipEndNormalizedTime;
                        if (clipData) {
                          promises.push(new Promise( /*#__PURE__*/function () {
                            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve) {
                              return _regeneratorRuntime().wrap(function _callee$(_context) {
                                while (1) {
                                  switch (_context.prev = _context.next) {
                                    case 0:
                                      _context.t0 = resolve;
                                      _context.t1 = layerIndex;
                                      _context.t2 = stateIndex;
                                      _context.next = 5;
                                      return resourceManager.getResourceByRef(clipData);
                                    case 5:
                                      _context.t3 = _context.sent;
                                      _context.t4 = {
                                        layerIndex: _context.t1,
                                        stateIndex: _context.t2,
                                        clip: _context.t3
                                      };
                                      (0, _context.t0)(_context.t4);
                                    case 8:
                                    case "end":
                                      return _context.stop();
                                  }
                                }
                              }, _callee);
                            }));
                            return function (_x2) {
                              return _ref2.apply(this, arguments);
                            };
                          }()));
                        }
                      });
                      states.forEach(function (stateData) {
                        var name = stateData.name,
                          transitions = stateData.transitions;
                        transitions.forEach(function (transitionData) {
                          var targetStateName = transitionData.targetStateName,
                            duration = transitionData.duration,
                            offset = transitionData.offset,
                            exitTime = transitionData.exitTime;
                          var sourceState = stateMachine.findStateByName(name);
                          var destState = stateMachine.findStateByName(targetStateName);
                          var transition = new AnimatorStateTransition();
                          transition.destinationState = destState;
                          transition.duration = duration;
                          transition.exitTime = exitTime;
                          transition.offset = offset;
                          sourceState.addTransition(transition);
                        });
                      });
                    }
                    animatorController.addLayer(layer);
                  });
                  Promise.all(promises).then(function (clipData) {
                    clipData.forEach(function (data) {
                      var layerIndex = data.layerIndex,
                        stateIndex = data.stateIndex,
                        clip = data.clip;
                      animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                    });
                    resolve(animatorController);
                  });
                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    });
  };
  return AnimatorControllerLoader;
}(Loader)) || _class$1);

var _dec, _class;
(_dec = resourceLoader(AssetType.Scene, ["prefab"], true), _dec(_class = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(SceneLoader, _Loader);
  function SceneLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = SceneLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    var engine = resourceManager.engine;
    return new AssetPromise(function (resolve, reject) {
      return _this.request(item.url, {
        type: "json"
      }).then(function (data) {
        // @ts-ignore
        engine.resourceManager.initVirtualResources(data.files);
        return SceneParser.parse(engine, data).then(function (scene) {
          var ambient = data.scene.ambient;
          var ambientLightPromise = Promise.resolve();
          if (ambient.ambientLight) {
            ambientLightPromise = resourceManager.getResourceByRef(data.scene.ambient.ambientLight).then(function (light) {
              scene.ambientLight = light;
              scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
              scene.ambientLight.specularIntensity = ambient.specularIntensity;
            });
          }
          var background = data.scene.background;
          scene.background.mode = background.mode;
          var backgroundPromise = Promise.resolve();
          switch (scene.background.mode) {
            case BackgroundMode.SolidColor:
              scene.background.solidColor.copyFrom(background.color);
              break;
            case BackgroundMode.Sky:
              if (background.sky) {
                backgroundPromise = resourceManager.getResourceByRef(background.sky).then(function (light) {
                  var sky = scene.background.sky;
                  var skyMaterial = new SkyBoxMaterial(engine);
                  skyMaterial.textureCubeMap = light.specularTexture;
                  skyMaterial.textureDecodeRGBM = true;
                  sky.material = skyMaterial;
                  sky.mesh = PrimitiveMesh.createCuboid(engine, 1, 1, 1);
                });
              }
              break;
            case BackgroundMode.Texture:
              if (background.texture) {
                backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function (texture) {
                  scene.background.texture = texture;
                });
              }
              break;
          }
          Promise.all([ambientLightPromise, backgroundPromise]).then(function () {
            resolve(scene);
          });
        });
      });
      //
    });
  };
  return SceneLoader;
}(Loader)) || _class);

export { EditorTextureLoader, GLTFResource, MeshDecoder, MeshLoader, PrefabParser, ReflectionParser, SceneParser, Texture2DDecoder, decode, parseSingleKTX };
//# sourceMappingURL=module.js.map
